(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _window = window,
    rh = _window.rh;
var model = rh.model;
var consts = rh.consts;
var _ = rh._;

var PhoneGap = function () {
  function PhoneGap() {
    _classCallCheck(this, PhoneGap);

    this.addJsToTopics();
  }

  _createClass(PhoneGap, [{
    key: 'addJsToTopics',
    value: function addJsToTopics() {
      return model.subscribeOnce(consts('KEY_MOBILE_APP_MODE'), function (val) {
        if (val) {
          return model.subscribe(consts('EVT_WIDGET_LOADED'), function () {
            return _.loadScript(consts('CORDOVA_JS_URL'), false, function () {
              if (rh.debug) {
                return rh._d('info', 'loaded Cordova.js');
              }
            });
          });
        }
      });
    }
  }]);

  return PhoneGap;
}();

new PhoneGap();

},{}],2:[function(require,module,exports){
'use strict';

var _window = window,
    rh = _window.rh;
var consts = rh.consts;


rh.model.subscribe(consts('EVT_SCROLL_TO_TOP'), function (dummy) {
  return window.scrollTo(0, 0);
});

rh.model.subscribe(consts('EVT_PRINT_TOPIC'), function () {
  window.focus();
  return window.print();
});

},{}],3:[function(require,module,exports){
'use strict';

var _window = window,
    rh = _window.rh;
var _ = rh._;
var consts = rh.consts;


_.getRootUrl = function () {
  var rootUrl = null;
  return function () {
    if (rootUrl == null) {
      var rootInfo = window.gScreenRelPathMap[window.gFinalCommonRootRelPath];
      rootUrl = '' + _.getHostFolder() + _.fixRelativeUrl(rootInfo != null ? rootInfo.defaultURL : undefined);
    }
    return rootUrl;
  };
}();

_.redirectToLayout = function () {
  var hostFolder = _.getHostFolder();
  var query = '';
  var relUrl = window._getRelativeFileName(hostFolder, decodeURI(document.location.href));
  var ref = document.referrer;
  if (ref && !_.isExternalUrl(ref)) {
    var queryMap = _.urlParams(_.extractParamString(ref));
    if (!_.isEmptyObject(queryMap)) {
      query = '?' + _.mapToEncodedString(queryMap);
    }
  }

  var hashMap = _.urlParams(_.extractParamString(relUrl));
  hashMap[consts('HASH_KEY_TOPIC')] = _.stripParam(relUrl);
  hashMap[consts('HASH_KEY_UIMODE')] = null;
  var hash = '#' + _.mapToEncodedString(hashMap);
  return document.location.replace('' + _.getRootUrl() + query + hash);
};

_.goToFullLayout = function () {
  var hostFolder = _.getHostFolder();
  var query = '';
  var relUrl = window._getRelativeFileName(hostFolder, decodeURI(document.location.href));
  var ref = document.referrer;
  if (ref && !_.isExternalUrl(ref)) {
    var queryMap = _.urlParams(_.extractParamString(ref));
    queryMap[consts('RHMAPID')] = null;
    queryMap[consts('RHMAPNO')] = null;
    if (!_.isEmptyObject(queryMap)) {
      query = '?' + _.mapToEncodedString(queryMap);
    }
  }

  var topicPagePath = consts('START_FILEPATH');
  if (topicPagePath && topicPagePath !== '') {
    var rootUrl = '' + hostFolder + _.fixRelativeUrl(topicPagePath);
    var hashMap = _.urlParams(_.extractParamString(relUrl));
    hashMap[consts('HASH_KEY_TOPIC')] = _.stripParam(relUrl);
    hashMap[consts('HASH_KEY_UIMODE')] = null;
    var hash = '#' + _.mapToEncodedString(hashMap);
    return document.location.replace('' + rootUrl + query + hash);
  }
};

_.goToDefaultTopic = function () {
  rh.model.publish(consts('GO_TO_DEFAULT_TOPIC'), '');
  return false;
};

},{}],4:[function(require,module,exports){
//----------------------------------------------------------------------
//
// ECMAScript 5 Polyfills
//
//----------------------------------------------------------------------

//----------------------------------------------------------------------
// ES5 15.2 Object Objects
//----------------------------------------------------------------------

//
// ES5 15.2.3 Properties of the Object Constructor
//

// ES5 15.2.3.2 Object.getPrototypeOf ( O )
// From http://ejohn.org/blog/objectgetprototypeof/
// NOTE: won't work for typical function T() {}; T.prototype = {}; new T; case
// since the constructor property is destroyed.
if (!Object.getPrototypeOf) {
  Object.getPrototypeOf = function (o) {
    if (o !== Object(o)) { throw TypeError("Object.getPrototypeOf called on non-object"); }
    return o.__proto__ || o.constructor.prototype || Object.prototype;
  };
}

//    // ES5 15.2.3.3 Object.getOwnPropertyDescriptor ( O, P )
//    if (typeof Object.getOwnPropertyDescriptor !== "function") {
//        Object.getOwnPropertyDescriptor = function (o, name) {
//            if (o !== Object(o)) { throw TypeError(); }
//            if (o.hasOwnProperty(name)) {
//                return {
//                    value: o[name],
//                    enumerable: true,
//                    writable: true,
//                    configurable: true
//                };
//            }
//        };
//    }

// ES5 15.2.3.4 Object.getOwnPropertyNames ( O )
if (typeof Object.getOwnPropertyNames !== "function") {
  Object.getOwnPropertyNames = function (o) {
    if (o !== Object(o)) { throw TypeError("Object.getOwnPropertyNames called on non-object"); }
    var props = [], p;
    for (p in o) {
      if (Object.prototype.hasOwnProperty.call(o, p)) {
        props.push(p);
      }
    }
    return props;
  };
}

// ES5 15.2.3.5 Object.create ( O [, Properties] )
if (typeof Object.create !== "function") {
  Object.create = function (prototype, properties) {
    if (typeof prototype !== "object") { throw TypeError(); }
    function Ctor() {}
    Ctor.prototype = prototype;
    var o = new Ctor();
    if (prototype) { o.constructor = Ctor; }
    if (properties !== undefined) {
      if (properties !== Object(properties)) { throw TypeError(); }
      Object.defineProperties(o, properties);
    }
    return o;
  };
}

// ES 15.2.3.6 Object.defineProperty ( O, P, Attributes )
// Partial support for most common case - getters, setters, and values
(function() {
  if (!Object.defineProperty ||
      !(function () { try { Object.defineProperty({}, 'x', {}); return true; } catch (e) { return false; } } ())) {
    var orig = Object.defineProperty;
    Object.defineProperty = function (o, prop, desc) {
      // In IE8 try built-in implementation for defining properties on DOM prototypes.
      if (orig) { try { return orig(o, prop, desc); } catch (e) {} }

      if (o !== Object(o)) { throw TypeError("Object.defineProperty called on non-object"); }
      if (Object.prototype.__defineGetter__ && ('get' in desc)) {
        Object.prototype.__defineGetter__.call(o, prop, desc.get);
      }
      if (Object.prototype.__defineSetter__ && ('set' in desc)) {
        Object.prototype.__defineSetter__.call(o, prop, desc.set);
      }
      if ('value' in desc) {
        o[prop] = desc.value;
      }
      return o;
    };
  }
}());

// ES 15.2.3.7 Object.defineProperties ( O, Properties )
if (typeof Object.defineProperties !== "function") {
  Object.defineProperties = function (o, properties) {
    if (o !== Object(o)) { throw TypeError("Object.defineProperties called on non-object"); }
    var name;
    for (name in properties) {
      if (Object.prototype.hasOwnProperty.call(properties, name)) {
        Object.defineProperty(o, name, properties[name]);
      }
    }
    return o;
  };
}


// ES5 15.2.3.14 Object.keys ( O )
// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object/keys
if (!Object.keys) {
  Object.keys = function (o) {
    if (o !== Object(o)) { throw TypeError('Object.keys called on non-object'); }
    var ret = [], p;
    for (p in o) {
      if (Object.prototype.hasOwnProperty.call(o, p)) {
        ret.push(p);
      }
    }
    return ret;
  };
}

//----------------------------------------------------------------------
// ES5 15.3 Function Objects
//----------------------------------------------------------------------

//
// ES5 15.3.4 Properties of the Function Prototype Object
//

// ES5 15.3.4.5 Function.prototype.bind ( thisArg [, arg1 [, arg2, ... ]] )
// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function/bind
if (!Function.prototype.bind) {
  Function.prototype.bind = function (o) {
    if (typeof this !== 'function') { throw TypeError("Bind must be called on a function"); }

    var args = Array.prototype.slice.call(arguments, 1),
        self = this,
        nop = function() {},
        bound = function () {
          return self.apply(this instanceof nop ? this : o,
                            args.concat(Array.prototype.slice.call(arguments)));
        };

    if (this.prototype)
      nop.prototype = this.prototype;
    bound.prototype = new nop();
    return bound;
  };
}


//----------------------------------------------------------------------
// ES5 15.4 Array Objects
//----------------------------------------------------------------------

//
// ES5 15.4.3 Properties of the Array Constructor
//


// ES5 15.4.3.2 Array.isArray ( arg )
// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/isArray
Array.isArray = Array.isArray || function (o) { return Boolean(o && Object.prototype.toString.call(Object(o)) === '[object Array]'); };


//
// ES5 15.4.4 Properties of the Array Prototype Object
//

// ES5 15.4.4.14 Array.prototype.indexOf ( searchElement [ , fromIndex ] )
// From https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/indexOf
if (!Array.prototype.indexOf) {
  Array.prototype.indexOf = function (searchElement /*, fromIndex */) {
    if (this === void 0 || this === null) { throw TypeError(); }

    var t = Object(this);
    var len = t.length >>> 0;
    if (len === 0) { return -1; }

    var n = 0;
    if (arguments.length > 0) {
      n = Number(arguments[1]);
      if (isNaN(n)) {
        n = 0;
      } else if (n !== 0 && n !== (1 / 0) && n !== -(1 / 0)) {
        n = (n > 0 || -1) * Math.floor(Math.abs(n));
      }
    }

    if (n >= len) { return -1; }

    var k = n >= 0 ? n : Math.max(len - Math.abs(n), 0);

    for (; k < len; k++) {
      if (k in t && t[k] === searchElement) {
        return k;
      }
    }
    return -1;
  };
}

// ES5 15.4.4.15 Array.prototype.lastIndexOf ( searchElement [ , fromIndex ] )
// From https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/lastIndexOf
if (!Array.prototype.lastIndexOf) {
  Array.prototype.lastIndexOf = function (searchElement /*, fromIndex*/) {
    if (this === void 0 || this === null) { throw TypeError(); }

    var t = Object(this);
    var len = t.length >>> 0;
    if (len === 0) { return -1; }

    var n = len;
    if (arguments.length > 1) {
      n = Number(arguments[1]);
      if (n !== n) {
        n = 0;
      } else if (n !== 0 && n !== (1 / 0) && n !== -(1 / 0)) {
        n = (n > 0 || -1) * Math.floor(Math.abs(n));
      }
    }

    var k = n >= 0 ? Math.min(n, len - 1) : len - Math.abs(n);

    for (; k >= 0; k--) {
      if (k in t && t[k] === searchElement) {
        return k;
      }
    }
    return -1;
  };
}

// ES5 15.4.4.16 Array.prototype.every ( callbackfn [ , thisArg ] )
// From https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/every
if (!Array.prototype.every) {
  Array.prototype.every = function (fun /*, thisp */) {
    if (this === void 0 || this === null) { throw TypeError(); }

    var t = Object(this);
    var len = t.length >>> 0;
    if (typeof fun !== "function") { throw TypeError(); }

    var thisp = arguments[1], i;
    for (i = 0; i < len; i++) {
      if (i in t && !fun.call(thisp, t[i], i, t)) {
        return false;
      }
    }

    return true;
  };
}

// ES5 15.4.4.17 Array.prototype.some ( callbackfn [ , thisArg ] )
// From https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/some
if (!Array.prototype.some) {
  Array.prototype.some = function (fun /*, thisp */) {
    if (this === void 0 || this === null) { throw TypeError(); }

    var t = Object(this);
    var len = t.length >>> 0;
    if (typeof fun !== "function") { throw TypeError(); }

    var thisp = arguments[1], i;
    for (i = 0; i < len; i++) {
      if (i in t && fun.call(thisp, t[i], i, t)) {
        return true;
      }
    }

    return false;
  };
}

// ES5 15.4.4.18 Array.prototype.forEach ( callbackfn [ , thisArg ] )
// From https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/forEach
if (!Array.prototype.forEach) {
  Array.prototype.forEach = function (fun /*, thisp */) {
    if (this === void 0 || this === null) { throw TypeError(); }

    var t = Object(this);
    var len = t.length >>> 0;
    if (typeof fun !== "function") { throw TypeError(); }

    var thisp = arguments[1], i;
    for (i = 0; i < len; i++) {
      if (i in t) {
        fun.call(thisp, t[i], i, t);
      }
    }
  };
}


// ES5 15.4.4.19 Array.prototype.map ( callbackfn [ , thisArg ] )
// From https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/Map
if (!Array.prototype.map) {
  Array.prototype.map = function (fun /*, thisp */) {
    if (this === void 0 || this === null) { throw TypeError(); }

    var t = Object(this);
    var len = t.length >>> 0;
    if (typeof fun !== "function") { throw TypeError(); }

    var res = []; res.length = len;
    var thisp = arguments[1], i;
    for (i = 0; i < len; i++) {
      if (i in t) {
        res[i] = fun.call(thisp, t[i], i, t);
      }
    }

    return res;
  };
}

// ES5 15.4.4.20 Array.prototype.filter ( callbackfn [ , thisArg ] )
// From https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/Filter
if (!Array.prototype.filter) {
  Array.prototype.filter = function (fun /*, thisp */) {
    if (this === void 0 || this === null) { throw TypeError(); }

    var t = Object(this);
    var len = t.length >>> 0;
    if (typeof fun !== "function") { throw TypeError(); }

    var res = [];
    var thisp = arguments[1], i;
    for (i = 0; i < len; i++) {
      if (i in t) {
        var val = t[i]; // in case fun mutates this
        if (fun.call(thisp, val, i, t)) {
          res.push(val);
        }
      }
    }

    return res;
  };
}


// ES5 15.4.4.21 Array.prototype.reduce ( callbackfn [ , initialValue ] )
// From https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/Reduce
if (!Array.prototype.reduce) {
  Array.prototype.reduce = function (fun /*, initialValue */) {
    if (this === void 0 || this === null) { throw TypeError(); }

    var t = Object(this);
    var len = t.length >>> 0;
    if (typeof fun !== "function") { throw TypeError(); }

    // no value to return if no initial value and an empty array
    if (len === 0 && arguments.length === 1) { throw TypeError(); }

    var k = 0;
    var accumulator;
    if (arguments.length >= 2) {
      accumulator = arguments[1];
    } else {
      do {
        if (k in t) {
          accumulator = t[k++];
          break;
        }

        // if array contains no values, no initial value to return
        if (++k >= len) { throw TypeError(); }
      }
      while (true);
    }

    while (k < len) {
      if (k in t) {
        accumulator = fun.call(undefined, accumulator, t[k], k, t);
      }
      k++;
    }

    return accumulator;
  };
}


// ES5 15.4.4.22 Array.prototype.reduceRight ( callbackfn [, initialValue ] )
// From https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/ReduceRight
if (!Array.prototype.reduceRight) {
  Array.prototype.reduceRight = function (callbackfn /*, initialValue */) {
    if (this === void 0 || this === null) { throw TypeError(); }

    var t = Object(this);
    var len = t.length >>> 0;
    if (typeof callbackfn !== "function") { throw TypeError(); }

    // no value to return if no initial value, empty array
    if (len === 0 && arguments.length === 1) { throw TypeError(); }

    var k = len - 1;
    var accumulator;
    if (arguments.length >= 2) {
      accumulator = arguments[1];
    } else {
      do {
        if (k in this) {
          accumulator = this[k--];
          break;
        }

        // if array contains no values, no initial value to return
        if (--k < 0) { throw TypeError(); }
      }
      while (true);
    }

    while (k >= 0) {
      if (k in t) {
        accumulator = callbackfn.call(undefined, accumulator, t[k], k, t);
      }
      k--;
    }

    return accumulator;
  };
}


//----------------------------------------------------------------------
// ES5 15.5 String Objects
//----------------------------------------------------------------------

//
// ES5 15.5.4 Properties of the String Prototype Object
//


// ES5 15.5.4.20 String.prototype.trim()
if (!String.prototype.trim) {
  String.prototype.trim = function () {
    return String(this).replace(/^\s+/, '').replace(/\s+$/, '');
  };
}



//----------------------------------------------------------------------
// ES5 15.9 Date Objects
//----------------------------------------------------------------------


//
// ES 15.9.4 Properties of the Date Constructor
//

// ES5 15.9.4.4 Date.now ( )
// From https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Global_Objects/Date/now
if (!Date.now) {
  Date.now = function now() {
    return Number(new Date());
  };
}


//
// ES5 15.9.5 Properties of the Date Prototype Object
//

// ES5 15.9.4.43 Date.prototype.toISOString ( )
// Inspired by http://www.json.org/json2.js
if (!Date.prototype.toISOString) {
  Date.prototype.toISOString = function () {
    function pad2(n) { return ('00' + n).slice(-2); }
    function pad3(n) { return ('000' + n).slice(-3); }

    return this.getUTCFullYear() + '-' +
      pad2(this.getUTCMonth() + 1) + '-' +
      pad2(this.getUTCDate()) + 'T' +
      pad2(this.getUTCHours()) + ':' +
      pad2(this.getUTCMinutes()) + ':' +
      pad2(this.getUTCSeconds()) + '.' +
      pad3(this.getUTCMilliseconds()) + 'Z';
  };
}

},{}],5:[function(require,module,exports){
//----------------------------------------------------------------------
//
// ECMAScript 2015 Polyfills
//
//----------------------------------------------------------------------

(function (global) {
  "use strict";

  // Set this to always override native implementations, for testing
  // the polyfill in browsers with partial/full ES2015 support.
  var OVERRIDE_NATIVE_FOR_TESTING = false;

  var undefined = (void 0); // Paranoia

  // Helpers

  function strict(o) {
    return o === global ? undefined : o;
  }

  function isSymbol(s) {
    return (typeof s === 'symbol') || ('Symbol' in global && s instanceof global.Symbol);
  }

  function getPropertyDescriptor(target, name) {
    var desc = Object.getOwnPropertyDescriptor(target, name);
    var proto = Object.getPrototypeOf(target);
    while (!desc && proto) {
      desc = Object.getOwnPropertyDescriptor(proto, name);
      proto = Object.getPrototypeOf(proto);
    }
    return desc;
  }

  var enqueue = (function(nativePromise, nativeSetImmediate) {
    if (nativePromise)
      return function(job) { nativePromise.resolve().then(function() { job(); }); };
    if (nativeSetImmediate)
      return function(job) { nativeSetImmediate(job); };
    return function(job) { setTimeout(job, 0); };
  }(global['Promise'], global['setImmediate']));

  function define(o, p, v, override) {
    if (p in o && !override && !OVERRIDE_NATIVE_FOR_TESTING)
      return;

    if (typeof v === 'function') {
      // Sanity check that functions are appropriately named (where possible)
      //console.assert(isSymbol(p) || !('name' in v) || v.name === p || v.name === p + '_', 'Expected function name "' + p.toString() + '", was "' + v.name + '"');
      Object.defineProperty(o, p, {
        value: v,
        configurable: true,
        enumerable: false,
        writable: true
      });
    } else {
      Object.defineProperty(o, p, {
        value: v,
        configurable: false,
        enumerable: false,
        writable: false
      });
    }
  }

  function set_internal(o, p, v) {
    Object.defineProperty(o, p, {
      value: v,
      configurable: false,
      enumerable: false,
      writable: true
    });
  }

  // Snapshot intrinsic functions
  var $isNaN = global.isNaN,
      $parseInt = global.parseInt,
      $parseFloat = global.parseFloat;

  var E = Math.E,
      LOG10E = Math.LOG10E,
      LOG2E = Math.LOG2E,
      abs = Math.abs,
      ceil = Math.ceil,
      exp = Math.exp,
      floor = Math.floor,
      log = Math.log,
      max = Math.max,
      min = Math.min,
      pow = Math.pow,
      random = Math.random,
      sqrt = Math.sqrt;

  var orig_match = String.prototype.match,
      orig_replace = String.prototype.replace,
      orig_search = String.prototype.search,
      orig_split = String.prototype.split;

  // These are used for implementing the polyfills, but not exported.

  // Inspired by https://gist.github.com/1638059
  /** @constructor */
  function EphemeronTable() {
    var secretKey = ObjectCreate(null);

    function conceal(o) {
      var oValueOf = o.valueOf, secrets = ObjectCreate(null);
      Object.defineProperty(o, 'valueOf', {
          value: (function(secretKey) {
            return function (k) {
              return (k === secretKey) ? secrets : oValueOf.apply(o, arguments);
            };
          }(secretKey)),
        configurable: true,
        writeable: true,
        enumerable: false
        });
      return secrets;
    }

    function reveal(o) {
      var v = typeof o.valueOf === 'function' && o.valueOf(secretKey);
      return v === o ? null : v;
    }

    return {
      clear: function() {
        secretKey = ObjectCreate(null);
      },
      remove: function(key) {
        var secrets = reveal(key);
        if (secrets && HasOwnProperty(secrets, 'value')) {
          delete secrets.value;
          return true;
        }
        return false;
      },
      get: function(key, defaultValue) {
        var secrets = reveal(key);
        return (secrets && HasOwnProperty(secrets, 'value')) ? secrets.value : defaultValue;
      },
      has: function(key) {
        var secrets = reveal(key);
        return Boolean(secrets && HasOwnProperty(secrets, 'value'));
      },
      set: function(key, value) {
        var secrets = reveal(key) || conceal(key);
        secrets.value = value;
      }
    };
  }

  var empty = Object.create(null);

  //----------------------------------------------------------------------
  //
  // ECMAScript 2015
  // http://www.ecma-international.org/ecma-262/6.0/
  //
  //----------------------------------------------------------------------

  // ---------------------------------------
  // 19.4 Symbol Objects
  // ---------------------------------------

  // NOTE: Symbols are defined here - out of spec order - since we need the
  // properties and prototype to be populated for other polyfills.

  // NOTE: Not secure, nor is obj[$$symbol] hidden from Object.keys()

  var symbolForKey;
  (function() {
    var secret = Object.create(null);
    var symbolMap = {};
    symbolForKey = function(k) {
      return symbolMap[k];
    };

    var GlobalSymbolRegistry = [];

    function unique(bits) {
      return Array(bits + 1).join('x').replace(/x/g, function() {
        return random() < 0.5 ? '\u200C' : '\u200D'; // JWNJ / ZWJ
      });
    }

    // 19.4.1 The Symbol Constructor
    // 19.4.1.1 Symbol ( description=undefined )
    function Symbol(description) {
      if (!(this instanceof Symbol)) return new Symbol(description, secret);
      if (this instanceof Symbol && arguments[1] !== secret) throw TypeError();

      var descString = description === undefined ? undefined : String(description);

      set_internal(this, '[[SymbolData]]', unique(128));
      set_internal(this, '[[Description]]', descString);

      symbolMap[this] = this;
      return this;
    }

    if (!('Symbol' in global) || OVERRIDE_NATIVE_FOR_TESTING)
      global.Symbol = Symbol;

    // 19.4.2 Properties of the Symbol Constructor

    // 19.4.2.1 Symbol.for (key)
    define(Symbol, 'for', function for_(key) {
      var stringKey = String(key);
      for (var i = 0; i < GlobalSymbolRegistry.length; ++i) {
        var e = GlobalSymbolRegistry[i];
        if (SameValue(e['[[key]]'], stringKey)) return e['[[symbol]]'];
      }
      var newSymbol = Symbol(key);
      GlobalSymbolRegistry.push({'[[key]]': stringKey, '[[symbol]]': newSymbol});
      return newSymbol;
    });

    // 19.4.2.2 Symbol.hasInstance
    // 19.4.2.3 Symbol.isConcatSpreadable

    // 19.4.2.4 Symbol.iterator
    define(global.Symbol, 'iterator', global.Symbol('Symbol.iterator'));

    // 19.4.2.5 Symbol.keyFor (sym)
    define(Symbol, 'keyFor', function keyFor(sym) {
      if (!(sym instanceof Symbol)) throw TypeError();
      for (var i = 0; i < GlobalSymbolRegistry.length; ++i) {
        var e = GlobalSymbolRegistry[i];
        if (SameValue(e['[[symbol]]'], sym)) return e['[[key]]'];
      }
      return undefined;
    });

    // 19.4.2.6 Symbol.match
    define(global.Symbol, 'match', global.Symbol('Symbol.match'));

    // 19.4.2.7 Symbol.prototype

    // 19.4.2.8 Symbol.replace
    define(global.Symbol, 'replace', global.Symbol('Symbol.replace'));

    // 19.4.2.9 Symbol.search
    define(global.Symbol, 'search', global.Symbol('Symbol.search'));

    // 19.4.2.10 Symbol.species

    // 19.4.2.11 Symbol.search
    define(global.Symbol, 'split', global.Symbol('Symbol.split'));

    // 19.4.2.12 Symbol.toPrimitive

    // 19.4.2.13 Symbol.toStringTag
    define(global.Symbol, 'toStringTag', global.Symbol('Symbol.toStringTag'));

    // 19.4.2.14 Symbol.unscopables

    // 19.4.3 Properties of the Symbol Prototype Object
    // 19.4.3.1 Symbol.prototype.constructor

    // 19.4.3.2 Symbol.prototype.toString ( )
    Object.defineProperty(Symbol.prototype, 'toString', {
      value: function toString() {
        var s = strict(this);
        var desc = s['[[Description]]'];
        return 'Symbol(' + (desc === undefined ? '' : desc) + s['[[SymbolData]]'] + ')';
      },
      configurable: true, writeable: true, enumerable: false });

    // 19.4.3.3 Symbol.prototype.valueOf ( )
    Object.defineProperty(Symbol.prototype, 'valueOf', {
      value: function valueOf() {
        // To prevent automatic string conversion:
        throw TypeError();

        // Spec has approximately the following:
        //var s = strict(this);
        //if (Type(s) === 'symbol') return s;
        //if (Type(s) !== 'object') throw TypeError();
        //if (!('[[SymbolData]]' in s)) throw TypeError();
        //return s['[[SymbolData]]'];
      },
      configurable: true, writeable: true, enumerable: false });

    // 19.4.3.4 Symbol.prototype [ @@toStringTag ]
    // (Done later to polyfill partial implementations)

    // 19.4.4 Properties of Symbol Instances
  }());

  console.assert(typeof global.Symbol() === 'symbol' || symbolForKey(String(global.Symbol('x'))) !== undefined);

  // Defined here so that other prototypes can reference it
  // 25.1.2 The %IteratorPrototype% Object
  var $IteratorPrototype$ = {};

  //----------------------------------------
  // 6 ECMAScript Data Types and Values
  //----------------------------------------

  // 6.1 ECMAScript Language Types

  // "Type(x)" is used as shorthand for "the type of x"...
  function Type(v) {
    switch (typeof v) {
    case 'undefined': return 'undefined';
    case 'boolean': return 'boolean';
    case 'number': return 'number';
    case 'string': return 'string';
    case 'symbol': return 'symbol';
    default:
      if (v === null) return 'null';
      if (v instanceof global.Symbol) return 'symbol';
      return 'object';
    }
  }

  // 6.1.5.1 Well-Known Symbols
  var $$iterator = global.Symbol.iterator,
      $$match = global.Symbol.match,
      $$replace = global.Symbol.replace,
      $$search = global.Symbol.search,
      $$split = global.Symbol.split,
      $$toStringTag = global.Symbol.toStringTag;

  //----------------------------------------
  // 7 Abstract Operations
  //----------------------------------------

  //----------------------------------------
  // 7.1 Type Conversion
  //----------------------------------------

  // 7.1.1 ToPrimitive ( input [, PreferredType] )
  // just use valueOf()

  // 7.1.2 ToBoolean ( argument )
  // just use Boolean()

  // 7.1.3 ToNumber ( argument )
  // just use Number()

  // 7.1.4 ToInteger ( argument )
  function ToInteger(n) {
    n = Number(n);
    if ($isNaN(n)) return 0;
    if (n === 0 || n === Infinity || n === -Infinity) return n;
    return ((n < 0) ? -1 : 1) * floor(abs(n));
  }

  // 7.1.5 ToInt32 ( argument )
  function ToInt32(v) { return v >> 0; }

  // 7.1.6 ToUint32 ( argument )
  function ToUint32(v) { return v >>> 0; }

  // 7.1.7 ToInt16 ( argument )
  function ToInt16(v) { return (v << 16) >> 16; }

  // 7.1.8 ToUint16 ( argument )
  function ToUint16(v) { return v & 0xFFFF; }

  // 7.1.9 ToInt8 ( argument )
  function ToInt8(v) { return (v << 24) >> 24; }

  // 7.1.10 ToUint8 ( argument )
  function ToUint8(v) { return v & 0xFF; }

  // 7.1.11 ToUint8Clamp ( argument )
  function ToUint8Clamp(argument) {
    var number = Number(argument);
    if ($isNaN(number)) return 0;
    if (number <= 0) return 0;
    if (number >= 255) return 255;
    var f = floor(number);
    if ((f + 0.5) < number) return f + 1;
    if (number < (f + 0.5)) return f;
    if (f % 2) return f + 1;
    return f;
  }

  // 7.1.12 ToString ( argument )
  // just use String()

  // 7.1.13 ToObject ( argument )
  function ToObject(v) {
    if (v === null || v === undefined) throw TypeError();
    return Object(v);
  }

  // 7.1.14 ToPropertyKey ( argument )
  function ToPropertyKey(v) {
    return String(v);
  }

  // 7.1.15 ToLength ( argument )
  function ToLength(v) {
    var len = ToInteger(v);
    if (len <= 0) return 0;
    if (len === Infinity) return 0x20000000000000 - 1; // 2^53-1
    return min(len, 0x20000000000000 - 1); // 2^53-1
  }

  // 7.1.16 CanonicalNumericIndexString ( argument )

  //----------------------------------------
  // 7.2 Testing and Comparison Operations
  //----------------------------------------

  // 7.2.1 RequireObjectCoercible ( argument )
  // 7.2.2 IsArray ( argument )

  // 7.2.3 IsCallable ( argument )
  function IsCallable(o) { return typeof o === 'function'; }

  // 7.2.4 IsConstructor ( argument )
  function IsConstructor(o) {
    // Hacks for Safari 7 TypedArray XXXConstructor objects
    if (/Constructor/.test(Object.prototype.toString.call(o))) return true;
    if (/Function/.test(Object.prototype.toString.call(o))) return true;
    // TODO: Can this be improved on?
    return typeof o === 'function';
  }

  // 7.2.5 IsExtensible (O)
  // 7.2.6 IsInteger ( argument )

  // 7.2.7 IsPropertyKey ( argument )
  function IsPropertyKey(argument) {
    if (Type(argument) === 'string') return true;
    if (Type(argument) === 'symbol') return true;
    return false;
  }

  // 7.2.8 IsRegExp ( argument )

  // 7.2.9 SameValue(x, y)
  function SameValue(x, y) {
    if (typeof x !== typeof y) return false;
    switch (typeof x) {
    case 'undefined':
      return true;
    case 'number':
      if (x !== x && y !== y) return true;
      if (x === 0 && y === 0) return 1/x === 1/y;
      return x === y;
    case 'boolean':
    case 'string':
    case 'object':
    default:
      return x === y;
    }
  }

  // 7.2.10 SameValueZero(x, y)
  function SameValueZero(x, y) {
    if (typeof x !== typeof y) return false;
    switch (typeof x) {
    case 'undefined':
      return true;
    case 'number':
      if (x !== x && y !== y) return true;
      return x === y;
    case 'boolean':
    case 'string':
    case 'object':
    default:
      return x === y;
    }
  }

  //----------------------------------------
  // 7.3 Operations on Objects
  //----------------------------------------

  // 7.3.1 Get (O, P)
  // - just use o.p or o[p]

  // 7.3.2 GetV (V, P)
  function GetV(v, p) {
    var o = ToObject(v);
    return o[p];
  }

  // 7.3.3 Set (O, P, V, Throw)
  // - just use o.p = v or o[p] = v




  // 7.3.9 GetMethod (O, P)
  function GetMethod(o, p) {
    var func = GetV(o, p);
    if (func === undefined || func === null) return undefined;
    if (!IsCallable(func)) throw TypeError();
    return func;
  }

  // 7.3.10 HasProperty (O, P)
  function HasProperty(o, p) {
    while (o) {
      if (Object.prototype.hasOwnProperty.call(o, p)) return true;
      if (Type(o) !== 'object') return false;
      var op = Object.getPrototypeOf(o);
      if (op === o) return false; // IE8 has self-referential prototypes
      o = op;
    }
    return false;
  }

  // 7.3.11 HasOwnProperty (O, P)
  function HasOwnProperty(o, p) {
    return Object.prototype.hasOwnProperty.call(o, p);
  }

  //----------------------------------------
  // 7.4 Operations on Iterator Objects
  //----------------------------------------

  // 7.4.1 GetIterator ( obj, method )
  function GetIterator(obj, method) {
    if (arguments.length < 2)
      method = GetMethod(obj, $$iterator);
    var iterator = method.call(obj);
    if (Type(iterator) !== 'object') throw TypeError();
    return iterator;
  }

  // 7.4.2 IteratorNext ( iterator, value )
  function IteratorNext(iterator, value) {
    if (arguments.length < 2)
      var result = iterator.next();
    else
      result = iterator.next(value);
    if (Type(result) !== 'object') throw TypeError();
    return result;
  }

  // 7.4.3 IteratorComplete ( iterResult )
  function IteratorComplete(iterResult) {
    console.assert(Type(iterResult) === 'object');
    return Boolean(iterResult.done);
  }

  // 7.4.4 IteratorValue ( iterResult )
  function IteratorValue(iterResult) {
    console.assert(Type(iterResult) === 'object');
    return iterResult.value;
  }

  // 7.4.5 IteratorStep ( iterator )
  function IteratorStep( iterator, value ) {
    var result = IteratorNext(iterator, value);
    var done = result['done'];
    if (Boolean(done) === true) return false;
    return result;
  }

  // 7.4.6 IteratorClose( iterator, completion )
  function IteratorClose( iterator, completion ) {
    console.assert(Type(iterator) === 'object');
    var _return = GetMethod(iterator, 'return');
    if (_return === undefined) return completion;
    try {
      var innerResult = _return[iterator]();
    } catch (result) {
      // TODO: If completion.[[type]] is throw, return completion
      return result;
    }
    if (Type(innerResult) !== 'object') throw TypeError();
    return completion;
  }

  // 7.4.7 CreateIterResultObject (value, done)
  function CreateIterResultObject(value, done) {
    console.assert(Type(done) === 'boolean');
    var obj = {};
    obj["value"] = value;
    obj["done"] = done;
    return obj;
  }

  // 7.4.8 CreateListIterator (list)
  // 7.4.8.1 ListIterator next( )

  //----------------------------------------
  // 8 Executable Code and Execution Contexts
  //----------------------------------------

  //----------------------------------------
  // 8.4 Jobs and Job Queues
  //----------------------------------------

  // 8.4.1 EnqueueJob ( queueName, job, arguments)
  function EnqueueJob(queueName, job, args) {
    var fn = function() { job.apply(undefined, args); };
    enqueue(fn);
  }

  // 8.4.2 NextJob result
  function NextJob(result) {
    // no-op
  }

  //----------------------------------------
  // 9 Ordinary and Exotic Objects Behaviors
  //----------------------------------------

  // 9.1.11 [[Enumerate]] ()
  function Enumerate(obj) {
    var e = [];
    if (Object(obj) !== obj) return e;
    var visited = new Set;
    while (obj !== null) {
      Object.getOwnPropertyNames(obj).forEach(function(name) {
        if (!visited.has(name)) {
          var desc = Object.getOwnPropertyDescriptor(obj, name);
          if (desc) {
            visited.add(name);
            if (desc.enumerable) e.push(name);
          }
        }
      });
      obj = Object.getPrototypeOf(obj);
    }
    return e[$$iterator]();
  }

  // 9.1.12 [[OwnPropertyKeys]] ( )
  function OwnPropertyKeys(o) {
    return Object.getOwnPropertyNames(o);
  }

  // 9.1.13 ObjectCreate(proto, internalSlotsList)
  function ObjectCreate(proto, internalSlotsList) {
    return Object.create(proto, internalSlotsList);
  }

  // ---------------------------------------
  // 19 Fundamental Objects
  // ---------------------------------------

  // ---------------------------------------
  // 19.1 Object Objects
  // ---------------------------------------

  // 19.1.1 The Object Constructor
  // 19.1.1.1 Object ( [ value ] )
  // 19.1.2 Properties of the Object Constructor
  // 19.1.2.1 Object.assign ( target, ...sources )
  define(
    Object, 'assign',
    function assign(target, /*...*/sources) {
      var to = ToObject(target);
      if (arguments.length < 2) return to;

      var sourcesIndex = 1;
      while (sourcesIndex < arguments.length) {
        var nextSource = arguments[sourcesIndex++];
        if (nextSource === undefined || nextSource === null) {
          var keys = [];
        } else {
          var from = ToObject(nextSource);
          keys = OwnPropertyKeys(from);
        }
        for (var keysIndex = 0; keysIndex < keys.length; ++keysIndex) {
          var nextKey = keys[keysIndex];
          var desc = Object.getOwnPropertyDescriptor(from, nextKey);
          if (desc !== undefined && desc.enumerable) {
            var propValue = from[nextKey];
            to[nextKey] = propValue;
          }
        }
      }
      return to;
    });

  // 19.1.2.2 Object.create ( O [ , Properties ] )
  // 19.1.2.3 Object.defineProperties ( O, Properties )
  // 19.1.2.4 Object.defineProperty ( O, P, Attributes )
  // 19.1.2.5 Object.freeze ( O )
  // 19.1.2.6 Object.getOwnPropertyDescriptor ( O, P )

  (function() {
    var nativeSymbols = (typeof global.Symbol() === 'symbol'),
        $getOwnPropertyNames = Object.getOwnPropertyNames,
        $keys = Object.keys,
        $window_names = (typeof window === 'object' ? $getOwnPropertyNames(window) : []);

    function isStringKey(k) { return !symbolForKey(k); }

    // 19.1.2.7 Object.getOwnPropertyNames ( O )
    define(
      Object, 'getOwnPropertyNames',
      function getOwnPropertyNames(o) {
        if (Object.prototype.toString.call(o) === '[object Window]') {
          // Workaround for cross-realm calling by IE itself.
          // https://github.com/inexorabletash/polyfill/issues/96
          try {
            return $getOwnPropertyNames(o).filter(isStringKey);
          } catch (_) {
            return $window_names.slice();
          }
        }
        return $getOwnPropertyNames(o).filter(isStringKey);
      }, !nativeSymbols);

    // 19.1.2.8 Object.getOwnPropertySymbols ( O )
    define(
      Object, 'getOwnPropertySymbols',
      function getOwnPropertySymbols(o) {
        return $getOwnPropertyNames(o).filter(symbolForKey).map(symbolForKey);
      }, !nativeSymbols);

    // 19.1.2.14 Object.keys ( O )
    define(
      Object, 'keys',
      function keys(o) {
        return $keys(o).filter(isStringKey);
      }, !nativeSymbols);
  }());

  // 19.1.2.9 Object.getPrototypeOf ( O )
  // 19.1.2.10 Object.is ( value1, value2 )
  define(
    Object, 'is',
    function is(value1, value2) {
      return SameValue(value1, value2);
    });

  // 19.1.2.11 Object.isExtensible ( O )
  // 19.1.2.12 Object.isFrozen ( O )
  // 19.1.2.13 Object.isSealed ( O )

  // 19.1.2.14 Object.keys ( O )
  // see above

  // 19.1.2.15 Object.preventExtensions ( O )
  // 19.1.2.16 Object.prototype
  // 19.1.2.17 Object.seal ( O )

  // 19.1.2.18 Object.setPrototypeOf ( O, proto )
  define(
    Object, 'setPrototypeOf',
    function setPrototypeOf(o, proto) {
      if (Type(o) !== 'object') throw TypeError();
      if (Type(proto) !== 'object' && Type(proto) !== 'null') throw TypeError();
      o.__proto__ = proto;
      return o;
    }
  );

  // 19.1.3 Properties of the Object Prototype Object
  // 19.1.3.1 Object.prototype.constructor
  // 19.1.3.2 Object.prototype.hasOwnProperty ( V )
  // 19.1.3.3 Object.prototype.isPrototypeOf ( V )
  // 19.1.3.4 Object.prototype.propertyIsEnumerable ( V )
  // 19.1.3.5 Object.prototype.toLocaleString ( [ reserved1 [ , reserved2 ] ] )
  // 19.1.3.6 Object.prototype.toString ( )
  var o_p_ts = Object.prototype.toString;
  define(Object.prototype, 'toString',
       function() {
         var o = strict(this);
         if (o === Object(o) && $$toStringTag in o) {
           return '[object ' + o[$$toStringTag] + ']';
         }
         return o_p_ts.apply(o, arguments);
       });

  // 19.1.3.7 Object.prototype.valueOf ( )
  // 19.1.4 Properties of Object Instances

  // ---------------------------------------
  // 19.2 Function Objects
  // ---------------------------------------

  // 19.2.1 The Function Constructor
  // 19.2.1.1 Function ( p1, p2, … , pn, body )
  // 19.2.2 Properties of the Function Constructor
  // 19.2.2.1 Function.length
  // 19.2.2.2 Function.prototype
  // 19.2.3 Properties of the Function Prototype Object
  // 19.2.3.1 Function.prototype.apply ( thisArg, argArray )
  // 19.2.3.2 Function.prototype.bind ( thisArg , ...args)
  // 19.2.3.3 Function.prototype.call (thisArg , ...args)
  // 19.2.3.4 Function.prototype.constructor
  // 19.2.3.5 Function.prototype.toString ( )
  // 19.2.3.6 Function.prototype[@@hasInstance] ( V )
  // 19.2.4 Function Instances
  // 19.2.4.1 length
  // 19.2.4.2 name
  // 19.2.4.3 prototype

  // (No polyfillable changes from ES5)

  // ---------------------------------------
  // 19.3 Boolean Objects
  // ---------------------------------------

  // 19.3.1 The Boolean Constructor
  // 19.3.1.1 Boolean ( value )
  // 19.3.2 Properties of the Boolean Constructor
  // 19.3.2.1 Boolean.prototype
  // 19.3.3 Properties of the Boolean Prototype Object
  // 19.3.3.1 Boolean.prototype.constructor
  // 19.3.3.2 Boolean.prototype.toString ( )
  // 19.3.3.3 Boolean.prototype.valueOf ( )
  // 19.3.4 Properties of Boolean Instances

  // (No polyfillable changes from ES5)

  // ---------------------------------------
  // 19.4 Symbol Objects
  // ---------------------------------------

  // Moved earlier in this script, so that other polyfills can depend on them.

  // 19.4.3.4 Symbol.prototype [ @@toStringTag ]
  define(global.Symbol.prototype, global.Symbol.toStringTag, 'Symbol');

  // ---------------------------------------
  // 19.5 Error Objects
  // ---------------------------------------

  // 19.5.1 The Error Constructor
  // 19.5.1.1 Error ( message )
  // 19.5.1.2 new Error( ...argumentsList )
  // 19.5.2 Properties of the Error Constructor
  // 19.5.2.1 Error.prototype
  // 19.5.3 Properties of the Error Prototype Object
  // 19.5.3.1 Error.prototype.constructor
  // 19.5.3.2 Error.prototype.message
  // 19.5.3.3 Error.prototype.name
  // 19.5.3.4 Error.prototype.toString ( )
  // 19.5.4 Properties of Error Instances
  // 19.5.5 Native Error Types Used in This Standard
  // 19.5.5.1 EvalError
  // 19.5.5.2 RangeError
  // 19.5.5.3 ReferenceError
  // 19.5.5.4 SyntaxError
  // 19.5.5.5 TypeError
  // 19.5.5.6 URIError
  // 19.5.6 NativeError Object Structure
  // 19.5.6.1 NativeError Constructors
  // 19.5.6.1.1 NativeError ( message )
  // 19.5.6.1.2 new NativeError ( ...argumentsList )
  // 19.5.6.2 Properties of the NativeError Constructors
  // 19.5.6.2.1 NativeError.prototype
  // 19.5.6.3 Properties of the NativeError Prototype Objects
  // 19.5.6.4 Properties of NativeError Instances

  // (No polyfillable changes from ES5)

  // ---------------------------------------
  // 20 Numbers and Dates
  // ---------------------------------------

  // ---------------------------------------
  // 20.1 Number Objects
  // ---------------------------------------

  // 20.1.1 The Number Constructor
  // 20.1.1.1 Number ( [ value ] )
  // 20.1.1.2 new Number ( ...argumentsList )
  // 20.1.2 Properties of the Number Constructor

  // 20.1.2.1 Number.EPSILON
  define(
    Number, 'EPSILON',
    (function () {
      var next, result;
      for (next = 1; 1 + next !== 1; next = next / 2)
        result = next;
      return result;
    }()));

  // 20.1.2.2 Number.isFinite ( number )
  define(
    Number, 'isFinite',
    function isFinite(number) {
      if (Type(number) !== 'number') return false;
      if (number !== number || number === +Infinity || number === -Infinity) return false;
      return true;
    });

  // 20.1.2.3 Number.isInteger ( number )
  define(
    Number, 'isInteger',
    function isInteger(number) {
      if (Type(number) !== 'number') return false;
      if (number !== number || number === +Infinity || number === -Infinity) return false;
      var integer = ToInteger(number);
      if (integer !== number) return false;
      return true;
    });

  // 20.1.2.4 Number.isNaN ( number )
  define(
    Number, 'isNaN',
    function isNaN(number) {
      if (Type(number) !== 'number') return false;
      if (number !== number) return true;
      return false;
    });

  // 20.1.2.5 Number.isSafeInteger ( number )
  define(
    Number, 'isSafeInteger',
    function isSafeInteger(number) {
      if (Type(number) !== 'number') return false;
      if (number !== number || number === +Infinity || number === -Infinity) return false;
      var integer = ToInteger(number);
      if (integer !== number) return false;
      if (abs(integer) <= (0x20000000000000 - 1)) // 2^53-1
        return true;
      return false;
    });

  // 20.1.2.6 Number.MAX_SAFE_INTEGER
  define(
    Number, 'MAX_SAFE_INTEGER',
    9007199254740991); // 2^53-1

  // 20.1.2.7 Number.MAX_VALUE

  // 20.1.2.8 Number.MIN_SAFE_INTEGER
  define(
    Number, 'MIN_SAFE_INTEGER',
    -9007199254740991); // -2^53+1

  // 20.1.2.9 Number.MIN_VALUE
  // 20.1.2.10 Number.NaN
  // 20.1.2.11 Number.NEGATIVE_INFINITY

  // 20.1.2.12 Number.parseFloat ( string )
  define(Number, 'parseFloat', $parseFloat);

  // 20.1.2.13 Number.parseInt ( string, radix )
  define(Number, 'parseInt', $parseInt);

  // 20.1.2.14 Number.POSITIVE_INFINITY
  // 20.1.2.15 Number.prototype

  // 20.1.3 Properties of the Number Prototype Object
  // 20.1.3.1 Number.prototype.constructor
  // 20.1.3.2 Number.prototype.toExponential ( fractionDigits )
  // 20.1.3.3 Number.prototype.toFixed ( fractionDigits )
  // 20.1.3.4 Number.prototype.toLocaleString( [ reserved1 [ , reserved2 ] ])
  // 20.1.3.5 Number.prototype.toPrecision ( precision )
  // 20.1.3.6 Number.prototype.toString ( [ radix ] )
  // 20.1.3.7 Number.prototype.valueOf ( )
  // 20.1.4 Properties of Number Instances

  // ---------------------------------------
  // 20.2 The Math Object
  // ---------------------------------------

  // 20.2.1 Value Properties of the Math Object
  // 20.2.1.1 Math.E
  // 20.2.1.2 Math.LN10
  // 20.2.1.3 Math.LN2
  // 20.2.1.4 Math.LOG10E
  // 20.2.1.5 Math.LOG2E
  // 20.2.1.6 Math.PI
  // 20.2.1.7 Math.SQRT1_2
  // 20.2.1.8 Math.SQRT2

  // 20.2.1.9 Math [ @@toStringTag ]
  define(Math, $$toStringTag, 'Math');

  // 20.2.2 Function Properties of the Math Object
  // 20.2.2.1 Math.abs ( x )
  // 20.2.2.2 Math.acos ( x )

  // 20.2.2.3 Math.acosh(x)
  define(
    Math, 'acosh',
    function acosh(x) {
      x = Number(x);
      return log(x + sqrt(x * x - 1));
    });

  // 20.2.2.4 Math.asin ( x )

  // 20.2.2.5 Math.asinh( x )
  define(
    Math, 'asinh',
    function asinh(x) {
      x = Number(x);
      if (SameValue(x, -0)) {
        return x;
      }
      var s = sqrt(x * x + 1);
      return (s === -x) ? log(0) : log(x + s);
    });

  // 20.2.2.6 Math.atan ( x )

  // 20.2.2.7 Math.atanh( x )
  define(
    Math, 'atanh',
    function atanh(x) {
      x = Number(x);
      return (x === 0) ? x : log((1 + x) / (1 - x)) / 2;
    });

  // 20.2.2.8 Math.atan2 ( y, x )

  // 20.2.2.9 Math.cbrt ( x )
  define(
    Math, 'cbrt',
    function cbrt(x) {
      x = Number(x);
      if ($isNaN(x/x)) {
        return x;
      }
      var r = pow(abs(x), 1/3);
      var t = x/r/r;
      return r + (r * (t-r) / (2*r + t));
    });

  // 20.2.2.10 Math.ceil ( x )

  // 20.2.2.11 Math.clz32 ( x )
  define(
    Math, 'clz32',
    function clz32(x) {
      function clz8(x) {
        return (x & 0xf0) ? (x & 0x80 ? 0 : x & 0x40 ? 1 : x & 0x20 ? 2 : 3) :
        (x & 0x08 ? 4 : x & 0x04 ? 5 : x & 0x02 ? 6 : x & 0x01 ? 7 : 8);
      }
      x = ToUint32(x);
      return x & 0xff000000 ? clz8(x >> 24) :
        x & 0xff0000 ? clz8(x >> 16) + 8 :
        x & 0xff00 ? clz8(x >> 8) + 16 : clz8(x) + 24;
    });



  // 20.2.2.12 Math.cos ( x )

  // 20.2.2.13 Math.cosh ( x )
  define(
    Math, 'cosh',
    function cosh(x) {
      x = Number(x);
      return (pow(E, x) + pow(E, -x)) / 2;
    });

  // 20.2.2.14 Math.exp ( x )

  // 20.2.2.15 Math.expm1 ( x )
  define(
    Math, 'expm1',
    function expm1(x) {
      x = Number(x);
      // from: http://www.johndcook.com/cpp_log1p.html
      if (SameValue(x, -0)) {
        return -0;
      } else if (abs(x) < 1e-5) {
        return x + 0.5 * x * x; // two terms of Taylor expansion
      } else {
        return exp(x) - 1;
      }
    });

  // 20.2.2.16 Math.floor ( x )

  // 20.2.2.17 Math.fround ( x )
  define(
    Math, 'fround',
    function fround(x) {
      if ($isNaN(x)) {
        return NaN;
      }
      if (1/x === +Infinity || 1/x === -Infinity || x === +Infinity || x === -Infinity) {
        return x;
      }
      return (new Float32Array([x]))[0];
    });

  // 20.2.2.18 Math.hypot ( value1 [, value2 [ ... ] ] )
  define(
    Math, 'hypot',
    function hypot() {
      var values = [];
      var m = 0, sawNaN = false;
      for (var i = 0; i < arguments.length; ++i) {
        var n = abs(Number(arguments[i]));
        if (n === Infinity) return n;
        if (n !== n) sawNaN = true;
        if (n > m) m = n;
        values[i] = n;
      }
      if (sawNaN) return NaN;
      if (m === 0) return +0;
      var sum = +0;
      for (i = 0; i < values.length; ++i) {
        var r = values[i] / m;
        sum = sum + r * r;
      }
      return m * sqrt(sum);
    });

  // 20.2.2.19 Math.imul ( x, y )
  define(
    Math, 'imul',
    function imul(x, y) {
      var a = ToUint32(x);
      var b = ToUint32(y);
      // (slow but accurate)
      var ah  = (a >>> 16) & 0xffff;
      var al = a & 0xffff;
      var bh  = (b >>> 16) & 0xffff;
      var bl = b & 0xffff;
      return ((al * bl) + (((ah * bl + al * bh) << 16) >>> 0)|0);
    }, ('imul' in Math && Math.imul(1, 0x80000000) === 0) // Safari 7 bug
  );

  // 20.2.2.20 Math.log ( x )

  // 20.2.2.21 Math.log1p ( x )
  define(
    Math, 'log1p',
    function log1p(x) {
      x = Number(x);
      // from: http://www.johndcook.com/cpp_expm1.html
      if (x < -1) {
        return NaN;
      } else if (SameValue(x, -0)) {
        return -0;
      } else if (abs(x) > 1e-4) {
        return log(1 + x);
      } else {
        return (-0.5 * x + 1) * x;
      }
    });

  // 20.2.2.22 Math.log10 ( x )
  define(
    Math, 'log10',
    function log10(x) {
      x = Number(x);
      return log(x) * LOG10E;
    });

  // 20.2.2.23 Math.log2 ( x )
  define(
    Math, 'log2',
    function log2(x) {
      x = Number(x);
      return log(x) * LOG2E;
    });

  // 20.2.2.24 Math.max ( value1, value2 , ...values )
  // 20.2.2.25 Math.min ( value1, value2 , ...values )
  // 20.2.2.26 Math.pow ( x, y )
  // 20.2.2.27 Math.random ( )
  // 20.2.2.28 Math.round ( x )

  // 20.2.2.29 Math.sign(x)
  define(
    Math, 'sign',
    function sign(x) {
      x = Number(x);
      return x < 0 ? -1 : x > 0 ? 1 : x;
    });

  // 20.2.2.30 Math.sin ( x )

  // 20.2.2.31 Math.sinh( x )
  define(
    Math, 'sinh',
    function sinh(x) {
      x = Number(x);
      return SameValue(x, -0) ? x : (pow(E, x) - pow(E, -x)) / 2;
    });

  // 20.2.2.32 Math.sqrt ( x )
  // 20.2.2.33 Math.tan ( x )

  // 20.2.2.34 Math.tanh ( x )
  define(
    Math, 'tanh',
    function tanh(x) {
      x = Number(x);
      var n = pow(E, 2 * x) - 1,
          d = pow(E, 2 * x) + 1;
      if (SameValue(x, -0))
        return x;
      return (n === d) ? 1 : n / d; // Handle Infinity/Infinity
    });

  // 20.2.2.35 Math.trunc ( x )
  define(
    Math, 'trunc',
    function trunc(x) {
      x = Number(x);
      return $isNaN(x) ? NaN :
        x < 0 ? ceil(x) : floor(x);
    });

  // ---------------------------------------
  // 20.3 Date Objects
  // ---------------------------------------

  // 20.3.1 Overview of Date Objects and Definitions of Abstract Operations
  // 20.3.1.1 Time Values and Time Range
  // 20.3.1.2 Day Number and Time within Day
  // 20.3.1.3 Year Number
  // 20.3.1.4 Month Number
  // 20.3.1.5 Date Number
  // 20.3.1.6 Week Day
  // 20.3.1.7 Local Time Zone Adjustment
  // 20.3.1.8 Daylight Saving Time Adjustment
  // 20.3.1.9 Local Time
  // 20.3.1.10 Hours, Minutes, Second, and Milliseconds
  // 20.3.1.11 MakeTime (hour, min, sec, ms)
  // 20.3.1.12 MakeDay (year, month, date)
  // 20.3.1.13 MakeDate (day, time)
  // 20.3.1.14 TimeClip (time)
  // 20.3.1.15 Date Time String Format
  // 20.3.1.15.1 Extended years
  // 20.3.2 The Date Constructor
  // 20.3.2.1 Date ( year, month [, date [ , hours [ , minutes [ , seconds [ , ms ] ] ] ] ] )
  // 20.3.2.2 Date ( value )
  // 20.3.2.3 Date ( )
  // 20.3.3 Properties of the Date Constructor
  // 20.3.3.1 Date.now ( )
  // 20.3.3.2 Date.parse (string)
  // 20.3.3.3 Date.prototype
  // 20.3.3.4 Date.UTC ( year, month [ , date [ , hours [ , minutes [ , seconds [ , ms ] ] ] ] ] )
  // 20.3.4 Properties of the Date Prototype Object
  // 20.3.4.1 Date.prototype.constructor
  // 20.3.4.2 Date.prototype.getDate ( )
  // 20.3.4.3 Date.prototype.getDay ( )
  // 20.3.4.4 Date.prototype.getFullYear ( )
  // 20.3.4.5 Date.prototype.getHours ( )
  // 20.3.4.6 Date.prototype.getMilliseconds ( )
  // 20.3.4.7 Date.prototype.getMinutes ( )
  // 20.3.4.8 Date.prototype.getMonth ( )
  // 20.3.4.9 Date.prototype.getSeconds ( )
  // 20.3.4.10 Date.prototype.getTime ( )
  // 20.3.4.11 Date.prototype.getTimezoneOffset ( )
  // 20.3.4.12 Date.prototype.getUTCDate ( )
  // 20.3.4.13 Date.prototype.getUTCDay ( )
  // 20.3.4.14 Date.prototype.getUTCFullYear ( )
  // 20.3.4.15 Date.prototype.getUTCHours ( )
  // 20.3.4.16 Date.prototype.getUTCMilliseconds ( )
  // 20.3.4.17 Date.prototype.getUTCMinutes ( )
  // 20.3.4.18 Date.prototype.getUTCMonth ( )
  // 20.3.4.19 Date.prototype.getUTCSeconds ( )
  // 20.3.4.20 Date.prototype.setDate ( date )
  // 20.3.4.21 Date.prototype.setFullYear ( year [ , month [ , date ] ] )
  // 20.3.4.22 Date.prototype.setHours ( hour [ , min [ , sec [ , ms ] ] ] )
  // 20.3.4.23 Date.prototype.setMilliseconds ( ms )
  // 20.3.4.24 Date.prototype.setMinutes ( min [ , sec [ , ms ] ] )
  // 20.3.4.25 Date.prototype.setMonth ( month [ , date ] )
  // 20.3.4.26 Date.prototype.setSeconds ( sec [ , ms ] )
  // 20.3.4.27 Date.prototype.setTime ( time )
  // 20.3.4.28 Date.prototype.setUTCDate ( date )
  // 20.3.4.29 Date.prototype.setUTCFullYear ( year [ , month [ , date ] ] )
  // 20.3.4.30 Date.prototype.setUTCHours ( hour [ , min [ , sec [ , ms ] ] ] )
  // 20.3.4.31 Date.prototype.setUTCMilliseconds ( ms )
  // 20.3.4.32 Date.prototype.setUTCMinutes ( min [ , sec [, ms ] ] )
  // 20.3.4.33 Date.prototype.setUTCMonth ( month [ , date ] )
  // 20.3.4.34 Date.prototype.setUTCSeconds ( sec [ , ms ] )
  // 20.3.4.35 Date.prototype.toDateString ( )
  // 20.3.4.36 Date.prototype.toISOString ( )
  // 20.3.4.37 Date.prototype.toJSON ( key )
  // 20.3.4.38 Date.prototype.toLocaleDateString ( [ reserved1 [ , reserved2 ] ] )
  // 20.3.4.39 Date.prototype.toLocaleString ( [ reserved1 [ , reserved2 ] ] )
  // 20.3.4.40 Date.prototype.toLocaleTimeString ( [ reserved1 [ , reserved2 ] ] )
  // 20.3.4.41 Date.prototype.toString ( )
  // 20.3.4.42 Date.prototype.toTimeString ( )
  // 20.3.4.43 Date.prototype.toUTCString ( )
  // 20.3.4.44 Date.prototype.valueOf ( )
  // 20.3.4.45 Date.prototype [ @@toPrimitive ] ( hint )
  // 20.3.5 Properties of Date Instances

  // (No polyfillable changes from ES5)

  // ---------------------------------------
  // 21 Text Processing
  // ---------------------------------------

  var string_regexp_dispatch = (function() {
    var faux = {}, secret = Symbol();
    faux[Symbol.match] = function() { return secret; };
    return ("").match(faux) === secret;
  }());

  // 21.1 String Objects
  // 21.1.1 The String Constructor
  // 21.1.1.1 String ( value )
  // 21.1.2 Properties of the String Constructor
  // 21.1.2.1 String.fromCharCode ( ...codeUnits )

  // 21.1.2.2 String.fromCodePoint ( ...codePoints )
  define(
    String, 'fromCodePoint',
    function fromCodePoint(/*...codePoints*/) {
      var codePoints = arguments,
          length = codePoints.length,
          elements = [],
          nextIndex = 0;
      while (nextIndex < length) {
        var next = codePoints[nextIndex];
        var nextCP = Number(next);
        if (!SameValue(nextCP, ToInteger(nextCP)) ||
            nextCP < 0 || nextCP > 0x10FFFF) {
          throw RangeError('Invalid code point ' + nextCP);
        }
        if (nextCP < 0x10000) {
          elements.push(String.fromCharCode(nextCP));
        } else {
          nextCP -= 0x10000;
          elements.push(String.fromCharCode((nextCP >> 10) + 0xD800));
          elements.push(String.fromCharCode((nextCP % 0x400) + 0xDC00));
        }
        nextIndex += 1;
      }
      return elements.join('');
    });

  // 21.1.2.3 String.prototype

  // 21.1.2.4 String.raw ( template , ...substitutions )
  define(
    String, 'raw',
    function raw(template /*, ...substitutions*/) {
      var substitutions = [].slice.call(arguments, 1);

      var cooked = Object(template);
      var rawValue = cooked['raw'];
      var raw = Object(rawValue);
      var len = raw['length'];
      var literalSegments = ToLength(len);
      if (literalSegments <= 0) return '';
      var stringElements = [];
      var nextIndex = 0;
      while (true) {
        var next = raw[nextIndex];
        var nextSeg = String(next);
        stringElements.push(nextSeg);
        if (nextIndex + 1 === literalSegments)
          return stringElements.join('');
        next = substitutions[nextIndex];
        var nextSub = String(next);
        stringElements.push(nextSub);
        nextIndex = nextIndex + 1;
      }
    });

  // See https://githib.com/inexorabletash/uate for a more useful version.

  // 21.1.3 Properties of the String Prototype Object
  // 21.1.3.1 String.prototype.charAt ( pos )
  // 21.1.3.2 String.prototype.charCodeAt ( pos )

  // 21.1.3.3 String.prototype.codePointAt ( pos )
  define(
    String.prototype, 'codePointAt',
    function codePointAt(pos) {
      var o = strict(this);
      var s = String(o);
      var position = ToInteger(pos);
      var size = s.length;
      if (position < 0 || position >= size) return undefined;
      var first = s.charCodeAt(position);
      if (first < 0xD800 || first > 0xDBFF || position + 1 === size) return first;
      var second = s.charCodeAt(position + 1);
      if (second < 0xDC00 || second > 0xDFFF) return first;
      return ((first - 0xD800) * 1024) + (second - 0xDC00) + 0x10000;
    });

  // 21.1.3.4 String.prototype.concat ( ...args )
  // 21.1.3.5 String.prototype.constructor

  // 21.1.3.6 String.prototype.endsWith ( searchString [ , endPosition] )
  define(
    String.prototype, 'endsWith',
    function endsWith(searchString) {
      var endPosition = arguments[1];

      var o = strict(this);
      var s = String(o);
      var searchStr = String(searchString);
      var len = s.length;
      var pos = (endPosition === undefined) ? len : ToInteger(endPosition);
      var end = min(max(pos, 0), len);
      var searchLength = searchStr.length;
      var start = end - searchLength;
      if (start < 0) return false;
      if (s.substring(start, start + searchLength) === searchStr) return true;
      return false;
    });

  // 21.1.3.7 String.prototype.includes ( searchString [ , position ] )
  define(
    String.prototype, 'includes',
    function includes(searchString) {
      var position = arguments[1];

      var o = strict(this);
      var s = String(o);
      var searchStr = String(searchString);
      var pos = ToInteger(position);
      var len = s.length;
      var start = min(max(pos, 0), len);
      return s.indexOf(searchStr, start) !== -1;
    });

  // 21.1.3.8 String.prototype.indexOf ( searchString [ , position ] )
  // 21.1.3.9 String.prototype.lastIndexOf ( searchString [ , position ] )
  // 21.1.3.10 String.prototype.localeCompare ( that [, reserved1 [ , reserved2 ] ] )
  // 21.1.3.11 String.prototype.match ( regexp )
  define(
    String.prototype, 'match',
    function match(regexp) {
      var o = strict(this);
      var s = String(o);
      if (HasProperty(regexp, $$match)) var rx = regexp;
      else rx = new RegExp(regexp);
      return rx[$$match](s);
    }, !string_regexp_dispatch);

  // 21.1.3.12 String.prototype.normalize ( [ form ] )

  // Not practical due to table sizes; if needed, pull in:
  // https://github.com/walling/unorm/

  // 21.1.3.13 String.prototype.repeat ( count )
  define(
    String.prototype, 'repeat',
    function repeat(count) {
      var o = strict(this);
      var s = String(o);
      var n = ToInteger(count);
      if (n < 0) throw RangeError();
      if (n === Infinity) throw RangeError();
      var t = new Array(n + 1).join(s);
      return t;
    });

  // 21.1.3.14 String.prototype.replace (searchValue, replaceValue )
  define(
    String.prototype, 'replace',
    function replace(searchValue, replaceValue) {
      var o = strict(this);
      if (HasProperty(searchValue, $$replace))
        return searchValue[$$replace](o, replaceValue);
      return orig_replace.call(o, searchValue, replaceValue);
    }, !string_regexp_dispatch);

  // 21.1.3.15 String.prototype.search ( regexp )
  define(
    String.prototype, 'search',
    function search(regexp) {
      var o = strict(this);
      var string = String(o);
      if (HasProperty(regexp, $$search)) var rx = regexp;
      else rx = new RegExp(regexp);
      return rx[$$search](string);
    }, !string_regexp_dispatch);

  // 21.1.3.16 String.prototype.slice ( start, end )
  // 21.1.3.17 String.prototype.split ( separator, limit )
  define(
    String.prototype, 'split',
    function split(separator, limit) {
      var o = strict(this);
      if (HasProperty(separator, $$split))
        return separator[$$split](o, limit);
      return orig_split.call(o, separator, limit);
    }, !string_regexp_dispatch);

  // 21.1.3.18 String.prototype.startsWith ( searchString [, position ] )
  define(
    String.prototype, 'startsWith',
    function startsWith(searchString) {
      var position = arguments[1];

      var o = strict(this);
      var s = String(o);
      var searchStr = String(searchString);
      var pos = ToInteger(position);
      var len = s.length;
      var start = min(max(pos, 0), len);
      var searchLength = searchStr.length;
      if (searchLength + start > len) return false;
      if (s.substring(start, start + searchLength) === searchStr) return true;
      return false;
    });

  // 21.1.3.19 String.prototype.substring ( start, end )
  // 21.1.3.20 String.prototype.toLocaleLowerCase ( [ reserved1 [ , reserved2 ] ] )
  // 21.1.3.21 String.prototype.toLocaleUpperCase ([ reserved1 [ , reserved2 ] ] )
  // 21.1.3.22 String.prototype.toLowerCase ( )
  // 21.1.3.23 String.prototype.toString ( )
  // 21.1.3.24 String.prototype.toUpperCase ( )
  // 21.1.3.25 String.prototype.trim ( )
  // 21.1.3.26 String.prototype.valueOf ( )

  // 21.1.3.27 String.prototype [ @@iterator ]( )
  define(
    String.prototype, $$iterator,
    function entries() {
      return CreateStringIterator(this, 'value');
    });

  // 21.1.4 Properties of String Instances
  // 21.1.4.1 length

  // 21.1.5 String Iterator Objects
  /** @constructor */
  function StringIterator() {}

  // 21.1.5.1 CreateStringIterator Abstract Operation
  function CreateStringIterator(string, kind) {
    var s = String(string);
    var iterator = new StringIterator;
    set_internal(iterator, '[[IteratedString]]', s);
    set_internal(iterator, '[[StringIteratorNextIndex]]', 0);
    set_internal(iterator, '[[StringIterationKind]]', kind);
    return iterator;
  }

  // 21.1.5.2 The %StringIteratorPrototype% Object
  var $StringIteratorPrototype$ = Object.create($IteratorPrototype$);
  StringIterator.prototype = $StringIteratorPrototype$;

  // 21.1.5.2.1 %StringIteratorPrototype%.next ( )
  define(
    $StringIteratorPrototype$, 'next',
    function next() {
      var o = ToObject(this);
      var s = String(o['[[IteratedString]]']),
          index = o['[[StringIteratorNextIndex]]'],
          len = s.length;
      if (index >= len) {
        set_internal(o, '[[StringIteratorNextIndex]]', Infinity);
        return CreateIterResultObject(undefined, true);
      }
      var cp = s.codePointAt(index);
      set_internal(o, '[[StringIteratorNextIndex]]', index + (cp > 0xFFFF ? 2 : 1));
      return CreateIterResultObject(String.fromCodePoint(cp), false);
    });

  // 21.1.5.2.2 %StringIteratorPrototype% [ @@toStringTag ]
  define($StringIteratorPrototype$, $$toStringTag, 'String Iterator');

  // 21.1.5.3 Properties of String Iterator Instances

  // ---------------------------------------
  // 21.2 RegExp (Regular Expression) Objects
  // ---------------------------------------

  // 21.2.1 Patterns
  // 21.2.2 Pattern Semantics
  // 21.2.2.1 Notation
  // 21.2.2.2 Pattern
  // 21.2.2.3 Disjunction
  // 21.2.2.4 Alternative
  // 21.2.2.5 Term
  // 21.2.2.6 Assertion
  // 21.2.2.7 Quantifier
  // 21.2.2.8 Atom
  // 21.2.2.9 AtomEscape
  // 21.2.2.10 CharacterEscape
  // 21.2.2.11 DecimalEscape
  // 21.2.2.12 CharacterClassEscape
  // 21.2.2.13 CharacterClass
  // 21.2.2.14 ClassRanges
  // 21.2.2.15 NonemptyClassRanges
  // 21.2.2.16 NonemptyClassRangesNoDash
  // 21.2.2.17 ClassAtom
  // 21.2.2.18 ClassAtomNoDash
  // 21.2.2.19 ClassEscape
  // 21.2.3 The RegExp Constructor
  // 21.2.3.1 RegExp ( pattern, flags )
  // 21.2.3.2 new RegExp( ...argumentsList )
  // 21.2.3.3 Abstract Operations for the RegExp Constructor
  // 21.2.4 Properties of the RegExp Constructor
  // 21.2.4.1 RegExp.prototype
  // 21.2.5 Properties of the RegExp Prototype Object
  // 21.2.5.1 RegExp.prototype.constructor
  // 21.2.5.2 RegExp.prototype.exec ( string )

  // 21.2.5.3 get RegExp.prototype.flags
  if (!('flags' in RegExp.prototype)) {
    Object.defineProperty(
      RegExp.prototype, 'flags', {
        get: function() {
          var s = String(this);
          return s.substring(s.lastIndexOf('/') + 1);
        }
      });
  }

  // 21.2.5.4 get RegExp.prototype.global
  // 21.2.5.5 get RegExp.prototype.ignoreCase

  // 21.2.5.6 RegExp.prototype [ @@match ] ( string )
  define(RegExp.prototype, $$match, function(string) {
    var o = strict(this);
    return orig_match.call(string, o);
  });

  // 21.2.5.7 get RegExp.prototype.multiline

  // 21.2.5.8 RegExp.prototype [ @@replace ] ( string, replaceValue )
  define(RegExp.prototype, $$replace, function(string, replaceValue) {
    var o = strict(this);
    return orig_replace.call(string, o, replaceValue);
  });

  // 21.2.5.9 RegExp.prototype [ @@search ] ( string )
  define(RegExp.prototype, $$search, function(string) {
    var o = strict(this);
    return orig_search.call(string, o);
  });

  // 21.2.5.10 get RegExp.prototype.source

  // 21.2.5.11 RegExp.prototype [ @@split ] ( string, limit )
  define(RegExp.prototype, $$split, function(string, limit) {
    var o = strict(this);
    return orig_split.call(string, o, limit);
  });

  // 21.2.5.12 get RegExp.prototype.sticky
  // 21.2.5.13 RegExp.prototype.test( S )
  // 21.2.5.14 RegExp.prototype.toString ( )
  // 21.2.5.15 get RegExp.prototype.unicode

  // 21.2.6 Properties of RegExp Instances
  // 21.2.6.1 lastIndex

  // (No polyfillable changes from ES5)

  // ---------------------------------------
  // 22 Indexed Collections
  // ---------------------------------------

  // ---------------------------------------
  // 22.1 Array Objects
  // ---------------------------------------

  // 22.1.1 The Array Constructor
  // 22.1.1.1 Array ( )
  // 22.1.1.2 Array (len)
  // 22.1.1.3 Array (...items )

  // 22.1.2 Properties of the Array Constructor

  // 22.1.2.1 Array.from ( items [ , mapfn [ , thisArg ] ] )
  define(
    Array, 'from',
    function from(items) {
      var mapfn = arguments[1];
      var thisArg = arguments[2];

      var c = strict(this);
      if (mapfn === undefined) {
        var mapping = false;
      } else {
        if (!IsCallable(mapfn)) throw TypeError();
        var t = thisArg;
        mapping = true;
      }
      var usingIterator = GetMethod(items, $$iterator);
      if (usingIterator !== undefined) {
         if (IsConstructor(c)) {
          var a = new c();
        } else {
          a = new Array(0);
        }
        var iterator = GetIterator(items, usingIterator);
        var k = 0;
        while (true) {
          var next = IteratorStep(iterator);
          if (next === false) {
            a.length = k;
            return a;
          }
          var nextValue = IteratorValue(next);
          if (mapping)
            var mappedValue = mapfn.call(t, nextValue);
          else
            mappedValue = nextValue;
          a[k] = mappedValue;
          k += 1;
        }
      }
      var arrayLike = ToObject(items);
      var lenValue = arrayLike.length;
      var len = ToLength(lenValue);
      if (IsConstructor(c)) {
        a = new c(len);
      } else {
        a = new Array(len);
      }
      k = 0;
      while (k < len) {
        var kValue = arrayLike[k];
        if (mapping)
          mappedValue = mapfn.call(t, kValue, k);
        else
          mappedValue = kValue;
        a[k] = mappedValue;
        k += 1;
      }
      a.length = len;
      return a;
    });

  // 22.1.2.2 Array.isArray ( arg )

  // 22.1.2.3 Array.of ( ...items )
  define(
    Array, 'of',
    function of() {
      var items = arguments;

      var lenValue = items.length;
      var len = ToUint32(lenValue);
      var c = strict(this), a;
      if (IsConstructor(c)) {
        a = new c(len);
        a = ToObject(a);
      } else {
        a = new Array(len);
      }
      var k = 0;
      while (k < len) {
        a[k] = items[k];
        k += 1;
      }
      a.length = len;
      return a;
    });

  // 22.1.2.4 Array.prototype
  // 22.1.2.5 get Array [ @@species ]
  // 22.1.3 Properties of the Array Prototype Object
  // 22.1.3.1 Array.prototype.concat ( ...arguments )
  // 22.1.3.1.1 Runtime Semantics: IsConcatSpreadable ( O )
  // 22.1.3.2 Array.prototype.constructor
  // 22.1.3.3 Array.prototype.copyWithin (target, start [ , end ] )
  define(
    Array.prototype, 'copyWithin',
    function copyWithin(target, start/*, end*/) {
      var end = arguments[2];

      var o = ToObject(this);
      var lenVal = o.length;
      var len = ToLength(lenVal);
      len = max(len, 0);
      var relativeTarget = ToInteger(target);
      var to;
      if (relativeTarget < 0)
        to = max(len + relativeTarget, 0);
      else
        to = min(relativeTarget, len);
      var relativeStart = ToInteger(start);
      var from;
      if (relativeStart < 0)
        from = max(len + relativeStart, 0);
      else
        from = min(relativeStart, len);
      var relativeEnd;
      if (end === undefined)
        relativeEnd = len;
      else
        relativeEnd = ToInteger(end);
      var final;
      if (relativeEnd < 0)
        final = max(len + relativeEnd, 0);
      else
        final = min(relativeEnd, len);
      var count = min(final - from, len - to);
      var direction;
      if (from < to && to < from + count) {
        direction = -1;
        from = from + count - 1;
        to = to + count - 1;
      } else {
        direction = 1;
      }
      while (count > 0) {
        var fromKey = String(from);
        var toKey = String(to);
        var fromPresent = HasProperty(o, fromKey);
        if (fromPresent) {
          var fromVal = o[fromKey];
          o[toKey] = fromVal;
        } else {
          delete o[toKey];
        }
        from = from + direction;
        to = to + direction;
        count = count - 1;
      }
      return o;
    });

  // 22.1.3.4 Array.prototype.entries ( )
  var nativeArrayIteratorMethods =
        ('entries' in Array.prototype && 'next' in [].entries());

  define(
    Array.prototype, 'entries',
    function entries() {
      return CreateArrayIterator(this, 'key+value');
    }, !nativeArrayIteratorMethods);

  // 22.1.3.5 Array.prototype.every ( callbackfn [ , thisArg] )

  // 22.1.3.6 Array.prototype.fill (value [ , start [ , end ] ] )
  define(
    Array.prototype, 'fill',
    function fill(value/*, start, end*/) {
      var start = arguments[1],
          end = arguments[2];

      var o = ToObject(this);
      var lenVal = o.length;
      var len = ToLength(lenVal);
      len = max(len, 0);
      var relativeStart = ToInteger(start);
      var k;
      if (relativeStart < 0)
        k = max((len + relativeStart), 0);
      else
        k = min(relativeStart, len);
      var relativeEnd;
      if (end === undefined)
        relativeEnd = len;
      else
        relativeEnd = ToInteger(end);
      var final;
      if (relativeEnd < 0)
        final = max((len + relativeEnd), 0);
      else
        final = min(relativeEnd, len);
      while (k < final) {
        var pk = String(k);
        o[pk] = value;
        k += 1;
      }
      return o;
    });

  // 22.1.3.7 Array.prototype.filter ( callbackfn [ , thisArg ] )

  // 22.1.3.8 Array.prototype.find ( predicate [ , thisArg ] )
  define(
    Array.prototype, 'find',
    function find(predicate) {
      var o = ToObject(this);
      var lenValue = o.length;
      var len = ToInteger(lenValue);
      if (!IsCallable(predicate)) throw TypeError();
      var t = arguments.length > 1 ? arguments[1] : undefined;
      var k = 0;
      while (k < len) {
        var pk = String(k);
        var kPresent = HasProperty(o, pk);
        if (kPresent) {
          var kValue = o[pk];
          var testResult = predicate.call(t, kValue, k, o);
          if (Boolean(testResult)) {
            return kValue;
          }
        }
        ++k;
      }
      return undefined;
    });

  // 22.1.3.9 Array.prototype.findIndex ( predicate [ , thisArg ] )
  define(
    Array.prototype, 'findIndex',
    function findIndex(predicate) {
      var o = ToObject(this);
      var lenValue = o.length;
      var len = ToLength(lenValue);
      if (!IsCallable(predicate)) throw TypeError();
      var t = arguments.length > 1 ? arguments[1] : undefined;
      var k = 0;
      while (k < len) {
        var pk = String(k);
        var kPresent = HasProperty(o, pk);
        if (kPresent) {
          var kValue = o[pk];
          var testResult = predicate.call(t, kValue, k, o);
          if (Boolean(testResult)) {
            return k;
          }
        }
        ++k;
      }
      return -1;
    });

  // 22.1.3.10 Array.prototype.forEach ( callbackfn [ , thisArg ] )
  // 22.1.3.11 Array.prototype.indexOf ( searchElement [ , fromIndex ] )
  // 22.1.3.12 Array.prototype.join (separator)

  // 22.1.3.13 Array.prototype.keys ( )
  define(
    Array.prototype, 'keys',
    function keys() {
      return CreateArrayIterator(this, 'key');
    }, !nativeArrayIteratorMethods);

  // 22.1.3.14 Array.prototype.lastIndexOf ( searchElement [ , fromIndex ] )
  // 22.1.3.15 Array.prototype.map ( callbackfn [ , thisArg ] )
  // 22.1.3.16 Array.prototype.pop ( )
  // 22.1.3.17 Array.prototype.push ( ...items )
  // 22.1.3.18 Array.prototype.reduce ( callbackfn [ , initialValue ] )
  // 22.1.3.19 Array.prototype.reduceRight ( callbackfn [ , initialValue ] )
  // 22.1.3.20 Array.prototype.reverse ( )
  // 22.1.3.21 Array.prototype.shift ( )
  // 22.1.3.22 Array.prototype.slice (start, end)
  // 22.1.3.23 Array.prototype.some ( callbackfn [ , thisArg ] )
  // 22.1.3.24 Array.prototype.sort (comparefn)
  // 22.1.3.25 Array.prototype.splice (start, deleteCount , ...items )
  // 22.1.3.26 Array.prototype.toLocaleString ( [ reserved1 [ , reserved2 ] ] )
  // 22.1.3.27 Array.prototype.toString ( )
  // 22.1.3.28 Array.prototype.unshift ( ...items )

  // 22.1.3.29 Array.prototype.values ( )
  define(
    Array.prototype, 'values',
    function values() {
      return CreateArrayIterator(this, 'value');
    }, !nativeArrayIteratorMethods);

  // 22.1.3.30 Array.prototype [ @@iterator ] ( )
  define(
    Array.prototype, $$iterator,
    Array.prototype.values
    );

  // 22.1.3.31 Array.prototype [ @@unscopables ]
  // 22.1.4 Properties of Array Instances
  // 22.1.4.1 length

  // 22.1.5 Array Iterator Objects
  function ArrayIterator() {}

  // 22.1.5.1 CreateArrayIterator Abstract Operation
  function CreateArrayIterator(array, kind) {
    var o = ToObject(array);
    var iterator = new ArrayIterator;
    set_internal(iterator, '[[IteratedObject]]', o);
    set_internal(iterator, '[[ArrayIteratorNextIndex]]', 0);
    set_internal(iterator, '[[ArrayIterationKind]]', kind);
    return iterator;
  }

  // 22.1.5.2 The %ArrayIteratorPrototype% Object
  var $ArrayIteratorPrototype$ = Object.create($IteratorPrototype$);
  ArrayIterator.prototype = $ArrayIteratorPrototype$;

  // 22.1.5.2.1 %ArrayIteratorPrototype%. next( )
  define(
    $ArrayIteratorPrototype$, 'next',
    function next() {
      var o = strict(this);
      if (Type(o) !== 'object') throw TypeError();
      var a = o['[[IteratedObject]]'],
          index = o['[[ArrayIteratorNextIndex]]'],
          itemKind = o['[[ArrayIterationKind]]'],
          lenValue = a.length,
          len = ToUint32(lenValue),
          elementKey,
          elementValue;
      if (itemKind.indexOf('sparse') !== -1) {
        var found = false;
        while (!found && index < len) {
          elementKey = String(index);
          found = HasProperty(a, elementKey);
          if (!found) {
            index += 1;
          }
        }
      }
      if (index >= len) {
        set_internal(o, '[[ArrayIteratorNextIndex]]', Infinity);
        return CreateIterResultObject(undefined, true);
      }
      elementKey = index;
      set_internal(o, '[[ArrayIteratorNextIndex]]', index + 1);
      if (itemKind.indexOf('value') !== -1)
        elementValue = a[elementKey];
      if (itemKind.indexOf('key+value') !== -1)
        return CreateIterResultObject([elementKey, elementValue], false);
      if (itemKind.indexOf('key') !== -1)
        return CreateIterResultObject(elementKey, false);
      if (itemKind === 'value')
        return CreateIterResultObject(elementValue, false);
      throw Error('Internal error');
    });

  // 22.1.5.2.2 %ArrayIteratorPrototype% [ @@toStringTag ]
  define($ArrayIteratorPrototype$, $$toStringTag, 'Array Iterator');

  // 22.1.5.3 Properties of Array Iterator Instances


  // ---------------------------------------
  // 22.2 TypedArray Objects
  // ---------------------------------------

  // See typedarray.js for TypedArray polyfill

  ['Int8Array', 'Uint8Array', 'Uint8ClampedArray',
   'Int16Array', 'Uint16Array',
   'Int32Array', 'Uint32Array',
   'Float32Array', 'Float64Array'].forEach(function ($TypedArrayName$) {
     if (!($TypedArrayName$ in global))
       return;
     var $TypedArray$ = global[$TypedArrayName$];

     // 22.2.1 The %TypedArray% Intrinsic Object
     // 22.2.1.1 %TypedArray% ( length )
     // 22.2.1.2 %TypedArray% ( typedArray )
     // 22.2.1.3 %TypedArray% ( object )
     // 22.2.1.4 %TypedArray% ( buffer [ , byteOffset [ , length ] ] )
     // 22.2.1.5 %TypedArray% ( all other argument combinations )
     // 22.2.2 Properties of the %TypedArray% Intrinsic Object

     // 22.2.2.1 %TypedArray%.from ( source [ , mapfn [ , thisArg ] ] )
     define(
       $TypedArray$, 'from',
       function from(source) {
         var mapfn = arguments[1];
         var thisArg = arguments[2];

         var c = strict(this);
         if (!IsConstructor(c)) throw TypeError();
         if (mapfn === undefined) {
           var mapping = false;
         } else {
           if (IsCallable(mapfn)) throw TypeError();
           var t = thisArg;
           mapping = true;
         }
         var usingIterator = GetMethod(source, $$iterator);
         if (usingIterator !== undefined) {
           var iterator = GetIterator(source, usingIterator);
           var values = [];
           var next = true;
           while (next !== false) {
             next = IteratorStep(iterator);
             if (next !== false) {
               var nextValue = IteratorValue(next);
               values.push(nextValue);
             }
           }
           var len = values.length;
           var newObj = new c(len);
           var k = 0;
           while (k < len) {
             var kValue = values.shift();
             if (mapping) {
               var mappedValue = mapfn.call(t, kValue);
             } else {
               mappedValue = kValue;
             }
             newObj[k] = mappedValue;
             ++k;
           }
           console.assert(values.length === 0);
           return newObj;
         }
         var arrayLike = ToObject(source);
         var lenValue = arrayLike.length;
         len = ToLength(lenValue);
         newObj = new c(len);
         k = 0;
         while (k < len) {
           kValue = arrayLike[k];
           if (mapping) {
             mappedValue = mapfn.call(t, kValue, k);
           } else {
             mappedValue = kValue;
           }
           newObj[k] = mappedValue;
           ++k;
         }
         return newObj;
       });

     // 22.2.2.2 %TypedArray%.of ( ...items )
     define(
       $TypedArray$, 'of',
       function of() {
         var items = arguments;

         var len = items.length;
         var c = strict(this);
         var newObj = new c(len);
         var k = 0;
         while (k < len) {
           newObj[k] = items[k];
           ++k;
         }
         return newObj;
       });

     // 22.2.2.3 %TypedArray%.prototype
     // 22.2.2.4 get %TypedArray% [ @@species ]
     // 22.2.3 Properties of the %TypedArrayPrototype% Object
     // 22.2.3.1 get %TypedArray%.prototype.buffer
     // 22.2.3.2 get %TypedArray%.prototype.byteLength
     // 22.2.3.3 get %TypedArray%.prototype.byteOffset
     // 22.2.3.4 %TypedArray%.prototype.constructor

     // 22.2.3.5 %TypedArray%.prototype.copyWithin (target, start [, end ] )
     define($TypedArray$.prototype, 'copyWithin', Array.prototype.copyWithin);

     // 22.2.3.6 %TypedArray%.prototype.entries ( )
     define($TypedArray$.prototype, 'entries', Array.prototype.entries);

     // 22.2.3.7 %TypedArray%.prototype.every ( callbackfn [ , thisArg ] )
     define($TypedArray$.prototype, 'every', Array.prototype.every);

     // 22.2.3.8 %TypedArray%.prototype.fill (value [ , start [ , end ] ] )
     define(
       $TypedArray$.prototype, 'fill',
       //Array.prototype.fill // Doesn't work in Safari 7
       function fill(value/*, start, end*/) {
         var start = arguments[1],
             end = arguments[2];

         var o = ToObject(this);
         var lenVal = o.length;
         var len = ToLength(lenVal);
         len = max(len, 0);
         var relativeStart = ToInteger(start);
         var k;
         if (relativeStart < 0) k = max((len + relativeStart), 0);
         else k = min(relativeStart, len);
         var relativeEnd;
         if (end === undefined) relativeEnd = len;
         else relativeEnd = ToInteger(end);
         var final;
         if (relativeEnd < 0) final = max((len + relativeEnd), 0);
         else final = min(relativeEnd, len);
         while (k < final) {
           var pk = String(k);
           o[pk] = value;
           k += 1;
         }
         return o;
       });

     // 22.2.3.9 %TypedArray%.prototype.filter ( callbackfn [ , thisArg ] )
     define(
       $TypedArray$.prototype, 'filter',
       function filter(callbackfn) {
         var thisArg = arguments[1];

         var o = ToObject(this);
         var lenVal = o.length;
         var len = ToLength(lenVal);
         if (!IsCallable(callbackfn)) throw TypeError();
         var t = thisArg;
         var c = o.constructor;
         var kept = [];
         var k = 0;
         var captured = 0;
         while (k < len) {
           var kValue = o[k];
           var selected = callbackfn.call(t, kValue, k, o);
           if (selected) {
             kept.push(kValue);
             ++captured;
           }
           ++k;
         }
         var a = new c(captured);
         var n = 0;
         for (var i = 0; i < kept.length; ++i) {
           var e = kept[i];
           a[n] = e;
           ++n;
         }
         return a;
       });

     // 22.2.3.10 %TypedArray%.prototype.find (predicate [ , thisArg ] )
     define($TypedArray$.prototype, 'find', Array.prototype.find);

     // 22.2.3.11 %TypedArray%.prototype.findIndex ( predicate [ , thisArg ] )
     define($TypedArray$.prototype, 'findIndex', Array.prototype.findIndex);

     // 22.2.3.12 %TypedArray%.prototype.forEach ( callbackfn [ , thisArg ] )
     define($TypedArray$.prototype, 'forEach', Array.prototype.forEach);

     // 22.2.3.13 %TypedArray%.prototype.indexOf (searchElement [ , fromIndex ] )
     define($TypedArray$.prototype, 'indexOf', Array.prototype.indexOf);

     // 22.2.3.14 %TypedArray%.prototype.join ( separator )
     define($TypedArray$.prototype, 'join', Array.prototype.join);

     // 22.2.3.15 %TypedArray%.prototype.keys ( )
     define($TypedArray$.prototype, 'keys', Array.prototype.keys);

     // 22.2.3.16 %TypedArray%.prototype.lastIndexOf ( searchElement [ , fromIndex ] )
     define($TypedArray$.prototype, 'lastIndexOf', Array.prototype.lastIndexOf);

     // 22.2.3.17 get %TypedArray%.prototype.length

     // 22.2.3.18 %TypedArray%.prototype.map ( callbackfn [ , thisArg ] )
     define(
       $TypedArray$.prototype, 'map',
       function map(callbackfn) {
         var thisArg = arguments[1];

         var o = ToObject(this);
         var lenValue = o.length;
         var len = ToLength(lenValue);
         if (!IsCallable(callbackfn)) throw TypeError();
         var t = thisArg;
         var a = undefined;
         var c = o.constructor;
         if (IsConstructor(c))
           a = new c(len);
         if (a === undefined)
           a = new Array(len);
         var k = 0;
         while (k < len) {
           var kPresent = HasProperty(o, k);
           if (kPresent) {
             var kValue = o[k];
             var mappedValue = callbackfn.call(t, kValue, k, o);
             a[k] = mappedValue;
           }
           ++k;
         }
         return a;
       });

     // 22.2.3.19 %TypedArray%.prototype.reduce ( callbackfn [, initialValue] )
     define($TypedArray$.prototype, 'reduce', Array.prototype.reduce);

     // 22.2.3.20 %TypedArray%.prototype.reduceRight ( callbackfn [, initialValue] )
     define($TypedArray$.prototype, 'reduceRight', Array.prototype.reduceRight);

     // 22.2.3.21 %TypedArray%.prototype.reverse ( )
     define($TypedArray$.prototype, 'reverse', Array.prototype.reverse);

     // 22.2.3.22 %TypedArray%.prototype.set ( overloaded [ , offset ])
     // 22.2.3.22.1 %TypedArray%.prototype.set (array [ , offset ] )
     // 22.2.3.22.2 %TypedArray%.prototype.set(typedArray [, offset ] )

     // 22.2.3.23 %TypedArray%.prototype.slice ( start, end )
     define(
       $TypedArray$.prototype, 'slice',
       function slice(start, end) {
         var o = ToObject(this);
         var lenVal = o.length;
         var len = ToLength(lenVal);
         var relativeStart = ToInteger(start);
         var k = (relativeStart < 0) ? max(len + relativeStart, 0) : min(relativeStart, len);
         var relativeEnd = (end === undefined) ? len : ToInteger(end);
         var final = (relativeEnd < 0) ? max(len + relativeEnd, 0) : min(relativeEnd, len);
         var count = final - k;
         var c = o.constructor;
         if (IsConstructor(c)) {
           var a = new c(count);
         } else {
           throw TypeError();
         }
         var n = 0;
         while (k < final) {
           var kValue = o[k];
           a[n] = kValue;
           ++k;
           ++n;
         }
         return a;
       });

     // 22.2.3.24 %TypedArray%.prototype.some ( callbackfn [ , thisArg ] )
     define($TypedArray$.prototype, 'some', Array.prototype.some);

     // 22.2.3.25 %TypedArray%.prototype.sort ( comparefn )
     define(
       $TypedArray$.prototype, 'sort',
       function sort() {
         var comparefn = arguments[0];

         function sortCompare(x, y) {
           console.assert(Type(x) === 'number' && Type(y) === 'number');
           if (x !== x && y !== y) return +0;
           if (x !== x) return 1;
           if (y !== y) return -1;
           if (comparefn !== undefined) {
             return comparefn(x, y);
           }
           if (x < y) return -1;
           if (x > y) return 1;
           return +0;
         }
         return Array.prototype.sort.call(this, sortCompare);
       });

     // 22.2.3.26 %TypedArray%.prototype.subarray( [ begin [ , end ] ] )
     // 22.2.3.27 %TypedArray%.prototype.toLocaleString ([ reserved1 [ , reserved2 ] ])
     // 22.2.3.28 %TypedArray%.prototype.toString ( )

     // 22.2.3.29 %TypedArray%.prototype.values ( )
     define($TypedArray$.prototype, 'values', Array.prototype.values);

     // 22.2.3.30 %TypedArray%.prototype [ @@iterator ] ( )
     define(
       $TypedArray$.prototype, $$iterator,
       $TypedArray$.prototype.values
     );

     // 22.2.3.31 get %TypedArray%.prototype [ @@toStringTag ]
     define($TypedArray$.prototype, $$toStringTag, $TypedArrayName$);

     // 22.2.4 The TypedArray Constructors
     // 22.2.4.1TypedArray( ... argumentsList)
     // 22.2.5 Properties of the TypedArray Constructors
     // 22.2.5.1 TypedArray.BYTES_PER_ELEMENT
     // 22.2.5.2 TypedArray.prototype
     // 22.2.6 Properties of TypedArray Prototype Objects
     // 22.2.6.1 TypedArray.prototype.BYTES_PER_ELEMENT
     // 22.2.6.2 TypedArray.prototype.constructor
     // 22.2.7 Properties of TypedArray Instances
   });

  // ---------------------------------------
  // 23 Keyed Collection
  // ---------------------------------------

  // ---------------------------------------
  // 23.1 Map Objects
  // ---------------------------------------

  (function() {
    // 23.1.1 The Map Constructor

    // 23.1.1.1 Map ( [ iterable ] )
    /** @constructor */
    function Map(/*iterable*/) {
      var map = strict(this);
      var iterable = arguments[0];

      if (Type(map) !== 'object') throw TypeError();
      if ('[[MapData]]' in map) throw TypeError();

      if (iterable !== undefined) {
        var adder = map['set'];
        if (!IsCallable(adder)) throw TypeError();
        var iter = GetIterator(ToObject(iterable));
      }
      set_internal(map, '[[MapData]]', { keys: [], values: [] });
      if (iter === undefined) return map;
      while (true) {
        var next = IteratorStep(iter);
        if (next === false)
          return map;
        var nextItem = IteratorValue(next);
        if (Type(nextItem) !== 'object') throw TypeError();
        var k = nextItem[0];
        var v = nextItem[1];
        adder.call(map, k, v);
      }

      return map;
    }

    if (!('Map' in global) || OVERRIDE_NATIVE_FOR_TESTING ||
        (function() { try { new global.Map([]); return false; } catch (_) { return true; } }()) ||
        (function() { try { return !new global.Map().entries().next; } catch (_) { return true; } }()) ||
        (new global.Map([['a', 1]]).size !== 1))
      global.Map = Map;


    function MapDataIndexOf(mapData, key) {
      var i;
      if (key === key) return mapData.keys.indexOf(key);
      // Slow case for NaN
      for (i = 0; i < mapData.keys.length; i += 1)
        if (SameValueZero(mapData.keys[i], key)) return i;
      return -1;
    }

    // 23.1.1.2 new Map ( ... argumentsList )
    // 23.1.2 Properties of the Map Constructor
    // 23.1.2.1 Map.prototype
    var $MapPrototype$ = {};
    Map.prototype = $MapPrototype$;

    // 23.1.2.2 get Map [ @@species ]

    // 23.1.3 Properties of the Map Prototype Object
    // 23.1.3.1 Map.prototype.clear ()
    define(
      Map.prototype, 'clear',
      function clear() {
        var m = strict(this);
        if (Type(m) !== 'object') throw TypeError();
        if (!('[[MapData]]' in m)) throw TypeError();
        if (m['[[MapData]]'] === undefined) throw TypeError();
        var entries = m['[[MapData]]'];
        entries.keys.length = 0;
        entries.values.length = 0;
        return undefined;
      });

    // 23.1.3.2 Map.prototype.constructor

    // 23.1.3.3 Map.prototype.delete ( key )
    define(
      Map.prototype, 'delete',
      function delete_(key) {
        var m = strict(this);
        if (Type(m) !== 'object') throw TypeError();
        if (!('[[MapData]]' in m)) throw TypeError();
        if (m['[[MapData]]'] === undefined) throw TypeError();
        var entries = m['[[MapData]]'];
        var i = MapDataIndexOf(entries, key);
        if (i < 0) return false;
        entries.keys[i] = empty;
        entries.values[i] = empty;
        return true;
      });

    // 23.1.3.4 Map.prototype.entries ( )
    define(
      Map.prototype, 'entries',
      function entries() {
        var m = strict(this);
        if (Type(m) !== 'object') throw TypeError();
        return CreateMapIterator(m, 'key+value');
      });

    // 23.1.3.5 Map.prototype.forEach ( callbackfn [ , thisArg ] )
    define(
      Map.prototype, 'forEach',
      function forEach(callbackfn /*, thisArg*/) {
        var thisArg = arguments[1];

        var m = strict(this);
        if (Type(m) !== 'object') throw TypeError();
        if (!('[[MapData]]' in m)) throw TypeError();
        if (m['[[MapData]]'] === undefined) throw TypeError();
        var entries = m['[[MapData]]'];

        if (!IsCallable(callbackfn)) {
          throw TypeError('First argument to forEach is not callable.');
        }
        for (var i = 0; i < entries.keys.length; ++i) {
          if (entries.keys[i] !== empty) {
            callbackfn.call(thisArg, entries.values[i], entries.keys[i], m);
          }
        }
        return undefined;
      });

    // 23.1.3.6 Map.prototype.get ( key )
    define(
      Map.prototype, 'get',
      function get(key) {
        var m = strict(this);
        if (Type(m) !== 'object') throw TypeError();
        if (!('[[MapData]]' in m)) throw TypeError();
        if (m['[[MapData]]'] === undefined) throw TypeError();
        var entries = m['[[MapData]]'];
        var i = MapDataIndexOf(entries, key);
        if (i >= 0) return entries.values[i];
        return undefined;
      });

    // 23.1.3.7 Map.prototype.has ( key )
    define(
      Map.prototype, 'has',
      function has(key) {
        var m = strict(this);
        if (Type(m) !== 'object') throw TypeError();
        if (!('[[MapData]]' in m)) throw TypeError();
        if (m['[[MapData]]'] === undefined) throw TypeError();
        var entries = m['[[MapData]]'];
        if (MapDataIndexOf(entries, key) >= 0) return true;
        return false;
      });

    // 23.1.3.8 Map.prototype.keys ( )
    define(
      Map.prototype, 'keys',
      function keys() {
        var m = strict(this);
        if (Type(m) !== 'object') throw TypeError();
        return CreateMapIterator(m, 'key');
      });

    // 23.1.3.9 Map.prototype.set ( key , value )
    define(
      Map.prototype, 'set',
      function set(key, value) {
        var m = strict(this);
        if (Type(m) !== 'object') throw TypeError();
        if (!('[[MapData]]' in m)) throw TypeError();
        if (m['[[MapData]]'] === undefined) throw TypeError();
        var entries = m['[[MapData]]'];
        var i = MapDataIndexOf(entries, key);
        if (i < 0) i = entries.keys.length;
        if (SameValue(key, -0)) key = 0;
        entries.keys[i] = key;
        entries.values[i] = value;
        return m;
      });

    // 23.1.3.10 get Map.prototype.size
    Object.defineProperty(
      Map.prototype, 'size', {
        get: function() {
          var m = strict(this);
          if (Type(m) !== 'object') throw TypeError();
          if (!('[[MapData]]' in m)) throw TypeError();
          if (m['[[MapData]]'] === undefined) throw TypeError();
          var entries = m['[[MapData]]'];
          var count = 0;
          for (var i = 0; i < entries.keys.length; ++i) {
            if (entries.keys[i] !== empty)
              count = count + 1;
          }
          return count;
        }
      });

    // 23.1.3.11 Map.prototype.values ( )
    define(
      Map.prototype, 'values',
      function values() {
        var m = strict(this);
        if (Type(m) !== 'object') throw TypeError();
        return CreateMapIterator(m, 'value');
      });

    // 23.1.3.12 Map.prototype [ @@iterator ]( )
    define(
      Map.prototype, $$iterator,
      function() {
        var m = strict(this);
        if (Type(m) !== 'object') throw TypeError();
        return CreateMapIterator(m, 'key+value');
      });

    // 23.1.3.13 Map.prototype [ @@toStringTag ]
    define(global.Map.prototype, $$toStringTag, 'Map');

    // 23.1.4 Properties of Map Instances
    // 23.1.5 Map Iterator Objects

    /** @constructor */
    function MapIterator() {}

    // 23.1.5.1 CreateMapIterator Abstract Operation
    function CreateMapIterator(map, kind) {
      if (Type(map) !== 'object') throw TypeError();
      if (!('[[MapData]]' in map)) throw TypeError();
      if (map['[[MapData]]'] === undefined) throw TypeError();
      var iterator = new MapIterator;
      set_internal(iterator, '[[Map]]', map);
      set_internal(iterator, '[[MapNextIndex]]', 0);
      set_internal(iterator, '[[MapIterationKind]]', kind);
      return iterator;
    }

    // 23.1.5.2 The %MapIteratorPrototype% Object
    var $MapIteratorPrototype$ = Object.create($IteratorPrototype$);
    MapIterator.prototype = $MapIteratorPrototype$;

    // 23.1.5.2.1 %MapIteratorPrototype%.next ( )
    define(
      $MapIteratorPrototype$, 'next',
      function next() {
        var o = strict(this);
        if (Type(o) !== 'object') throw TypeError();
        var m = o['[[Map]]'],
            index = o['[[MapNextIndex]]'],
            itemKind = o['[[MapIterationKind]]'],
            entries = m['[[MapData]]'];
        while (index < entries.keys.length) {
          var e = {key: entries.keys[index], value: entries.values[index]};
          index = index += 1;
          set_internal(o, '[[MapNextIndex]]', index);
          if (e.key !== empty) {
            if (itemKind === 'key') {
              return CreateIterResultObject(e.key, false);
            } else if (itemKind === 'value') {
              return CreateIterResultObject(e.value, false);
            } else {
              return CreateIterResultObject([e.key, e.value], false);
            }
          }
        }
        return CreateIterResultObject(undefined, true);
      });

    // 23.1.5.2.2 %MapIteratorPrototype% [ @@toStringTag ]
    define($MapIteratorPrototype$, $$toStringTag, 'Map Iterator');

    // 23.1.5.3 Properties of Map Iterator Instances
  }());

  // ---------------------------------------
  // 23.2 Set Objects
  // ---------------------------------------

  (function() {
    // 23.2.1 The Set Constructor
    // 23.2.1.1 Set ( [ iterable ] )

    /** @constructor */
    function Set(/*iterable*/) {
      var set = strict(this);
      var iterable = arguments[0];

      if (Type(set) !== 'object') throw TypeError();
      if ('[[SetData]]' in set) throw TypeError();

      if (iterable !== undefined) {
        var adder = set['add'];
        if (!IsCallable(adder)) throw TypeError();
        var iter = GetIterator(ToObject(iterable));
      }
      set_internal(set, '[[SetData]]', []);
      if (iter === undefined) return set;
      while (true) {
        var next = IteratorStep(iter);
        if (next === false)
          return set;
        var nextValue = IteratorValue(next);
        adder.call(set, nextValue);
      }

      return set;
    }

    if (!('Set' in global) || OVERRIDE_NATIVE_FOR_TESTING ||
        (function() { try { return !new global.Set().entries().next; } catch (_) { return true; } }()) ||
        (new global.Set([1]).size !== 1))
      global.Set = Set;

    function SetDataIndexOf(setData, key) {
      var i;
      if (key === key)
        return setData.indexOf(key);
      // Slow case for NaN
      for (i = 0; i < setData.length; i += 1)
        if (SameValueZero(setData[i], key)) return i;
      return -1;
    }

    // 23.2.1.2 new Set ( ...argumentsList )
    // 23.2.2 Properties of the Set Constructor

    // 23.2.2.1 Set.prototype
    var $SetPrototype$ =  {};
    Set.prototype = $SetPrototype$;

    // 23.2.2.2 get Set [ @@species ]
    // 23.2.3 Properties of the Set Prototype Object

    // 23.2.3.1 Set.prototype.add (value )
    define(
      Set.prototype, 'add',
      function add(value) {
        var s = strict(this);
        if (Type(s) !== 'object') throw TypeError();
        if (!('[[SetData]]' in s)) throw TypeError();
        if (s['[[SetData]]'] === undefined) throw TypeError();
        if (SameValue(value, -0)) value = 0;
        var entries = s['[[SetData]]'];
        var i = SetDataIndexOf(entries, value);
        if (i < 0) i = s['[[SetData]]'].length;
        s['[[SetData]]'][i] = value;

        return s;
      });

    // 23.2.3.2 Set.prototype.clear ()
    define(
      Set.prototype, 'clear',
      function clear() {
        var s = strict(this);
        if (Type(s) !== 'object') throw TypeError();
        if (!('[[SetData]]' in s)) throw TypeError();
        if (s['[[SetData]]'] === undefined) throw TypeError();
        var entries = s['[[SetData]]'];
        entries.length = 0;
        return undefined;
      });

    // 23.2.3.3 Set.prototype.constructor
    // 23.2.3.4 Set.prototype.delete ( value )
    define(
      Set.prototype, 'delete',
      function delete_(value) {
        var s = strict(this);
        if (Type(s) !== 'object') throw TypeError();
        if (!('[[SetData]]' in s)) throw TypeError();
        if (s['[[SetData]]'] === undefined) throw TypeError();
        var entries = s['[[SetData]]'];
        var i = SetDataIndexOf(entries, value);
        if (i < 0) return false;
        entries[i] = empty;
        return true;
      });

    // 23.2.3.5 Set.prototype.entries ( )
    define(
      Set.prototype, 'entries',
      function entries() {
        var s = strict(this);
        if (Type(s) !== 'object') throw TypeError();
        return CreateSetIterator(s, 'key+value');
      });

    // 23.2.3.6 Set.prototype.forEach ( callbackfn [ , thisArg ] )
    define(
      Set.prototype, 'forEach',
      function forEach(callbackfn/*, thisArg*/) {
        var thisArg = arguments[1];

        var s = strict(this);
        if (Type(s) !== 'object') throw TypeError();
        if (!('[[SetData]]' in s)) throw TypeError();
        if (s['[[SetData]]'] === undefined) throw TypeError();
        var entries = s['[[SetData]]'];

        if (!IsCallable(callbackfn)) {
          throw TypeError('First argument to forEach is not callable.');
        }
        for (var i = 0; i < entries.length; ++i) {
          if (entries[i] !== empty) {
            callbackfn.call(thisArg, entries[i], entries[i], s);
          }
        }
      });

    // 23.2.3.7 Set.prototype.has ( value )
    define(
      Set.prototype, 'has',
      function has(key) {
        var s = strict(this);
        if (Type(s) !== 'object') throw TypeError();
        if (!('[[SetData]]' in s)) throw TypeError();
        if (s['[[SetData]]'] === undefined) throw TypeError();
        var entries = s['[[SetData]]'];
        return SetDataIndexOf(entries, key) !== -1;
      });

    // 23.2.3.8 Set.prototype.keys ( )
    // See Set.prototype.values

    // 23.2.3.9 get Set.prototype.size
    Object.defineProperty(
      Set.prototype, 'size', {
        get: function() {
          var s = strict(this);
          if (Type(s) !== 'object') throw TypeError();
          if (!('[[SetData]]' in s)) throw TypeError();
          if (s['[[SetData]]'] === undefined) throw TypeError();
          var entries = s['[[SetData]]'];
          var count = 0;
          for (var i = 0; i < entries.length; ++i) {
            if (entries[i] !== empty)
              count = count + 1;
          }
          return count;
        }
      });

    // 23.2.3.10 Set.prototype.values ( )
    define(
      Set.prototype, 'values',
      function values() {
        var s = strict(this);
        if (Type(s) !== 'object') throw TypeError();
        return CreateSetIterator(s, 'value');
      });
    // NOTE: function name is still 'values':
    Set.prototype.keys = Set.prototype.values;

    // 23.2.3.11 Set.prototype [@@iterator ] ( )
    define(
      Set.prototype, $$iterator,
      function() {
        var s = strict(this);
        if (Type(s) !== 'object') throw TypeError();
        return CreateSetIterator(s);
      });

    // 23.2.3.12 Set.prototype [ @@toStringTag ]
    define(global.Set.prototype, $$toStringTag, 'Set');

    // 23.2.4 Properties of Set Instances
    // 23.2.5 Set Iterator Objects
    /** @constructor */
    function SetIterator() {}

    // 23.2.5.1 CreateSetIterator Abstract Operation
    function CreateSetIterator(set, kind) {
      if (Type(set) !== 'object') throw TypeError();
      if (!('[[SetData]]' in set)) throw TypeError();
      if (set['[[SetData]]'] === undefined) throw TypeError();
      var iterator = new SetIterator;
      set_internal(iterator, '[[IteratedSet]]', set);
      set_internal(iterator, '[[SetNextIndex]]', 0);
      set_internal(iterator, '[[SetIterationKind]]', kind);
      return iterator;
    }

    // 23.2.5.2 The %SetIteratorPrototype% Object
    var $SetIteratorPrototype$ = Object.create($IteratorPrototype$);
    SetIterator.prototype = $SetIteratorPrototype$;

    // 23.2.5.2.1 %SetIteratorPrototype%.next( )
    define(
      $SetIteratorPrototype$, 'next',
      function next() {
        var o = strict(this);
        if (Type(o) !== 'object') throw TypeError();
        var s = o['[[IteratedSet]]'],
            index = o['[[SetNextIndex]]'],
            itemKind = o['[[SetIterationKind]]'],
            entries = s['[[SetData]]'];
        while (index < entries.length) {
          var e = entries[index];
          index = index += 1;
          set_internal(o, '[[SetNextIndex]]', index);
          if (e !== empty) {
            if (itemKind === 'key+value')
              return CreateIterResultObject([e, e], false);
            return CreateIterResultObject(e, false);
          }
        }
        return CreateIterResultObject(undefined, true);
      });

    // 23.2.5.2.2 %SetIteratorPrototype% [ @@toStringTag ]
    define($SetIteratorPrototype$, $$toStringTag, 'Set Iterator');

    // 23.2.5.3 Properties of Set Iterator Instances

  }());

  // ---------------------------------------
  // 23.3 WeakMap Objects
  // ---------------------------------------

  (function() {
    // 23.3.1 The WeakMap Constructor
    // 23.3.1.1 WeakMap ( [ iterable ] )
    /** @constructor */
    function WeakMap(/*iterable*/) {
      var map = strict(this);
      var iterable = arguments[0];

      if (Type(map) !== 'object') throw TypeError();
      if ('[[WeakMapData]]' in map) throw TypeError();

      if (iterable !== undefined) {
        var adder = map['set'];
        if (!IsCallable(adder)) throw TypeError();
        var iter = GetIterator(ToObject(iterable));
      }
      set_internal(map, '[[WeakMapData]]', new EphemeronTable);
      if (iter === undefined) return map;
      while (true) {
        var next = IteratorStep(iter);
        if (next === false)
          return map;
        var nextValue = IteratorValue(next);
        if (Type(nextValue) !== 'object') throw TypeError();
        var k = nextValue[0];
        var v = nextValue[1];
        adder.call(map, k, v);
      }

      return map;
    }

    if (!('WeakMap' in global) || OVERRIDE_NATIVE_FOR_TESTING)
      global.WeakMap = WeakMap;

    // 23.3.2 Properties of the WeakMap Constructor
    // 23.3.2.1 WeakMap.prototype
    var $WeakMapPrototype$ = {};
    WeakMap.prototype = $WeakMapPrototype$;



   // 23.3.2.2 WeakMap[ @@create ] ( )
    // 23.3.3 Properties of the WeakMap Prototype Object

    // 23.3.3.1 WeakMap.prototype.constructor

    // 23.3.3.2 WeakMap.prototype.delete ( key )
    define(
      WeakMap.prototype, 'delete',
      function delete_(key) {
        var M = strict(this);
        if (Type(M) !== 'object') throw TypeError();
        if (M['[[WeakMapData]]'] === undefined) throw TypeError();
        if (Type(key) !== 'object') throw TypeError('Expected object');
        return M['[[WeakMapData]]'].remove(key);
      });

    // 23.3.3.3 WeakMap.prototype.get ( key )
    define(
      WeakMap.prototype, 'get',
      function get(key, defaultValue) {
        var M = strict(this);
        if (Type(M) !== 'object') throw TypeError();
        if (M['[[WeakMapData]]'] === undefined) throw TypeError();
        if (Type(key) !== 'object') throw TypeError('Expected object');
        return M['[[WeakMapData]]'].get(key, defaultValue);
      });

    // 23.3.3.4 WeakMap.prototype.has ( key )
    define(
      WeakMap.prototype, 'has',
      function has(key) {
        var M = strict(this);
        if (Type(M) !== 'object') throw TypeError();
        if (M['[[WeakMapData]]'] === undefined) throw TypeError();
        if (Type(key) !== 'object') throw TypeError('Expected object');
        return M['[[WeakMapData]]'].has(key);
      });

    // 23.3.3.5 WeakMap.prototype.set ( key , value )
    define(
      WeakMap.prototype, 'set',
      function set(key, value) {
        var M = strict(this);
        if (Type(M) !== 'object') throw TypeError();
        if (M['[[WeakMapData]]'] === undefined) throw TypeError();
        if (Type(key) !== 'object') throw TypeError('Expected object');
        M['[[WeakMapData]]'].set(key, value);
        return M;
      });

    // 23.3.3.6 WeakMap.prototype [ @@toStringTag ]
    define(global.WeakMap.prototype, $$toStringTag, 'WeakMap');

    // 23.3.4 Properties of WeakMap Instances

    // Polyfills for incomplete native implementations:
    (function() {
      var wm = new global.WeakMap();
      var orig = global.WeakMap.prototype.set;
      define(global.WeakMap.prototype, 'set', function set() {
        orig.apply(this, arguments);
        return this;
      }, wm.set({}, 0) !== wm);
    }());
  }());

  // ---------------------------------------
  // 23.4 WeakSet Objects
  // ---------------------------------------

  (function() {
    // 23.4.1 The WeakSet Constructor
    // 23.4.1.1 WeakSet ( [ iterable ] )
    /** @constructor */
    function WeakSet(/*iterable*/) {
      var set = strict(this);
      var iterable = arguments[0];

      if (Type(set) !== 'object') throw TypeError();
      if ('[[WeakSetData]]' in set) throw TypeError();

      if (iterable !== undefined) {
        var adder = set['add'];
        if (!IsCallable(adder)) throw TypeError();
        var iter = GetIterator(ToObject(iterable));
      }
      set_internal(set, '[[WeakSetData]]', new EphemeronTable);
      if (iter === undefined) return set;
      while (true) {
        var next = IteratorStep(iter);
        if (next === false)
          return set;
        var nextValue = IteratorValue(next);
        adder.call(set, nextValue);
      }

      return set;
    }

    if (!('WeakSet' in global) || OVERRIDE_NATIVE_FOR_TESTING)
      global.WeakSet = WeakSet;

    // 23.4.2 Properties of the WeakSet Constructor
    // 23.4.2.1 WeakSet.prototype
    var $WeakSetPrototype$ = {};
    WeakSet.prototype = $WeakSetPrototype$;

    // 23.4.3 Properties of the WeakSet Prototype Object
    // 23.4.3.1 WeakSet.prototype.add (value )
    define(
      WeakSet.prototype, 'add',
      function add(value) {
        var S = strict(this);
        if (Type(S) !== 'object') throw TypeError();
        if (S['[[WeakSetData]]'] === undefined) throw TypeError();
        if (Type(value) !== 'object') throw TypeError('Expected object');
        S['[[WeakSetData]]'].set(value, true);
        return S;
      });

    // 23.4.3.2 WeakSet.prototype.constructor
    // 23.4.3.3 WeakSet.prototype.delete ( value )
    define(
      WeakSet.prototype, 'delete',
      function delete_(value) {
        var S = strict(this);
        if (Type(S) !== 'object') throw TypeError();
        if (S['[[WeakSetData]]'] === undefined) throw TypeError();
        if (Type(value) !== 'object') throw TypeError('Expected object');
        return S['[[WeakSetData]]'].remove(value);
      });

    // 23.4.3.4 WeakSet.prototype.has ( value )
    define(
      WeakSet.prototype, 'has',
      function has(key) {
        var S = strict(this);
        if (Type(S) !== 'object') throw TypeError();
        if (S['[[WeakSetData]]'] === undefined) throw TypeError();
        if (Type(key) !== 'object') throw TypeError('Expected object');
        return S['[[WeakSetData]]'].has(key);
      });

    // 23.4.3.5 WeakSet.prototype [ @@toStringTag ]
    define(global.WeakSet.prototype, $$toStringTag, 'WeakSet');

    // 23.4.4 Properties of WeakSet Instances

    // Polyfills for incomplete native implementations:
    (function() {
      var ws = new global.WeakSet();
      var orig = global.WeakSet.prototype.add;
      define(global.WeakSet.prototype, 'add', function add() {
        orig.apply(this, arguments);
        return this;
      }, ws.add({}) !== ws);
    }());
  }());

  // ---------------------------------------
  // 24 Structured Data
  // ---------------------------------------

  // ---------------------------------------
  // 24.1 ArrayBuffer Objects
  // ---------------------------------------

  // See typedarray.js for TypedArray polyfill

  (function() {
    if (!('ArrayBuffer' in global))
      return;

    // 24.1.1 Abstract Operations For ArrayBuffer Objects
    // 24.1.1.1 AllocateArrayBuffer( constructor, byteLength )
    // 24.1.1.2 IsDetachedBuffer( arrayBuffer )
    // 24.1.1.3 DetachArrayBuffer( arrayBuffer )
    // 24.1.1.4 CloneArrayBuffer( srcBuffer, srcByteOffset [, cloneConstructor] )
    // 24.1.1.5 GetValueFromBuffer ( arrayBuffer, byteIndex, type, isLittleEndian )
    // 24.1.1.6 SetValueInBuffer ( arrayBuffer, byteIndex, type, value, isLittleEndian )
    // 24.1.2 The ArrayBuffer Constructor
    // 24.1.2.1 ArrayBuffer( length )
    // 24.1.3 Properties of the ArrayBuffer Constructor

    // 24.1.3.1 ArrayBuffer.isView ( arg )
    define(
      ArrayBuffer, 'isView',
      function isView(arg) {
        if (Type(arg) !== 'object') return false;
        if ('buffer' in arg && arg.buffer instanceof ArrayBuffer) return true;
        return false;
      });

    // 24.1.3.2 ArrayBuffer.prototype
    // 24.1.3.3 get ArrayBuffer [ @@species ]
    // 24.1.4 Properties of the ArrayBuffer Prototype Object
    // 24.1.4.1 get ArrayBuffer.prototype.byteLength
    // 24.1.4.2 ArrayBuffer.prototype.constructor
    // 24.1.4.3 ArrayBuffer.prototype.slice ( start , end)

    // 24.1.4.4 ArrayBuffer.prototype [ @@toStringTag ]
    define(ArrayBuffer.prototype, $$toStringTag, 'ArrayBuffer');

    // 24.1.5 Properties of the ArrayBuffer Instances
  }());

  // ---------------------------------------
  // 24.2 DataView Objects
  // ---------------------------------------

  // See typedarray.js for TypedArray polyfill

  (function() {
    if (!('DataView' in global))
      return;

    // 24.2.1 Abstract Operations For DataView Objects
    // 24.2.1.1 GetViewValue(view, requestIndex, isLittleEndian, type)
    // 24.2.1.2 SetViewValue(view, requestIndex, isLittleEndian, type, value)
    // 24.2.2 The DataView Constructor
    // 24.2.2.1 DataView (buffer [ , byteOffset [ , byteLength ] ] )
    // 24.2.3 Properties of the DataView Constructor
    // 24.2.3.1 DataView.prototype
    // 24.2.4 Properties of the DataView Prototype Object
    // 24.2.4.1 get DataView.prototype.buffer
    // 24.2.4.2 get DataView.prototype.byteLength
    // 24.2.4.3 get DataView.prototype.byteOffset
    // 24.2.4.4 DataView.prototype.constructor
    // 24.2.4.5 DataView.prototype.getFloat32 ( byteOffset [ , littleEndian ] )
    // 24.2.4.6 DataView.prototype.getFloat64 ( byteOffset [ , littleEndian ] )
    // 24.2.4.7 DataView.prototype.getInt8 ( byteOffset )
    // 24.2.4.8 DataView.prototype.getInt16 ( byteOffset [ , littleEndian ] )
    // 24.2.4.9 DataView.prototype.getInt32 ( byteOffset [ , littleEndian ] )
    // 24.2.4.10 DataView.prototype.getUint8 ( byteOffset )
    // 24.2.4.11 DataView.prototype.getUint16 ( byteOffset [ , littleEndian ] )
    // 24.2.4.12 DataView.prototype.getUint32 ( byteOffset [ , littleEndian ] )
    // 24.2.4.13 DataView.prototype.setFloat32 ( byteOffset, value [ , littleEndian ] )
    // 24.2.4.14 DataView.prototype.setFloat64 ( byteOffset, value [ , littleEndian ] )
    // 24.2.4.15 DataView.prototype.setInt8 ( byteOffset, value )
    // 24.2.4.16 DataView.prototype.setInt16 ( byteOffset, value [ , littleEndian ] )
    // 24.2.4.17 DataView.prototype.setInt32 ( byteOffset, value [ , littleEndian ] )
    // 24.2.4.18 DataView.prototype.setUint8 ( byteOffset, value )
    // 24.2.4.19 DataView.prototype.setUint16 ( byteOffset, value [ , littleEndian ] )
    // 24.2.4.20 DataView.prototype.setUint32 ( byteOffset, value [ , littleEndian ] )

    // 24.2.4.21 DataView.prototype[ @@toStringTag ]
    define(DataView.prototype, $$toStringTag, 'DataView');

    // 24.2.5 Properties of DataView Instances
  }());

  // ---------------------------------------
  // 24.3 The JSON Object
  // ---------------------------------------

  // 24.3.1 JSON.parse ( text [ , reviver ] )
  // 24.3.2 JSON.stringify ( value [ , replacer [ , space ] ] )
  // 24.3.3 JSON [ @@toStringTag ]
  define(JSON, $$toStringTag, 'JSON');

  // ---------------------------------------
  // 25.1 Iteration
  // ---------------------------------------

  // 25.1.1 Common Iteration Interfaces
  // 25.1.1.1 The Iterable Interface
  // 25.1.1.2 The Iterator Interface
  // 25.1.1.3 The IteratorResult Interface

  // 25.1.2 The %IteratorPrototype% Object
  // Defined earlier, so other prototypes can reference it.
  // 25.1.2.1 %IteratorPrototype% [ @@iterator ] ( )
  define($IteratorPrototype$, $$iterator, function() {
    return this;
  });


  // ---------------------------------------
  // 25.4 Promise Objects
  // ---------------------------------------

  (function() {
    // 25.4 Promise Objects

    // 25.4.1 Promise Abstract Operations

    // 25.4.1.1 PromiseCapability Records
    // 25.4.1.1.1 IfAbruptRejectPromise ( value, capability )

    function IfAbruptRejectPromise(value, capability) {
      var rejectResult = capability['[[Reject]]'].call(undefined, value);
      return capability['[[Promise]]'];
    }

    // 25.4.1.2 PromiseReaction Records

    // 25.4.1.3 CreateResolvingFunctions ( promise )

    function CreateResolvingFunctions(promise) {
      var alreadyResolved = {'[[value]]': false};
      var resolve = PromiseResolveFunction();
      set_internal(resolve, '[[Promise]]',  promise);
      set_internal(resolve, '[[AlreadyResolved]]', alreadyResolved);
      var reject = PromiseRejectFunction();
      set_internal(reject, '[[Promise]]', promise);
      set_internal(reject, '[[AlreadyResolved]]', alreadyResolved);
      return { '[[Resolve]]': resolve, '[[Reject]]': reject};
    }

    // 25.4.1.3.1 Promise Reject Functions

    function PromiseRejectFunction() {
      var F = function(reason) {
        console.assert(Type(F['[[Promise]]']) === 'object');
        var promise = F['[[Promise]]'];
        var alreadyResolved = F['[[AlreadyResolved]]'];
        if (alreadyResolved['[[value]]']) return undefined;
        set_internal(alreadyResolved, '[[value]]', true);
        return RejectPromise(promise, reason);
      };
      return F;
    }

    // 25.4.1.3.2 Promise Resolve Functions

    function PromiseResolveFunction() {
      var F = function(resolution) {
        console.assert(Type(F['[[Promise]]']) === 'object');
        var promise = F['[[Promise]]'];
        var alreadyResolved = F['[[AlreadyResolved]]'];
        if (alreadyResolved['[[value]]']) return undefined;
        set_internal(alreadyResolved, '[[value]]', true);

        if (SameValue(resolution, promise))  {
          var selfResolutionError = TypeError();
          return RejectPromise(promise, selfResolutionError);
        }
        if (Type(resolution) !== 'object')
          return FulfillPromise(promise, resolution);
        try {
          var then = resolution['then'];
        } catch(then) {
          return RejectPromise(promise, then);
        }
        if (!IsCallable(then))
          return FulfillPromise(promise, resolution);
        EnqueueJob('PromiseJobs', PromiseResolveThenableJob, [promise, resolution, then]);
        return undefined;
      };
      return F;
    }

    // 25.4.1.4 FulfillPromise ( promise, value )

    function FulfillPromise(promise, value) {
      console.assert(promise['[[PromiseState]]'] === 'pending');
      var reactions = promise['[[PromiseFulfillReactions]]'];
      set_internal(promise, '[[PromiseResult]]', value);
      set_internal(promise, '[[PromiseFulfillReactions]]', undefined);
      set_internal(promise, '[[PromiseRejectReactions]]', undefined);
      set_internal(promise, '[[PromiseState]]', 'fulfilled');
      return TriggerPromiseReactions(reactions, value);
    }

    // 25.4.1.5 NewPromiseCapability ( C )

    function NewPromiseCapability(c) {
      // To keep Promise hermetic, this doesn't look much like the spec.
      return CreatePromiseCapabilityRecord(undefined, c);
    }

    // 25.4.1.5.1 CreatePromiseCapabilityRecord ( promise, constructor )

    function CreatePromiseCapabilityRecord(promise, constructor) {
      // To keep Promise hermetic, this doesn't look much like the spec.
      console.assert(IsConstructor(constructor));
      var promiseCapability = {};
      set_internal(promiseCapability, '[[Promise]]', promise);
      set_internal(promiseCapability, '[[Resolve]]', undefined);
      set_internal(promiseCapability, '[[Reject]]', undefined);
      var executor = GetCapabilitiesExecutor();
      set_internal(executor, '[[Capability]]', promiseCapability);

      // NOTE: Differs from spec; object is constructed here
      var constructorResult = promise = new constructor(executor);
      set_internal(promiseCapability, '[[Promise]]', promise);

      if (!IsCallable(promiseCapability['[[Resolve]]'])) throw TypeError();
      if (!IsCallable(promiseCapability['[[Reject]]'])) throw TypeError();
      if (Type(constructorResult) === 'object' && !SameValue(promise, constructorResult)) throw TypeError();
      return promiseCapability;
    }

    // 25.4.1.5.2 GetCapabilitiesExecutor Functions

    function GetCapabilitiesExecutor() {
      var F = function(resolve, reject) {
        console.assert(F['[[Capability]]']);
        var promiseCapability = F['[[Capability]]'];
        if (promiseCapability['[[Resolve]]'] !== undefined) throw TypeError();
        if (promiseCapability['[[Reject]]'] !== undefined) throw TypeError();
        set_internal(promiseCapability, '[[Resolve]]', resolve);
        set_internal(promiseCapability, '[[Reject]]', reject);
        return undefined;
      };
      return F;
    }

    // 25.4.1.6 IsPromise ( x )

    function IsPromise(x) {
      if (Type(x) !== 'object') return false;
      if (!('[[PromiseState]]' in x)) return false;
      if (x['[[PromiseState]]'] === undefined) return false;
      return true;
    }

    // 25.4.1.7 RejectPromise ( promise, reason )

    function RejectPromise(promise, reason) {
      console.assert(promise['[[PromiseState]]'] === 'pending');
      var reactions = promise['[[PromiseRejectReactions]]'];
      set_internal(promise, '[[PromiseResult]]', reason);
      set_internal(promise, '[[PromiseFulfillReactions]]', undefined);
      set_internal(promise, '[[PromiseRejectReactions]]', undefined);
      set_internal(promise, '[[PromiseState]]', 'rejected');
      return TriggerPromiseReactions(reactions, reason);
    }

    // 25.4.1.8 TriggerPromiseReactions ( reactions, argument )

    function TriggerPromiseReactions(reactions, argument) {
      for (var i = 0, len = reactions.length; i < len; ++i)
        EnqueueJob('PromiseJobs', PromiseReactionJob, [reactions[i], argument]);
      return undefined;
    }

    // 25.4.2 Promise Jobs

    // 25.4.2.1 PromiseReactionJob ( reaction, argument )

    function PromiseReactionJob(reaction, argument) {
      var promiseCapability = reaction['[[Capabilities]]'];
      var handler = reaction['[[Handler]]'];
      var handlerResult, status;
      try {
        if (handler === 'Identity') handlerResult = argument;
        else if (handler === 'Thrower') throw argument;
        else handlerResult = handler.call(undefined, argument);
      } catch (handlerResult) {
        status = promiseCapability['[[Reject]]'].call(undefined, handlerResult);
        NextJob(status); return;
      }
      status = promiseCapability['[[Resolve]]'].call(undefined, handlerResult);
      NextJob(status);
    }

    // 25.4.2.2 PromiseResolveThenableJob ( promiseToResolve, thenable, then)

    function PromiseResolveThenableJob(promiseToResolve, thenable, then) {
      // SPEC BUG: promise vs. promiseToResolve
      var resolvingFunctions = CreateResolvingFunctions(promiseToResolve);
      try {
        var thenCallResult = then.call(thenable, resolvingFunctions['[[Resolve]]'],
                                       resolvingFunctions['[[Reject]]']);
      } catch (thenCallResult) {
        var status = resolvingFunctions['[[Reject]]'].call(undefined, thenCallResult);
        NextJob(status); return;
      }
      NextJob(thenCallResult);
    }

    // 25.4.3 The Promise Constructor

    // 25.4.3.1 Promise ( executor )

    function Promise(executor) {
      var config = { configurable: false, enumerable: false, writable: true, value: undefined };
      Object.defineProperty(this, '[[PromiseState]]', config);
      Object.defineProperty(this, '[[PromiseConstructor]]', config);
      Object.defineProperty(this, '[[PromiseResult]]', config);
      Object.defineProperty(this, '[[PromiseFulfillReactions]]', config);
      Object.defineProperty(this, '[[PromiseRejectReactions]]', config);

      var promise = this;
      if (Type(promise) !== 'object') throw new TypeError();
      if (!('[[PromiseState]]' in promise)) throw TypeError();
      if (promise['[[PromiseState]]'] !== undefined) throw TypeError();
      if (!IsCallable(executor)) throw TypeError();

      set_internal(promise, '[[PromiseConstructor]]', Promise);

      return InitializePromise(promise, executor);
    }

    // 25.4.3.1.1 InitializePromise ( promise, executor )

    function InitializePromise(promise, executor) {
      console.assert('[[PromiseState]]' in promise);
      console.assert(IsCallable(executor));
      set_internal(promise, '[[PromiseState]]', 'pending');
      set_internal(promise, '[[PromiseFulfillReactions]]', []);
      set_internal(promise, '[[PromiseRejectReactions]]', []);
      var resolvingFunctions = CreateResolvingFunctions(promise);
      try {
        var completion = executor.call(undefined, resolvingFunctions['[[Resolve]]'],
                                       resolvingFunctions['[[Reject]]']);
      } catch (completion) {
        var status = resolvingFunctions['[[Reject]]'].call(undefined, completion);
      }
      return promise;
    }

    // 25.4.4 Properties of the Promise Constructor
    // 25.4.4.1 Promise.all ( iterable )

    define(Promise, 'all', function all(iterable) {
      var c = strict(this);
      var promiseCapability = NewPromiseCapability(c);
      try {
        var iterator = GetIterator(iterable);
      } catch (value) {
        promiseCapability['[[Reject]]'].call(undefined, value);
        return promiseCapability['[[Promise]]'];
      }
      var values = [];
      var remainingElementsCount = { value: 1 };
      var index = 0;
      while (true) {
        try {
          var next = IteratorStep(iterator);
        } catch (value) {
          promiseCapability['[[Reject]]'].call(undefined, value);
          return promiseCapability['[[Promise]]'];
        }
        if (!next) {
          remainingElementsCount.value -= 1;
          if (remainingElementsCount.value === 0) {
            var resolveResult = promiseCapability['[[Resolve]]'].apply(undefined, values);


          }
          return promiseCapability['[[Promise]]'];
        }
        try {
          var nextValue = IteratorValue(next);
        } catch (value) {
          promiseCapability['[[Reject]]'].call(undefined, value);
          return promiseCapability['[[Promise]]'];
        }
        try {
          var nextPromise = c.resolve(nextValue);
        } catch (value) {
          promiseCapability['[[Reject]]'].call(undefined, value);
          return promiseCapability['[[Promise]]'];
        }
        var resolveElement = PromiseAllResolveElementFunction();
        set_internal(resolveElement, '[[AlreadyCalled]]', { value: false });
        set_internal(resolveElement, '[[Index]]', index);
        set_internal(resolveElement, '[[Values]]', values);
        set_internal(resolveElement, '[[Capabilities]]', promiseCapability);
        set_internal(resolveElement, '[[RemainingElements]]', remainingElementsCount);
        remainingElementsCount.value += 1;
        try {
          var result = nextPromise.then(resolveElement, promiseCapability['[[Reject]]']);
        } catch (value) {
          promiseCapability['[[Reject]]'].call(undefined, value);
          return promiseCapability['[[Promise]]'];
        }
        index += 1;
      }
    });

    // 25.4.4.1.1 Promise.all Resolve Element Functions

    function PromiseAllResolveElementFunction() {
      var F = function(x) {
        var alreadyCalled = F['[[AlreadyCalled]]'];
        if (alreadyCalled.value) return undefined;
        alreadyCalled.value = true;
        var index = F['[[Index]]'];
        var values = F['[[Values]]'];
        var promiseCapability = F['[[Capabilities]]'];
        var remainingElementsCount = F['[[RemainingElements]]'];
        try {
          values[index] = x;
        } catch (result) {
          promiseCapability['[[Reject]]'].call(undefined, result);
          return promiseCapability['[[Promise]]'];
        }
        remainingElementsCount.value -= 1;
        if (remainingElementsCount.value === 0)
          return promiseCapability['[[Resolve]]'].call(undefined, values);
        return undefined;
      };
      return F;
    }

    // 25.4.4.2 Promise.prototype

    Promise.prototype = {};

    // 25.4.4.3 Promise.race ( iterable )

    define(Promise, 'race', function race(iterable) {
      var c = strict(this);
      var promiseCapability = NewPromiseCapability(c);
      try {
        var iterator = GetIterator(iterable);
      } catch (value) {
        promiseCapability['[[Reject]]'].call(undefined, value);
        return promiseCapability['[[Promise]]'];
      }
      while (true) {
        try {
          var next = IteratorStep(iterator);
        } catch (value) {
          promiseCapability['[[Reject]]'].call(undefined, value);
          return promiseCapability['[[Promise]]'];
        }
        if (!next) return promiseCapability['[[Promise]]'];
        try {
          var nextValue = IteratorValue(next);
        } catch (value) {
          promiseCapability['[[Reject]]'].call(undefined, value);
          return promiseCapability['[[Promise]]'];
        }
        try {
          var nextPromise = c.resolve(nextValue);
        } catch (value) {
          promiseCapability['[[Reject]]'].call(undefined, value);
          return promiseCapability['[[Promise]]'];
        }
        try {
          nextPromise.then(promiseCapability['[[Resolve]]'], promiseCapability['[[Reject]]']);
        } catch (value) {
          promiseCapability['[[Reject]]'].call(undefined, value);
          return promiseCapability['[[Promise]]'];
        }
      }
    });

    // 25.4.4.4 Promise.reject ( r )

    define(Promise, 'reject', function reject(r) {
      var c = strict(this);
      var promiseCapability = NewPromiseCapability(c);
      var rejectResult = promiseCapability['[[Reject]]'].call(undefined, r);
      return promiseCapability['[[Promise]]'];
    });

    // 25.4.4.5 Promise.resolve ( x )

    define(Promise, 'resolve', function resolve(x) {
      var c = strict(this);
      if (IsPromise(x)) {
        var constructor = x['[[PromiseConstructor]]'];
        if (SameValue(constructor, c)) return x;
      }
      var promiseCapability = NewPromiseCapability(c);
      var resolveResult = promiseCapability['[[Resolve]]'].call(undefined, x);
      return promiseCapability['[[Promise]]'];
    });

    // 25.4.4.6 Promise [ @@create ] ( )
    // 25.4.4.6.1 AllocatePromise ( constructor )
    // 25.4.5 Properties of the Promise Prototype Object
    // 25.4.5.1 Promise.prototype.catch ( onRejected )

    define(Promise.prototype, 'catch', function catch_(onRejected) {
      var promise = this;
      return promise.then(undefined, onRejected);
    });

    // 25.4.5.2 Promise.prototype.constructor

    Promise.prototype.constructor = Promise;

    // 25.4.5.3 Promise.prototype.then ( onFulfilled , onRejected )

    define(Promise.prototype, 'then', function then(onFulfilled, onRejected) {
      var promise = this;
      if (!IsPromise(promise)) throw TypeError();
      if (!IsCallable(onFulfilled)) onFulfilled = 'Identity';
      if (!IsCallable(onRejected)) onRejected = 'Thrower';
      var c = promise.constructor;
      var promiseCapability = NewPromiseCapability(c);
      var fulfillReaction = { '[[Capabilities]]': promiseCapability,
                              '[[Handler]]': onFulfilled };
      var rejectReaction = { '[[Capabilities]]': promiseCapability,
                             '[[Handler]]': onRejected };
      if (promise['[[PromiseState]]'] === 'pending') {
        promise['[[PromiseFulfillReactions]]'].push(fulfillReaction);
        promise['[[PromiseRejectReactions]]'].push(rejectReaction);
      } else if (promise['[[PromiseState]]'] === 'fulfilled') {
        var value = promise['[[PromiseResult]]'];
        EnqueueJob('PromiseJobs', PromiseReactionJob, [fulfillReaction, value]);
      } else if (promise['[[PromiseState]]'] === 'rejected') {
        var reason = promise['[[PromiseResult]]'];
        EnqueueJob('PromiseJobs', PromiseReactionJob, [rejectReaction, reason]);
      }
      return promiseCapability['[[Promise]]'];
    });

    // 25.4.6 Properties of Promise Instances

    if (!('Promise' in global) || OVERRIDE_NATIVE_FOR_TESTING)
      global.Promise = Promise;

    // Patch early Promise.cast vs. Promise.resolve implementations
    if ('cast' in global.Promise) global.Promise.resolve = global.Promise.cast;
  }());

  // 25.4.5.1 Promise.prototype [ @@toStringTag ]
  define(Promise.prototype, $$toStringTag, 'Promise');

  // ---------------------------------------
  // 26 Reflection
  // ---------------------------------------

  (function() {
    // 26.1 The Reflect Object
    if (!('Reflect' in global) || OVERRIDE_NATIVE_FOR_TESTING)
      global.Reflect = {};

    // 26.1.1 Reflect.apply ( target, thisArgument, argumentsList )
    define(
      Reflect, 'apply',
      function apply(target, thisArgument, argumentsList) {
        if (!IsCallable(target)) throw TypeError();
        return Function.prototype.apply.call(target, thisArgument, argumentsList);
      });

    // 26.1.2 Reflect.construct ( target, argumentsList [, newTarget] )
    define(
      Reflect, 'construct',
      function construct(target, argumentsList) {
        return __cons(target, argumentsList);
      });

    // 26.1.3 Reflect.defineProperty ( target, propertyKey, attributes )
    define(
      Reflect, 'defineProperty',
      function defineProperty(target, propertyKey, attributes) {
        try {
          Object.defineProperty(target, propertyKey, attributes);
          return true;
        } catch (_) {
          return false;
        }
      });

    // 26.1.4 Reflect.deleteProperty ( target, propertyKey )
    define(
      Reflect, 'deleteProperty',
      function deleteProperty(target,name) {
        try {
          delete target[name];
          return !HasOwnProperty(target, name);
        } catch (_) {
          return false;
        }
      });

    // 26.1.5 Reflect.enumerate ( target )
    define(
      Reflect, 'enumerate',
      function enumerate(target) {
        target = ToObject(target);
        var iterator = Enumerate(target);
        return iterator;
      });

    // 26.1.6 Reflect.get ( target, propertyKey [ , receiver ])
    define(
      Reflect, 'get',
      function get(target, name, receiver) {
        target = ToObject(target);
        name = String(name);
        receiver = (receiver === undefined) ? target : ToObject(receiver);
        var desc = getPropertyDescriptor(target, name);
        if (desc && 'get' in desc)
          return Function.prototype.call.call(desc['get'], receiver);
        return target[name];
      });

    // 26.1.7 Reflect.getOwnPropertyDescriptor ( target, propertyKey )
    define(
      Reflect, 'getOwnPropertyDescriptor',
      Object.getOwnPropertyDescriptor);

    // 26.1.8 Reflect.getPrototypeOf ( target )
    define(
      Reflect, 'getPrototypeOf',
      Object.getPrototypeOf);

    // 26.1.9 Reflect.has ( target, propertyKey )
    define(
      Reflect, 'has',
      function has(target,name) {
        return String(name) in ToObject(target);
      });

    // 26.1.10 Reflect.isExtensible (target)
    define(
      Reflect, 'isExtensible',
      Object.isExtensible);

    // 26.1.11 Reflect.ownKeys ( target )
    define(
      Reflect, 'ownKeys',
      function ownKeys(target) {
        var obj = ToObject(target);
        return Object.getOwnPropertyNames(obj);
      });

    // 26.1.12 Reflect.preventExtensions ( target )
    define(
      Reflect, 'preventExtensions',
      function preventExtensions(target) {
        try { Object.preventExtensions(target); return true; } catch (_) { return false; }
      });

    // 26.1.13 Reflect.set ( target, propertyKey, V [ , receiver ] )
    define(
      Reflect, 'set',
      function set(target, name, value, receiver) {
        target = ToObject(target);
        name = String(name);
        receiver = (receiver === undefined) ? target : ToObject(receiver);
        var desc = getPropertyDescriptor(target, name);
        try {
          if (desc && 'set' in desc)
            Function.prototype.call.call(desc['set'], receiver, value);
          else
            target[name] = value;
          return true;
        } catch (_) {
          return false;
        }
      });

    // 26.1.14 Reflect.setPrototypeOf ( target, proto )
    define(
      Reflect, 'setPrototypeOf',
      function setPrototypeOf(target, proto) {
        try {
          target.__proto__ = proto;
          return Reflect.getPrototypeOf(target) === proto;
        } catch(_) {
          return false;
        }
      });

  }());

  // ---------------------------------------
  // 26.2 Proxy Objects
  // ---------------------------------------

  // Not polyfillable.

}(self));

// This helper is defined outside the main scope so that the use of
// 'eval' does not taint the scope for minifiers.
function __cons(t, a) {
  return eval('new t(' + a.map(function(_, i) { return 'a[' + i + ']'; }).join(',') + ')');
}

},{}],6:[function(require,module,exports){
"use strict";

require("./shim/array");
require("./shim/object");

},{"./shim/array":7,"./shim/object":8}],7:[function(require,module,exports){
'use strict';

// https://tc39.github.io/ecma262/#sec-array.prototype.includes
if (!Array.prototype.includes) {
  Object.defineProperty(Array.prototype, 'includes', {
    value: function value(searchElement, fromIndex) {
      return this.indexOf(searchElement, fromIndex) !== -1;
    }
  });
}

},{}],8:[function(require,module,exports){
"use strict";

//https://tc39.es/proposal-object-values-entries/
//https://github.com/tc39/proposal-object-values-entries
if (!Object.entries) {
  Object.entries = function (obj) {
    var ownProps = Object.keys(obj),
        i = ownProps.length,
        resArray = new Array(i); // preallocate the Array
    while (i--) {
      resArray[i] = [ownProps[i], obj[ownProps[i]]];
    }

    return resArray;
  };
}

},{}],9:[function(require,module,exports){
(function (global){
'use strict';

require('../frameworks/shim');
require('js-polyfills/es5');
require('js-polyfills/es6');

if (global.rh === undefined) {
  global.rh = {};
}

module.exports = global.rh;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../frameworks/shim":6,"js-polyfills/es5":4,"js-polyfills/es6":5}],10:[function(require,module,exports){
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var rh = require("../../lib/rh");
var nodeUtils = require("../utils/node_utils");
var $ = rh.$;
var _ = rh._;

var ModalDialog = function () {
  function ModalDialog() {
    _classCallCheck(this, ModalDialog);
  }

  _createClass(ModalDialog, [{
    key: "createChildWidget",
    value: function createChildWidget() {
      this.node = $.createElement('div', this.template);
      nodeUtils.appendChild(document.body, this.node);
      this.widget = new rh.Widget({ node: this.node });
      this.widget.init();
    }
  }, {
    key: "setOnImageLoad",
    value: function setOnImageLoad() {
      var modalContent = $.find(this.node, '.rh-modal-content')[0];
      if (!modalContent) {
        return;
      }
      this.modalContent = modalContent;
      var img = $.find(modalContent, 'img')[0];
      if (img) {
        this.img = img;
        img.addEventListener('load', this.setModalSize.bind(this));
        img.addEventListener('error', this.setModalSize.bind(this));
      }
    }
  }, {
    key: "setModalSize",
    value: function setModalSize() {
      this.imageWidth = this.img.naturalWidth;
      this.imageHeight = this.img.naturalHeight;
      var position = this.calculatePosition(this.imageWidth, this.imageHeight);
      var modalContainer = $.find(this.node, '.rh-modal-container')[0];
      if (modalContainer) {
        this.setContainerStyle(modalContainer, position);
      }
    }
  }, {
    key: "setContainerStyle",
    value: function setContainerStyle(modalContainer, position) {
      var top = Math.round(position.top);
      var left = Math.round(position.left);

      $.css(modalContainer, 'left', left.toString() + 'px');
      $.css(modalContainer, 'top', top.toString() + 'px');

      if (this.modalContent) {
        this.setImageSize(position.width, position.height);
      }
      $.css(modalContainer, 'display', "block");
    }
  }, {
    key: "calculateImageSize",
    value: function calculateImageSize(size) {
      var aspect = size.imageWidth / size.imageHeight;
      if (size.imageWidth < size.pageWidth && size.imageHeight < size.pageHeight) {
        return { width: size.imageWidth, height: size.imageHeight };
      }

      if (size.imageWidth >= size.pageWidth && size.imageHeight <= size.pageHeight) {
        return { height: size.pageWidth / aspect, width: size.pageWidth };
      }
      if (size.imageWidth <= size.pageWidth && size.imageHeight >= size.pageHeight) {
        return { height: size.pageHeight, width: size.pageHeight * aspect
        };
      }
      if (size.imageWidth >= size.pageWidth && size.imageHeight >= size.pageHeight) {
        return this._calculateFullyExceedSize(size, aspect);
      }
    }
  }, {
    key: "_calculateFullyExceedSize",
    value: function _calculateFullyExceedSize(size, aspect) {
      var pageAspect = size.pageWidth / size.pageHeight;
      if (aspect < pageAspect) {
        return { height: size.pageHeight, width: size.pageHeight * aspect };
      } else {
        return { height: size.pageWidth / aspect, width: size.pageWidth };
      }
    }
  }, {
    key: "calculatePosition",
    value: function calculatePosition(imageWidth, imageHeight) {
      var pageWidth = window.innerWidth || document.body.clientWidth;
      var pageHeight = window.innerHeight || document.body.clientHeight;
      pageWidth -= 70;
      pageHeight -= 70;
      pageWidth = pageWidth >= 0 ? pageWidth : 0;
      pageHeight = pageHeight >= 0 ? pageHeight : 0;

      var size = { imageWidth: imageWidth, imageHeight: imageHeight, pageWidth: pageWidth, pageHeight: pageHeight };
      var image_size = this.calculateImageSize(size);
      imageWidth = image_size.width;
      imageHeight = image_size.height;
      var left = Math.max(5, (pageWidth - imageWidth) / 2);
      var top = Math.max(5, (pageHeight - imageHeight) / 2);

      return {
        left: left,
        top: top,
        width: imageWidth,
        height: imageHeight,
        pageWidth: pageWidth,
        pageHeight: pageHeight
      };
    }
  }, {
    key: "initialStyle",
    value: function initialStyle() {
      return this.isImage ? "style=\"display:none\"" : '';
    }
  }, {
    key: "ShowModal",
    value: function ShowModal(config) {
      this.isImage = config.isImage;
      this.createChildWidget();
      this.widget.subscribe('close', this._close.bind(this));
      this.widget.publish('content', config.content);
      _.defer(this.setOnImageLoad.bind(this));
    }
  }, {
    key: "setImageSize",
    value: function setImageSize(maxWidth, maxHeight) {
      if (this.imageWidth > maxWidth) {
        $.css(this.img, 'width', Math.round(maxWidth) + "px");
      }
      if (this.imageHeight > maxHeight) {
        $.css(this.img, 'height', Math.round(maxHeight) + "px");
      }
    }
  }, {
    key: "_close",
    value: function _close() {
      this.widget.destruct();
      this.widget = undefined;
      nodeUtils.removeChild(this.node);
      this.node = undefined;
    }
  }, {
    key: "template",
    get: function get() {
      var initialStyle = this.initialStyle();

      return "\n    <div class=\"rh-modal\">\n        <div class=\"rh-modal-container\" " + initialStyle + ">\n          <div class=\"rh-modal-content\" data-html=\"content\"></div>\n          <div class=\"rh-modal-close\" data-click=\"@close(true)\"> </div>\n        </div>\n    </div>";
    }
  }]);

  return ModalDialog;
}();

if (!_.isIframe()) {
  rh.model.csubscribe('SHOW_MODAL', function (config) {
    var model = new ModalDialog();
    model.ShowModal(config);
  });
}

rh.model.csubscribe('SHOW_MODAL_IN_TOPIC', function (config) {
  var model = new ModalDialog();
  model.ShowModal(config);
});

},{"../../lib/rh":9,"../utils/node_utils":20}],11:[function(require,module,exports){
"use strict";

require("../lib/rh");
require("../../lenient_src/robohelp/topic/url_utils");
require("../../lenient_src/robohelp/topic/topic_events");
require("../../lenient_src/robohelp/topic/phonegap");
require("./topic/init");
require("./topic/widgets/dropdown_text");
require("./topic/widgets/expanding_text");
require("./topic/widgets/popover");
require("./topic/widgets/hyperlink_popover");
require("./topic/widgets/text_popover");
require("./topic/widgets/trigger");
require("./topic/highlight");
require("../../lenient_src/robohelp/topic/topic_events");
require("./layout/modal_dialog");

},{"../../lenient_src/robohelp/topic/phonegap":1,"../../lenient_src/robohelp/topic/topic_events":2,"../../lenient_src/robohelp/topic/url_utils":3,"../lib/rh":9,"./layout/modal_dialog":10,"./topic/highlight":12,"./topic/init":13,"./topic/widgets/dropdown_text":14,"./topic/widgets/expanding_text":15,"./topic/widgets/hyperlink_popover":16,"./topic/widgets/popover":17,"./topic/widgets/text_popover":18,"./topic/widgets/trigger":19}],12:[function(require,module,exports){
'use strict';

var rh = require("../../lib/rh");
var _ = rh._;
var $ = rh.$;

_.removeHighlight = function () {
  var $body = $('body', 0);
  var $highlight_elements = $.find($body, 'span[data-highlight]') || [];
  _.each($highlight_elements, function (node) {
    $.removeAttribute(node, 'style');
  });
};

rh.model.csubscribe('EVT_REMOVE_HIGHLIGHT', _.removeHighlight);

},{"../../lib/rh":9}],13:[function(require,module,exports){
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var rh = require("../../lib/rh");
var NodesUtil = require("../../responsive_help/utils/node_utils");
var _ = rh._;
var consts = rh.consts;
var $ = rh.$;
var model = rh.model;
var EventHandlers = void 0,
    eHandlers = void 0,
    registeredEvents = void 0;

_.onTopicLoad = function () {
  var paramsStr = _.extractParamString(document.location.href);
  var paramsMap = _.urlParams(paramsStr);
  var redirectattr = consts('RH_FULL_LAYOUT_PARAM');
  var $html = $('html', 0);
  var lang = model.get(consts('KEY_LNG_NAME'));
  if ($html && lang && lang !== '') {
    $.setAttribute($html, 'lang', lang);
  }
  if (redirectattr in paramsMap) {
    _.addProjectData(_.goToFullLayout);
  } else {
    _.addGoToLayout();
    _.remove_cbt();
  }
};

_.remove_cbt = function () {
  var $body = $('body', 0);
  var $cbt_elements = $.find($body, '[data-rhtags]');
  if ($cbt_elements) {
    _.each($cbt_elements, function (node) {
      $.removeClass(node, 'rh-hide');
    });
  }
};

_.showDefaultText = function (shouldShow) {
  var defaultTextDiv = void 0,
      DEFAULT_TEXT_ID = 'rh-default-text';
  var lng = model.get(consts('KEY_LNG'));
  if (shouldShow && $.find(document.head, 'meta[name="condition-tags"]').length !== 0) {
    if (!document.getElementById(DEFAULT_TEXT_ID)) {
      defaultTextDiv = document.createElement('div');
      $.setAttribute(defaultTextDiv, 'id', DEFAULT_TEXT_ID);
      defaultTextDiv.innerHTML = lng.TopicHiddenText || "The current topic is hidden for the selected filters.";
      document.body.appendChild(defaultTextDiv);
    }
  } else {
    defaultTextDiv = document.getElementById(DEFAULT_TEXT_ID);
    NodesUtil.removeChild(defaultTextDiv);
  }
};

_.getRelativeTopicPath = function () {
  var path = _.makeRelativeUrl(_.getRootUrl(), _.filePath());
  var index = path.lastIndexOf('/');
  return index !== -1 ? _.parentPath(path) : "";
};

_.addLayoutHTML = function () {

  model.subscribeOnce([consts('KEY_HEADER_HTML')], function () {
    var format = model.get(consts('KEY_HEADER_HTML'));

    if (format && format !== "") {

      model.subscribeOnce([consts('KEY_HEADER_TITLE'), consts('KEY_LNG')], function () {
        var title = model.get(consts('KEY_HEADER_TITLE'));
        var label = model.get(consts('KEY_LNG')).ShowTopicInContext;
        label = label ? label : "Click here to see this page in full context";
        var tooltip = label;
        var logo = model.get(consts('KEY_HEADER_LOGO_PATH'));
        logo = _.getRelativeTopicPath() + logo;
        var html = _.resolveEnclosedVar(format, function (variable) {
          if (variable === "label") {
            return label;
          } else if (variable === "tooltip") {
            return tooltip;
          } else if (variable === "title") {
            return title;
          } else if (variable === "logo") {
            return logo;
          }
        });
        var $body = $('body', 0);
        var $div = document.createElement("div");
        $div.innerHTML = html;
        $body.insertBefore($div, $body.childNodes[0]);
      });
    }
  });
};

_.addLayoutCSS = function () {

  model.subscribeOnce([consts('KEY_HEADER_CSS')], function () {
    var format = model.get(consts('KEY_HEADER_CSS'));

    if (format && format !== "") {

      model.subscribeOnce([consts('KEY_HEADER_LOGO_PATH'), consts('KEY_HEADER_TITLE_COLOR'), consts('KEY_HEADER_BACKGROUND_COLOR'), consts('KEY_LAYOUT_FONT_FAMILY')], function () {
        var backgroundColor = model.get(consts('KEY_HEADER_BACKGROUND_COLOR'));
        backgroundColor = backgroundColor ? backgroundColor : model.get(consts('KEY_HEADER_DEFAULT_BACKGROUND_COLOR'));
        var color = model.get(consts('KEY_HEADER_TITLE_COLOR'));
        color = color ? color : model.get(consts('KEY_HEADER_DEFAULT_TITLE_COLOR'));
        var fontFamily = model.get(consts('KEY_LAYOUT_FONT_FAMILY'));
        fontFamily = fontFamily ? fontFamily : model.get(consts('KEY_LAYOUT_DEFAULT_FONT_FAMILY'));
        var css = _.resolveEnclosedVar(format, function (variable) {
          if (variable === "background-color") {
            return backgroundColor;
          } else if (variable === "color") {
            return color;
          } else if (variable === "font-family") {
            return fontFamily;
          }
        });
        var $style = document.createElement("style");
        $style.type = 'text/css';
        $style.innerHTML = css;
        document.head.appendChild($style);
      });
    }
  });
};

_.addProjectData = function (callback) {
  callback = callback || function () {};
  var src = _.getRelativeTopicPath() + "template/scripts/projectdata.js";
  _.loadScript(src, null, callback);
};

_.addGoToLayout = function () {
  _.addProjectData();
  _.showTopicHeader();
  _.addLayoutHTML();
  _.addLayoutCSS();
};

_.showTopicHeader = function () {
  var headerNode = document.getElementById('rh-topic-header'),
      headerShadowNode = document.getElementById('rh-topic-header-shadow');
  _.each([headerNode, headerShadowNode], function (node) {
    if (node) {
      $.removeClass(node, 'rh-hide');
    }
  });
};

model.publish(consts('KEY_SHARED_INPUT'), [consts('KEY_PROJECT_TAG_COMBINATIONS'), consts('KEY_TAG_EXPRESSION'), consts('KEY_TOPIC_IN_IFRAME'), {
  key: consts('EVT_SCROLL_TO_TOP'),
  nested: false
}, consts('EVT_PRINT_TOPIC'), consts('KEY_MERGED_PROJECT_MAP'), consts('KEY_PROJECT_LIST'), consts('KEY_SHOW_TAGS'), consts('KEY_IFRAME_EVENTS'), consts('EVT_RELOAD_TOPIC'), consts('KEY_MOBILE_APP_MODE'), consts('KEY_HEADER_LOGO_PATH'), consts('KEY_HEADER_TITLE'), consts('KEY_HEADER_TITLE_COLOR'), consts('KEY_HEADER_BACKGROUND_COLOR'), consts('KEY_LAYOUT_FONT_FAMILY'), consts('KEY_HEADER_HTML'), consts('KEY_HEADER_CSS'), consts('KEY_HEADER_DEFAULT_BACKGROUND_COLOR'), consts('KEY_HEADER_DEFAULT_TITLE_COLOR'), consts('KEY_LAYOUT_DEFAULT_FONT_FAMILY'), consts('KEY_TOC_ORDER'), consts('KEY_LNG_NAME'), consts('EVT_COLLAPSE_ALL'), consts('EVT_EXPAND_ALL'), consts('KEY_SEARCH_HIGHLIGHT_COLOR'), consts('KEY_SEARCH_BG_COLOR'), consts('KEY_SHOW_SCROLL_TO_TOP'), consts('KEY_DO_NOT_PRESERVE_AR'), consts('EVT_REMOVE_HIGHLIGHT'), consts('KEY_SUBSTR_SEARCH'), consts('KEY_SHOW_CONTEXT')]);

model.publish(consts('KEY_SHARED_OUTPUT'), [consts('KEY_TOPIC_URL'), consts('KEY_TOPIC_ID'), consts('KEY_TOPIC_TITLE'), consts('KEY_TOPIC_BRSMAP'), consts('SHOW_MODAL'), consts('EVT_NAVIGATE_TO_URL'), consts('EVT_CLICK_INSIDE_IFRAME'), consts('EVT_SCROLL_INSIDE_IFRAME'), consts('EVT_INSIDE_IFRAME_DOM_CONTENTLOADED'), consts('KEY_TOPIC_HEIGHT'), consts('KEY_TOPIC_CONTENT_SIZE'), consts('GO_TO_DEFAULT_TOPIC'), consts('EVT_TOPIC_WIDGET_LOADED')]);

rh.iframe.init();

EventHandlers = function () {
  var lastScrollTop = void 0,
      publishScrollInfo = void 0;

  var EventHandlers = function () {
    function EventHandlers() {
      _classCallCheck(this, EventHandlers);
    }

    _createClass(EventHandlers, [{
      key: "handle_click",
      value: function handle_click(event) {
        if (!event.defaultPrevented) {
          model.publish(consts('EVT_CLICK_INSIDE_IFRAME'), null);
          return _.hookClick(event);
        }
      }
    }, {
      key: "handle_scroll",
      value: function handle_scroll() {
        var curScrollTop = void 0,
            dir = void 0;
        curScrollTop = document.body.scrollTop;
        if (curScrollTop > lastScrollTop) {
          dir = 'down';
        } else {
          dir = 'up';
        }
        lastScrollTop = curScrollTop;
        return publishScrollInfo(dir);
      }
    }]);

    return EventHandlers;
  }();

  lastScrollTop = -1;

  publishScrollInfo = _.throttle(function (dir) {
    var body = void 0,
        info = void 0;
    body = document.body;
    info = {
      scrollTop: body.scrollTop,
      scrollHeight: body.scrollHeight,
      dir: dir
    };
    return model.publish(consts('EVT_SCROLL_INSIDE_IFRAME'), info);
  }, 200);

  return EventHandlers;
}();

eHandlers = new EventHandlers();

registeredEvents = {};

model.subscribe(consts('EVT_WIDGET_LOADED'), _.one(function () {
  model.subscribe(consts('KEY_IFRAME_EVENTS'), function (obj) {
    if (obj === null) {
      obj = {};
    }
    return _.each(['click', 'scroll'], function (eName) {
      if (obj[eName]) {
        _.addEventListener(document, eName, eHandlers["handle_" + eName]);
        registeredEvents[eName] = true;
      } else if (registeredEvents[eName]) {
        _.removeEventListener(document, eName, eHandlers["handle_" + eName]);
        registeredEvents[eName] = false;
      }
    });
  });
  return _.delay(function () {
    var height = $.pageHeight();
    var width = $.pageWidth();
    model.publish(consts('KEY_TOPIC_HEIGHT'), height);
    model.publish(consts('KEY_TOPIC_CONTENT_SIZE'), { height: height, width: width });
  }, 100);
}));

model.subscribeOnce([rh.consts('KEY_TOC_ORDER'), rh.consts('EVT_PROJECT_LOADED')], function () {
  var orderData = rh.model.get(rh.consts('KEY_TOC_ORDER'));
  var url = rh._.parentPath(rh._.filePath().substring(rh._.getHostFolder().length));
  url = url.length && url[url.length - 1] === '/' ? url.substring(0, url.length - 1) : url;
  while (orderData[url] === undefined) {
    url = url.substring(0, url.lastIndexOf('/'));
  }
  var order = url && orderData[url].order;
  rh.model.publish(rh.consts('KEY_TOC_CHILD_ORDER'), order);
});

model.subscribe(consts('EVT_RELOAD_TOPIC'), function () {
  return document.location.reload();
});

model.subscribeOnce([consts('EVT_WINDOW_LOADED'), consts('KEY_TAG_EXPRESSION'), consts('KEY_TOPIC_ORIGIN')], function () {
  return _.defer(function () {
    var bookmark = decodeURIComponent(document.location.hash);
    if (bookmark !== undefined && bookmark !== "" && bookmark !== "#") {
      var bookmark_name = escape(bookmark.substring(1));
      var $elements = rh.query("#" + bookmark_name + ",a[name=" + bookmark_name + "]");
      if ($elements.length > 0) {
        $elements[0].scrollIntoView(true);
      }
    }
  });
});

model.subscribe(consts('KEY_TOPIC_HEIGHT'), function () {
  _.delay(function () {
    model.publish(consts('EVT_WINDOW_LOADED'), null);
  }, 1000);
});

model.subscribe([consts('KEY_TOPIC_IN_IFRAME'), consts('KEY_TOPIC_ORIGIN'), consts('KEY_TAG_EXPRESSION')], function () {
  _.defer(function () {
    var tagExprs = model.get(consts('KEY_TAG_EXPRESSION'));
    var origin = model.get(consts('KEY_TOPIC_ORIGIN'));
    var cTagNode = $.find(document.head, 'meta[name="condition-tags"]')[0];
    var nodes = $.find(document, '[data-rhtags]');
    var showDefaultText = true;
    _.any(nodes, function (node) {
      var tagIndex = Number.parseInt($.getAttribute(node, 'data-rhtags'));
      if (!Number.isNaN(tagIndex) && _.evalTagExpression([tagIndex], tagExprs, origin)) {
        showDefaultText = false;
        return true;
      }
    });

    if (cTagNode) {
      var tagIndex = Number.parseInt($.getAttribute(cTagNode, 'data-rhtags'));
      if (!Number.isNaN(tagIndex)) {
        _.showDefaultText(!_.evalTagExpression([tagIndex], tagExprs, origin) && showDefaultText);
      }
    }
  });
});

_.addEventListener(document, 'DOMContentLoaded', function () {
  return model.publish(consts('EVT_INSIDE_IFRAME_DOM_CONTENTLOADED'), null);
});

_.addEventListener(window, 'resize', function () {
  var triggeredByMe = void 0;
  triggeredByMe = false;
  return _.debounce(function () {
    var height = void 0;
    if (triggeredByMe) {
      triggeredByMe = false;
      return triggeredByMe;
    } else {
      height = $.pageHeight();
      if (height !== model.get(consts('KEY_TOPIC_HEIGHT'))) {
        triggeredByMe = true;
        return model.publish(consts('KEY_TOPIC_HEIGHT'), $.pageHeight());
      }
    }
  }, 250);
}());

},{"../../lib/rh":9,"../../responsive_help/utils/node_utils":20}],14:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var rh = require("../../../lib/rh"),
    $ = rh.$,
    _ = rh._;

var DropdownText = function (_rh$Widget) {
  _inherits(DropdownText, _rh$Widget);

  function DropdownText(config) {
    _classCallCheck(this, DropdownText);

    var _this = _possibleConstructorReturn(this, (DropdownText.__proto__ || Object.getPrototypeOf(DropdownText)).call(this, config));

    _this.contentClass = 'dropdown-content';
    _this.titleClass = 'dropdown-title';
    _this.initNodes();
    return _this;
  }

  _createClass(DropdownText, [{
    key: 'initNodes',
    value: function initNodes() {
      var _this2 = this;

      var contentNodes = [];
      $.eachChildNode(this.node, function (child) {
        if ($.hasClass(child, _this2.contentClass)) {
          contentNodes.push(child);
        }
      });
      var nodeHolder = new rh.NodeHolder(contentNodes);
      nodeHolder.hide();
      $.eachChildNode(this.node, function (child) {
        if ($.hasClass(child, _this2.titleClass)) {
          _.addEventListener(child, 'click', function (evt) {
            if (!evt.defaultPrevented) {
              _this2.toggleState(nodeHolder);
              return _.preventDefault(evt);
            }
          });
        }
      });

      rh.model.csubscribe('EVT_COLLAPSE_ALL', function () {
        _this2.hide(nodeHolder);
      });

      rh.model.csubscribe('EVT_EXPAND_ALL', function () {
        _this2.show(nodeHolder);
      });
    }
  }, {
    key: 'hide',
    value: function hide(nodeHolder) {
      $.removeClass(this.node, 'expanded');
      nodeHolder.hide();
    }
  }, {
    key: 'show',
    value: function show(nodeHolder) {
      if (!$.hasClass(this.node, 'expanded')) {
        $.addClass(this.node, 'expanded');
      }
      nodeHolder.show();
    }
  }, {
    key: 'toggleState',
    value: function toggleState(nodeHolder) {
      if ($.hasClass(this.node, 'expanded')) {
        this.hide(nodeHolder);
      } else {
        this.show(nodeHolder);
      }
    }
  }]);

  return DropdownText;
}(rh.Widget);

exports.default = DropdownText;


rh.widgets.DropdownText = DropdownText;

},{"../../../lib/rh":9}],15:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _rh = require('../../../lib/rh');

var _rh2 = _interopRequireDefault(_rh);

var _dropdown_text = require('./dropdown_text');

var _dropdown_text2 = _interopRequireDefault(_dropdown_text);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ExpandingText = function (_DropdownText) {
  _inherits(ExpandingText, _DropdownText);

  function ExpandingText() {
    _classCallCheck(this, ExpandingText);

    return _possibleConstructorReturn(this, (ExpandingText.__proto__ || Object.getPrototypeOf(ExpandingText)).apply(this, arguments));
  }

  _createClass(ExpandingText, [{
    key: 'initNodes',
    value: function initNodes() {
      this.contentClass = 'expanding-content';
      this.titleClass = 'expanding-title';
      _get(ExpandingText.prototype.__proto__ || Object.getPrototypeOf(ExpandingText.prototype), 'initNodes', this).call(this);
    }
  }]);

  return ExpandingText;
}(_dropdown_text2.default);

_rh2.default.widgets.ExpandingText = ExpandingText;

},{"../../../lib/rh":9,"./dropdown_text":14}],16:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var rh = require("../../../lib/rh"),
    nodeUtils = require("../../utils/node_utils"),
    $ = rh.$,
    _ = rh._,
    instanceCount = 0;

var HyperlinkPopover = function (_rh$Widget) {
  _inherits(HyperlinkPopover, _rh$Widget);

  function HyperlinkPopover(config) {
    _classCallCheck(this, HyperlinkPopover);

    var _this = _possibleConstructorReturn(this, (HyperlinkPopover.__proto__ || Object.getPrototypeOf(HyperlinkPopover)).call(this, config));

    instanceCount = instanceCount + 1;
    _.addEventListener(_this.node, 'click', function (evt) {
      _this.showPopover(evt);
      return _.preventDefault(evt);
    });

    rh.model.subscribe(rh.consts('KEY_TOPIC_CONTENT_SIZE'), function (size) {
      if (_this.popupNode) {
        if (_this.node.getAttribute('data-width') && _this.node.getAttribute('data-height')) {
          $.dataset(_this.popupNode, 'height', $.dataset(_this.node, 'height'));
          $.dataset(_this.popupNode, 'width', $.dataset(_this.node, 'width'));
        } else {
          var _this$reSize = _this.reSize(_this.popupNode, parseInt(size.height), parseInt(size.width)),
              _height = _this$reSize._height,
              _width = _this$reSize._width;

          $.addStyle(_this.popupNode, 'width', _width + "px");
          $.addStyle(_this.popupNode, 'maxWidth ', _width + "px");
          $.addStyle(_this.popupNode, 'height', _height + "px");
          $.addStyle(_this.popupNode, 'maxHeight', _height + "px");
          $.addStyle(_this.popupNode, 'margin', "10px");

          $.dataset(_this.popupNode, 'height', _height);
          $.dataset(_this.popupNode, 'width', _width);
        }
        if (!_.isExternalUrl(_this.hyperlink)) {
          $.addStyle(_this.popupNode, 'visibility', 'visible');
        }
      }
    });
    return _this;
  }

  _createClass(HyperlinkPopover, [{
    key: "reSize",
    value: function reSize(node, height, width) {
      var area = void 0;
      var result = { _height: height, _width: width };
      area = height * width;
      result._width = Math.max(parseInt(node.style.width), Math.sqrt(4 * area / 3));
      result._height = area / result._width;

      return result;
    }
  }, {
    key: "createPopupNode",
    value: function createPopupNode() {
      this.popupNode = $.createElement('div');
      $.addClass(this.popupNode, 'rh-popover');
      $.dataset(this.popupNode, 'height', $.dataset(this.node, 'height'));
      $.dataset(this.popupNode, 'width', $.dataset(this.node, 'width'));
      $.dataset(this.popupNode, 'placement', $.dataset(this.node, 'placement'));
      this.popupNode.innerHTML = "<div class=\"rh-popover-content\">\n      <iframe class=\"popover-topic\" id=\"" + this.iframeID + "\" src=\"" + this.hyperlink + "\" frameborder=\"0\" scrolling=\"auto\"\n      onload=\"rh._.resetIframeSize('#" + this.iframeID + "')\" ></iframe>\n    </div>";
      if (!_.isExternalUrl(this.hyperlink)) {
        $.addStyle(this.popupNode, 'visibility', 'hidden');
      }
    }
  }, {
    key: "showPopover",
    value: function showPopover(evt) {
      this.createPopupNode();
      nodeUtils.appendChild(document.body, this.popupNode);
      this.popoverWidget = new rh.widgets.Popover({ node: this.popupNode });
      this.popoverWidget.init();
      this.popoverWidget.initPosition(this.node, evt);
    }
  }, {
    key: "hyperlink",
    get: function get() {
      return $.getAttribute(this.node, 'href');
    }
  }, {
    key: "iframeID",
    get: function get() {
      return "RhPopoverIframe" + instanceCount;
    }
  }]);

  return HyperlinkPopover;
}(rh.Widget);

exports.default = HyperlinkPopover;


rh.widgets.HyperlinkPopover = HyperlinkPopover;

},{"../../../lib/rh":9,"../../utils/node_utils":20}],17:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var rh = require("../../../lib/rh"),
    nodeUtils = require("../../utils/node_utils"),
    pageUtil = require("../../utils/page_utils"),
    _ = rh._,
    $ = rh.$;

var Popover = function (_rh$Widget) {
  _inherits(Popover, _rh$Widget);

  function Popover(config) {
    _classCallCheck(this, Popover);

    var _this = _possibleConstructorReturn(this, (Popover.__proto__ || Object.getPrototypeOf(Popover)).call(this, config));

    _this.placement = $.dataset(_this.node, 'placement');
    _this.height = _.parseInt($.dataset(_this.node, 'height'), 300);
    _this.width = _.parseInt($.dataset(_this.node, 'width'), 400);
    _this.doNotResize = config && config.doNotResize;

    _.delay(function () {
      _this.handleClick = function (evt) {
        return _this._handleClick(evt);
      };
      _.addEventListener(document, 'click', _this.handleClick);
    }, 250);
    return _this;
  }

  _createClass(Popover, [{
    key: "destruct",
    value: function destruct() {
      _.removeEventListener(document, 'click', this.handleClick);
      _get(Popover.prototype.__proto__ || Object.getPrototypeOf(Popover.prototype), "destruct", this).call(this);
      nodeUtils.removeChild(this.node);
    }
  }, {
    key: "eventToRect",
    value: function eventToRect(evt) {
      if (!evt) {
        return;
      }
      var clientX = evt.clientX + _.getScroll()[0],
          clientY = evt.clientY + _.getScroll()[1];
      if (clientX && clientY) {
        return {
          x: clientX,
          y: clientY,
          top: clientY,
          bottom: clientY,
          left: clientX,
          right: clientX
        };
      }
    }
  }, {
    key: "initPosition",
    value: function initPosition(target, evt) {
      var rect = this.eventToRect(evt) || target && target.getClientRects()[0];
      if (rect) {
        this.setPosition(rect);
        if (this.doNotResize) {
          return;
        }

        if (this.height) {
          this.node.style.height = _.min([this.height, pageUtil.innerHeight()]) + "px";
        }
        if (this.width) {
          this.node.style.width = _.min([this.width, pageUtil.innerWidth()]) + "px";
        }
      }
    }
  }, {
    key: "setPosition",
    value: function setPosition(rect) {
      var pageHeight = pageUtil.pageMaxHeight(),
          pageWidth = pageUtil.pageMaxWidth();
      if (this.placement === 'top') {
        this.showTop(rect, pageHeight);
        this.setAutoHorizontalPosition(rect, pageWidth);
      } else if (this.placement === 'bottom') {
        this.showBottom(rect);
        this.setAutoHorizontalPosition(rect, pageWidth);
      } else if (this.placement === 'left') {
        this.setAutoVerticalPosition(rect, pageHeight);
        this.showLeft(rect, pageWidth);
      } else if (this.placement === 'right') {
        this.setAutoVerticalPosition(rect, pageHeight);
        this.showRight(rect);
      } else {
        this.setAutoHorizontalPosition(rect, pageWidth);
        this.setAutoVerticalPosition(rect, pageHeight);
      }
      this.node.style.position = 'absolute';
    }
  }, {
    key: "canShowTop",
    value: function canShowTop(rect) {
      return rect.top - pageUtil.nodeHeight(this.node) > 0;
    }
  }, {
    key: "canShowBottom",
    value: function canShowBottom(rect, pageHeight) {
      return pageHeight - rect.bottom - pageUtil.nodeHeight(this.node) > 0;
    }
  }, {
    key: "canShowLeft",
    value: function canShowLeft(rect) {
      return rect.left - pageUtil.nodeWidth(this.node) > 0;
    }
  }, {
    key: "canShowRight",
    value: function canShowRight(rect, pageWidth) {
      return pageWidth - rect.right - pageUtil.nodeWidth(this.node) > 0;
    }
  }, {
    key: "showTop",
    value: function showTop(rect) {
      this.node.style.top = _.max([rect.top - pageUtil.nodeHeight(this.node) - 2, 0]) + "px";
    }
  }, {
    key: "showBottom",
    value: function showBottom(rect) {
      this.node.style.top = rect.bottom + "px";
    }
  }, {
    key: "showRight",
    value: function showRight(rect) {
      this.node.style.left = rect.right + 2 + "px";
    }
  }, {
    key: "showLeft",
    value: function showLeft(rect) {
      this.node.style.left = _.max([rect.right - pageUtil.nodeWidth(this.node) - 2, 0]) + "px";
    }
  }, {
    key: "setAutoHorizontalPosition",
    value: function setAutoHorizontalPosition(rect, pageWidth) {
      if (this.canShowRight(rect, pageWidth)) {
        this.showRight(rect);
      } else if (this.canShowLeft(rect)) {
        this.showLeft(rect, pageWidth);
      } else {
        this.node.style.left = rect.left + "px";
      }
    }
  }, {
    key: "setAutoVerticalPosition",
    value: function setAutoVerticalPosition(rect, pageHeight) {
      if (this.canShowBottom(rect, pageHeight)) {
        this.showBottom(rect);
      } else if (this.canShowTop(rect)) {
        this.showTop(rect, pageHeight);
      } else {
        this.node.style.top = rect.top + "px";
      }
    }
  }, {
    key: "_handleClick",
    value: function _handleClick(evt) {
      this.destruct();
      return _.preventDefault(evt);
    }
  }]);

  return Popover;
}(rh.Widget);

exports.default = Popover;


rh.widgets.Popover = Popover;

},{"../../../lib/rh":9,"../../utils/node_utils":20,"../../utils/page_utils":21}],18:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var rh = require("../../../lib/rh"),
    nodeUtils = require("../../utils/node_utils"),
    $ = rh.$,
    _ = rh._,
    instanceCount = 0;

var TextPopOver = function (_rh$Widget) {
  _inherits(TextPopOver, _rh$Widget);

  function TextPopOver(config) {
    _classCallCheck(this, TextPopOver);

    var _this = _possibleConstructorReturn(this, (TextPopOver.__proto__ || Object.getPrototypeOf(TextPopOver)).call(this, config));

    instanceCount = instanceCount + 1;
    _.addEventListener(_this.node, 'click', function (evt) {
      _this.showPopover(evt);
      return _.preventDefault(evt);
    });
    return _this;
  }

  _createClass(TextPopOver, [{
    key: "createPopupNode",
    value: function createPopupNode() {
      var node = $.createElement('div');
      $.addClass(node, 'rh-popover');
      $.dataset(node, 'height', $.dataset(this.node, 'height'));
      $.dataset(node, 'width', $.dataset(this.node, 'width'));
      $.dataset(node, 'placement', $.dataset(this.node, 'placement'));

      node.innerHTML = "<div class=\"rh-popover-content\">\n      <p class=\"popover-text\" id=\"" + this.contentID + "\">" + this.text + "</p>\n    </div>";
      return node;
    }
  }, {
    key: "showPopover",
    value: function showPopover(evt) {
      var node = this.createPopupNode();
      nodeUtils.appendChild(document.body, node);
      this.popoverWidget = new rh.widgets.Popover({ node: node, doNotResize: true });
      this.popoverWidget.init();
      this.popoverWidget.initPosition(this.node, evt);
    }
  }, {
    key: "text",
    get: function get() {
      return $.dataset(this.node, 'popovertext');
    }
  }, {
    key: "contentID",
    get: function get() {
      return "Rh-textPopOver" + instanceCount;
    }
  }]);

  return TextPopOver;
}(rh.Widget);

exports.default = TextPopOver;


rh.widgets.TextPopOver = TextPopOver;

/*<a data-rhwidget="TextPopOver" data-popovertext="this is definition" href="#"> term </a> */

},{"../../../lib/rh":9,"../../utils/node_utils":20}],19:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var rh = require("../../../lib/rh"),
    $ = rh.$,
    _ = rh._;

var Trigger = function (_rh$Widget) {
  _inherits(Trigger, _rh$Widget);

  function Trigger(config) {
    _classCallCheck(this, Trigger);

    var _this = _possibleConstructorReturn(this, (Trigger.__proto__ || Object.getPrototypeOf(Trigger)).call(this, config));

    _this.initTargets();
    _this.updateTriggerLabels();
    return _this;
  }

  _createClass(Trigger, [{
    key: 'initExpanded',
    value: function initExpanded(nodeHolder) {
      var isExpanded = $.getAttribute(this.node, 'data-expanded');
      if (isExpanded === 'true') {
        this.show(nodeHolder);
      } else {
        this.hide(nodeHolder);
      }
    }
  }, {
    key: 'updateTriggerLabels',
    value: function updateTriggerLabels() {
      var pressed = $.hasClass(this.node, 'pressed');
      var openText = $.find(this.node, 'span[data-open-text]')[0];
      var closeText = $.find(this.node, 'span[data-close-text]')[0];
      this.showTriggerLabel(openText, pressed);
      this.showTriggerLabel(closeText, !pressed);
    }
  }, {
    key: 'showTriggerLabel',
    value: function showTriggerLabel(text, show) {
      if (text) {
        var textHolder = new rh.NodeHolder([text]);
        return show ? textHolder.show() : textHolder.hide();
      }
    }
  }, {
    key: 'getTargetNodes',
    value: function getTargetNodes() {
      var targetNames = _.splitAndTrim($.dataset(this.node, 'target'), ' ');
      var targetNodes = [];
      _.each(targetNames, function (targetName) {
        var nodes = $.find(document, '[data-targetname="' + targetName + '"]');
        _.each(nodes, function (node) {
          targetNodes.push(node);
        });
      });
      return targetNodes;
    }
  }, {
    key: 'initTargets',
    value: function initTargets() {
      var _this2 = this;

      var targetNodes = this.getTargetNodes();
      _.each(targetNodes, function (node) {
        if (!$.dataset(node, 'targetset')) {
          $.dataset(node, 'targetset', true);
        }
      });
      var nodeHolder = new rh.NodeHolder(targetNodes);
      nodeHolder.hide();
      _.addEventListener(this.node, 'click', function (evt) {
        if (!evt.defaultPrevented) {
          _this2.toggleState(nodeHolder);
          return _.preventDefault(evt);
        }
      });
      _.addEventListener(this.node, 'open', function (evt) {
        if (!evt.defaultPrevented) {
          if (!$.hasClass(_this2.node, 'pressed')) {
            _this2.show(nodeHolder);
          }
          return _.preventDefault(evt);
        }
      });
      rh.model.csubscribe('EVT_COLLAPSE_ALL', function () {
        _this2.hide(nodeHolder);
      });

      rh.model.csubscribe('EVT_EXPAND_ALL', function () {
        _this2.show(nodeHolder);
      });
      this.initExpanded(nodeHolder);
    }
  }, {
    key: 'hide',
    value: function hide(nodeHolder) {
      $.removeClass(this.node, 'pressed');
      nodeHolder.hide();
      nodeHolder.updateClass([]);
      this.updateTriggerLabels();
    }
  }, {
    key: 'show',
    value: function show(nodeHolder) {
      if (!$.hasClass(this.node, 'pressed')) {
        $.addClass(this.node, 'pressed');
      }
      nodeHolder.show();
      nodeHolder.updateClass(['show']);
      this.updateTriggerLabels();
    }
  }, {
    key: 'toggleState',
    value: function toggleState(nodeHolder) {
      if ($.hasClass(this.node, 'pressed')) {
        this.hide(nodeHolder);
      } else {
        this.show(nodeHolder);
      }
      this.updateTriggerLabels();
    }
  }]);

  return Trigger;
}(rh.Widget);

exports.default = Trigger;


rh.widgets.Trigger = Trigger;
rh.widgets.DropSpot = Trigger;
rh.widgets.ExpandSpot = Trigger;

},{"../../../lib/rh":9}],20:[function(require,module,exports){
'use strict';

var rh = require("../../lib/rh");
var $ = rh.$;
module.exports = {

  nodeType: {
    ELEMENT_NODE: 1,
    ATTRIBUTE_NODE: 2,
    TEXT_NODE: 3,
    CDATA_SECTION_NODE: 4,
    ENTITY_REFERENCE_NODE: 5,
    ENTITY_NODE: 6,
    PROCESSING_INSTRUCTION_NODE: 7,
    COMMENT_NODE: 8,
    DOCUMENT_NODE: 9,
    DOCUMENT_TYPE_NODE: 10,
    DOCUMENT_FRAGMENT_NODE: 11,
    NOTATION_NODE: 12
  },

  removeChild: function removeChild(node) {
    var parent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.parentNode(node);

    return parent && parent.removeChild && parent.removeChild(node);
  },
  appendChild: function appendChild(parent, newNode) {
    return parent && parent.appendChild && parent.appendChild(newNode);
  },
  parentNode: function parentNode(node) {
    return node && node.parentNode;
  },
  childNodes: function childNodes(node) {
    return node && node.childNodes || [];
  },
  toHtmlNode: function toHtmlNode(html) {
    return this.childNodes($.createElement('div', html));
  },
  outerHTML: function outerHTML(node) {
    return node && node.outerHTML || '';
  },
  insertAfter: function insertAfter(node, newNode) {
    return node.parentNode.insertBefore(newNode, node.nextSibling);
  },
  value: function value(node) {
    return node && node.nodeValue;
  },
  name: function name(node) {
    return node && node.nodeName;
  },
  type: function type(node) {
    return node && node.nodeType;
  },
  isElementNode: function isElementNode(node) {
    return this.type(node) === this.nodeType.ELEMENT_NODE;
  },
  isTextNode: function isTextNode(node) {
    return this.type(node) === this.nodeType.TEXT_NODE;
  }
};

},{"../../lib/rh":9}],21:[function(require,module,exports){
(function (global){
'use strict';

var rh = require("../../lib/rh"),
    _ = rh._;

module.exports = {
  innerWidth: function innerWidth() {
    var innerWidth = global.innerWidth;
    if (!_.isDefined(innerWidth)) {
      var clientWidth = _.get(document, 'documentElement.clientWidth');
      clientWidth = _.isDefined(clientWidth) ? clientWidth : _.get(document, 'body.clientWidth');
      if (_.isDefined(clientWidth)) {
        innerWidth = clientWidth;
      }
    }
    return innerWidth;
  },
  innerHeight: function innerHeight() {
    var innerHeight = global.innerHeight;
    if (!_.isDefined(innerHeight)) {
      var clientHeight = _.get(document, 'documentElement.clientHeight');
      clientHeight = _.isDefined(clientHeight) ? clientHeight : _.get(document, 'body.clientHeight');
      if (_.isDefined(clientHeight)) {
        innerHeight = clientHeight;
      }
    }
    return innerHeight;
  },
  nodeWidth: function nodeWidth(node) {
    var width = node.getBoundingClientRect && node.getBoundingClientRect().width;
    return width || node.clientWidth || 0;
  },
  nodeHeight: function nodeHeight(node) {
    var height = node.getBoundingClientRect && node.getBoundingClientRect().height;
    return height || node.clientHeight || 0;
  },
  pageMaxHeight: function pageMaxHeight() {
    if (document.documentElement && window.innerHeight) {
      return _.max([document.documentElement.offsetHeight, window.innerHeight]);
    } else if (document.documentElement) {
      return document.documentElement.offsetHeight;
    } else {
      return window.innerHeight;
    }
  },
  pageMaxWidth: function pageMaxWidth() {
    if (document.documentElement && window.innerWidth) {
      return _.max([document.documentElement.offsetWidth, window.innerWidth]);
    } else if (document.documentElement) {
      return document.documentElement.offsetWidth;
    } else {
      return window.innerWidth;
    }
  }
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../lib/rh":9}]},{},[11])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJsZW5pZW50X3NyYy9yb2JvaGVscC90b3BpYy9waG9uZWdhcC5qcyIsImxlbmllbnRfc3JjL3JvYm9oZWxwL3RvcGljL3RvcGljX2V2ZW50cy5qcyIsImxlbmllbnRfc3JjL3JvYm9oZWxwL3RvcGljL3VybF91dGlscy5qcyIsIm5vZGVfbW9kdWxlcy9qcy1wb2x5ZmlsbHMvZXM1LmpzIiwibm9kZV9tb2R1bGVzL2pzLXBvbHlmaWxscy9lczYuanMiLCJzcmMvZnJhbWV3b3Jrcy9zaGltLmpzIiwic3JjL2ZyYW1ld29ya3Mvc2hpbS9hcnJheS5qcyIsInNyYy9mcmFtZXdvcmtzL3NoaW0vb2JqZWN0LmpzIiwic3JjL2xpYi9yaC5qcyIsInNyYy9yZXNwb25zaXZlX2hlbHAvbGF5b3V0L21vZGFsX2RpYWxvZy5qcyIsInNyYy9yZXNwb25zaXZlX2hlbHAvdG9waWMuanMiLCJzcmMvcmVzcG9uc2l2ZV9oZWxwL3RvcGljL2hpZ2hsaWdodC5qcyIsInNyYy9yZXNwb25zaXZlX2hlbHAvdG9waWMvaW5pdC5qcyIsInNyYy9yZXNwb25zaXZlX2hlbHAvdG9waWMvd2lkZ2V0cy9kcm9wZG93bl90ZXh0LmpzIiwic3JjL3Jlc3BvbnNpdmVfaGVscC90b3BpYy93aWRnZXRzL2V4cGFuZGluZ190ZXh0LmpzIiwic3JjL3Jlc3BvbnNpdmVfaGVscC90b3BpYy93aWRnZXRzL2h5cGVybGlua19wb3BvdmVyLmpzIiwic3JjL3Jlc3BvbnNpdmVfaGVscC90b3BpYy93aWRnZXRzL3BvcG92ZXIuanMiLCJzcmMvcmVzcG9uc2l2ZV9oZWxwL3RvcGljL3dpZGdldHMvdGV4dF9wb3BvdmVyLmpzIiwic3JjL3Jlc3BvbnNpdmVfaGVscC90b3BpYy93aWRnZXRzL3RyaWdnZXIuanMiLCJzcmMvcmVzcG9uc2l2ZV9oZWxwL3V0aWxzL25vZGVfdXRpbHMuanMiLCJzcmMvcmVzcG9uc2l2ZV9oZWxwL3V0aWxzL3Bh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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2ZUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDaHNIQSxRQUFRLGNBQVI7QUFDQSxRQUFRLGVBQVI7Ozs7O0FDREE7QUFDQSxJQUFJLENBQUMsTUFBTSxTQUFOLENBQWdCLFFBQXJCLEVBQStCO0FBQzdCLFNBQU8s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SyxxQkFBTCxHQUE2QixNQUF4RTtBQUNBLFdBQU8sVUFBVSxLQUFLLFlBQWYsSUFBK0IsQ0FBdEM7QUFDRCxHQS9CYztBQWdDZixlQWhDZSwyQkFnQ0M7QUFDZCxRQUFJLFNBQVMsZUFBVCxJQUE0QixPQUFPLFdBQXZDLEVBQW9EO0FBQ2xELGFBQU8sRUFBRSxHQUFGLENBQU0sQ0FBQyxTQUFTLGVBQVQsQ0FBeUIsWUFBMUIsRUFBd0MsT0FBTyxXQUEvQyxDQUFOLENBQVA7QUFDRCxLQUZELE1BR0ssSUFBSSxTQUFTLGVBQWIsRUFBOEI7QUFDakMsYUFBTyxTQUFTLGVBQVQsQ0FBeUIsWUFBaEM7QUFDRCxLQUZJLE1BR0E7QUFDSCxhQUFPLE9BQU8sV0FBZDtBQUNEO0FBQ0YsR0ExQ2M7QUEyQ2YsY0EzQ2UsMEJBMkNBO0FBQ2IsUUFBSSxTQUFTLGVBQVQsSUFBNEIsT0FBTyxVQUF2QyxFQUFtRDtBQUNqRCxhQUFPLEVBQUUsR0FBRixDQUFNLENBQUMsU0FBUyxlQUFULENBQXlCLFdBQTFCLEVBQXVDLE9BQU8sVUFBOUMsQ0FBTixDQUFQO0FBQ0QsS0FGRCxNQUdLLElBQUksU0FBUyxlQUFiLEVBQThCO0FBQ2pDLGFBQU8sU0FBUyxlQUFULENBQXlCLFdBQWhDO0FBQ0QsS0FGSSxNQUdBO0FBQ0gsYUFBTyxPQUFPLFVBQWQ7QUFDRDtBQUNGO0FBckRjLENBQWpCIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKXtmdW5jdGlvbiByKGUsbix0KXtmdW5jdGlvbiBvKGksZil7aWYoIW5baV0pe2lmKCFlW2ldKXt2YXIgYz1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlO2lmKCFmJiZjKXJldHVybiBjKGksITApO2lmKHUpcmV0dXJuIHUoaSwhMCk7dmFyIGE9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitpK1wiJ1wiKTt0aHJvdyBhLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsYX12YXIgcD1uW2ldPXtleHBvcnRzOnt9fTtlW2ldWzBdLmNhbGwocC5leHBvcnRzLGZ1bmN0aW9uKHIpe3ZhciBuPWVbaV1bMV1bcl07cmV0dXJuIG8obnx8cil9LHAscC5leHBvcnRzLHIsZSxuLHQpfXJldHVybiBuW2ldLmV4cG9ydHN9Zm9yKHZhciB1PVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmUsaT0wO2k8dC5sZW5ndGg7aSsrKW8odFtpXSk7cmV0dXJuIG99cmV0dXJuIHJ9KSgpIiwibGV0IHsgcmggfSA9IHdpbmRvdztcclxubGV0IHsgbW9kZWwgfSA9IHJoO1xyXG5sZXQgeyBjb25zdHMgfSA9IHJoO1xyXG5sZXQgeyBfIH0gPSByaDtcclxuXHJcbmNsYXNzIFBob25lR2FwIHtcclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICh0aGlzLmFkZEpzVG9Ub3BpY3MpKCk7XHJcbiAgfVxyXG5cclxuICBhZGRKc1RvVG9waWNzKCkge1xyXG4gICAgcmV0dXJuIG1vZGVsLnN1YnNjcmliZU9uY2UoY29uc3RzKCdLRVlfTU9CSUxFX0FQUF9NT0RFJyksIGZ1bmN0aW9uKHZhbCkge1xyXG4gICAgICBpZiAodmFsKSB7XHJcbiAgICAgICAgcmV0dXJuIG1vZGVsLnN1YnNjcmliZShjb25zdHMoJ0VWVF9XSURHRVRfTE9BREVEJyksICgpID0+XHJcbiAgICAgICAgICBfLmxvYWRTY3JpcHQoY29uc3RzKCdDT1JET1ZBX0pTX1VSTCcpLCBmYWxzZSwgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIGlmIChyaC5kZWJ1ZykgeyByZXR1cm4gcmguX2QoJ2luZm8nLCAnbG9hZGVkIENvcmRvdmEuanMnKTsgfVxyXG4gICAgICAgICAgfSlcclxuICAgICAgICApO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcbn1cclxuXHJcblxyXG5uZXcgUGhvbmVHYXA7XHJcbiIsImxldCB7IHJoIH0gPSB3aW5kb3c7XHJcbmxldCB7IGNvbnN0cyB9ID0gcmg7XHJcblxyXG5yaC5tb2RlbC5zdWJzY3JpYmUoY29uc3RzKCdFVlRfU0NST0xMX1RPX1RPUCcpLCBkdW1teSA9PiB3aW5kb3cuc2Nyb2xsVG8oMCwgMCkpO1xyXG5cclxucmgubW9kZWwuc3Vic2NyaWJlKGNvbnN0cygnRVZUX1BSSU5UX1RPUElDJyksIGZ1bmN0aW9uKCkge1xyXG4gICh3aW5kb3cuZm9jdXMpKCk7XHJcbiAgcmV0dXJuICh3aW5kb3cucHJpbnQpKCk7XHJcbn0pO1xyXG4iLCJsZXQgeyByaCB9ID0gd2luZG93O1xyXG5sZXQgeyBfIH0gPSByaDtcclxubGV0IHsgY29uc3RzIH0gPSByaDtcclxuXHJcbl8uZ2V0Um9vdFVybCA9IChmdW5jdGlvbigpIHtcclxuICBsZXQgcm9vdFVybCA9IG51bGw7XHJcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xyXG4gICAgaWYgKHJvb3RVcmwgPT0gbnVsbCkge1xyXG4gICAgICBsZXQgcm9vdEluZm8gPSB3aW5kb3cuZ1NjcmVlblJlbFBhdGhNYXBbd2luZG93LmdGaW5hbENvbW1vblJvb3RSZWxQYXRoXTtcclxuICAgICAgcm9vdFVybCA9IGAke18uZ2V0SG9zdEZvbGRlcigpfSR7Xy5maXhSZWxhdGl2ZVVybChyb290SW5mbyAhPSBudWxsID8gcm9vdEluZm8uZGVmYXVsdFVSTCA6IHVuZGVmaW5lZCl9YDtcclxuICAgIH1cclxuICAgIHJldHVybiByb290VXJsO1xyXG4gIH07XHJcbn0pKCk7XHJcblxyXG5fLnJlZGlyZWN0VG9MYXlvdXQgPSBmdW5jdGlvbigpIHtcclxuICBsZXQgaG9zdEZvbGRlciA9IF8uZ2V0SG9zdEZvbGRlcigpO1xyXG4gIGxldCBxdWVyeSA9ICcnO1xyXG4gIGxldCByZWxVcmwgPSB3aW5kb3cuX2dldFJlbGF0aXZlRmlsZU5hbWUoaG9zdEZvbGRlcixcclxuICAgIGRlY29kZVVSSShkb2N1bWVudC5sb2NhdGlvbi5ocmVmKSk7XHJcbiAgbGV0IHJlZiA9IGRvY3VtZW50LnJlZmVycmVyO1xyXG4gIGlmIChyZWYgJiYgIV8uaXNFeHRlcm5hbFVybChyZWYpKSB7XHJcbiAgICBsZXQgcXVlcnlNYXAgPSBfLnVybFBhcmFtcyhfLmV4dHJhY3RQYXJhbVN0cmluZyhyZWYpKTtcclxuICAgIGlmICghXy5pc0VtcHR5T2JqZWN0KHF1ZXJ5TWFwKSkgeyBxdWVyeSA9IGA/JHtfLm1hcFRvRW5jb2RlZFN0cmluZyhxdWVyeU1hcCl9YDsgfVxyXG4gIH1cclxuXHJcbiAgbGV0IGhhc2hNYXAgPSBfLnVybFBhcmFtcyhfLmV4dHJhY3RQYXJhbVN0cmluZyhyZWxVcmwpKTtcclxuICBoYXNoTWFwW2NvbnN0cygnSEFTSF9LRVlfVE9QSUMnKV0gPSBfLnN0cmlwUGFyYW0ocmVsVXJsKTtcclxuICBoYXNoTWFwW2NvbnN0cygnSEFTSF9LRVlfVUlNT0RFJyldID0gbnVsbDtcclxuICBsZXQgaGFzaCA9IGAjJHtfLm1hcFRvRW5jb2RlZFN0cmluZyhoYXNoTWFwKX1gO1xyXG4gIHJldHVybiBkb2N1bWVudC5sb2NhdGlvbi5yZXBsYWNlKGAke18uZ2V0Um9vdFVybCgpfSR7cXVlcnl9JHtoYXNofWApO1xyXG59O1xyXG5cclxuXHJcbl8uZ29Ub0Z1bGxMYXlvdXQgPSBmdW5jdGlvbigpIHtcclxuICBsZXQgaG9zdEZvbGRlciA9IF8uZ2V0SG9zdEZvbGRlcigpO1xyXG4gIGxldCBxdWVyeSA9ICcnO1xyXG4gIGxldCByZWxVcmwgPSB3aW5kb3cuX2dldFJlbGF0aXZlRmlsZU5hbWUoaG9zdEZvbGRlcixcclxuICAgIGRlY29kZVVSSShkb2N1bWVudC5sb2NhdGlvbi5ocmVmKSk7XHJcbiAgbGV0IHJlZiA9IGRvY3VtZW50LnJlZmVycmVyO1xyXG4gIGlmIChyZWYgJiYgIV8uaXNFeHRlcm5hbFVybChyZWYpKSB7XHJcbiAgICBsZXQgcXVlcnlNYXAgPSBfLnVybFBhcmFtcyhfLmV4dHJhY3RQYXJhbVN0cmluZyhyZWYpKTtcclxuICAgIHF1ZXJ5TWFwW2NvbnN0cygnUkhNQVBJRCcpXSA9IG51bGw7XHJcbiAgICBxdWVyeU1hcFtjb25zdHMoJ1JITUFQTk8nKV0gPSBudWxsO1xyXG4gICAgaWYgKCFfLmlzRW1wdHlPYmplY3QocXVlcnlNYXApKSB7IHF1ZXJ5ID0gYD8ke18ubWFwVG9FbmNvZGVkU3RyaW5nKHF1ZXJ5TWFwKX1gOyB9XHJcbiAgfVxyXG5cclxuICBsZXQgdG9waWNQYWdlUGF0aCA9IGNvbnN0cygnU1RBUlRfRklMRVBBVEgnKTtcclxuICBpZih0b3BpY1BhZ2VQYXRoICYmICh0b3BpY1BhZ2VQYXRoICE9PSAnJykpIHtcclxuICAgIGxldCByb290VXJsID0gYCR7aG9zdEZvbGRlcn0ke18uZml4UmVsYXRpdmVVcmwodG9waWNQYWdlUGF0aCl9YDtcclxuICAgIGxldCBoYXNoTWFwID0gXy51cmxQYXJhbXMoXy5leHRyYWN0UGFyYW1TdHJpbmcocmVsVXJsKSk7XHJcbiAgICBoYXNoTWFwW2NvbnN0cygnSEFTSF9LRVlfVE9QSUMnKV0gPSBfLnN0cmlwUGFyYW0ocmVsVXJsKTtcclxuICAgIGhhc2hNYXBbY29uc3RzKCdIQVNIX0tFWV9VSU1PREUnKV0gPSBudWxsO1xyXG4gICAgbGV0IGhhc2ggPSBgIyR7Xy5tYXBUb0VuY29kZWRTdHJpbmcoaGFzaE1hcCl9YDtcclxuICAgIHJldHVybiBkb2N1bWVudC5sb2NhdGlvbi5yZXBsYWNlKGAke3Jvb3RVcmx9JHtxdWVyeX0ke2hhc2h9YCk7XHJcbiAgfVxyXG59O1xyXG5cclxuXy5nb1RvRGVmYXVsdFRvcGljID0gZnVuY3Rpb24gKCl7XHJcbiAgcmgubW9kZWwucHVibGlzaChjb25zdHMoJ0dPX1RPX0RFRkFVTFRfVE9QSUMnKSwgJycpO1xyXG4gIHJldHVybiBmYWxzZVxyXG59XHJcbiAiLCIvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuLy9cclxuLy8gRUNNQVNjcmlwdCA1IFBvbHlmaWxsc1xyXG4vL1xyXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4vLyBFUzUgMTUuMiBPYmplY3QgT2JqZWN0c1xyXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcbi8vXHJcbi8vIEVTNSAxNS4yLjMgUHJvcGVydGllcyBvZiB0aGUgT2JqZWN0IENvbnN0cnVjdG9yXHJcbi8vXHJcblxyXG4vLyBFUzUgMTUuMi4zLjIgT2JqZWN0LmdldFByb3RvdHlwZU9mICggTyApXHJcbi8vIEZyb20gaHR0cDovL2Vqb2huLm9yZy9ibG9nL29iamVjdGdldHByb3RvdHlwZW9mL1xyXG4vLyBOT1RFOiB3b24ndCB3b3JrIGZvciB0eXBpY2FsIGZ1bmN0aW9uIFQoKSB7fTsgVC5wcm90b3R5cGUgPSB7fTsgbmV3IFQ7IGNhc2VcclxuLy8gc2luY2UgdGhlIGNvbnN0cnVjdG9yIHByb3BlcnR5IGlzIGRlc3Ryb3llZC5cclxuaWYgKCFPYmplY3QuZ2V0UHJvdG90eXBlT2YpIHtcclxuICBPYmplY3QuZ2V0UHJvdG90eXBlT2YgPSBmdW5jdGlvbiAobykge1xyXG4gICAgaWYgKG8gIT09IE9iamVjdChvKSkgeyB0aHJvdyBUeXBlRXJyb3IoXCJPYmplY3QuZ2V0UHJvdG90eXBlT2YgY2FsbGVkIG9uIG5vbi1vYmplY3RcIik7IH1cclxuICAgIHJldHVybiBvLl9fcHJvdG9fXyB8fCBvLmNvbnN0cnVjdG9yLnByb3RvdHlwZSB8fCBPYmplY3QucHJvdG90eXBlO1xyXG4gIH07XHJcbn1cclxuXHJcbi8vICAgIC8vIEVTNSAxNS4yLjMuMyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yICggTywgUCApXHJcbi8vICAgIGlmICh0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciAhPT0gXCJmdW5jdGlvblwiKSB7XHJcbi8vICAgICAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gZnVuY3Rpb24gKG8sIG5hbWUpIHtcclxuLy8gICAgICAgICAgICBpZiAobyAhPT0gT2JqZWN0KG8pKSB7IHRocm93IFR5cGVFcnJvcigpOyB9XHJcbi8vICAgICAgICAgICAgaWYgKG8uaGFzT3duUHJvcGVydHkobmFtZSkpIHtcclxuLy8gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuLy8gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBvW25hbWVdLFxyXG4vLyAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuLy8gICAgICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4vLyAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbi8vICAgICAgICAgICAgICAgIH07XHJcbi8vICAgICAgICAgICAgfVxyXG4vLyAgICAgICAgfTtcclxuLy8gICAgfVxyXG5cclxuLy8gRVM1IDE1LjIuMy40IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzICggTyApXHJcbmlmICh0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgIT09IFwiZnVuY3Rpb25cIikge1xyXG4gIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzID0gZnVuY3Rpb24gKG8pIHtcclxuICAgIGlmIChvICE9PSBPYmplY3QobykpIHsgdGhyb3cgVHlwZUVycm9yKFwiT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgY2FsbGVkIG9uIG5vbi1vYmplY3RcIik7IH1cclxuICAgIHZhciBwcm9wcyA9IFtdLCBwO1xyXG4gICAgZm9yIChwIGluIG8pIHtcclxuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvLCBwKSkge1xyXG4gICAgICAgIHByb3BzLnB1c2gocCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBwcm9wcztcclxuICB9O1xyXG59XHJcblxyXG4vLyBFUzUgMTUuMi4zLjUgT2JqZWN0LmNyZWF0ZSAoIE8gWywgUHJvcGVydGllc10gKVxyXG5pZiAodHlwZW9mIE9iamVjdC5jcmVhdGUgIT09IFwiZnVuY3Rpb25cIikge1xyXG4gIE9iamVjdC5jcmVhdGUgPSBmdW5jdGlvbiAocHJvdG90eXBlLCBwcm9wZXJ0aWVzKSB7XHJcbiAgICBpZiAodHlwZW9mIHByb3RvdHlwZSAhPT0gXCJvYmplY3RcIikgeyB0aHJvdyBUeXBlRXJyb3IoKTsgfVxyXG4gICAgZnVuY3Rpb24gQ3RvcigpIHt9XHJcbiAgICBDdG9yLnByb3RvdHlwZSA9IHByb3RvdHlwZTtcclxuICAgIHZhciBvID0gbmV3IEN0b3IoKTtcclxuICAgIGlmIChwcm90b3R5cGUpIHsgby5jb25zdHJ1Y3RvciA9IEN0b3I7IH1cclxuICAgIGlmIChwcm9wZXJ0aWVzICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgaWYgKHByb3BlcnRpZXMgIT09IE9iamVjdChwcm9wZXJ0aWVzKSkgeyB0aHJvdyBUeXBlRXJyb3IoKTsgfVxyXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhvLCBwcm9wZXJ0aWVzKTtcclxuICAgIH1cclxuICAgIHJldHVybiBvO1xyXG4gIH07XHJcbn1cclxuXHJcbi8vIEVTIDE1LjIuMy42IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAoIE8sIFAsIEF0dHJpYnV0ZXMgKVxyXG4vLyBQYXJ0aWFsIHN1cHBvcnQgZm9yIG1vc3QgY29tbW9uIGNhc2UgLSBnZXR0ZXJzLCBzZXR0ZXJzLCBhbmQgdmFsdWVzXHJcbihmdW5jdGlvbigpIHtcclxuICBpZiAoIU9iamVjdC5kZWZpbmVQcm9wZXJ0eSB8fFxyXG4gICAgICAhKGZ1bmN0aW9uICgpIHsgdHJ5IHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAneCcsIHt9KTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH0gKCkpKSB7XHJcbiAgICB2YXIgb3JpZyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSA9IGZ1bmN0aW9uIChvLCBwcm9wLCBkZXNjKSB7XHJcbiAgICAgIC8vIEluIElFOCB0cnkgYnVpbHQtaW4gaW1wbGVtZW50YXRpb24gZm9yIGRlZmluaW5nIHByb3BlcnRpZXMgb24gRE9NIHByb3RvdHlwZXMuXHJcbiAgICAgIGlmIChvcmlnKSB7IHRyeSB7IHJldHVybiBvcmlnKG8sIHByb3AsIGRlc2MpOyB9IGNhdGNoIChlKSB7fSB9XHJcblxyXG4gICAgICBpZiAobyAhPT0gT2JqZWN0KG8pKSB7IHRocm93IFR5cGVFcnJvcihcIk9iamVjdC5kZWZpbmVQcm9wZXJ0eSBjYWxsZWQgb24gbm9uLW9iamVjdFwiKTsgfVxyXG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5fX2RlZmluZUdldHRlcl9fICYmICgnZ2V0JyBpbiBkZXNjKSkge1xyXG4gICAgICAgIE9iamVjdC5wcm90b3R5cGUuX19kZWZpbmVHZXR0ZXJfXy5jYWxsKG8sIHByb3AsIGRlc2MuZ2V0KTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5fX2RlZmluZVNldHRlcl9fICYmICgnc2V0JyBpbiBkZXNjKSkge1xyXG4gICAgICAgIE9iamVjdC5wcm90b3R5cGUuX19kZWZpbmVTZXR0ZXJfXy5jYWxsKG8sIHByb3AsIGRlc2Muc2V0KTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoJ3ZhbHVlJyBpbiBkZXNjKSB7XHJcbiAgICAgICAgb1twcm9wXSA9IGRlc2MudmFsdWU7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIG87XHJcbiAgICB9O1xyXG4gIH1cclxufSgpKTtcclxuXHJcbi8vIEVTIDE1LjIuMy43IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzICggTywgUHJvcGVydGllcyApXHJcbmlmICh0eXBlb2YgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMgIT09IFwiZnVuY3Rpb25cIikge1xyXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKG8sIHByb3BlcnRpZXMpIHtcclxuICAgIGlmIChvICE9PSBPYmplY3QobykpIHsgdGhyb3cgVHlwZUVycm9yKFwiT2JqZWN0LmRlZmluZVByb3BlcnRpZXMgY2FsbGVkIG9uIG5vbi1vYmplY3RcIik7IH1cclxuICAgIHZhciBuYW1lO1xyXG4gICAgZm9yIChuYW1lIGluIHByb3BlcnRpZXMpIHtcclxuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChwcm9wZXJ0aWVzLCBuYW1lKSkge1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBuYW1lLCBwcm9wZXJ0aWVzW25hbWVdKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG87XHJcbiAgfTtcclxufVxyXG5cclxuXHJcbi8vIEVTNSAxNS4yLjMuMTQgT2JqZWN0LmtleXMgKCBPIClcclxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2tleXNcclxuaWYgKCFPYmplY3Qua2V5cykge1xyXG4gIE9iamVjdC5rZXlzID0gZnVuY3Rpb24gKG8pIHtcclxuICAgIGlmIChvICE9PSBPYmplY3QobykpIHsgdGhyb3cgVHlwZUVycm9yKCdPYmplY3Qua2V5cyBjYWxsZWQgb24gbm9uLW9iamVjdCcpOyB9XHJcbiAgICB2YXIgcmV0ID0gW10sIHA7XHJcbiAgICBmb3IgKHAgaW4gbykge1xyXG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG8sIHApKSB7XHJcbiAgICAgICAgcmV0LnB1c2gocCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiByZXQ7XHJcbiAgfTtcclxufVxyXG5cclxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbi8vIEVTNSAxNS4zIEZ1bmN0aW9uIE9iamVjdHNcclxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG4vL1xyXG4vLyBFUzUgMTUuMy40IFByb3BlcnRpZXMgb2YgdGhlIEZ1bmN0aW9uIFByb3RvdHlwZSBPYmplY3RcclxuLy9cclxuXHJcbi8vIEVTNSAxNS4zLjQuNSBGdW5jdGlvbi5wcm90b3R5cGUuYmluZCAoIHRoaXNBcmcgWywgYXJnMSBbLCBhcmcyLCAuLi4gXV0gKVxyXG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9GdW5jdGlvbi9iaW5kXHJcbmlmICghRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQpIHtcclxuICBGdW5jdGlvbi5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uIChvKSB7XHJcbiAgICBpZiAodHlwZW9mIHRoaXMgIT09ICdmdW5jdGlvbicpIHsgdGhyb3cgVHlwZUVycm9yKFwiQmluZCBtdXN0IGJlIGNhbGxlZCBvbiBhIGZ1bmN0aW9uXCIpOyB9XHJcblxyXG4gICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpLFxyXG4gICAgICAgIHNlbGYgPSB0aGlzLFxyXG4gICAgICAgIG5vcCA9IGZ1bmN0aW9uKCkge30sXHJcbiAgICAgICAgYm91bmQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICByZXR1cm4gc2VsZi5hcHBseSh0aGlzIGluc3RhbmNlb2Ygbm9wID8gdGhpcyA6IG8sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpKSk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICBpZiAodGhpcy5wcm90b3R5cGUpXHJcbiAgICAgIG5vcC5wcm90b3R5cGUgPSB0aGlzLnByb3RvdHlwZTtcclxuICAgIGJvdW5kLnByb3RvdHlwZSA9IG5ldyBub3AoKTtcclxuICAgIHJldHVybiBib3VuZDtcclxuICB9O1xyXG59XHJcblxyXG5cclxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbi8vIEVTNSAxNS40IEFycmF5IE9iamVjdHNcclxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG4vL1xyXG4vLyBFUzUgMTUuNC4zIFByb3BlcnRpZXMgb2YgdGhlIEFycmF5IENvbnN0cnVjdG9yXHJcbi8vXHJcblxyXG5cclxuLy8gRVM1IDE1LjQuMy4yIEFycmF5LmlzQXJyYXkgKCBhcmcgKVxyXG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9pc0FycmF5XHJcbkFycmF5LmlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChvKSB7IHJldHVybiBCb29sZWFuKG8gJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKE9iamVjdChvKSkgPT09ICdbb2JqZWN0IEFycmF5XScpOyB9O1xyXG5cclxuXHJcbi8vXHJcbi8vIEVTNSAxNS40LjQgUHJvcGVydGllcyBvZiB0aGUgQXJyYXkgUHJvdG90eXBlIE9iamVjdFxyXG4vL1xyXG5cclxuLy8gRVM1IDE1LjQuNC4xNCBBcnJheS5wcm90b3R5cGUuaW5kZXhPZiAoIHNlYXJjaEVsZW1lbnQgWyAsIGZyb21JbmRleCBdIClcclxuLy8gRnJvbSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9pbmRleE9mXHJcbmlmICghQXJyYXkucHJvdG90eXBlLmluZGV4T2YpIHtcclxuICBBcnJheS5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIChzZWFyY2hFbGVtZW50IC8qLCBmcm9tSW5kZXggKi8pIHtcclxuICAgIGlmICh0aGlzID09PSB2b2lkIDAgfHwgdGhpcyA9PT0gbnVsbCkgeyB0aHJvdyBUeXBlRXJyb3IoKTsgfVxyXG5cclxuICAgIHZhciB0ID0gT2JqZWN0KHRoaXMpO1xyXG4gICAgdmFyIGxlbiA9IHQubGVuZ3RoID4+PiAwO1xyXG4gICAgaWYgKGxlbiA9PT0gMCkgeyByZXR1cm4gLTE7IH1cclxuXHJcbiAgICB2YXIgbiA9IDA7XHJcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDApIHtcclxuICAgICAgbiA9IE51bWJlcihhcmd1bWVudHNbMV0pO1xyXG4gICAgICBpZiAoaXNOYU4obikpIHtcclxuICAgICAgICBuID0gMDtcclxuICAgICAgfSBlbHNlIGlmIChuICE9PSAwICYmIG4gIT09ICgxIC8gMCkgJiYgbiAhPT0gLSgxIC8gMCkpIHtcclxuICAgICAgICBuID0gKG4gPiAwIHx8IC0xKSAqIE1hdGguZmxvb3IoTWF0aC5hYnMobikpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKG4gPj0gbGVuKSB7IHJldHVybiAtMTsgfVxyXG5cclxuICAgIHZhciBrID0gbiA+PSAwID8gbiA6IE1hdGgubWF4KGxlbiAtIE1hdGguYWJzKG4pLCAwKTtcclxuXHJcbiAgICBmb3IgKDsgayA8IGxlbjsgaysrKSB7XHJcbiAgICAgIGlmIChrIGluIHQgJiYgdFtrXSA9PT0gc2VhcmNoRWxlbWVudCkge1xyXG4gICAgICAgIHJldHVybiBrO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gLTE7XHJcbiAgfTtcclxufVxyXG5cclxuLy8gRVM1IDE1LjQuNC4xNSBBcnJheS5wcm90b3R5cGUubGFzdEluZGV4T2YgKCBzZWFyY2hFbGVtZW50IFsgLCBmcm9tSW5kZXggXSApXHJcbi8vIEZyb20gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvbGFzdEluZGV4T2ZcclxuaWYgKCFBcnJheS5wcm90b3R5cGUubGFzdEluZGV4T2YpIHtcclxuICBBcnJheS5wcm90b3R5cGUubGFzdEluZGV4T2YgPSBmdW5jdGlvbiAoc2VhcmNoRWxlbWVudCAvKiwgZnJvbUluZGV4Ki8pIHtcclxuICAgIGlmICh0aGlzID09PSB2b2lkIDAgfHwgdGhpcyA9PT0gbnVsbCkgeyB0aHJvdyBUeXBlRXJyb3IoKTsgfVxyXG5cclxuICAgIHZhciB0ID0gT2JqZWN0KHRoaXMpO1xyXG4gICAgdmFyIGxlbiA9IHQubGVuZ3RoID4+PiAwO1xyXG4gICAgaWYgKGxlbiA9PT0gMCkgeyByZXR1cm4gLTE7IH1cclxuXHJcbiAgICB2YXIgbiA9IGxlbjtcclxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xyXG4gICAgICBuID0gTnVtYmVyKGFyZ3VtZW50c1sxXSk7XHJcbiAgICAgIGlmIChuICE9PSBuKSB7XHJcbiAgICAgICAgbiA9IDA7XHJcbiAgICAgIH0gZWxzZSBpZiAobiAhPT0gMCAmJiBuICE9PSAoMSAvIDApICYmIG4gIT09IC0oMSAvIDApKSB7XHJcbiAgICAgICAgbiA9IChuID4gMCB8fCAtMSkgKiBNYXRoLmZsb29yKE1hdGguYWJzKG4pKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHZhciBrID0gbiA+PSAwID8gTWF0aC5taW4obiwgbGVuIC0gMSkgOiBsZW4gLSBNYXRoLmFicyhuKTtcclxuXHJcbiAgICBmb3IgKDsgayA+PSAwOyBrLS0pIHtcclxuICAgICAgaWYgKGsgaW4gdCAmJiB0W2tdID09PSBzZWFyY2hFbGVtZW50KSB7XHJcbiAgICAgICAgcmV0dXJuIGs7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiAtMTtcclxuICB9O1xyXG59XHJcblxyXG4vLyBFUzUgMTUuNC40LjE2IEFycmF5LnByb3RvdHlwZS5ldmVyeSAoIGNhbGxiYWNrZm4gWyAsIHRoaXNBcmcgXSApXHJcbi8vIEZyb20gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvZXZlcnlcclxuaWYgKCFBcnJheS5wcm90b3R5cGUuZXZlcnkpIHtcclxuICBBcnJheS5wcm90b3R5cGUuZXZlcnkgPSBmdW5jdGlvbiAoZnVuIC8qLCB0aGlzcCAqLykge1xyXG4gICAgaWYgKHRoaXMgPT09IHZvaWQgMCB8fCB0aGlzID09PSBudWxsKSB7IHRocm93IFR5cGVFcnJvcigpOyB9XHJcblxyXG4gICAgdmFyIHQgPSBPYmplY3QodGhpcyk7XHJcbiAgICB2YXIgbGVuID0gdC5sZW5ndGggPj4+IDA7XHJcbiAgICBpZiAodHlwZW9mIGZ1biAhPT0gXCJmdW5jdGlvblwiKSB7IHRocm93IFR5cGVFcnJvcigpOyB9XHJcblxyXG4gICAgdmFyIHRoaXNwID0gYXJndW1lbnRzWzFdLCBpO1xyXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgIGlmIChpIGluIHQgJiYgIWZ1bi5jYWxsKHRoaXNwLCB0W2ldLCBpLCB0KSkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH07XHJcbn1cclxuXHJcbi8vIEVTNSAxNS40LjQuMTcgQXJyYXkucHJvdG90eXBlLnNvbWUgKCBjYWxsYmFja2ZuIFsgLCB0aGlzQXJnIF0gKVxyXG4vLyBGcm9tIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L3NvbWVcclxuaWYgKCFBcnJheS5wcm90b3R5cGUuc29tZSkge1xyXG4gIEFycmF5LnByb3RvdHlwZS5zb21lID0gZnVuY3Rpb24gKGZ1biAvKiwgdGhpc3AgKi8pIHtcclxuICAgIGlmICh0aGlzID09PSB2b2lkIDAgfHwgdGhpcyA9PT0gbnVsbCkgeyB0aHJvdyBUeXBlRXJyb3IoKTsgfVxyXG5cclxuICAgIHZhciB0ID0gT2JqZWN0KHRoaXMpO1xyXG4gICAgdmFyIGxlbiA9IHQubGVuZ3RoID4+PiAwO1xyXG4gICAgaWYgKHR5cGVvZiBmdW4gIT09IFwiZnVuY3Rpb25cIikgeyB0aHJvdyBUeXBlRXJyb3IoKTsgfVxyXG5cclxuICAgIHZhciB0aGlzcCA9IGFyZ3VtZW50c1sxXSwgaTtcclxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICBpZiAoaSBpbiB0ICYmIGZ1bi5jYWxsKHRoaXNwLCB0W2ldLCBpLCB0KSkge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH07XHJcbn1cclxuXHJcbi8vIEVTNSAxNS40LjQuMTggQXJyYXkucHJvdG90eXBlLmZvckVhY2ggKCBjYWxsYmFja2ZuIFsgLCB0aGlzQXJnIF0gKVxyXG4vLyBGcm9tIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L2ZvckVhY2hcclxuaWYgKCFBcnJheS5wcm90b3R5cGUuZm9yRWFjaCkge1xyXG4gIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gKGZ1biAvKiwgdGhpc3AgKi8pIHtcclxuICAgIGlmICh0aGlzID09PSB2b2lkIDAgfHwgdGhpcyA9PT0gbnVsbCkgeyB0aHJvdyBUeXBlRXJyb3IoKTsgfVxyXG5cclxuICAgIHZhciB0ID0gT2JqZWN0KHRoaXMpO1xyXG4gICAgdmFyIGxlbiA9IHQubGVuZ3RoID4+PiAwO1xyXG4gICAgaWYgKHR5cGVvZiBmdW4gIT09IFwiZnVuY3Rpb25cIikgeyB0aHJvdyBUeXBlRXJyb3IoKTsgfVxyXG5cclxuICAgIHZhciB0aGlzcCA9IGFyZ3VtZW50c1sxXSwgaTtcclxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICBpZiAoaSBpbiB0KSB7XHJcbiAgICAgICAgZnVuLmNhbGwodGhpc3AsIHRbaV0sIGksIHQpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfTtcclxufVxyXG5cclxuXHJcbi8vIEVTNSAxNS40LjQuMTkgQXJyYXkucHJvdG90eXBlLm1hcCAoIGNhbGxiYWNrZm4gWyAsIHRoaXNBcmcgXSApXHJcbi8vIEZyb20gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvTWFwXHJcbmlmICghQXJyYXkucHJvdG90eXBlLm1hcCkge1xyXG4gIEFycmF5LnByb3RvdHlwZS5tYXAgPSBmdW5jdGlvbiAoZnVuIC8qLCB0aGlzcCAqLykge1xyXG4gICAgaWYgKHRoaXMgPT09IHZvaWQgMCB8fCB0aGlzID09PSBudWxsKSB7IHRocm93IFR5cGVFcnJvcigpOyB9XHJcblxyXG4gICAgdmFyIHQgPSBPYmplY3QodGhpcyk7XHJcbiAgICB2YXIgbGVuID0gdC5sZW5ndGggPj4+IDA7XHJcbiAgICBpZiAodHlwZW9mIGZ1biAhPT0gXCJmdW5jdGlvblwiKSB7IHRocm93IFR5cGVFcnJvcigpOyB9XHJcblxyXG4gICAgdmFyIHJlcyA9IFtdOyByZXMubGVuZ3RoID0gbGVuO1xyXG4gICAgdmFyIHRoaXNwID0gYXJndW1lbnRzWzFdLCBpO1xyXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgIGlmIChpIGluIHQpIHtcclxuICAgICAgICByZXNbaV0gPSBmdW4uY2FsbCh0aGlzcCwgdFtpXSwgaSwgdCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcmVzO1xyXG4gIH07XHJcbn1cclxuXHJcbi8vIEVTNSAxNS40LjQuMjAgQXJyYXkucHJvdG90eXBlLmZpbHRlciAoIGNhbGxiYWNrZm4gWyAsIHRoaXNBcmcgXSApXHJcbi8vIEZyb20gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvRmlsdGVyXHJcbmlmICghQXJyYXkucHJvdG90eXBlLmZpbHRlcikge1xyXG4gIEFycmF5LnByb3RvdHlwZS5maWx0ZXIgPSBmdW5jdGlvbiAoZnVuIC8qLCB0aGlzcCAqLykge1xyXG4gICAgaWYgKHRoaXMgPT09IHZvaWQgMCB8fCB0aGlzID09PSBudWxsKSB7IHRocm93IFR5cGVFcnJvcigpOyB9XHJcblxyXG4gICAgdmFyIHQgPSBPYmplY3QodGhpcyk7XHJcbiAgICB2YXIgbGVuID0gdC5sZW5ndGggPj4+IDA7XHJcbiAgICBpZiAodHlwZW9mIGZ1biAhPT0gXCJmdW5jdGlvblwiKSB7IHRocm93IFR5cGVFcnJvcigpOyB9XHJcblxyXG4gICAgdmFyIHJlcyA9IFtdO1xyXG4gICAgdmFyIHRoaXNwID0gYXJndW1lbnRzWzFdLCBpO1xyXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgIGlmIChpIGluIHQpIHtcclxuICAgICAgICB2YXIgdmFsID0gdFtpXTsgLy8gaW4gY2FzZSBmdW4gbXV0YXRlcyB0aGlzXHJcbiAgICAgICAgaWYgKGZ1bi5jYWxsKHRoaXNwLCB2YWwsIGksIHQpKSB7XHJcbiAgICAgICAgICByZXMucHVzaCh2YWwpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiByZXM7XHJcbiAgfTtcclxufVxyXG5cclxuXHJcbi8vIEVTNSAxNS40LjQuMjEgQXJyYXkucHJvdG90eXBlLnJlZHVjZSAoIGNhbGxiYWNrZm4gWyAsIGluaXRpYWxWYWx1ZSBdIClcclxuLy8gRnJvbSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9SZWR1Y2VcclxuaWYgKCFBcnJheS5wcm90b3R5cGUucmVkdWNlKSB7XHJcbiAgQXJyYXkucHJvdG90eXBlLnJlZHVjZSA9IGZ1bmN0aW9uIChmdW4gLyosIGluaXRpYWxWYWx1ZSAqLykge1xyXG4gICAgaWYgKHRoaXMgPT09IHZvaWQgMCB8fCB0aGlzID09PSBudWxsKSB7IHRocm93IFR5cGVFcnJvcigpOyB9XHJcblxyXG4gICAgdmFyIHQgPSBPYmplY3QodGhpcyk7XHJcbiAgICB2YXIgbGVuID0gdC5sZW5ndGggPj4+IDA7XHJcbiAgICBpZiAodHlwZW9mIGZ1biAhPT0gXCJmdW5jdGlvblwiKSB7IHRocm93IFR5cGVFcnJvcigpOyB9XHJcblxyXG4gICAgLy8gbm8gdmFsdWUgdG8gcmV0dXJuIGlmIG5vIGluaXRpYWwgdmFsdWUgYW5kIGFuIGVtcHR5IGFycmF5XHJcbiAgICBpZiAobGVuID09PSAwICYmIGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHsgdGhyb3cgVHlwZUVycm9yKCk7IH1cclxuXHJcbiAgICB2YXIgayA9IDA7XHJcbiAgICB2YXIgYWNjdW11bGF0b3I7XHJcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAyKSB7XHJcbiAgICAgIGFjY3VtdWxhdG9yID0gYXJndW1lbnRzWzFdO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgZG8ge1xyXG4gICAgICAgIGlmIChrIGluIHQpIHtcclxuICAgICAgICAgIGFjY3VtdWxhdG9yID0gdFtrKytdO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBpZiBhcnJheSBjb250YWlucyBubyB2YWx1ZXMsIG5vIGluaXRpYWwgdmFsdWUgdG8gcmV0dXJuXHJcbiAgICAgICAgaWYgKCsrayA+PSBsZW4pIHsgdGhyb3cgVHlwZUVycm9yKCk7IH1cclxuICAgICAgfVxyXG4gICAgICB3aGlsZSAodHJ1ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgd2hpbGUgKGsgPCBsZW4pIHtcclxuICAgICAgaWYgKGsgaW4gdCkge1xyXG4gICAgICAgIGFjY3VtdWxhdG9yID0gZnVuLmNhbGwodW5kZWZpbmVkLCBhY2N1bXVsYXRvciwgdFtrXSwgaywgdCk7XHJcbiAgICAgIH1cclxuICAgICAgaysrO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBhY2N1bXVsYXRvcjtcclxuICB9O1xyXG59XHJcblxyXG5cclxuLy8gRVM1IDE1LjQuNC4yMiBBcnJheS5wcm90b3R5cGUucmVkdWNlUmlnaHQgKCBjYWxsYmFja2ZuIFssIGluaXRpYWxWYWx1ZSBdIClcclxuLy8gRnJvbSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9SZWR1Y2VSaWdodFxyXG5pZiAoIUFycmF5LnByb3RvdHlwZS5yZWR1Y2VSaWdodCkge1xyXG4gIEFycmF5LnByb3RvdHlwZS5yZWR1Y2VSaWdodCA9IGZ1bmN0aW9uIChjYWxsYmFja2ZuIC8qLCBpbml0aWFsVmFsdWUgKi8pIHtcclxuICAgIGlmICh0aGlzID09PSB2b2lkIDAgfHwgdGhpcyA9PT0gbnVsbCkgeyB0aHJvdyBUeXBlRXJyb3IoKTsgfVxyXG5cclxuICAgIHZhciB0ID0gT2JqZWN0KHRoaXMpO1xyXG4gICAgdmFyIGxlbiA9IHQubGVuZ3RoID4+PiAwO1xyXG4gICAgaWYgKHR5cGVvZiBjYWxsYmFja2ZuICE9PSBcImZ1bmN0aW9uXCIpIHsgdGhyb3cgVHlwZUVycm9yKCk7IH1cclxuXHJcbiAgICAvLyBubyB2YWx1ZSB0byByZXR1cm4gaWYgbm8gaW5pdGlhbCB2YWx1ZSwgZW1wdHkgYXJyYXlcclxuICAgIGlmIChsZW4gPT09IDAgJiYgYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkgeyB0aHJvdyBUeXBlRXJyb3IoKTsgfVxyXG5cclxuICAgIHZhciBrID0gbGVuIC0gMTtcclxuICAgIHZhciBhY2N1bXVsYXRvcjtcclxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDIpIHtcclxuICAgICAgYWNjdW11bGF0b3IgPSBhcmd1bWVudHNbMV07XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBkbyB7XHJcbiAgICAgICAgaWYgKGsgaW4gdGhpcykge1xyXG4gICAgICAgICAgYWNjdW11bGF0b3IgPSB0aGlzW2stLV07XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGlmIGFycmF5IGNvbnRhaW5zIG5vIHZhbHVlcywgbm8gaW5pdGlhbCB2YWx1ZSB0byByZXR1cm5cclxuICAgICAgICBpZiAoLS1rIDwgMCkgeyB0aHJvdyBUeXBlRXJyb3IoKTsgfVxyXG4gICAgICB9XHJcbiAgICAgIHdoaWxlICh0cnVlKTtcclxuICAgIH1cclxuXHJcbiAgICB3aGlsZSAoayA+PSAwKSB7XHJcbiAgICAgIGlmIChrIGluIHQpIHtcclxuICAgICAgICBhY2N1bXVsYXRvciA9IGNhbGxiYWNrZm4uY2FsbCh1bmRlZmluZWQsIGFjY3VtdWxhdG9yLCB0W2tdLCBrLCB0KTtcclxuICAgICAgfVxyXG4gICAgICBrLS07XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xyXG4gIH07XHJcbn1cclxuXHJcblxyXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuLy8gRVM1IDE1LjUgU3RyaW5nIE9iamVjdHNcclxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG4vL1xyXG4vLyBFUzUgMTUuNS40IFByb3BlcnRpZXMgb2YgdGhlIFN0cmluZyBQcm90b3R5cGUgT2JqZWN0XHJcbi8vXHJcblxyXG5cclxuLy8gRVM1IDE1LjUuNC4yMCBTdHJpbmcucHJvdG90eXBlLnRyaW0oKVxyXG5pZiAoIVN0cmluZy5wcm90b3R5cGUudHJpbSkge1xyXG4gIFN0cmluZy5wcm90b3R5cGUudHJpbSA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiBTdHJpbmcodGhpcykucmVwbGFjZSgvXlxccysvLCAnJykucmVwbGFjZSgvXFxzKyQvLCAnJyk7XHJcbiAgfTtcclxufVxyXG5cclxuXHJcblxyXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuLy8gRVM1IDE1LjkgRGF0ZSBPYmplY3RzXHJcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cclxuXHJcbi8vXHJcbi8vIEVTIDE1LjkuNCBQcm9wZXJ0aWVzIG9mIHRoZSBEYXRlIENvbnN0cnVjdG9yXHJcbi8vXHJcblxyXG4vLyBFUzUgMTUuOS40LjQgRGF0ZS5ub3cgKCApXHJcbi8vIEZyb20gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vQ29yZV9KYXZhU2NyaXB0XzEuNV9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRGF0ZS9ub3dcclxuaWYgKCFEYXRlLm5vdykge1xyXG4gIERhdGUubm93ID0gZnVuY3Rpb24gbm93KCkge1xyXG4gICAgcmV0dXJuIE51bWJlcihuZXcgRGF0ZSgpKTtcclxuICB9O1xyXG59XHJcblxyXG5cclxuLy9cclxuLy8gRVM1IDE1LjkuNSBQcm9wZXJ0aWVzIG9mIHRoZSBEYXRlIFByb3RvdHlwZSBPYmplY3RcclxuLy9cclxuXHJcbi8vIEVTNSAxNS45LjQuNDMgRGF0ZS5wcm90b3R5cGUudG9JU09TdHJpbmcgKCApXHJcbi8vIEluc3BpcmVkIGJ5IGh0dHA6Ly93d3cuanNvbi5vcmcvanNvbjIuanNcclxuaWYgKCFEYXRlLnByb3RvdHlwZS50b0lTT1N0cmluZykge1xyXG4gIERhdGUucHJvdG90eXBlLnRvSVNPU3RyaW5nID0gZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gcGFkMihuKSB7IHJldHVybiAoJzAwJyArIG4pLnNsaWNlKC0yKTsgfVxyXG4gICAgZnVuY3Rpb24gcGFkMyhuKSB7IHJldHVybiAoJzAwMCcgKyBuKS5zbGljZSgtMyk7IH1cclxuXHJcbiAgICByZXR1cm4gdGhpcy5nZXRVVENGdWxsWWVhcigpICsgJy0nICtcclxuICAgICAgcGFkMih0aGlzLmdldFVUQ01vbnRoKCkgKyAxKSArICctJyArXHJcbiAgICAgIHBhZDIodGhpcy5nZXRVVENEYXRlKCkpICsgJ1QnICtcclxuICAgICAgcGFkMih0aGlzLmdldFVUQ0hvdXJzKCkpICsgJzonICtcclxuICAgICAgcGFkMih0aGlzLmdldFVUQ01pbnV0ZXMoKSkgKyAnOicgK1xyXG4gICAgICBwYWQyKHRoaXMuZ2V0VVRDU2Vjb25kcygpKSArICcuJyArXHJcbiAgICAgIHBhZDModGhpcy5nZXRVVENNaWxsaXNlY29uZHMoKSkgKyAnWic7XHJcbiAgfTtcclxufVxyXG4iLCIvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuLy9cclxuLy8gRUNNQVNjcmlwdCAyMDE1IFBvbHlmaWxsc1xyXG4vL1xyXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcbihmdW5jdGlvbiAoZ2xvYmFsKSB7XHJcbiAgXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4gIC8vIFNldCB0aGlzIHRvIGFsd2F5cyBvdmVycmlkZSBuYXRpdmUgaW1wbGVtZW50YXRpb25zLCBmb3IgdGVzdGluZ1xyXG4gIC8vIHRoZSBwb2x5ZmlsbCBpbiBicm93c2VycyB3aXRoIHBhcnRpYWwvZnVsbCBFUzIwMTUgc3VwcG9ydC5cclxuICB2YXIgT1ZFUlJJREVfTkFUSVZFX0ZPUl9URVNUSU5HID0gZmFsc2U7XHJcblxyXG4gIHZhciB1bmRlZmluZWQgPSAodm9pZCAwKTsgLy8gUGFyYW5vaWFcclxuXHJcbiAgLy8gSGVscGVyc1xyXG5cclxuICBmdW5jdGlvbiBzdHJpY3Qobykge1xyXG4gICAgcmV0dXJuIG8gPT09IGdsb2JhbCA/IHVuZGVmaW5lZCA6IG87XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBpc1N5bWJvbChzKSB7XHJcbiAgICByZXR1cm4gKHR5cGVvZiBzID09PSAnc3ltYm9sJykgfHwgKCdTeW1ib2wnIGluIGdsb2JhbCAmJiBzIGluc3RhbmNlb2YgZ2xvYmFsLlN5bWJvbCk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBnZXRQcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBuYW1lKSB7XHJcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBuYW1lKTtcclxuICAgIHZhciBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih0YXJnZXQpO1xyXG4gICAgd2hpbGUgKCFkZXNjICYmIHByb3RvKSB7XHJcbiAgICAgIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHByb3RvLCBuYW1lKTtcclxuICAgICAgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YocHJvdG8pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGRlc2M7XHJcbiAgfVxyXG5cclxuICB2YXIgZW5xdWV1ZSA9IChmdW5jdGlvbihuYXRpdmVQcm9taXNlLCBuYXRpdmVTZXRJbW1lZGlhdGUpIHtcclxuICAgIGlmIChuYXRpdmVQcm9taXNlKVxyXG4gICAgICByZXR1cm4gZnVuY3Rpb24oam9iKSB7IG5hdGl2ZVByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24oKSB7IGpvYigpOyB9KTsgfTtcclxuICAgIGlmIChuYXRpdmVTZXRJbW1lZGlhdGUpXHJcbiAgICAgIHJldHVybiBmdW5jdGlvbihqb2IpIHsgbmF0aXZlU2V0SW1tZWRpYXRlKGpvYik7IH07XHJcbiAgICByZXR1cm4gZnVuY3Rpb24oam9iKSB7IHNldFRpbWVvdXQoam9iLCAwKTsgfTtcclxuICB9KGdsb2JhbFsnUHJvbWlzZSddLCBnbG9iYWxbJ3NldEltbWVkaWF0ZSddKSk7XHJcblxyXG4gIGZ1bmN0aW9uIGRlZmluZShvLCBwLCB2LCBvdmVycmlkZSkge1xyXG4gICAgaWYgKHAgaW4gbyAmJiAhb3ZlcnJpZGUgJiYgIU9WRVJSSURFX05BVElWRV9GT1JfVEVTVElORylcclxuICAgICAgcmV0dXJuO1xyXG5cclxuICAgIGlmICh0eXBlb2YgdiA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAvLyBTYW5pdHkgY2hlY2sgdGhhdCBmdW5jdGlvbnMgYXJlIGFwcHJvcHJpYXRlbHkgbmFtZWQgKHdoZXJlIHBvc3NpYmxlKVxyXG4gICAgICAvL2NvbnNvbGUuYXNzZXJ0KGlzU3ltYm9sKHApIHx8ICEoJ25hbWUnIGluIHYpIHx8IHYubmFtZSA9PT0gcCB8fCB2Lm5hbWUgPT09IHAgKyAnXycsICdFeHBlY3RlZCBmdW5jdGlvbiBuYW1lIFwiJyArIHAudG9TdHJpbmcoKSArICdcIiwgd2FzIFwiJyArIHYubmFtZSArICdcIicpO1xyXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgcCwge1xyXG4gICAgICAgIHZhbHVlOiB2LFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxyXG4gICAgICB9KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBwLCB7XHJcbiAgICAgICAgdmFsdWU6IHYsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcclxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICB3cml0YWJsZTogZmFsc2VcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBzZXRfaW50ZXJuYWwobywgcCwgdikge1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIHAsIHtcclxuICAgICAgdmFsdWU6IHYsXHJcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXHJcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICB3cml0YWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvLyBTbmFwc2hvdCBpbnRyaW5zaWMgZnVuY3Rpb25zXHJcbiAgdmFyICRpc05hTiA9IGdsb2JhbC5pc05hTixcclxuICAgICAgJHBhcnNlSW50ID0gZ2xvYmFsLnBhcnNlSW50LFxyXG4gICAgICAkcGFyc2VGbG9hdCA9IGdsb2JhbC5wYXJzZUZsb2F0O1xyXG5cclxuICB2YXIgRSA9IE1hdGguRSxcclxuICAgICAgTE9HMTBFID0gTWF0aC5MT0cxMEUsXHJcbiAgICAgIExPRzJFID0gTWF0aC5MT0cyRSxcclxuICAgICAgYWJzID0gTWF0aC5hYnMsXHJcbiAgICAgIGNlaWwgPSBNYXRoLmNlaWwsXHJcbiAgICAgIGV4cCA9IE1hdGguZXhwLFxyXG4gICAgICBmbG9vciA9IE1hdGguZmxvb3IsXHJcbiAgICAgIGxvZyA9IE1hdGgubG9nLFxyXG4gICAgICBtYXggPSBNYXRoLm1heCxcclxuICAgICAgbWluID0gTWF0aC5taW4sXHJcbiAgICAgIHBvdyA9IE1hdGgucG93LFxyXG4gICAgICByYW5kb20gPSBNYXRoLnJhbmRvbSxcclxuICAgICAgc3FydCA9IE1hdGguc3FydDtcclxuXHJcbiAgdmFyIG9yaWdfbWF0Y2ggPSBTdHJpbmcucHJvdG90eXBlLm1hdGNoLFxyXG4gICAgICBvcmlnX3JlcGxhY2UgPSBTdHJpbmcucHJvdG90eXBlLnJlcGxhY2UsXHJcbiAgICAgIG9yaWdfc2VhcmNoID0gU3RyaW5nLnByb3RvdHlwZS5zZWFyY2gsXHJcbiAgICAgIG9yaWdfc3BsaXQgPSBTdHJpbmcucHJvdG90eXBlLnNwbGl0O1xyXG5cclxuICAvLyBUaGVzZSBhcmUgdXNlZCBmb3IgaW1wbGVtZW50aW5nIHRoZSBwb2x5ZmlsbHMsIGJ1dCBub3QgZXhwb3J0ZWQuXHJcblxyXG4gIC8vIEluc3BpcmVkIGJ5IGh0dHBzOi8vZ2lzdC5naXRodWIuY29tLzE2MzgwNTlcclxuICAvKiogQGNvbnN0cnVjdG9yICovXHJcbiAgZnVuY3Rpb24gRXBoZW1lcm9uVGFibGUoKSB7XHJcbiAgICB2YXIgc2VjcmV0S2V5ID0gT2JqZWN0Q3JlYXRlKG51bGwpO1xyXG5cclxuICAgIGZ1bmN0aW9uIGNvbmNlYWwobykge1xyXG4gICAgICB2YXIgb1ZhbHVlT2YgPSBvLnZhbHVlT2YsIHNlY3JldHMgPSBPYmplY3RDcmVhdGUobnVsbCk7XHJcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCAndmFsdWVPZicsIHtcclxuICAgICAgICAgIHZhbHVlOiAoZnVuY3Rpb24oc2VjcmV0S2V5KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoaykge1xyXG4gICAgICAgICAgICAgIHJldHVybiAoayA9PT0gc2VjcmV0S2V5KSA/IHNlY3JldHMgOiBvVmFsdWVPZi5hcHBseShvLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgfShzZWNyZXRLZXkpKSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgd3JpdGVhYmxlOiB0cnVlLFxyXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIHJldHVybiBzZWNyZXRzO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHJldmVhbChvKSB7XHJcbiAgICAgIHZhciB2ID0gdHlwZW9mIG8udmFsdWVPZiA9PT0gJ2Z1bmN0aW9uJyAmJiBvLnZhbHVlT2Yoc2VjcmV0S2V5KTtcclxuICAgICAgcmV0dXJuIHYgPT09IG8gPyBudWxsIDogdjtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBjbGVhcjogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgc2VjcmV0S2V5ID0gT2JqZWN0Q3JlYXRlKG51bGwpO1xyXG4gICAgICB9LFxyXG4gICAgICByZW1vdmU6IGZ1bmN0aW9uKGtleSkge1xyXG4gICAgICAgIHZhciBzZWNyZXRzID0gcmV2ZWFsKGtleSk7XHJcbiAgICAgICAgaWYgKHNlY3JldHMgJiYgSGFzT3duUHJvcGVydHkoc2VjcmV0cywgJ3ZhbHVlJykpIHtcclxuICAgICAgICAgIGRlbGV0ZSBzZWNyZXRzLnZhbHVlO1xyXG4gICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgfSxcclxuICAgICAgZ2V0OiBmdW5jdGlvbihrZXksIGRlZmF1bHRWYWx1ZSkge1xyXG4gICAgICAgIHZhciBzZWNyZXRzID0gcmV2ZWFsKGtleSk7XHJcbiAgICAgICAgcmV0dXJuIChzZWNyZXRzICYmIEhhc093blByb3BlcnR5KHNlY3JldHMsICd2YWx1ZScpKSA/IHNlY3JldHMudmFsdWUgOiBkZWZhdWx0VmFsdWU7XHJcbiAgICAgIH0sXHJcbiAgICAgIGhhczogZnVuY3Rpb24oa2V5KSB7XHJcbiAgICAgICAgdmFyIHNlY3JldHMgPSByZXZlYWwoa2V5KTtcclxuICAgICAgICByZXR1cm4gQm9vbGVhbihzZWNyZXRzICYmIEhhc093blByb3BlcnR5KHNlY3JldHMsICd2YWx1ZScpKTtcclxuICAgICAgfSxcclxuICAgICAgc2V0OiBmdW5jdGlvbihrZXksIHZhbHVlKSB7XHJcbiAgICAgICAgdmFyIHNlY3JldHMgPSByZXZlYWwoa2V5KSB8fCBjb25jZWFsKGtleSk7XHJcbiAgICAgICAgc2VjcmV0cy52YWx1ZSA9IHZhbHVlO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgdmFyIGVtcHR5ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuXHJcbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgLy9cclxuICAvLyBFQ01BU2NyaXB0IDIwMTVcclxuICAvLyBodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wL1xyXG4gIC8vXHJcbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gIC8vIDE5LjQgU3ltYm9sIE9iamVjdHNcclxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcbiAgLy8gTk9URTogU3ltYm9scyBhcmUgZGVmaW5lZCBoZXJlIC0gb3V0IG9mIHNwZWMgb3JkZXIgLSBzaW5jZSB3ZSBuZWVkIHRoZVxyXG4gIC8vIHByb3BlcnRpZXMgYW5kIHByb3RvdHlwZSB0byBiZSBwb3B1bGF0ZWQgZm9yIG90aGVyIHBvbHlmaWxscy5cclxuXHJcbiAgLy8gTk9URTogTm90IHNlY3VyZSwgbm9yIGlzIG9ialskJHN5bWJvbF0gaGlkZGVuIGZyb20gT2JqZWN0LmtleXMoKVxyXG5cclxuICB2YXIgc3ltYm9sRm9yS2V5O1xyXG4gIChmdW5jdGlvbigpIHtcclxuICAgIHZhciBzZWNyZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG4gICAgdmFyIHN5bWJvbE1hcCA9IHt9O1xyXG4gICAgc3ltYm9sRm9yS2V5ID0gZnVuY3Rpb24oaykge1xyXG4gICAgICByZXR1cm4gc3ltYm9sTWFwW2tdO1xyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgR2xvYmFsU3ltYm9sUmVnaXN0cnkgPSBbXTtcclxuXHJcbiAgICBmdW5jdGlvbiB1bmlxdWUoYml0cykge1xyXG4gICAgICByZXR1cm4gQXJyYXkoYml0cyArIDEpLmpvaW4oJ3gnKS5yZXBsYWNlKC94L2csIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiByYW5kb20oKSA8IDAuNSA/ICdcXHUyMDBDJyA6ICdcXHUyMDBEJzsgLy8gSldOSiAvIFpXSlxyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyAxOS40LjEgVGhlIFN5bWJvbCBDb25zdHJ1Y3RvclxyXG4gICAgLy8gMTkuNC4xLjEgU3ltYm9sICggZGVzY3JpcHRpb249dW5kZWZpbmVkIClcclxuICAgIGZ1bmN0aW9uIFN5bWJvbChkZXNjcmlwdGlvbikge1xyXG4gICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU3ltYm9sKSkgcmV0dXJuIG5ldyBTeW1ib2woZGVzY3JpcHRpb24sIHNlY3JldCk7XHJcbiAgICAgIGlmICh0aGlzIGluc3RhbmNlb2YgU3ltYm9sICYmIGFyZ3VtZW50c1sxXSAhPT0gc2VjcmV0KSB0aHJvdyBUeXBlRXJyb3IoKTtcclxuXHJcbiAgICAgIHZhciBkZXNjU3RyaW5nID0gZGVzY3JpcHRpb24gPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IFN0cmluZyhkZXNjcmlwdGlvbik7XHJcblxyXG4gICAgICBzZXRfaW50ZXJuYWwodGhpcywgJ1tbU3ltYm9sRGF0YV1dJywgdW5pcXVlKDEyOCkpO1xyXG4gICAgICBzZXRfaW50ZXJuYWwodGhpcywgJ1tbRGVzY3JpcHRpb25dXScsIGRlc2NTdHJpbmcpO1xyXG5cclxuICAgICAgc3ltYm9sTWFwW3RoaXNdID0gdGhpcztcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCEoJ1N5bWJvbCcgaW4gZ2xvYmFsKSB8fCBPVkVSUklERV9OQVRJVkVfRk9SX1RFU1RJTkcpXHJcbiAgICAgIGdsb2JhbC5TeW1ib2wgPSBTeW1ib2w7XHJcblxyXG4gICAgLy8gMTkuNC4yIFByb3BlcnRpZXMgb2YgdGhlIFN5bWJvbCBDb25zdHJ1Y3RvclxyXG5cclxuICAgIC8vIDE5LjQuMi4xIFN5bWJvbC5mb3IgKGtleSlcclxuICAgIGRlZmluZShTeW1ib2wsICdmb3InLCBmdW5jdGlvbiBmb3JfKGtleSkge1xyXG4gICAgICB2YXIgc3RyaW5nS2V5ID0gU3RyaW5nKGtleSk7XHJcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgR2xvYmFsU3ltYm9sUmVnaXN0cnkubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICB2YXIgZSA9IEdsb2JhbFN5bWJvbFJlZ2lzdHJ5W2ldO1xyXG4gICAgICAgIGlmIChTYW1lVmFsdWUoZVsnW1trZXldXSddLCBzdHJpbmdLZXkpKSByZXR1cm4gZVsnW1tzeW1ib2xdXSddO1xyXG4gICAgICB9XHJcbiAgICAgIHZhciBuZXdTeW1ib2wgPSBTeW1ib2woa2V5KTtcclxuICAgICAgR2xvYmFsU3ltYm9sUmVnaXN0cnkucHVzaCh7J1tba2V5XV0nOiBzdHJpbmdLZXksICdbW3N5bWJvbF1dJzogbmV3U3ltYm9sfSk7XHJcbiAgICAgIHJldHVybiBuZXdTeW1ib2w7XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyAxOS40LjIuMiBTeW1ib2wuaGFzSW5zdGFuY2VcclxuICAgIC8vIDE5LjQuMi4zIFN5bWJvbC5pc0NvbmNhdFNwcmVhZGFibGVcclxuXHJcbiAgICAvLyAxOS40LjIuNCBTeW1ib2wuaXRlcmF0b3JcclxuICAgIGRlZmluZShnbG9iYWwuU3ltYm9sLCAnaXRlcmF0b3InLCBnbG9iYWwuU3ltYm9sKCdTeW1ib2wuaXRlcmF0b3InKSk7XHJcblxyXG4gICAgLy8gMTkuNC4yLjUgU3ltYm9sLmtleUZvciAoc3ltKVxyXG4gICAgZGVmaW5lKFN5bWJvbCwgJ2tleUZvcicsIGZ1bmN0aW9uIGtleUZvcihzeW0pIHtcclxuICAgICAgaWYgKCEoc3ltIGluc3RhbmNlb2YgU3ltYm9sKSkgdGhyb3cgVHlwZUVycm9yKCk7XHJcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgR2xvYmFsU3ltYm9sUmVnaXN0cnkubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICB2YXIgZSA9IEdsb2JhbFN5bWJvbFJlZ2lzdHJ5W2ldO1xyXG4gICAgICAgIGlmIChTYW1lVmFsdWUoZVsnW1tzeW1ib2xdXSddLCBzeW0pKSByZXR1cm4gZVsnW1trZXldXSddO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyAxOS40LjIuNiBTeW1ib2wubWF0Y2hcclxuICAgIGRlZmluZShnbG9iYWwuU3ltYm9sLCAnbWF0Y2gnLCBnbG9iYWwuU3ltYm9sKCdTeW1ib2wubWF0Y2gnKSk7XHJcblxyXG4gICAgLy8gMTkuNC4yLjcgU3ltYm9sLnByb3RvdHlwZVxyXG5cclxuICAgIC8vIDE5LjQuMi44IFN5bWJvbC5yZXBsYWNlXHJcbiAgICBkZWZpbmUoZ2xvYmFsLlN5bWJvbCwgJ3JlcGxhY2UnLCBnbG9iYWwuU3ltYm9sKCdTeW1ib2wucmVwbGFjZScpKTtcclxuXHJcbiAgICAvLyAxOS40LjIuOSBTeW1ib2wuc2VhcmNoXHJcbiAgICBkZWZpbmUoZ2xvYmFsLlN5bWJvbCwgJ3NlYXJjaCcsIGdsb2JhbC5TeW1ib2woJ1N5bWJvbC5zZWFyY2gnKSk7XHJcblxyXG4gICAgLy8gMTkuNC4yLjEwIFN5bWJvbC5zcGVjaWVzXHJcblxyXG4gICAgLy8gMTkuNC4yLjExIFN5bWJvbC5zZWFyY2hcclxuICAgIGRlZmluZShnbG9iYWwuU3ltYm9sLCAnc3BsaXQnLCBnbG9iYWwuU3ltYm9sKCdTeW1ib2wuc3BsaXQnKSk7XHJcblxyXG4gICAgLy8gMTkuNC4yLjEyIFN5bWJvbC50b1ByaW1pdGl2ZVxyXG5cclxuICAgIC8vIDE5LjQuMi4xMyBTeW1ib2wudG9TdHJpbmdUYWdcclxuICAgIGRlZmluZShnbG9iYWwuU3ltYm9sLCAndG9TdHJpbmdUYWcnLCBnbG9iYWwuU3ltYm9sKCdTeW1ib2wudG9TdHJpbmdUYWcnKSk7XHJcblxyXG4gICAgLy8gMTkuNC4yLjE0IFN5bWJvbC51bnNjb3BhYmxlc1xyXG5cclxuICAgIC8vIDE5LjQuMyBQcm9wZXJ0aWVzIG9mIHRoZSBTeW1ib2wgUHJvdG90eXBlIE9iamVjdFxyXG4gICAgLy8gMTkuNC4zLjEgU3ltYm9sLnByb3RvdHlwZS5jb25zdHJ1Y3RvclxyXG5cclxuICAgIC8vIDE5LjQuMy4yIFN5bWJvbC5wcm90b3R5cGUudG9TdHJpbmcgKCApXHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU3ltYm9sLnByb3RvdHlwZSwgJ3RvU3RyaW5nJywge1xyXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XHJcbiAgICAgICAgdmFyIHMgPSBzdHJpY3QodGhpcyk7XHJcbiAgICAgICAgdmFyIGRlc2MgPSBzWydbW0Rlc2NyaXB0aW9uXV0nXTtcclxuICAgICAgICByZXR1cm4gJ1N5bWJvbCgnICsgKGRlc2MgPT09IHVuZGVmaW5lZCA/ICcnIDogZGVzYykgKyBzWydbW1N5bWJvbERhdGFdXSddICsgJyknO1xyXG4gICAgICB9LFxyXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsIHdyaXRlYWJsZTogdHJ1ZSwgZW51bWVyYWJsZTogZmFsc2UgfSk7XHJcblxyXG4gICAgLy8gMTkuNC4zLjMgU3ltYm9sLnByb3RvdHlwZS52YWx1ZU9mICggKVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFN5bWJvbC5wcm90b3R5cGUsICd2YWx1ZU9mJywge1xyXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWVPZigpIHtcclxuICAgICAgICAvLyBUbyBwcmV2ZW50IGF1dG9tYXRpYyBzdHJpbmcgY29udmVyc2lvbjpcclxuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoKTtcclxuXHJcbiAgICAgICAgLy8gU3BlYyBoYXMgYXBwcm94aW1hdGVseSB0aGUgZm9sbG93aW5nOlxyXG4gICAgICAgIC8vdmFyIHMgPSBzdHJpY3QodGhpcyk7XHJcbiAgICAgICAgLy9pZiAoVHlwZShzKSA9PT0gJ3N5bWJvbCcpIHJldHVybiBzO1xyXG4gICAgICAgIC8vaWYgKFR5cGUocykgIT09ICdvYmplY3QnKSB0aHJvdyBUeXBlRXJyb3IoKTtcclxuICAgICAgICAvL2lmICghKCdbW1N5bWJvbERhdGFdXScgaW4gcykpIHRocm93IFR5cGVFcnJvcigpO1xyXG4gICAgICAgIC8vcmV0dXJuIHNbJ1tbU3ltYm9sRGF0YV1dJ107XHJcbiAgICAgIH0sXHJcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGVhYmxlOiB0cnVlLCBlbnVtZXJhYmxlOiBmYWxzZSB9KTtcclxuXHJcbiAgICAvLyAxOS40LjMuNCBTeW1ib2wucHJvdG90eXBlIFsgQEB0b1N0cmluZ1RhZyBdXHJcbiAgICAvLyAoRG9uZSBsYXRlciB0byBwb2x5ZmlsbCBwYXJ0aWFsIGltcGxlbWVudGF0aW9ucylcclxuXHJcbiAgICAvLyAxOS40LjQgUHJvcGVydGllcyBvZiBTeW1ib2wgSW5zdGFuY2VzXHJcbiAgfSgpKTtcclxuXHJcbiAgY29uc29sZS5hc3NlcnQodHlwZW9mIGdsb2JhbC5TeW1ib2woKSA9PT0gJ3N5bWJvbCcgfHwgc3ltYm9sRm9yS2V5KFN0cmluZyhnbG9iYWwuU3ltYm9sKCd4JykpKSAhPT0gdW5kZWZpbmVkKTtcclxuXHJcbiAgLy8gRGVmaW5lZCBoZXJlIHNvIHRoYXQgb3RoZXIgcHJvdG90eXBlcyBjYW4gcmVmZXJlbmNlIGl0XHJcbiAgLy8gMjUuMS4yIFRoZSAlSXRlcmF0b3JQcm90b3R5cGUlIE9iamVjdFxyXG4gIHZhciAkSXRlcmF0b3JQcm90b3R5cGUkID0ge307XHJcblxyXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gIC8vIDYgRUNNQVNjcmlwdCBEYXRhIFR5cGVzIGFuZCBWYWx1ZXNcclxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcbiAgLy8gNi4xIEVDTUFTY3JpcHQgTGFuZ3VhZ2UgVHlwZXNcclxuXHJcbiAgLy8gXCJUeXBlKHgpXCIgaXMgdXNlZCBhcyBzaG9ydGhhbmQgZm9yIFwidGhlIHR5cGUgb2YgeFwiLi4uXHJcbiAgZnVuY3Rpb24gVHlwZSh2KSB7XHJcbiAgICBzd2l0Y2ggKHR5cGVvZiB2KSB7XHJcbiAgICBjYXNlICd1bmRlZmluZWQnOiByZXR1cm4gJ3VuZGVmaW5lZCc7XHJcbiAgICBjYXNlICdib29sZWFuJzogcmV0dXJuICdib29sZWFuJztcclxuICAgIGNhc2UgJ251bWJlcic6IHJldHVybiAnbnVtYmVyJztcclxuICAgIGNhc2UgJ3N0cmluZyc6IHJldHVybiAnc3RyaW5nJztcclxuICAgIGNhc2UgJ3N5bWJvbCc6IHJldHVybiAnc3ltYm9sJztcclxuICAgIGRlZmF1bHQ6XHJcbiAgICAgIGlmICh2ID09PSBudWxsKSByZXR1cm4gJ251bGwnO1xyXG4gICAgICBpZiAodiBpbnN0YW5jZW9mIGdsb2JhbC5TeW1ib2wpIHJldHVybiAnc3ltYm9sJztcclxuICAgICAgcmV0dXJuICdvYmplY3QnO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gNi4xLjUuMSBXZWxsLUtub3duIFN5bWJvbHNcclxuICB2YXIgJCRpdGVyYXRvciA9IGdsb2JhbC5TeW1ib2wuaXRlcmF0b3IsXHJcbiAgICAgICQkbWF0Y2ggPSBnbG9iYWwuU3ltYm9sLm1hdGNoLFxyXG4gICAgICAkJHJlcGxhY2UgPSBnbG9iYWwuU3ltYm9sLnJlcGxhY2UsXHJcbiAgICAgICQkc2VhcmNoID0gZ2xvYmFsLlN5bWJvbC5zZWFyY2gsXHJcbiAgICAgICQkc3BsaXQgPSBnbG9iYWwuU3ltYm9sLnNwbGl0LFxyXG4gICAgICAkJHRvU3RyaW5nVGFnID0gZ2xvYmFsLlN5bWJvbC50b1N0cmluZ1RhZztcclxuXHJcbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgLy8gNyBBYnN0cmFjdCBPcGVyYXRpb25zXHJcbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gIC8vIDcuMSBUeXBlIENvbnZlcnNpb25cclxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcbiAgLy8gNy4xLjEgVG9QcmltaXRpdmUgKCBpbnB1dCBbLCBQcmVmZXJyZWRUeXBlXSApXHJcbiAgLy8ganVzdCB1c2UgdmFsdWVPZigpXHJcblxyXG4gIC8vIDcuMS4yIFRvQm9vbGVhbiAoIGFyZ3VtZW50IClcclxuICAvLyBqdXN0IHVzZSBCb29sZWFuKClcclxuXHJcbiAgLy8gNy4xLjMgVG9OdW1iZXIgKCBhcmd1bWVudCApXHJcbiAgLy8ganVzdCB1c2UgTnVtYmVyKClcclxuXHJcbiAgLy8gNy4xLjQgVG9JbnRlZ2VyICggYXJndW1lbnQgKVxyXG4gIGZ1bmN0aW9uIFRvSW50ZWdlcihuKSB7XHJcbiAgICBuID0gTnVtYmVyKG4pO1xyXG4gICAgaWYgKCRpc05hTihuKSkgcmV0dXJuIDA7XHJcbiAgICBpZiAobiA9PT0gMCB8fCBuID09PSBJbmZpbml0eSB8fCBuID09PSAtSW5maW5pdHkpIHJldHVybiBuO1xyXG4gICAgcmV0dXJuICgobiA8IDApID8gLTEgOiAxKSAqIGZsb29yKGFicyhuKSk7XHJcbiAgfVxyXG5cclxuICAvLyA3LjEuNSBUb0ludDMyICggYXJndW1lbnQgKVxyXG4gIGZ1bmN0aW9uIFRvSW50MzIodikgeyByZXR1cm4gdiA+PiAwOyB9XHJcblxyXG4gIC8vIDcuMS42IFRvVWludDMyICggYXJndW1lbnQgKVxyXG4gIGZ1bmN0aW9uIFRvVWludDMyKHYpIHsgcmV0dXJuIHYgPj4+IDA7IH1cclxuXHJcbiAgLy8gNy4xLjcgVG9JbnQxNiAoIGFyZ3VtZW50IClcclxuICBmdW5jdGlvbiBUb0ludDE2KHYpIHsgcmV0dXJuICh2IDw8IDE2KSA+PiAxNjsgfVxyXG5cclxuICAvLyA3LjEuOCBUb1VpbnQxNiAoIGFyZ3VtZW50IClcclxuICBmdW5jdGlvbiBUb1VpbnQxNih2KSB7IHJldHVybiB2ICYgMHhGRkZGOyB9XHJcblxyXG4gIC8vIDcuMS45IFRvSW50OCAoIGFyZ3VtZW50IClcclxuICBmdW5jdGlvbiBUb0ludDgodikgeyByZXR1cm4gKHYgPDwgMjQpID4+IDI0OyB9XHJcblxyXG4gIC8vIDcuMS4xMCBUb1VpbnQ4ICggYXJndW1lbnQgKVxyXG4gIGZ1bmN0aW9uIFRvVWludDgodikgeyByZXR1cm4gdiAmIDB4RkY7IH1cclxuXHJcbiAgLy8gNy4xLjExIFRvVWludDhDbGFtcCAoIGFyZ3VtZW50IClcclxuICBmdW5jdGlvbiBUb1VpbnQ4Q2xhbXAoYXJndW1lbnQpIHtcclxuICAgIHZhciBudW1iZXIgPSBOdW1iZXIoYXJndW1lbnQpO1xyXG4gICAgaWYgKCRpc05hTihudW1iZXIpKSByZXR1cm4gMDtcclxuICAgIGlmIChudW1iZXIgPD0gMCkgcmV0dXJuIDA7XHJcbiAgICBpZiAobnVtYmVyID49IDI1NSkgcmV0dXJuIDI1NTtcclxuICAgIHZhciBmID0gZmxvb3IobnVtYmVyKTtcclxuICAgIGlmICgoZiArIDAuNSkgPCBudW1iZXIpIHJldHVybiBmICsgMTtcclxuICAgIGlmIChudW1iZXIgPCAoZiArIDAuNSkpIHJldHVybiBmO1xyXG4gICAgaWYgKGYgJSAyKSByZXR1cm4gZiArIDE7XHJcbiAgICByZXR1cm4gZjtcclxuICB9XHJcblxyXG4gIC8vIDcuMS4xMiBUb1N0cmluZyAoIGFyZ3VtZW50IClcclxuICAvLyBqdXN0IHVzZSBTdHJpbmcoKVxyXG5cclxuICAvLyA3LjEuMTMgVG9PYmplY3QgKCBhcmd1bWVudCApXHJcbiAgZnVuY3Rpb24gVG9PYmplY3Qodikge1xyXG4gICAgaWYgKHYgPT09IG51bGwgfHwgdiA9PT0gdW5kZWZpbmVkKSB0aHJvdyBUeXBlRXJyb3IoKTtcclxuICAgIHJldHVybiBPYmplY3Qodik7XHJcbiAgfVxyXG5cclxuICAvLyA3LjEuMTQgVG9Qcm9wZXJ0eUtleSAoIGFyZ3VtZW50IClcclxuICBmdW5jdGlvbiBUb1Byb3BlcnR5S2V5KHYpIHtcclxuICAgIHJldHVybiBTdHJpbmcodik7XHJcbiAgfVxyXG5cclxuICAvLyA3LjEuMTUgVG9MZW5ndGggKCBhcmd1bWVudCApXHJcbiAgZnVuY3Rpb24gVG9MZW5ndGgodikge1xyXG4gICAgdmFyIGxlbiA9IFRvSW50ZWdlcih2KTtcclxuICAgIGlmIChsZW4gPD0gMCkgcmV0dXJuIDA7XHJcbiAgICBpZiAobGVuID09PSBJbmZpbml0eSkgcmV0dXJuIDB4MjAwMDAwMDAwMDAwMDAgLSAxOyAvLyAyXjUzLTFcclxuICAgIHJldHVybiBtaW4obGVuLCAweDIwMDAwMDAwMDAwMDAwIC0gMSk7IC8vIDJeNTMtMVxyXG4gIH1cclxuXHJcbiAgLy8gNy4xLjE2IENhbm9uaWNhbE51bWVyaWNJbmRleFN0cmluZyAoIGFyZ3VtZW50IClcclxuXHJcbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgLy8gNy4yIFRlc3RpbmcgYW5kIENvbXBhcmlzb24gT3BlcmF0aW9uc1xyXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cclxuICAvLyA3LjIuMSBSZXF1aXJlT2JqZWN0Q29lcmNpYmxlICggYXJndW1lbnQgKVxyXG4gIC8vIDcuMi4yIElzQXJyYXkgKCBhcmd1bWVudCApXHJcblxyXG4gIC8vIDcuMi4zIElzQ2FsbGFibGUgKCBhcmd1bWVudCApXHJcbiAgZnVuY3Rpb24gSXNDYWxsYWJsZShvKSB7IHJldHVybiB0eXBlb2YgbyA9PT0gJ2Z1bmN0aW9uJzsgfVxyXG5cclxuICAvLyA3LjIuNCBJc0NvbnN0cnVjdG9yICggYXJndW1lbnQgKVxyXG4gIGZ1bmN0aW9uIElzQ29uc3RydWN0b3Iobykge1xyXG4gICAgLy8gSGFja3MgZm9yIFNhZmFyaSA3IFR5cGVkQXJyYXkgWFhYQ29uc3RydWN0b3Igb2JqZWN0c1xyXG4gICAgaWYgKC9Db25zdHJ1Y3Rvci8udGVzdChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykpKSByZXR1cm4gdHJ1ZTtcclxuICAgIGlmICgvRnVuY3Rpb24vLnRlc3QoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pKSkgcmV0dXJuIHRydWU7XHJcbiAgICAvLyBUT0RPOiBDYW4gdGhpcyBiZSBpbXByb3ZlZCBvbj9cclxuICAgIHJldHVybiB0eXBlb2YgbyA9PT0gJ2Z1bmN0aW9uJztcclxuICB9XHJcblxyXG4gIC8vIDcuMi41IElzRXh0ZW5zaWJsZSAoTylcclxuICAvLyA3LjIuNiBJc0ludGVnZXIgKCBhcmd1bWVudCApXHJcblxyXG4gIC8vIDcuMi43IElzUHJvcGVydHlLZXkgKCBhcmd1bWVudCApXHJcbiAgZnVuY3Rpb24gSXNQcm9wZXJ0eUtleShhcmd1bWVudCkge1xyXG4gICAgaWYgKFR5cGUoYXJndW1lbnQpID09PSAnc3RyaW5nJykgcmV0dXJuIHRydWU7XHJcbiAgICBpZiAoVHlwZShhcmd1bWVudCkgPT09ICdzeW1ib2wnKSByZXR1cm4gdHJ1ZTtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcblxyXG4gIC8vIDcuMi44IElzUmVnRXhwICggYXJndW1lbnQgKVxyXG5cclxuICAvLyA3LjIuOSBTYW1lVmFsdWUoeCwgeSlcclxuICBmdW5jdGlvbiBTYW1lVmFsdWUoeCwgeSkge1xyXG4gICAgaWYgKHR5cGVvZiB4ICE9PSB0eXBlb2YgeSkgcmV0dXJuIGZhbHNlO1xyXG4gICAgc3dpdGNoICh0eXBlb2YgeCkge1xyXG4gICAgY2FzZSAndW5kZWZpbmVkJzpcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICBjYXNlICdudW1iZXInOlxyXG4gICAgICBpZiAoeCAhPT0geCAmJiB5ICE9PSB5KSByZXR1cm4gdHJ1ZTtcclxuICAgICAgaWYgKHggPT09IDAgJiYgeSA9PT0gMCkgcmV0dXJuIDEveCA9PT0gMS95O1xyXG4gICAgICByZXR1cm4geCA9PT0geTtcclxuICAgIGNhc2UgJ2Jvb2xlYW4nOlxyXG4gICAgY2FzZSAnc3RyaW5nJzpcclxuICAgIGNhc2UgJ29iamVjdCc6XHJcbiAgICBkZWZhdWx0OlxyXG4gICAgICByZXR1cm4geCA9PT0geTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIDcuMi4xMCBTYW1lVmFsdWVaZXJvKHgsIHkpXHJcbiAgZnVuY3Rpb24gU2FtZVZhbHVlWmVybyh4LCB5KSB7XHJcbiAgICBpZiAodHlwZW9mIHggIT09IHR5cGVvZiB5KSByZXR1cm4gZmFsc2U7XHJcbiAgICBzd2l0Y2ggKHR5cGVvZiB4KSB7XHJcbiAgICBjYXNlICd1bmRlZmluZWQnOlxyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIGNhc2UgJ251bWJlcic6XHJcbiAgICAgIGlmICh4ICE9PSB4ICYmIHkgIT09IHkpIHJldHVybiB0cnVlO1xyXG4gICAgICByZXR1cm4geCA9PT0geTtcclxuICAgIGNhc2UgJ2Jvb2xlYW4nOlxyXG4gICAgY2FzZSAnc3RyaW5nJzpcclxuICAgIGNhc2UgJ29iamVjdCc6XHJcbiAgICBkZWZhdWx0OlxyXG4gICAgICByZXR1cm4geCA9PT0geTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gIC8vIDcuMyBPcGVyYXRpb25zIG9uIE9iamVjdHNcclxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcbiAgLy8gNy4zLjEgR2V0IChPLCBQKVxyXG4gIC8vIC0ganVzdCB1c2Ugby5wIG9yIG9bcF1cclxuXHJcbiAgLy8gNy4zLjIgR2V0ViAoViwgUClcclxuICBmdW5jdGlvbiBHZXRWKHYsIHApIHtcclxuICAgIHZhciBvID0gVG9PYmplY3Qodik7XHJcbiAgICByZXR1cm4gb1twXTtcclxuICB9XHJcblxyXG4gIC8vIDcuMy4zIFNldCAoTywgUCwgViwgVGhyb3cpXHJcbiAgLy8gLSBqdXN0IHVzZSBvLnAgPSB2IG9yIG9bcF0gPSB2XHJcblxyXG5cclxuXHJcblxyXG4gIC8vIDcuMy45IEdldE1ldGhvZCAoTywgUClcclxuICBmdW5jdGlvbiBHZXRNZXRob2QobywgcCkge1xyXG4gICAgdmFyIGZ1bmMgPSBHZXRWKG8sIHApO1xyXG4gICAgaWYgKGZ1bmMgPT09IHVuZGVmaW5lZCB8fCBmdW5jID09PSBudWxsKSByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgaWYgKCFJc0NhbGxhYmxlKGZ1bmMpKSB0aHJvdyBUeXBlRXJyb3IoKTtcclxuICAgIHJldHVybiBmdW5jO1xyXG4gIH1cclxuXHJcbiAgLy8gNy4zLjEwIEhhc1Byb3BlcnR5IChPLCBQKVxyXG4gIGZ1bmN0aW9uIEhhc1Byb3BlcnR5KG8sIHApIHtcclxuICAgIHdoaWxlIChvKSB7XHJcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobywgcCkpIHJldHVybiB0cnVlO1xyXG4gICAgICBpZiAoVHlwZShvKSAhPT0gJ29iamVjdCcpIHJldHVybiBmYWxzZTtcclxuICAgICAgdmFyIG9wID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pO1xyXG4gICAgICBpZiAob3AgPT09IG8pIHJldHVybiBmYWxzZTsgLy8gSUU4IGhhcyBzZWxmLXJlZmVyZW50aWFsIHByb3RvdHlwZXNcclxuICAgICAgbyA9IG9wO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgLy8gNy4zLjExIEhhc093blByb3BlcnR5IChPLCBQKVxyXG4gIGZ1bmN0aW9uIEhhc093blByb3BlcnR5KG8sIHApIHtcclxuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobywgcCk7XHJcbiAgfVxyXG5cclxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAvLyA3LjQgT3BlcmF0aW9ucyBvbiBJdGVyYXRvciBPYmplY3RzXHJcbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG4gIC8vIDcuNC4xIEdldEl0ZXJhdG9yICggb2JqLCBtZXRob2QgKVxyXG4gIGZ1bmN0aW9uIEdldEl0ZXJhdG9yKG9iaiwgbWV0aG9kKSB7XHJcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpXHJcbiAgICAgIG1ldGhvZCA9IEdldE1ldGhvZChvYmosICQkaXRlcmF0b3IpO1xyXG4gICAgdmFyIGl0ZXJhdG9yID0gbWV0aG9kLmNhbGwob2JqKTtcclxuICAgIGlmIChUeXBlKGl0ZXJhdG9yKSAhPT0gJ29iamVjdCcpIHRocm93IFR5cGVFcnJvcigpO1xyXG4gICAgcmV0dXJuIGl0ZXJhdG9yO1xyXG4gIH1cclxuXHJcbiAgLy8gNy40LjIgSXRlcmF0b3JOZXh0ICggaXRlcmF0b3IsIHZhbHVlIClcclxuICBmdW5jdGlvbiBJdGVyYXRvck5leHQoaXRlcmF0b3IsIHZhbHVlKSB7XHJcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpXHJcbiAgICAgIHZhciByZXN1bHQgPSBpdGVyYXRvci5uZXh0KCk7XHJcbiAgICBlbHNlXHJcbiAgICAgIHJlc3VsdCA9IGl0ZXJhdG9yLm5leHQodmFsdWUpO1xyXG4gICAgaWYgKFR5cGUocmVzdWx0KSAhPT0gJ29iamVjdCcpIHRocm93IFR5cGVFcnJvcigpO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxuICB9XHJcblxyXG4gIC8vIDcuNC4zIEl0ZXJhdG9yQ29tcGxldGUgKCBpdGVyUmVzdWx0IClcclxuICBmdW5jdGlvbiBJdGVyYXRvckNvbXBsZXRlKGl0ZXJSZXN1bHQpIHtcclxuICAgIGNvbnNvbGUuYXNzZXJ0KFR5cGUoaXRlclJlc3VsdCkgPT09ICdvYmplY3QnKTtcclxuICAgIHJldHVybiBCb29sZWFuKGl0ZXJSZXN1bHQuZG9uZSk7XHJcbiAgfVxyXG5cclxuICAvLyA3LjQuNCBJdGVyYXRvclZhbHVlICggaXRlclJlc3VsdCApXHJcbiAgZnVuY3Rpb24gSXRlcmF0b3JWYWx1ZShpdGVyUmVzdWx0KSB7XHJcbiAgICBjb25zb2xlLmFzc2VydChUeXBlKGl0ZXJSZXN1bHQpID09PSAnb2JqZWN0Jyk7XHJcbiAgICByZXR1cm4gaXRlclJlc3VsdC52YWx1ZTtcclxuICB9XHJcblxyXG4gIC8vIDcuNC41IEl0ZXJhdG9yU3RlcCAoIGl0ZXJhdG9yIClcclxuICBmdW5jdGlvbiBJdGVyYXRvclN0ZXAoIGl0ZXJhdG9yLCB2YWx1ZSApIHtcclxuICAgIHZhciByZXN1bHQgPSBJdGVyYXRvck5leHQoaXRlcmF0b3IsIHZhbHVlKTtcclxuICAgIHZhciBkb25lID0gcmVzdWx0Wydkb25lJ107XHJcbiAgICBpZiAoQm9vbGVhbihkb25lKSA9PT0gdHJ1ZSkgcmV0dXJuIGZhbHNlO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxuICB9XHJcblxyXG4gIC8vIDcuNC42IEl0ZXJhdG9yQ2xvc2UoIGl0ZXJhdG9yLCBjb21wbGV0aW9uIClcclxuICBmdW5jdGlvbiBJdGVyYXRvckNsb3NlKCBpdGVyYXRvciwgY29tcGxldGlvbiApIHtcclxuICAgIGNvbnNvbGUuYXNzZXJ0KFR5cGUoaXRlcmF0b3IpID09PSAnb2JqZWN0Jyk7XHJcbiAgICB2YXIgX3JldHVybiA9IEdldE1ldGhvZChpdGVyYXRvciwgJ3JldHVybicpO1xyXG4gICAgaWYgKF9yZXR1cm4gPT09IHVuZGVmaW5lZCkgcmV0dXJuIGNvbXBsZXRpb247XHJcbiAgICB0cnkge1xyXG4gICAgICB2YXIgaW5uZXJSZXN1bHQgPSBfcmV0dXJuW2l0ZXJhdG9yXSgpO1xyXG4gICAgfSBjYXRjaCAocmVzdWx0KSB7XHJcbiAgICAgIC8vIFRPRE86IElmIGNvbXBsZXRpb24uW1t0eXBlXV0gaXMgdGhyb3csIHJldHVybiBjb21wbGV0aW9uXHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICBpZiAoVHlwZShpbm5lclJlc3VsdCkgIT09ICdvYmplY3QnKSB0aHJvdyBUeXBlRXJyb3IoKTtcclxuICAgIHJldHVybiBjb21wbGV0aW9uO1xyXG4gIH1cclxuXHJcbiAgLy8gNy40LjcgQ3JlYXRlSXRlclJlc3VsdE9iamVjdCAodmFsdWUsIGRvbmUpXHJcbiAgZnVuY3Rpb24gQ3JlYXRlSXRlclJlc3VsdE9iamVjdCh2YWx1ZSwgZG9uZSkge1xyXG4gICAgY29uc29sZS5hc3NlcnQoVHlwZShkb25lKSA9PT0gJ2Jvb2xlYW4nKTtcclxuICAgIHZhciBvYmogPSB7fTtcclxuICAgIG9ialtcInZhbHVlXCJdID0gdmFsdWU7XHJcbiAgICBvYmpbXCJkb25lXCJdID0gZG9uZTtcclxuICAgIHJldHVybiBvYmo7XHJcbiAgfVxyXG5cclxuICAvLyA3LjQuOCBDcmVhdGVMaXN0SXRlcmF0b3IgKGxpc3QpXHJcbiAgLy8gNy40LjguMSBMaXN0SXRlcmF0b3IgbmV4dCggKVxyXG5cclxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAvLyA4IEV4ZWN1dGFibGUgQ29kZSBhbmQgRXhlY3V0aW9uIENvbnRleHRzXHJcbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gIC8vIDguNCBKb2JzIGFuZCBKb2IgUXVldWVzXHJcbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG4gIC8vIDguNC4xIEVucXVldWVKb2IgKCBxdWV1ZU5hbWUsIGpvYiwgYXJndW1lbnRzKVxyXG4gIGZ1bmN0aW9uIEVucXVldWVKb2IocXVldWVOYW1lLCBqb2IsIGFyZ3MpIHtcclxuICAgIHZhciBmbiA9IGZ1bmN0aW9uKCkgeyBqb2IuYXBwbHkodW5kZWZpbmVkLCBhcmdzKTsgfTtcclxuICAgIGVucXVldWUoZm4pO1xyXG4gIH1cclxuXHJcbiAgLy8gOC40LjIgTmV4dEpvYiByZXN1bHRcclxuICBmdW5jdGlvbiBOZXh0Sm9iKHJlc3VsdCkge1xyXG4gICAgLy8gbm8tb3BcclxuICB9XHJcblxyXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gIC8vIDkgT3JkaW5hcnkgYW5kIEV4b3RpYyBPYmplY3RzIEJlaGF2aW9yc1xyXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cclxuICAvLyA5LjEuMTEgW1tFbnVtZXJhdGVdXSAoKVxyXG4gIGZ1bmN0aW9uIEVudW1lcmF0ZShvYmopIHtcclxuICAgIHZhciBlID0gW107XHJcbiAgICBpZiAoT2JqZWN0KG9iaikgIT09IG9iaikgcmV0dXJuIGU7XHJcbiAgICB2YXIgdmlzaXRlZCA9IG5ldyBTZXQ7XHJcbiAgICB3aGlsZSAob2JqICE9PSBudWxsKSB7XHJcbiAgICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG9iaikuZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XHJcbiAgICAgICAgaWYgKCF2aXNpdGVkLmhhcyhuYW1lKSkge1xyXG4gICAgICAgICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwgbmFtZSk7XHJcbiAgICAgICAgICBpZiAoZGVzYykge1xyXG4gICAgICAgICAgICB2aXNpdGVkLmFkZChuYW1lKTtcclxuICAgICAgICAgICAgaWYgKGRlc2MuZW51bWVyYWJsZSkgZS5wdXNoKG5hbWUpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICAgIG9iaiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmopO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGVbJCRpdGVyYXRvcl0oKTtcclxuICB9XHJcblxyXG4gIC8vIDkuMS4xMiBbW093blByb3BlcnR5S2V5c11dICggKVxyXG4gIGZ1bmN0aW9uIE93blByb3BlcnR5S2V5cyhvKSB7XHJcbiAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMobyk7XHJcbiAgfVxyXG5cclxuICAvLyA5LjEuMTMgT2JqZWN0Q3JlYXRlKHByb3RvLCBpbnRlcm5hbFNsb3RzTGlzdClcclxuICBmdW5jdGlvbiBPYmplY3RDcmVhdGUocHJvdG8sIGludGVybmFsU2xvdHNMaXN0KSB7XHJcbiAgICByZXR1cm4gT2JqZWN0LmNyZWF0ZShwcm90bywgaW50ZXJuYWxTbG90c0xpc3QpO1xyXG4gIH1cclxuXHJcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgLy8gMTkgRnVuZGFtZW50YWwgT2JqZWN0c1xyXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cclxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAvLyAxOS4xIE9iamVjdCBPYmplY3RzXHJcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG4gIC8vIDE5LjEuMSBUaGUgT2JqZWN0IENvbnN0cnVjdG9yXHJcbiAgLy8gMTkuMS4xLjEgT2JqZWN0ICggWyB2YWx1ZSBdIClcclxuICAvLyAxOS4xLjIgUHJvcGVydGllcyBvZiB0aGUgT2JqZWN0IENvbnN0cnVjdG9yXHJcbiAgLy8gMTkuMS4yLjEgT2JqZWN0LmFzc2lnbiAoIHRhcmdldCwgLi4uc291cmNlcyApXHJcbiAgZGVmaW5lKFxyXG4gICAgT2JqZWN0LCAnYXNzaWduJyxcclxuICAgIGZ1bmN0aW9uIGFzc2lnbih0YXJnZXQsIC8qLi4uKi9zb3VyY2VzKSB7XHJcbiAgICAgIHZhciB0byA9IFRvT2JqZWN0KHRhcmdldCk7XHJcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikgcmV0dXJuIHRvO1xyXG5cclxuICAgICAgdmFyIHNvdXJjZXNJbmRleCA9IDE7XHJcbiAgICAgIHdoaWxlIChzb3VyY2VzSW5kZXggPCBhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgdmFyIG5leHRTb3VyY2UgPSBhcmd1bWVudHNbc291cmNlc0luZGV4KytdO1xyXG4gICAgICAgIGlmIChuZXh0U291cmNlID09PSB1bmRlZmluZWQgfHwgbmV4dFNvdXJjZSA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgdmFyIGtleXMgPSBbXTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgdmFyIGZyb20gPSBUb09iamVjdChuZXh0U291cmNlKTtcclxuICAgICAgICAgIGtleXMgPSBPd25Qcm9wZXJ0eUtleXMoZnJvbSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAodmFyIGtleXNJbmRleCA9IDA7IGtleXNJbmRleCA8IGtleXMubGVuZ3RoOyArK2tleXNJbmRleCkge1xyXG4gICAgICAgICAgdmFyIG5leHRLZXkgPSBrZXlzW2tleXNJbmRleF07XHJcbiAgICAgICAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZnJvbSwgbmV4dEtleSk7XHJcbiAgICAgICAgICBpZiAoZGVzYyAhPT0gdW5kZWZpbmVkICYmIGRlc2MuZW51bWVyYWJsZSkge1xyXG4gICAgICAgICAgICB2YXIgcHJvcFZhbHVlID0gZnJvbVtuZXh0S2V5XTtcclxuICAgICAgICAgICAgdG9bbmV4dEtleV0gPSBwcm9wVmFsdWU7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB0bztcclxuICAgIH0pO1xyXG5cclxuICAvLyAxOS4xLjIuMiBPYmplY3QuY3JlYXRlICggTyBbICwgUHJvcGVydGllcyBdIClcclxuICAvLyAxOS4xLjIuMyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyAoIE8sIFByb3BlcnRpZXMgKVxyXG4gIC8vIDE5LjEuMi40IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAoIE8sIFAsIEF0dHJpYnV0ZXMgKVxyXG4gIC8vIDE5LjEuMi41IE9iamVjdC5mcmVlemUgKCBPIClcclxuICAvLyAxOS4xLjIuNiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yICggTywgUCApXHJcblxyXG4gIChmdW5jdGlvbigpIHtcclxuICAgIHZhciBuYXRpdmVTeW1ib2xzID0gKHR5cGVvZiBnbG9iYWwuU3ltYm9sKCkgPT09ICdzeW1ib2wnKSxcclxuICAgICAgICAkZ2V0T3duUHJvcGVydHlOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzLFxyXG4gICAgICAgICRrZXlzID0gT2JqZWN0LmtleXMsXHJcbiAgICAgICAgJHdpbmRvd19uYW1lcyA9ICh0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JyA/ICRnZXRPd25Qcm9wZXJ0eU5hbWVzKHdpbmRvdykgOiBbXSk7XHJcblxyXG4gICAgZnVuY3Rpb24gaXNTdHJpbmdLZXkoaykgeyByZXR1cm4gIXN5bWJvbEZvcktleShrKTsgfVxyXG5cclxuICAgIC8vIDE5LjEuMi43IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzICggTyApXHJcbiAgICBkZWZpbmUoXHJcbiAgICAgIE9iamVjdCwgJ2dldE93blByb3BlcnR5TmFtZXMnLFxyXG4gICAgICBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKG8pIHtcclxuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pID09PSAnW29iamVjdCBXaW5kb3ddJykge1xyXG4gICAgICAgICAgLy8gV29ya2Fyb3VuZCBmb3IgY3Jvc3MtcmVhbG0gY2FsbGluZyBieSBJRSBpdHNlbGYuXHJcbiAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vaW5leG9yYWJsZXRhc2gvcG9seWZpbGwvaXNzdWVzLzk2XHJcbiAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICByZXR1cm4gJGdldE93blByb3BlcnR5TmFtZXMobykuZmlsdGVyKGlzU3RyaW5nS2V5KTtcclxuICAgICAgICAgIH0gY2F0Y2ggKF8pIHtcclxuICAgICAgICAgICAgcmV0dXJuICR3aW5kb3dfbmFtZXMuc2xpY2UoKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuICRnZXRPd25Qcm9wZXJ0eU5hbWVzKG8pLmZpbHRlcihpc1N0cmluZ0tleSk7XHJcbiAgICAgIH0sICFuYXRpdmVTeW1ib2xzKTtcclxuXHJcbiAgICAvLyAxOS4xLjIuOCBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzICggTyApXHJcbiAgICBkZWZpbmUoXHJcbiAgICAgIE9iamVjdCwgJ2dldE93blByb3BlcnR5U3ltYm9scycsXHJcbiAgICAgIGZ1bmN0aW9uIGdldE93blByb3BlcnR5U3ltYm9scyhvKSB7XHJcbiAgICAgICAgcmV0dXJuICRnZXRPd25Qcm9wZXJ0eU5hbWVzKG8pLmZpbHRlcihzeW1ib2xGb3JLZXkpLm1hcChzeW1ib2xGb3JLZXkpO1xyXG4gICAgICB9LCAhbmF0aXZlU3ltYm9scyk7XHJcblxyXG4gICAgLy8gMTkuMS4yLjE0IE9iamVjdC5rZXlzICggTyApXHJcbiAgICBkZWZpbmUoXHJcbiAgICAgIE9iamVjdCwgJ2tleXMnLFxyXG4gICAgICBmdW5jdGlvbiBrZXlzKG8pIHtcclxuICAgICAgICByZXR1cm4gJGtleXMobykuZmlsdGVyKGlzU3RyaW5nS2V5KTtcclxuICAgICAgfSwgIW5hdGl2ZVN5bWJvbHMpO1xyXG4gIH0oKSk7XHJcblxyXG4gIC8vIDE5LjEuMi45IE9iamVjdC5nZXRQcm90b3R5cGVPZiAoIE8gKVxyXG4gIC8vIDE5LjEuMi4xMCBPYmplY3QuaXMgKCB2YWx1ZTEsIHZhbHVlMiApXHJcbiAgZGVmaW5lKFxyXG4gICAgT2JqZWN0LCAnaXMnLFxyXG4gICAgZnVuY3Rpb24gaXModmFsdWUxLCB2YWx1ZTIpIHtcclxuICAgICAgcmV0dXJuIFNhbWVWYWx1ZSh2YWx1ZTEsIHZhbHVlMik7XHJcbiAgICB9KTtcclxuXHJcbiAgLy8gMTkuMS4yLjExIE9iamVjdC5pc0V4dGVuc2libGUgKCBPIClcclxuICAvLyAxOS4xLjIuMTIgT2JqZWN0LmlzRnJvemVuICggTyApXHJcbiAgLy8gMTkuMS4yLjEzIE9iamVjdC5pc1NlYWxlZCAoIE8gKVxyXG5cclxuICAvLyAxOS4xLjIuMTQgT2JqZWN0LmtleXMgKCBPIClcclxuICAvLyBzZWUgYWJvdmVcclxuXHJcbiAgLy8gMTkuMS4yLjE1IE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyAoIE8gKVxyXG4gIC8vIDE5LjEuMi4xNiBPYmplY3QucHJvdG90eXBlXHJcbiAgLy8gMTkuMS4yLjE3IE9iamVjdC5zZWFsICggTyApXHJcblxyXG4gIC8vIDE5LjEuMi4xOCBPYmplY3Quc2V0UHJvdG90eXBlT2YgKCBPLCBwcm90byApXHJcbiAgZGVmaW5lKFxyXG4gICAgT2JqZWN0LCAnc2V0UHJvdG90eXBlT2YnLFxyXG4gICAgZnVuY3Rpb24gc2V0UHJvdG90eXBlT2YobywgcHJvdG8pIHtcclxuICAgICAgaWYgKFR5cGUobykgIT09ICdvYmplY3QnKSB0aHJvdyBUeXBlRXJyb3IoKTtcclxuICAgICAgaWYgKFR5cGUocHJvdG8pICE9PSAnb2JqZWN0JyAmJiBUeXBlKHByb3RvKSAhPT0gJ251bGwnKSB0aHJvdyBUeXBlRXJyb3IoKTtcclxuICAgICAgby5fX3Byb3RvX18gPSBwcm90bztcclxuICAgICAgcmV0dXJuIG87XHJcbiAgICB9XHJcbiAgKTtcclxuXHJcbiAgLy8gMTkuMS4zIFByb3BlcnRpZXMgb2YgdGhlIE9iamVjdCBQcm90b3R5cGUgT2JqZWN0XHJcbiAgLy8gMTkuMS4zLjEgT2JqZWN0LnByb3RvdHlwZS5jb25zdHJ1Y3RvclxyXG4gIC8vIDE5LjEuMy4yIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkgKCBWIClcclxuICAvLyAxOS4xLjMuMyBPYmplY3QucHJvdG90eXBlLmlzUHJvdG90eXBlT2YgKCBWIClcclxuICAvLyAxOS4xLjMuNCBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlICggViApXHJcbiAgLy8gMTkuMS4zLjUgT2JqZWN0LnByb3RvdHlwZS50b0xvY2FsZVN0cmluZyAoIFsgcmVzZXJ2ZWQxIFsgLCByZXNlcnZlZDIgXSBdIClcclxuICAvLyAxOS4xLjMuNiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nICggKVxyXG4gIHZhciBvX3BfdHMgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xyXG4gIGRlZmluZShPYmplY3QucHJvdG90eXBlLCAndG9TdHJpbmcnLFxyXG4gICAgICAgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgIHZhciBvID0gc3RyaWN0KHRoaXMpO1xyXG4gICAgICAgICBpZiAobyA9PT0gT2JqZWN0KG8pICYmICQkdG9TdHJpbmdUYWcgaW4gbykge1xyXG4gICAgICAgICAgIHJldHVybiAnW29iamVjdCAnICsgb1skJHRvU3RyaW5nVGFnXSArICddJztcclxuICAgICAgICAgfVxyXG4gICAgICAgICByZXR1cm4gb19wX3RzLmFwcGx5KG8sIGFyZ3VtZW50cyk7XHJcbiAgICAgICB9KTtcclxuXHJcbiAgLy8gMTkuMS4zLjcgT2JqZWN0LnByb3RvdHlwZS52YWx1ZU9mICggKVxyXG4gIC8vIDE5LjEuNCBQcm9wZXJ0aWVzIG9mIE9iamVjdCBJbnN0YW5jZXNcclxuXHJcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgLy8gMTkuMiBGdW5jdGlvbiBPYmplY3RzXHJcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG4gIC8vIDE5LjIuMSBUaGUgRnVuY3Rpb24gQ29uc3RydWN0b3JcclxuICAvLyAxOS4yLjEuMSBGdW5jdGlvbiAoIHAxLCBwMiwg4oCmICwgcG4sIGJvZHkgKVxyXG4gIC8vIDE5LjIuMiBQcm9wZXJ0aWVzIG9mIHRoZSBGdW5jdGlvbiBDb25zdHJ1Y3RvclxyXG4gIC8vIDE5LjIuMi4xIEZ1bmN0aW9uLmxlbmd0aFxyXG4gIC8vIDE5LjIuMi4yIEZ1bmN0aW9uLnByb3RvdHlwZVxyXG4gIC8vIDE5LjIuMyBQcm9wZXJ0aWVzIG9mIHRoZSBGdW5jdGlvbiBQcm90b3R5cGUgT2JqZWN0XHJcbiAgLy8gMTkuMi4zLjEgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5ICggdGhpc0FyZywgYXJnQXJyYXkgKVxyXG4gIC8vIDE5LjIuMy4yIEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kICggdGhpc0FyZyAsIC4uLmFyZ3MpXHJcbiAgLy8gMTkuMi4zLjMgRnVuY3Rpb24ucHJvdG90eXBlLmNhbGwgKHRoaXNBcmcgLCAuLi5hcmdzKVxyXG4gIC8vIDE5LjIuMy40IEZ1bmN0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvclxyXG4gIC8vIDE5LjIuMy41IEZ1bmN0aW9uLnByb3RvdHlwZS50b1N0cmluZyAoIClcclxuICAvLyAxOS4yLjMuNiBGdW5jdGlvbi5wcm90b3R5cGVbQEBoYXNJbnN0YW5jZV0gKCBWIClcclxuICAvLyAxOS4yLjQgRnVuY3Rpb24gSW5zdGFuY2VzXHJcbiAgLy8gMTkuMi40LjEgbGVuZ3RoXHJcbiAgLy8gMTkuMi40LjIgbmFtZVxyXG4gIC8vIDE5LjIuNC4zIHByb3RvdHlwZVxyXG5cclxuICAvLyAoTm8gcG9seWZpbGxhYmxlIGNoYW5nZXMgZnJvbSBFUzUpXHJcblxyXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gIC8vIDE5LjMgQm9vbGVhbiBPYmplY3RzXHJcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG4gIC8vIDE5LjMuMSBUaGUgQm9vbGVhbiBDb25zdHJ1Y3RvclxyXG4gIC8vIDE5LjMuMS4xIEJvb2xlYW4gKCB2YWx1ZSApXHJcbiAgLy8gMTkuMy4yIFByb3BlcnRpZXMgb2YgdGhlIEJvb2xlYW4gQ29uc3RydWN0b3JcclxuICAvLyAxOS4zLjIuMSBCb29sZWFuLnByb3RvdHlwZVxyXG4gIC8vIDE5LjMuMyBQcm9wZXJ0aWVzIG9mIHRoZSBCb29sZWFuIFByb3RvdHlwZSBPYmplY3RcclxuICAvLyAxOS4zLjMuMSBCb29sZWFuLnByb3RvdHlwZS5jb25zdHJ1Y3RvclxyXG4gIC8vIDE5LjMuMy4yIEJvb2xlYW4ucHJvdG90eXBlLnRvU3RyaW5nICggKVxyXG4gIC8vIDE5LjMuMy4zIEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YgKCApXHJcbiAgLy8gMTkuMy40IFByb3BlcnRpZXMgb2YgQm9vbGVhbiBJbnN0YW5jZXNcclxuXHJcbiAgLy8gKE5vIHBvbHlmaWxsYWJsZSBjaGFuZ2VzIGZyb20gRVM1KVxyXG5cclxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAvLyAxOS40IFN5bWJvbCBPYmplY3RzXHJcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG4gIC8vIE1vdmVkIGVhcmxpZXIgaW4gdGhpcyBzY3JpcHQsIHNvIHRoYXQgb3RoZXIgcG9seWZpbGxzIGNhbiBkZXBlbmQgb24gdGhlbS5cclxuXHJcbiAgLy8gMTkuNC4zLjQgU3ltYm9sLnByb3RvdHlwZSBbIEBAdG9TdHJpbmdUYWcgXVxyXG4gIGRlZmluZShnbG9iYWwuU3ltYm9sLnByb3RvdHlwZSwgZ2xvYmFsLlN5bWJvbC50b1N0cmluZ1RhZywgJ1N5bWJvbCcpO1xyXG5cclxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAvLyAxOS41IEVycm9yIE9iamVjdHNcclxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcbiAgLy8gMTkuNS4xIFRoZSBFcnJvciBDb25zdHJ1Y3RvclxyXG4gIC8vIDE5LjUuMS4xIEVycm9yICggbWVzc2FnZSApXHJcbiAgLy8gMTkuNS4xLjIgbmV3IEVycm9yKCAuLi5hcmd1bWVudHNMaXN0IClcclxuICAvLyAxOS41LjIgUHJvcGVydGllcyBvZiB0aGUgRXJyb3IgQ29uc3RydWN0b3JcclxuICAvLyAxOS41LjIuMSBFcnJvci5wcm90b3R5cGVcclxuICAvLyAxOS41LjMgUHJvcGVydGllcyBvZiB0aGUgRXJyb3IgUHJvdG90eXBlIE9iamVjdFxyXG4gIC8vIDE5LjUuMy4xIEVycm9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvclxyXG4gIC8vIDE5LjUuMy4yIEVycm9yLnByb3RvdHlwZS5tZXNzYWdlXHJcbiAgLy8gMTkuNS4zLjMgRXJyb3IucHJvdG90eXBlLm5hbWVcclxuICAvLyAxOS41LjMuNCBFcnJvci5wcm90b3R5cGUudG9TdHJpbmcgKCApXHJcbiAgLy8gMTkuNS40IFByb3BlcnRpZXMgb2YgRXJyb3IgSW5zdGFuY2VzXHJcbiAgLy8gMTkuNS41IE5hdGl2ZSBFcnJvciBUeXBlcyBVc2VkIGluIFRoaXMgU3RhbmRhcmRcclxuICAvLyAxOS41LjUuMSBFdmFsRXJyb3JcclxuICAvLyAxOS41LjUuMiBSYW5nZUVycm9yXHJcbiAgLy8gMTkuNS41LjMgUmVmZXJlbmNlRXJyb3JcclxuICAvLyAxOS41LjUuNCBTeW50YXhFcnJvclxyXG4gIC8vIDE5LjUuNS41IFR5cGVFcnJvclxyXG4gIC8vIDE5LjUuNS42IFVSSUVycm9yXHJcbiAgLy8gMTkuNS42IE5hdGl2ZUVycm9yIE9iamVjdCBTdHJ1Y3R1cmVcclxuICAvLyAxOS41LjYuMSBOYXRpdmVFcnJvciBDb25zdHJ1Y3RvcnNcclxuICAvLyAxOS41LjYuMS4xIE5hdGl2ZUVycm9yICggbWVzc2FnZSApXHJcbiAgLy8gMTkuNS42LjEuMiBuZXcgTmF0aXZlRXJyb3IgKCAuLi5hcmd1bWVudHNMaXN0IClcclxuICAvLyAxOS41LjYuMiBQcm9wZXJ0aWVzIG9mIHRoZSBOYXRpdmVFcnJvciBDb25zdHJ1Y3RvcnNcclxuICAvLyAxOS41LjYuMi4xIE5hdGl2ZUVycm9yLnByb3RvdHlwZVxyXG4gIC8vIDE5LjUuNi4zIFByb3BlcnRpZXMgb2YgdGhlIE5hdGl2ZUVycm9yIFByb3RvdHlwZSBPYmplY3RzXHJcbiAgLy8gMTkuNS42LjQgUHJvcGVydGllcyBvZiBOYXRpdmVFcnJvciBJbnN0YW5jZXNcclxuXHJcbiAgLy8gKE5vIHBvbHlmaWxsYWJsZSBjaGFuZ2VzIGZyb20gRVM1KVxyXG5cclxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAvLyAyMCBOdW1iZXJzIGFuZCBEYXRlc1xyXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cclxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAvLyAyMC4xIE51bWJlciBPYmplY3RzXHJcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG4gIC8vIDIwLjEuMSBUaGUgTnVtYmVyIENvbnN0cnVjdG9yXHJcbiAgLy8gMjAuMS4xLjEgTnVtYmVyICggWyB2YWx1ZSBdIClcclxuICAvLyAyMC4xLjEuMiBuZXcgTnVtYmVyICggLi4uYXJndW1lbnRzTGlzdCApXHJcbiAgLy8gMjAuMS4yIFByb3BlcnRpZXMgb2YgdGhlIE51bWJlciBDb25zdHJ1Y3RvclxyXG5cclxuICAvLyAyMC4xLjIuMSBOdW1iZXIuRVBTSUxPTlxyXG4gIGRlZmluZShcclxuICAgIE51bWJlciwgJ0VQU0lMT04nLFxyXG4gICAgKGZ1bmN0aW9uICgpIHtcclxuICAgICAgdmFyIG5leHQsIHJlc3VsdDtcclxuICAgICAgZm9yIChuZXh0ID0gMTsgMSArIG5leHQgIT09IDE7IG5leHQgPSBuZXh0IC8gMilcclxuICAgICAgICByZXN1bHQgPSBuZXh0O1xyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfSgpKSk7XHJcblxyXG4gIC8vIDIwLjEuMi4yIE51bWJlci5pc0Zpbml0ZSAoIG51bWJlciApXHJcbiAgZGVmaW5lKFxyXG4gICAgTnVtYmVyLCAnaXNGaW5pdGUnLFxyXG4gICAgZnVuY3Rpb24gaXNGaW5pdGUobnVtYmVyKSB7XHJcbiAgICAgIGlmIChUeXBlKG51bWJlcikgIT09ICdudW1iZXInKSByZXR1cm4gZmFsc2U7XHJcbiAgICAgIGlmIChudW1iZXIgIT09IG51bWJlciB8fCBudW1iZXIgPT09ICtJbmZpbml0eSB8fCBudW1iZXIgPT09IC1JbmZpbml0eSkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH0pO1xyXG5cclxuICAvLyAyMC4xLjIuMyBOdW1iZXIuaXNJbnRlZ2VyICggbnVtYmVyIClcclxuICBkZWZpbmUoXHJcbiAgICBOdW1iZXIsICdpc0ludGVnZXInLFxyXG4gICAgZnVuY3Rpb24gaXNJbnRlZ2VyKG51bWJlcikge1xyXG4gICAgICBpZiAoVHlwZShudW1iZXIpICE9PSAnbnVtYmVyJykgcmV0dXJuIGZhbHNlO1xyXG4gICAgICBpZiAobnVtYmVyICE9PSBudW1iZXIgfHwgbnVtYmVyID09PSArSW5maW5pdHkgfHwgbnVtYmVyID09PSAtSW5maW5pdHkpIHJldHVybiBmYWxzZTtcclxuICAgICAgdmFyIGludGVnZXIgPSBUb0ludGVnZXIobnVtYmVyKTtcclxuICAgICAgaWYgKGludGVnZXIgIT09IG51bWJlcikgcmV0dXJuIGZhbHNlO1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH0pO1xyXG5cclxuICAvLyAyMC4xLjIuNCBOdW1iZXIuaXNOYU4gKCBudW1iZXIgKVxyXG4gIGRlZmluZShcclxuICAgIE51bWJlciwgJ2lzTmFOJyxcclxuICAgIGZ1bmN0aW9uIGlzTmFOKG51bWJlcikge1xyXG4gICAgICBpZiAoVHlwZShudW1iZXIpICE9PSAnbnVtYmVyJykgcmV0dXJuIGZhbHNlO1xyXG4gICAgICBpZiAobnVtYmVyICE9PSBudW1iZXIpIHJldHVybiB0cnVlO1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9KTtcclxuXHJcbiAgLy8gMjAuMS4yLjUgTnVtYmVyLmlzU2FmZUludGVnZXIgKCBudW1iZXIgKVxyXG4gIGRlZmluZShcclxuICAgIE51bWJlciwgJ2lzU2FmZUludGVnZXInLFxyXG4gICAgZnVuY3Rpb24gaXNTYWZlSW50ZWdlcihudW1iZXIpIHtcclxuICAgICAgaWYgKFR5cGUobnVtYmVyKSAhPT0gJ251bWJlcicpIHJldHVybiBmYWxzZTtcclxuICAgICAgaWYgKG51bWJlciAhPT0gbnVtYmVyIHx8IG51bWJlciA9PT0gK0luZmluaXR5IHx8IG51bWJlciA9PT0gLUluZmluaXR5KSByZXR1cm4gZmFsc2U7XHJcbiAgICAgIHZhciBpbnRlZ2VyID0gVG9JbnRlZ2VyKG51bWJlcik7XHJcbiAgICAgIGlmIChpbnRlZ2VyICE9PSBudW1iZXIpIHJldHVybiBmYWxzZTtcclxuICAgICAgaWYgKGFicyhpbnRlZ2VyKSA8PSAoMHgyMDAwMDAwMDAwMDAwMCAtIDEpKSAvLyAyXjUzLTFcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfSk7XHJcblxyXG4gIC8vIDIwLjEuMi42IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSXHJcbiAgZGVmaW5lKFxyXG4gICAgTnVtYmVyLCAnTUFYX1NBRkVfSU5URUdFUicsXHJcbiAgICA5MDA3MTk5MjU0NzQwOTkxKTsgLy8gMl41My0xXHJcblxyXG4gIC8vIDIwLjEuMi43IE51bWJlci5NQVhfVkFMVUVcclxuXHJcbiAgLy8gMjAuMS4yLjggTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVJcclxuICBkZWZpbmUoXHJcbiAgICBOdW1iZXIsICdNSU5fU0FGRV9JTlRFR0VSJyxcclxuICAgIC05MDA3MTk5MjU0NzQwOTkxKTsgLy8gLTJeNTMrMVxyXG5cclxuICAvLyAyMC4xLjIuOSBOdW1iZXIuTUlOX1ZBTFVFXHJcbiAgLy8gMjAuMS4yLjEwIE51bWJlci5OYU5cclxuICAvLyAyMC4xLjIuMTEgTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZXHJcblxyXG4gIC8vIDIwLjEuMi4xMiBOdW1iZXIucGFyc2VGbG9hdCAoIHN0cmluZyApXHJcbiAgZGVmaW5lKE51bWJlciwgJ3BhcnNlRmxvYXQnLCAkcGFyc2VGbG9hdCk7XHJcblxyXG4gIC8vIDIwLjEuMi4xMyBOdW1iZXIucGFyc2VJbnQgKCBzdHJpbmcsIHJhZGl4IClcclxuICBkZWZpbmUoTnVtYmVyLCAncGFyc2VJbnQnLCAkcGFyc2VJbnQpO1xyXG5cclxuICAvLyAyMC4xLjIuMTQgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZXHJcbiAgLy8gMjAuMS4yLjE1IE51bWJlci5wcm90b3R5cGVcclxuXHJcbiAgLy8gMjAuMS4zIFByb3BlcnRpZXMgb2YgdGhlIE51bWJlciBQcm90b3R5cGUgT2JqZWN0XHJcbiAgLy8gMjAuMS4zLjEgTnVtYmVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvclxyXG4gIC8vIDIwLjEuMy4yIE51bWJlci5wcm90b3R5cGUudG9FeHBvbmVudGlhbCAoIGZyYWN0aW9uRGlnaXRzIClcclxuICAvLyAyMC4xLjMuMyBOdW1iZXIucHJvdG90eXBlLnRvRml4ZWQgKCBmcmFjdGlvbkRpZ2l0cyApXHJcbiAgLy8gMjAuMS4zLjQgTnVtYmVyLnByb3RvdHlwZS50b0xvY2FsZVN0cmluZyggWyByZXNlcnZlZDEgWyAsIHJlc2VydmVkMiBdIF0pXHJcbiAgLy8gMjAuMS4zLjUgTnVtYmVyLnByb3RvdHlwZS50b1ByZWNpc2lvbiAoIHByZWNpc2lvbiApXHJcbiAgLy8gMjAuMS4zLjYgTnVtYmVyLnByb3RvdHlwZS50b1N0cmluZyAoIFsgcmFkaXggXSApXHJcbiAgLy8gMjAuMS4zLjcgTnVtYmVyLnByb3RvdHlwZS52YWx1ZU9mICggKVxyXG4gIC8vIDIwLjEuNCBQcm9wZXJ0aWVzIG9mIE51bWJlciBJbnN0YW5jZXNcclxuXHJcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgLy8gMjAuMiBUaGUgTWF0aCBPYmplY3RcclxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcbiAgLy8gMjAuMi4xIFZhbHVlIFByb3BlcnRpZXMgb2YgdGhlIE1hdGggT2JqZWN0XHJcbiAgLy8gMjAuMi4xLjEgTWF0aC5FXHJcbiAgLy8gMjAuMi4xLjIgTWF0aC5MTjEwXHJcbiAgLy8gMjAuMi4xLjMgTWF0aC5MTjJcclxuICAvLyAyMC4yLjEuNCBNYXRoLkxPRzEwRVxyXG4gIC8vIDIwLjIuMS41IE1hdGguTE9HMkVcclxuICAvLyAyMC4yLjEuNiBNYXRoLlBJXHJcbiAgLy8gMjAuMi4xLjcgTWF0aC5TUVJUMV8yXHJcbiAgLy8gMjAuMi4xLjggTWF0aC5TUVJUMlxyXG5cclxuICAvLyAyMC4yLjEuOSBNYXRoIFsgQEB0b1N0cmluZ1RhZyBdXHJcbiAgZGVmaW5lKE1hdGgsICQkdG9TdHJpbmdUYWcsICdNYXRoJyk7XHJcblxyXG4gIC8vIDIwLjIuMiBGdW5jdGlvbiBQcm9wZXJ0aWVzIG9mIHRoZSBNYXRoIE9iamVjdFxyXG4gIC8vIDIwLjIuMi4xIE1hdGguYWJzICggeCApXHJcbiAgLy8gMjAuMi4yLjIgTWF0aC5hY29zICggeCApXHJcblxyXG4gIC8vIDIwLjIuMi4zIE1hdGguYWNvc2goeClcclxuICBkZWZpbmUoXHJcbiAgICBNYXRoLCAnYWNvc2gnLFxyXG4gICAgZnVuY3Rpb24gYWNvc2goeCkge1xyXG4gICAgICB4ID0gTnVtYmVyKHgpO1xyXG4gICAgICByZXR1cm4gbG9nKHggKyBzcXJ0KHggKiB4IC0gMSkpO1xyXG4gICAgfSk7XHJcblxyXG4gIC8vIDIwLjIuMi40IE1hdGguYXNpbiAoIHggKVxyXG5cclxuICAvLyAyMC4yLjIuNSBNYXRoLmFzaW5oKCB4IClcclxuICBkZWZpbmUoXHJcbiAgICBNYXRoLCAnYXNpbmgnLFxyXG4gICAgZnVuY3Rpb24gYXNpbmgoeCkge1xyXG4gICAgICB4ID0gTnVtYmVyKHgpO1xyXG4gICAgICBpZiAoU2FtZVZhbHVlKHgsIC0wKSkge1xyXG4gICAgICAgIHJldHVybiB4O1xyXG4gICAgICB9XHJcbiAgICAgIHZhciBzID0gc3FydCh4ICogeCArIDEpO1xyXG4gICAgICByZXR1cm4gKHMgPT09IC14KSA/IGxvZygwKSA6IGxvZyh4ICsgcyk7XHJcbiAgICB9KTtcclxuXHJcbiAgLy8gMjAuMi4yLjYgTWF0aC5hdGFuICggeCApXHJcblxyXG4gIC8vIDIwLjIuMi43IE1hdGguYXRhbmgoIHggKVxyXG4gIGRlZmluZShcclxuICAgIE1hdGgsICdhdGFuaCcsXHJcbiAgICBmdW5jdGlvbiBhdGFuaCh4KSB7XHJcbiAgICAgIHggPSBOdW1iZXIoeCk7XHJcbiAgICAgIHJldHVybiAoeCA9PT0gMCkgPyB4IDogbG9nKCgxICsgeCkgLyAoMSAtIHgpKSAvIDI7XHJcbiAgICB9KTtcclxuXHJcbiAgLy8gMjAuMi4yLjggTWF0aC5hdGFuMiAoIHksIHggKVxyXG5cclxuICAvLyAyMC4yLjIuOSBNYXRoLmNicnQgKCB4IClcclxuICBkZWZpbmUoXHJcbiAgICBNYXRoLCAnY2JydCcsXHJcbiAgICBmdW5jdGlvbiBjYnJ0KHgpIHtcclxuICAgICAgeCA9IE51bWJlcih4KTtcclxuICAgICAgaWYgKCRpc05hTih4L3gpKSB7XHJcbiAgICAgICAgcmV0dXJuIHg7XHJcbiAgICAgIH1cclxuICAgICAgdmFyIHIgPSBwb3coYWJzKHgpLCAxLzMpO1xyXG4gICAgICB2YXIgdCA9IHgvci9yO1xyXG4gICAgICByZXR1cm4gciArIChyICogKHQtcikgLyAoMipyICsgdCkpO1xyXG4gICAgfSk7XHJcblxyXG4gIC8vIDIwLjIuMi4xMCBNYXRoLmNlaWwgKCB4IClcclxuXHJcbiAgLy8gMjAuMi4yLjExIE1hdGguY2x6MzIgKCB4IClcclxuICBkZWZpbmUoXHJcbiAgICBNYXRoLCAnY2x6MzInLFxyXG4gICAgZnVuY3Rpb24gY2x6MzIoeCkge1xyXG4gICAgICBmdW5jdGlvbiBjbHo4KHgpIHtcclxuICAgICAgICByZXR1cm4gKHggJiAweGYwKSA/ICh4ICYgMHg4MCA/IDAgOiB4ICYgMHg0MCA/IDEgOiB4ICYgMHgyMCA/IDIgOiAzKSA6XHJcbiAgICAgICAgKHggJiAweDA4ID8gNCA6IHggJiAweDA0ID8gNSA6IHggJiAweDAyID8gNiA6IHggJiAweDAxID8gNyA6IDgpO1xyXG4gICAgICB9XHJcbiAgICAgIHggPSBUb1VpbnQzMih4KTtcclxuICAgICAgcmV0dXJuIHggJiAweGZmMDAwMDAwID8gY2x6OCh4ID4+IDI0KSA6XHJcbiAgICAgICAgeCAmIDB4ZmYwMDAwID8gY2x6OCh4ID4+IDE2KSArIDggOlxyXG4gICAgICAgIHggJiAweGZmMDAgPyBjbHo4KHggPj4gOCkgKyAxNiA6IGNsejgoeCkgKyAyNDtcclxuICAgIH0pO1xyXG5cclxuXHJcblxyXG4gIC8vIDIwLjIuMi4xMiBNYXRoLmNvcyAoIHggKVxyXG5cclxuICAvLyAyMC4yLjIuMTMgTWF0aC5jb3NoICggeCApXHJcbiAgZGVmaW5lKFxyXG4gICAgTWF0aCwgJ2Nvc2gnLFxyXG4gICAgZnVuY3Rpb24gY29zaCh4KSB7XHJcbiAgICAgIHggPSBOdW1iZXIoeCk7XHJcbiAgICAgIHJldHVybiAocG93KEUsIHgpICsgcG93KEUsIC14KSkgLyAyO1xyXG4gICAgfSk7XHJcblxyXG4gIC8vIDIwLjIuMi4xNCBNYXRoLmV4cCAoIHggKVxyXG5cclxuICAvLyAyMC4yLjIuMTUgTWF0aC5leHBtMSAoIHggKVxyXG4gIGRlZmluZShcclxuICAgIE1hdGgsICdleHBtMScsXHJcbiAgICBmdW5jdGlvbiBleHBtMSh4KSB7XHJcbiAgICAgIHggPSBOdW1iZXIoeCk7XHJcbiAgICAgIC8vIGZyb206IGh0dHA6Ly93d3cuam9obmRjb29rLmNvbS9jcHBfbG9nMXAuaHRtbFxyXG4gICAgICBpZiAoU2FtZVZhbHVlKHgsIC0wKSkge1xyXG4gICAgICAgIHJldHVybiAtMDtcclxuICAgICAgfSBlbHNlIGlmIChhYnMoeCkgPCAxZS01KSB7XHJcbiAgICAgICAgcmV0dXJuIHggKyAwLjUgKiB4ICogeDsgLy8gdHdvIHRlcm1zIG9mIFRheWxvciBleHBhbnNpb25cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gZXhwKHgpIC0gMTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gIC8vIDIwLjIuMi4xNiBNYXRoLmZsb29yICggeCApXHJcblxyXG4gIC8vIDIwLjIuMi4xNyBNYXRoLmZyb3VuZCAoIHggKVxyXG4gIGRlZmluZShcclxuICAgIE1hdGgsICdmcm91bmQnLFxyXG4gICAgZnVuY3Rpb24gZnJvdW5kKHgpIHtcclxuICAgICAgaWYgKCRpc05hTih4KSkge1xyXG4gICAgICAgIHJldHVybiBOYU47XHJcbiAgICAgIH1cclxuICAgICAgaWYgKDEveCA9PT0gK0luZmluaXR5IHx8IDEveCA9PT0gLUluZmluaXR5IHx8IHggPT09ICtJbmZpbml0eSB8fCB4ID09PSAtSW5maW5pdHkpIHtcclxuICAgICAgICByZXR1cm4geDtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gKG5ldyBGbG9hdDMyQXJyYXkoW3hdKSlbMF07XHJcbiAgICB9KTtcclxuXHJcbiAgLy8gMjAuMi4yLjE4IE1hdGguaHlwb3QgKCB2YWx1ZTEgWywgdmFsdWUyIFsgLi4uIF0gXSApXHJcbiAgZGVmaW5lKFxyXG4gICAgTWF0aCwgJ2h5cG90JyxcclxuICAgIGZ1bmN0aW9uIGh5cG90KCkge1xyXG4gICAgICB2YXIgdmFsdWVzID0gW107XHJcbiAgICAgIHZhciBtID0gMCwgc2F3TmFOID0gZmFsc2U7XHJcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgdmFyIG4gPSBhYnMoTnVtYmVyKGFyZ3VtZW50c1tpXSkpO1xyXG4gICAgICAgIGlmIChuID09PSBJbmZpbml0eSkgcmV0dXJuIG47XHJcbiAgICAgICAgaWYgKG4gIT09IG4pIHNhd05hTiA9IHRydWU7XHJcbiAgICAgICAgaWYgKG4gPiBtKSBtID0gbjtcclxuICAgICAgICB2YWx1ZXNbaV0gPSBuO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChzYXdOYU4pIHJldHVybiBOYU47XHJcbiAgICAgIGlmIChtID09PSAwKSByZXR1cm4gKzA7XHJcbiAgICAgIHZhciBzdW0gPSArMDtcclxuICAgICAgZm9yIChpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgIHZhciByID0gdmFsdWVzW2ldIC8gbTtcclxuICAgICAgICBzdW0gPSBzdW0gKyByICogcjtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gbSAqIHNxcnQoc3VtKTtcclxuICAgIH0pO1xyXG5cclxuICAvLyAyMC4yLjIuMTkgTWF0aC5pbXVsICggeCwgeSApXHJcbiAgZGVmaW5lKFxyXG4gICAgTWF0aCwgJ2ltdWwnLFxyXG4gICAgZnVuY3Rpb24gaW11bCh4LCB5KSB7XHJcbiAgICAgIHZhciBhID0gVG9VaW50MzIoeCk7XHJcbiAgICAgIHZhciBiID0gVG9VaW50MzIoeSk7XHJcbiAgICAgIC8vIChzbG93IGJ1dCBhY2N1cmF0ZSlcclxuICAgICAgdmFyIGFoICA9IChhID4+PiAxNikgJiAweGZmZmY7XHJcbiAgICAgIHZhciBhbCA9IGEgJiAweGZmZmY7XHJcbiAgICAgIHZhciBiaCAgPSAoYiA+Pj4gMTYpICYgMHhmZmZmO1xyXG4gICAgICB2YXIgYmwgPSBiICYgMHhmZmZmO1xyXG4gICAgICByZXR1cm4gKChhbCAqIGJsKSArICgoKGFoICogYmwgKyBhbCAqIGJoKSA8PCAxNikgPj4+IDApfDApO1xyXG4gICAgfSwgKCdpbXVsJyBpbiBNYXRoICYmIE1hdGguaW11bCgxLCAweDgwMDAwMDAwKSA9PT0gMCkgLy8gU2FmYXJpIDcgYnVnXHJcbiAgKTtcclxuXHJcbiAgLy8gMjAuMi4yLjIwIE1hdGgubG9nICggeCApXHJcblxyXG4gIC8vIDIwLjIuMi4yMSBNYXRoLmxvZzFwICggeCApXHJcbiAgZGVmaW5lKFxyXG4gICAgTWF0aCwgJ2xvZzFwJyxcclxuICAgIGZ1bmN0aW9uIGxvZzFwKHgpIHtcclxuICAgICAgeCA9IE51bWJlcih4KTtcclxuICAgICAgLy8gZnJvbTogaHR0cDovL3d3dy5qb2huZGNvb2suY29tL2NwcF9leHBtMS5odG1sXHJcbiAgICAgIGlmICh4IDwgLTEpIHtcclxuICAgICAgICByZXR1cm4gTmFOO1xyXG4gICAgICB9IGVsc2UgaWYgKFNhbWVWYWx1ZSh4LCAtMCkpIHtcclxuICAgICAgICByZXR1cm4gLTA7XHJcbiAgICAgIH0gZWxzZSBpZiAoYWJzKHgpID4gMWUtNCkge1xyXG4gICAgICAgIHJldHVybiBsb2coMSArIHgpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiAoLTAuNSAqIHggKyAxKSAqIHg7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAvLyAyMC4yLjIuMjIgTWF0aC5sb2cxMCAoIHggKVxyXG4gIGRlZmluZShcclxuICAgIE1hdGgsICdsb2cxMCcsXHJcbiAgICBmdW5jdGlvbiBsb2cxMCh4KSB7XHJcbiAgICAgIHggPSBOdW1iZXIoeCk7XHJcbiAgICAgIHJldHVybiBsb2coeCkgKiBMT0cxMEU7XHJcbiAgICB9KTtcclxuXHJcbiAgLy8gMjAuMi4yLjIzIE1hdGgubG9nMiAoIHggKVxyXG4gIGRlZmluZShcclxuICAgIE1hdGgsICdsb2cyJyxcclxuICAgIGZ1bmN0aW9uIGxvZzIoeCkge1xyXG4gICAgICB4ID0gTnVtYmVyKHgpO1xyXG4gICAgICByZXR1cm4gbG9nKHgpICogTE9HMkU7XHJcbiAgICB9KTtcclxuXHJcbiAgLy8gMjAuMi4yLjI0IE1hdGgubWF4ICggdmFsdWUxLCB2YWx1ZTIgLCAuLi52YWx1ZXMgKVxyXG4gIC8vIDIwLjIuMi4yNSBNYXRoLm1pbiAoIHZhbHVlMSwgdmFsdWUyICwgLi4udmFsdWVzIClcclxuICAvLyAyMC4yLjIuMjYgTWF0aC5wb3cgKCB4LCB5IClcclxuICAvLyAyMC4yLjIuMjcgTWF0aC5yYW5kb20gKCApXHJcbiAgLy8gMjAuMi4yLjI4IE1hdGgucm91bmQgKCB4IClcclxuXHJcbiAgLy8gMjAuMi4yLjI5IE1hdGguc2lnbih4KVxyXG4gIGRlZmluZShcclxuICAgIE1hdGgsICdzaWduJyxcclxuICAgIGZ1bmN0aW9uIHNpZ24oeCkge1xyXG4gICAgICB4ID0gTnVtYmVyKHgpO1xyXG4gICAgICByZXR1cm4geCA8IDAgPyAtMSA6IHggPiAwID8gMSA6IHg7XHJcbiAgICB9KTtcclxuXHJcbiAgLy8gMjAuMi4yLjMwIE1hdGguc2luICggeCApXHJcblxyXG4gIC8vIDIwLjIuMi4zMSBNYXRoLnNpbmgoIHggKVxyXG4gIGRlZmluZShcclxuICAgIE1hdGgsICdzaW5oJyxcclxuICAgIGZ1bmN0aW9uIHNpbmgoeCkge1xyXG4gICAgICB4ID0gTnVtYmVyKHgpO1xyXG4gICAgICByZXR1cm4gU2FtZVZhbHVlKHgsIC0wKSA/IHggOiAocG93KEUsIHgpIC0gcG93KEUsIC14KSkgLyAyO1xyXG4gICAgfSk7XHJcblxyXG4gIC8vIDIwLjIuMi4zMiBNYXRoLnNxcnQgKCB4IClcclxuICAvLyAyMC4yLjIuMzMgTWF0aC50YW4gKCB4IClcclxuXHJcbiAgLy8gMjAuMi4yLjM0IE1hdGgudGFuaCAoIHggKVxyXG4gIGRlZmluZShcclxuICAgIE1hdGgsICd0YW5oJyxcclxuICAgIGZ1bmN0aW9uIHRhbmgoeCkge1xyXG4gICAgICB4ID0gTnVtYmVyKHgpO1xyXG4gICAgICB2YXIgbiA9IHBvdyhFLCAyICogeCkgLSAxLFxyXG4gICAgICAgICAgZCA9IHBvdyhFLCAyICogeCkgKyAxO1xyXG4gICAgICBpZiAoU2FtZVZhbHVlKHgsIC0wKSlcclxuICAgICAgICByZXR1cm4geDtcclxuICAgICAgcmV0dXJuIChuID09PSBkKSA/IDEgOiBuIC8gZDsgLy8gSGFuZGxlIEluZmluaXR5L0luZmluaXR5XHJcbiAgICB9KTtcclxuXHJcbiAgLy8gMjAuMi4yLjM1IE1hdGgudHJ1bmMgKCB4IClcclxuICBkZWZpbmUoXHJcbiAgICBNYXRoLCAndHJ1bmMnLFxyXG4gICAgZnVuY3Rpb24gdHJ1bmMoeCkge1xyXG4gICAgICB4ID0gTnVtYmVyKHgpO1xyXG4gICAgICByZXR1cm4gJGlzTmFOKHgpID8gTmFOIDpcclxuICAgICAgICB4IDwgMCA/IGNlaWwoeCkgOiBmbG9vcih4KTtcclxuICAgIH0pO1xyXG5cclxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAvLyAyMC4zIERhdGUgT2JqZWN0c1xyXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cclxuICAvLyAyMC4zLjEgT3ZlcnZpZXcgb2YgRGF0ZSBPYmplY3RzIGFuZCBEZWZpbml0aW9ucyBvZiBBYnN0cmFjdCBPcGVyYXRpb25zXHJcbiAgLy8gMjAuMy4xLjEgVGltZSBWYWx1ZXMgYW5kIFRpbWUgUmFuZ2VcclxuICAvLyAyMC4zLjEuMiBEYXkgTnVtYmVyIGFuZCBUaW1lIHdpdGhpbiBEYXlcclxuICAvLyAyMC4zLjEuMyBZZWFyIE51bWJlclxyXG4gIC8vIDIwLjMuMS40IE1vbnRoIE51bWJlclxyXG4gIC8vIDIwLjMuMS41IERhdGUgTnVtYmVyXHJcbiAgLy8gMjAuMy4xLjYgV2VlayBEYXlcclxuICAvLyAyMC4zLjEuNyBMb2NhbCBUaW1lIFpvbmUgQWRqdXN0bWVudFxyXG4gIC8vIDIwLjMuMS44IERheWxpZ2h0IFNhdmluZyBUaW1lIEFkanVzdG1lbnRcclxuICAvLyAyMC4zLjEuOSBMb2NhbCBUaW1lXHJcbiAgLy8gMjAuMy4xLjEwIEhvdXJzLCBNaW51dGVzLCBTZWNvbmQsIGFuZCBNaWxsaXNlY29uZHNcclxuICAvLyAyMC4zLjEuMTEgTWFrZVRpbWUgKGhvdXIsIG1pbiwgc2VjLCBtcylcclxuICAvLyAyMC4zLjEuMTIgTWFrZURheSAoeWVhciwgbW9udGgsIGRhdGUpXHJcbiAgLy8gMjAuMy4xLjEzIE1ha2VEYXRlIChkYXksIHRpbWUpXHJcbiAgLy8gMjAuMy4xLjE0IFRpbWVDbGlwICh0aW1lKVxyXG4gIC8vIDIwLjMuMS4xNSBEYXRlIFRpbWUgU3RyaW5nIEZvcm1hdFxyXG4gIC8vIDIwLjMuMS4xNS4xIEV4dGVuZGVkIHllYXJzXHJcbiAgLy8gMjAuMy4yIFRoZSBEYXRlIENvbnN0cnVjdG9yXHJcbiAgLy8gMjAuMy4yLjEgRGF0ZSAoIHllYXIsIG1vbnRoIFssIGRhdGUgWyAsIGhvdXJzIFsgLCBtaW51dGVzIFsgLCBzZWNvbmRzIFsgLCBtcyBdIF0gXSBdIF0gKVxyXG4gIC8vIDIwLjMuMi4yIERhdGUgKCB2YWx1ZSApXHJcbiAgLy8gMjAuMy4yLjMgRGF0ZSAoIClcclxuICAvLyAyMC4zLjMgUHJvcGVydGllcyBvZiB0aGUgRGF0ZSBDb25zdHJ1Y3RvclxyXG4gIC8vIDIwLjMuMy4xIERhdGUubm93ICggKVxyXG4gIC8vIDIwLjMuMy4yIERhdGUucGFyc2UgKHN0cmluZylcclxuICAvLyAyMC4zLjMuMyBEYXRlLnByb3RvdHlwZVxyXG4gIC8vIDIwLjMuMy40IERhdGUuVVRDICggeWVhciwgbW9udGggWyAsIGRhdGUgWyAsIGhvdXJzIFsgLCBtaW51dGVzIFsgLCBzZWNvbmRzIFsgLCBtcyBdIF0gXSBdIF0gKVxyXG4gIC8vIDIwLjMuNCBQcm9wZXJ0aWVzIG9mIHRoZSBEYXRlIFByb3RvdHlwZSBPYmplY3RcclxuICAvLyAyMC4zLjQuMSBEYXRlLnByb3RvdHlwZS5jb25zdHJ1Y3RvclxyXG4gIC8vIDIwLjMuNC4yIERhdGUucHJvdG90eXBlLmdldERhdGUgKCApXHJcbiAgLy8gMjAuMy40LjMgRGF0ZS5wcm90b3R5cGUuZ2V0RGF5ICggKVxyXG4gIC8vIDIwLjMuNC40IERhdGUucHJvdG90eXBlLmdldEZ1bGxZZWFyICggKVxyXG4gIC8vIDIwLjMuNC41IERhdGUucHJvdG90eXBlLmdldEhvdXJzICggKVxyXG4gIC8vIDIwLjMuNC42IERhdGUucHJvdG90eXBlLmdldE1pbGxpc2Vjb25kcyAoIClcclxuICAvLyAyMC4zLjQuNyBEYXRlLnByb3RvdHlwZS5nZXRNaW51dGVzICggKVxyXG4gIC8vIDIwLjMuNC44IERhdGUucHJvdG90eXBlLmdldE1vbnRoICggKVxyXG4gIC8vIDIwLjMuNC45IERhdGUucHJvdG90eXBlLmdldFNlY29uZHMgKCApXHJcbiAgLy8gMjAuMy40LjEwIERhdGUucHJvdG90eXBlLmdldFRpbWUgKCApXHJcbiAgLy8gMjAuMy40LjExIERhdGUucHJvdG90eXBlLmdldFRpbWV6b25lT2Zmc2V0ICggKVxyXG4gIC8vIDIwLjMuNC4xMiBEYXRlLnByb3RvdHlwZS5nZXRVVENEYXRlICggKVxyXG4gIC8vIDIwLjMuNC4xMyBEYXRlLnByb3RvdHlwZS5nZXRVVENEYXkgKCApXHJcbiAgLy8gMjAuMy40LjE0IERhdGUucHJvdG90eXBlLmdldFVUQ0Z1bGxZZWFyICggKVxyXG4gIC8vIDIwLjMuNC4xNSBEYXRlLnByb3RvdHlwZS5nZXRVVENIb3VycyAoIClcclxuICAvLyAyMC4zLjQuMTYgRGF0ZS5wcm90b3R5cGUuZ2V0VVRDTWlsbGlzZWNvbmRzICggKVxyXG4gIC8vIDIwLjMuNC4xNyBEYXRlLnByb3RvdHlwZS5nZXRVVENNaW51dGVzICggKVxyXG4gIC8vIDIwLjMuNC4xOCBEYXRlLnByb3RvdHlwZS5nZXRVVENNb250aCAoIClcclxuICAvLyAyMC4zLjQuMTkgRGF0ZS5wcm90b3R5cGUuZ2V0VVRDU2Vjb25kcyAoIClcclxuICAvLyAyMC4zLjQuMjAgRGF0ZS5wcm90b3R5cGUuc2V0RGF0ZSAoIGRhdGUgKVxyXG4gIC8vIDIwLjMuNC4yMSBEYXRlLnByb3RvdHlwZS5zZXRGdWxsWWVhciAoIHllYXIgWyAsIG1vbnRoIFsgLCBkYXRlIF0gXSApXHJcbiAgLy8gMjAuMy40LjIyIERhdGUucHJvdG90eXBlLnNldEhvdXJzICggaG91ciBbICwgbWluIFsgLCBzZWMgWyAsIG1zIF0gXSBdIClcclxuICAvLyAyMC4zLjQuMjMgRGF0ZS5wcm90b3R5cGUuc2V0TWlsbGlzZWNvbmRzICggbXMgKVxyXG4gIC8vIDIwLjMuNC4yNCBEYXRlLnByb3RvdHlwZS5zZXRNaW51dGVzICggbWluIFsgLCBzZWMgWyAsIG1zIF0gXSApXHJcbiAgLy8gMjAuMy40LjI1IERhdGUucHJvdG90eXBlLnNldE1vbnRoICggbW9udGggWyAsIGRhdGUgXSApXHJcbiAgLy8gMjAuMy40LjI2IERhdGUucHJvdG90eXBlLnNldFNlY29uZHMgKCBzZWMgWyAsIG1zIF0gKVxyXG4gIC8vIDIwLjMuNC4yNyBEYXRlLnByb3RvdHlwZS5zZXRUaW1lICggdGltZSApXHJcbiAgLy8gMjAuMy40LjI4IERhdGUucHJvdG90eXBlLnNldFVUQ0RhdGUgKCBkYXRlIClcclxuICAvLyAyMC4zLjQuMjkgRGF0ZS5wcm90b3R5cGUuc2V0VVRDRnVsbFllYXIgKCB5ZWFyIFsgLCBtb250aCBbICwgZGF0ZSBdIF0gKVxyXG4gIC8vIDIwLjMuNC4zMCBEYXRlLnByb3RvdHlwZS5zZXRVVENIb3VycyAoIGhvdXIgWyAsIG1pbiBbICwgc2VjIFsgLCBtcyBdIF0gXSApXHJcbiAgLy8gMjAuMy40LjMxIERhdGUucHJvdG90eXBlLnNldFVUQ01pbGxpc2Vjb25kcyAoIG1zIClcclxuICAvLyAyMC4zLjQuMzIgRGF0ZS5wcm90b3R5cGUuc2V0VVRDTWludXRlcyAoIG1pbiBbICwgc2VjIFssIG1zIF0gXSApXHJcbiAgLy8gMjAuMy40LjMzIERhdGUucHJvdG90eXBlLnNldFVUQ01vbnRoICggbW9udGggWyAsIGRhdGUgXSApXHJcbiAgLy8gMjAuMy40LjM0IERhdGUucHJvdG90eXBlLnNldFVUQ1NlY29uZHMgKCBzZWMgWyAsIG1zIF0gKVxyXG4gIC8vIDIwLjMuNC4zNSBEYXRlLnByb3RvdHlwZS50b0RhdGVTdHJpbmcgKCApXHJcbiAgLy8gMjAuMy40LjM2IERhdGUucHJvdG90eXBlLnRvSVNPU3RyaW5nICggKVxyXG4gIC8vIDIwLjMuNC4zNyBEYXRlLnByb3RvdHlwZS50b0pTT04gKCBrZXkgKVxyXG4gIC8vIDIwLjMuNC4zOCBEYXRlLnByb3RvdHlwZS50b0xvY2FsZURhdGVTdHJpbmcgKCBbIHJlc2VydmVkMSBbICwgcmVzZXJ2ZWQyIF0gXSApXHJcbiAgLy8gMjAuMy40LjM5IERhdGUucHJvdG90eXBlLnRvTG9jYWxlU3RyaW5nICggWyByZXNlcnZlZDEgWyAsIHJlc2VydmVkMiBdIF0gKVxyXG4gIC8vIDIwLjMuNC40MCBEYXRlLnByb3RvdHlwZS50b0xvY2FsZVRpbWVTdHJpbmcgKCBbIHJlc2VydmVkMSBbICwgcmVzZXJ2ZWQyIF0gXSApXHJcbiAgLy8gMjAuMy40LjQxIERhdGUucHJvdG90eXBlLnRvU3RyaW5nICggKVxyXG4gIC8vIDIwLjMuNC40MiBEYXRlLnByb3RvdHlwZS50b1RpbWVTdHJpbmcgKCApXHJcbiAgLy8gMjAuMy40LjQzIERhdGUucHJvdG90eXBlLnRvVVRDU3RyaW5nICggKVxyXG4gIC8vIDIwLjMuNC40NCBEYXRlLnByb3RvdHlwZS52YWx1ZU9mICggKVxyXG4gIC8vIDIwLjMuNC40NSBEYXRlLnByb3RvdHlwZSBbIEBAdG9QcmltaXRpdmUgXSAoIGhpbnQgKVxyXG4gIC8vIDIwLjMuNSBQcm9wZXJ0aWVzIG9mIERhdGUgSW5zdGFuY2VzXHJcblxyXG4gIC8vIChObyBwb2x5ZmlsbGFibGUgY2hhbmdlcyBmcm9tIEVTNSlcclxuXHJcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgLy8gMjEgVGV4dCBQcm9jZXNzaW5nXHJcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG4gIHZhciBzdHJpbmdfcmVnZXhwX2Rpc3BhdGNoID0gKGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIGZhdXggPSB7fSwgc2VjcmV0ID0gU3ltYm9sKCk7XHJcbiAgICBmYXV4W1N5bWJvbC5tYXRjaF0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHNlY3JldDsgfTtcclxuICAgIHJldHVybiAoXCJcIikubWF0Y2goZmF1eCkgPT09IHNlY3JldDtcclxuICB9KCkpO1xyXG5cclxuICAvLyAyMS4xIFN0cmluZyBPYmplY3RzXHJcbiAgLy8gMjEuMS4xIFRoZSBTdHJpbmcgQ29uc3RydWN0b3JcclxuICAvLyAyMS4xLjEuMSBTdHJpbmcgKCB2YWx1ZSApXHJcbiAgLy8gMjEuMS4yIFByb3BlcnRpZXMgb2YgdGhlIFN0cmluZyBDb25zdHJ1Y3RvclxyXG4gIC8vIDIxLjEuMi4xIFN0cmluZy5mcm9tQ2hhckNvZGUgKCAuLi5jb2RlVW5pdHMgKVxyXG5cclxuICAvLyAyMS4xLjIuMiBTdHJpbmcuZnJvbUNvZGVQb2ludCAoIC4uLmNvZGVQb2ludHMgKVxyXG4gIGRlZmluZShcclxuICAgIFN0cmluZywgJ2Zyb21Db2RlUG9pbnQnLFxyXG4gICAgZnVuY3Rpb24gZnJvbUNvZGVQb2ludCgvKi4uLmNvZGVQb2ludHMqLykge1xyXG4gICAgICB2YXIgY29kZVBvaW50cyA9IGFyZ3VtZW50cyxcclxuICAgICAgICAgIGxlbmd0aCA9IGNvZGVQb2ludHMubGVuZ3RoLFxyXG4gICAgICAgICAgZWxlbWVudHMgPSBbXSxcclxuICAgICAgICAgIG5leHRJbmRleCA9IDA7XHJcbiAgICAgIHdoaWxlIChuZXh0SW5kZXggPCBsZW5ndGgpIHtcclxuICAgICAgICB2YXIgbmV4dCA9IGNvZGVQb2ludHNbbmV4dEluZGV4XTtcclxuICAgICAgICB2YXIgbmV4dENQID0gTnVtYmVyKG5leHQpO1xyXG4gICAgICAgIGlmICghU2FtZVZhbHVlKG5leHRDUCwgVG9JbnRlZ2VyKG5leHRDUCkpIHx8XHJcbiAgICAgICAgICAgIG5leHRDUCA8IDAgfHwgbmV4dENQID4gMHgxMEZGRkYpIHtcclxuICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoJ0ludmFsaWQgY29kZSBwb2ludCAnICsgbmV4dENQKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG5leHRDUCA8IDB4MTAwMDApIHtcclxuICAgICAgICAgIGVsZW1lbnRzLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShuZXh0Q1ApKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgbmV4dENQIC09IDB4MTAwMDA7XHJcbiAgICAgICAgICBlbGVtZW50cy5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoKG5leHRDUCA+PiAxMCkgKyAweEQ4MDApKTtcclxuICAgICAgICAgIGVsZW1lbnRzLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZSgobmV4dENQICUgMHg0MDApICsgMHhEQzAwKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG5leHRJbmRleCArPSAxO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBlbGVtZW50cy5qb2luKCcnKTtcclxuICAgIH0pO1xyXG5cclxuICAvLyAyMS4xLjIuMyBTdHJpbmcucHJvdG90eXBlXHJcblxyXG4gIC8vIDIxLjEuMi40IFN0cmluZy5yYXcgKCB0ZW1wbGF0ZSAsIC4uLnN1YnN0aXR1dGlvbnMgKVxyXG4gIGRlZmluZShcclxuICAgIFN0cmluZywgJ3JhdycsXHJcbiAgICBmdW5jdGlvbiByYXcodGVtcGxhdGUgLyosIC4uLnN1YnN0aXR1dGlvbnMqLykge1xyXG4gICAgICB2YXIgc3Vic3RpdHV0aW9ucyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcclxuXHJcbiAgICAgIHZhciBjb29rZWQgPSBPYmplY3QodGVtcGxhdGUpO1xyXG4gICAgICB2YXIgcmF3VmFsdWUgPSBjb29rZWRbJ3JhdyddO1xyXG4gICAgICB2YXIgcmF3ID0gT2JqZWN0KHJhd1ZhbHVlKTtcclxuICAgICAgdmFyIGxlbiA9IHJhd1snbGVuZ3RoJ107XHJcbiAgICAgIHZhciBsaXRlcmFsU2VnbWVudHMgPSBUb0xlbmd0aChsZW4pO1xyXG4gICAgICBpZiAobGl0ZXJhbFNlZ21lbnRzIDw9IDApIHJldHVybiAnJztcclxuICAgICAgdmFyIHN0cmluZ0VsZW1lbnRzID0gW107XHJcbiAgICAgIHZhciBuZXh0SW5kZXggPSAwO1xyXG4gICAgICB3aGlsZSAodHJ1ZSkge1xyXG4gICAgICAgIHZhciBuZXh0ID0gcmF3W25leHRJbmRleF07XHJcbiAgICAgICAgdmFyIG5leHRTZWcgPSBTdHJpbmcobmV4dCk7XHJcbiAgICAgICAgc3RyaW5nRWxlbWVudHMucHVzaChuZXh0U2VnKTtcclxuICAgICAgICBpZiAobmV4dEluZGV4ICsgMSA9PT0gbGl0ZXJhbFNlZ21lbnRzKVxyXG4gICAgICAgICAgcmV0dXJuIHN0cmluZ0VsZW1lbnRzLmpvaW4oJycpO1xyXG4gICAgICAgIG5leHQgPSBzdWJzdGl0dXRpb25zW25leHRJbmRleF07XHJcbiAgICAgICAgdmFyIG5leHRTdWIgPSBTdHJpbmcobmV4dCk7XHJcbiAgICAgICAgc3RyaW5nRWxlbWVudHMucHVzaChuZXh0U3ViKTtcclxuICAgICAgICBuZXh0SW5kZXggPSBuZXh0SW5kZXggKyAxO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgLy8gU2VlIGh0dHBzOi8vZ2l0aGliLmNvbS9pbmV4b3JhYmxldGFzaC91YXRlIGZvciBhIG1vcmUgdXNlZnVsIHZlcnNpb24uXHJcblxyXG4gIC8vIDIxLjEuMyBQcm9wZXJ0aWVzIG9mIHRoZSBTdHJpbmcgUHJvdG90eXBlIE9iamVjdFxyXG4gIC8vIDIxLjEuMy4xIFN0cmluZy5wcm90b3R5cGUuY2hhckF0ICggcG9zIClcclxuICAvLyAyMS4xLjMuMiBTdHJpbmcucHJvdG90eXBlLmNoYXJDb2RlQXQgKCBwb3MgKVxyXG5cclxuICAvLyAyMS4xLjMuMyBTdHJpbmcucHJvdG90eXBlLmNvZGVQb2ludEF0ICggcG9zIClcclxuICBkZWZpbmUoXHJcbiAgICBTdHJpbmcucHJvdG90eXBlLCAnY29kZVBvaW50QXQnLFxyXG4gICAgZnVuY3Rpb24gY29kZVBvaW50QXQocG9zKSB7XHJcbiAgICAgIHZhciBvID0gc3RyaWN0KHRoaXMpO1xyXG4gICAgICB2YXIgcyA9IFN0cmluZyhvKTtcclxuICAgICAgdmFyIHBvc2l0aW9uID0gVG9JbnRlZ2VyKHBvcyk7XHJcbiAgICAgIHZhciBzaXplID0gcy5sZW5ndGg7XHJcbiAgICAgIGlmIChwb3NpdGlvbiA8IDAgfHwgcG9zaXRpb24gPj0gc2l6ZSkgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgdmFyIGZpcnN0ID0gcy5jaGFyQ29kZUF0KHBvc2l0aW9uKTtcclxuICAgICAgaWYgKGZpcnN0IDwgMHhEODAwIHx8IGZpcnN0ID4gMHhEQkZGIHx8IHBvc2l0aW9uICsgMSA9PT0gc2l6ZSkgcmV0dXJuIGZpcnN0O1xyXG4gICAgICB2YXIgc2Vjb25kID0gcy5jaGFyQ29kZUF0KHBvc2l0aW9uICsgMSk7XHJcbiAgICAgIGlmIChzZWNvbmQgPCAweERDMDAgfHwgc2Vjb25kID4gMHhERkZGKSByZXR1cm4gZmlyc3Q7XHJcbiAgICAgIHJldHVybiAoKGZpcnN0IC0gMHhEODAwKSAqIDEwMjQpICsgKHNlY29uZCAtIDB4REMwMCkgKyAweDEwMDAwO1xyXG4gICAgfSk7XHJcblxyXG4gIC8vIDIxLjEuMy40IFN0cmluZy5wcm90b3R5cGUuY29uY2F0ICggLi4uYXJncyApXHJcbiAgLy8gMjEuMS4zLjUgU3RyaW5nLnByb3RvdHlwZS5jb25zdHJ1Y3RvclxyXG5cclxuICAvLyAyMS4xLjMuNiBTdHJpbmcucHJvdG90eXBlLmVuZHNXaXRoICggc2VhcmNoU3RyaW5nIFsgLCBlbmRQb3NpdGlvbl0gKVxyXG4gIGRlZmluZShcclxuICAgIFN0cmluZy5wcm90b3R5cGUsICdlbmRzV2l0aCcsXHJcbiAgICBmdW5jdGlvbiBlbmRzV2l0aChzZWFyY2hTdHJpbmcpIHtcclxuICAgICAgdmFyIGVuZFBvc2l0aW9uID0gYXJndW1lbnRzWzFdO1xyXG5cclxuICAgICAgdmFyIG8gPSBzdHJpY3QodGhpcyk7XHJcbiAgICAgIHZhciBzID0gU3RyaW5nKG8pO1xyXG4gICAgICB2YXIgc2VhcmNoU3RyID0gU3RyaW5nKHNlYXJjaFN0cmluZyk7XHJcbiAgICAgIHZhciBsZW4gPSBzLmxlbmd0aDtcclxuICAgICAgdmFyIHBvcyA9IChlbmRQb3NpdGlvbiA9PT0gdW5kZWZpbmVkKSA/IGxlbiA6IFRvSW50ZWdlcihlbmRQb3NpdGlvbik7XHJcbiAgICAgIHZhciBlbmQgPSBtaW4obWF4KHBvcywgMCksIGxlbik7XHJcbiAgICAgIHZhciBzZWFyY2hMZW5ndGggPSBzZWFyY2hTdHIubGVuZ3RoO1xyXG4gICAgICB2YXIgc3RhcnQgPSBlbmQgLSBzZWFyY2hMZW5ndGg7XHJcbiAgICAgIGlmIChzdGFydCA8IDApIHJldHVybiBmYWxzZTtcclxuICAgICAgaWYgKHMuc3Vic3RyaW5nKHN0YXJ0LCBzdGFydCArIHNlYXJjaExlbmd0aCkgPT09IHNlYXJjaFN0cikgcmV0dXJuIHRydWU7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH0pO1xyXG5cclxuICAvLyAyMS4xLjMuNyBTdHJpbmcucHJvdG90eXBlLmluY2x1ZGVzICggc2VhcmNoU3RyaW5nIFsgLCBwb3NpdGlvbiBdIClcclxuICBkZWZpbmUoXHJcbiAgICBTdHJpbmcucHJvdG90eXBlLCAnaW5jbHVkZXMnLFxyXG4gICAgZnVuY3Rpb24gaW5jbHVkZXMoc2VhcmNoU3RyaW5nKSB7XHJcbiAgICAgIHZhciBwb3NpdGlvbiA9IGFyZ3VtZW50c1sxXTtcclxuXHJcbiAgICAgIHZhciBvID0gc3RyaWN0KHRoaXMpO1xyXG4gICAgICB2YXIgcyA9IFN0cmluZyhvKTtcclxuICAgICAgdmFyIHNlYXJjaFN0ciA9IFN0cmluZyhzZWFyY2hTdHJpbmcpO1xyXG4gICAgICB2YXIgcG9zID0gVG9JbnRlZ2VyKHBvc2l0aW9uKTtcclxuICAgICAgdmFyIGxlbiA9IHMubGVuZ3RoO1xyXG4gICAgICB2YXIgc3RhcnQgPSBtaW4obWF4KHBvcywgMCksIGxlbik7XHJcbiAgICAgIHJldHVybiBzLmluZGV4T2Yoc2VhcmNoU3RyLCBzdGFydCkgIT09IC0xO1xyXG4gICAgfSk7XHJcblxyXG4gIC8vIDIxLjEuMy44IFN0cmluZy5wcm90b3R5cGUuaW5kZXhPZiAoIHNlYXJjaFN0cmluZyBbICwgcG9zaXRpb24gXSApXHJcbiAgLy8gMjEuMS4zLjkgU3RyaW5nLnByb3RvdHlwZS5sYXN0SW5kZXhPZiAoIHNlYXJjaFN0cmluZyBbICwgcG9zaXRpb24gXSApXHJcbiAgLy8gMjEuMS4zLjEwIFN0cmluZy5wcm90b3R5cGUubG9jYWxlQ29tcGFyZSAoIHRoYXQgWywgcmVzZXJ2ZWQxIFsgLCByZXNlcnZlZDIgXSBdIClcclxuICAvLyAyMS4xLjMuMTEgU3RyaW5nLnByb3RvdHlwZS5tYXRjaCAoIHJlZ2V4cCApXHJcbiAgZGVmaW5lKFxyXG4gICAgU3RyaW5nLnByb3RvdHlwZSwgJ21hdGNoJyxcclxuICAgIGZ1bmN0aW9uIG1hdGNoKHJlZ2V4cCkge1xyXG4gICAgICB2YXIgbyA9IHN0cmljdCh0aGlzKTtcclxuICAgICAgdmFyIHMgPSBTdHJpbmcobyk7XHJcbiAgICAgIGlmIChIYXNQcm9wZXJ0eShyZWdleHAsICQkbWF0Y2gpKSB2YXIgcnggPSByZWdleHA7XHJcbiAgICAgIGVsc2UgcnggPSBuZXcgUmVnRXhwKHJlZ2V4cCk7XHJcbiAgICAgIHJldHVybiByeFskJG1hdGNoXShzKTtcclxuICAgIH0sICFzdHJpbmdfcmVnZXhwX2Rpc3BhdGNoKTtcclxuXHJcbiAgLy8gMjEuMS4zLjEyIFN0cmluZy5wcm90b3R5cGUubm9ybWFsaXplICggWyBmb3JtIF0gKVxyXG5cclxuICAvLyBOb3QgcHJhY3RpY2FsIGR1ZSB0byB0YWJsZSBzaXplczsgaWYgbmVlZGVkLCBwdWxsIGluOlxyXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS93YWxsaW5nL3Vub3JtL1xyXG5cclxuICAvLyAyMS4xLjMuMTMgU3RyaW5nLnByb3RvdHlwZS5yZXBlYXQgKCBjb3VudCApXHJcbiAgZGVmaW5lKFxyXG4gICAgU3RyaW5nLnByb3RvdHlwZSwgJ3JlcGVhdCcsXHJcbiAgICBmdW5jdGlvbiByZXBlYXQoY291bnQpIHtcclxuICAgICAgdmFyIG8gPSBzdHJpY3QodGhpcyk7XHJcbiAgICAgIHZhciBzID0gU3RyaW5nKG8pO1xyXG4gICAgICB2YXIgbiA9IFRvSW50ZWdlcihjb3VudCk7XHJcbiAgICAgIGlmIChuIDwgMCkgdGhyb3cgUmFuZ2VFcnJvcigpO1xyXG4gICAgICBpZiAobiA9PT0gSW5maW5pdHkpIHRocm93IFJhbmdlRXJyb3IoKTtcclxuICAgICAgdmFyIHQgPSBuZXcgQXJyYXkobiArIDEpLmpvaW4ocyk7XHJcbiAgICAgIHJldHVybiB0O1xyXG4gICAgfSk7XHJcblxyXG4gIC8vIDIxLjEuMy4xNCBTdHJpbmcucHJvdG90eXBlLnJlcGxhY2UgKHNlYXJjaFZhbHVlLCByZXBsYWNlVmFsdWUgKVxyXG4gIGRlZmluZShcclxuICAgIFN0cmluZy5wcm90b3R5cGUsICdyZXBsYWNlJyxcclxuICAgIGZ1bmN0aW9uIHJlcGxhY2Uoc2VhcmNoVmFsdWUsIHJlcGxhY2VWYWx1ZSkge1xyXG4gICAgICB2YXIgbyA9IHN0cmljdCh0aGlzKTtcclxuICAgICAgaWYgKEhhc1Byb3BlcnR5KHNlYXJjaFZhbHVlLCAkJHJlcGxhY2UpKVxyXG4gICAgICAgIHJldHVybiBzZWFyY2hWYWx1ZVskJHJlcGxhY2VdKG8sIHJlcGxhY2VWYWx1ZSk7XHJcbiAgICAgIHJldHVybiBvcmlnX3JlcGxhY2UuY2FsbChvLCBzZWFyY2hWYWx1ZSwgcmVwbGFjZVZhbHVlKTtcclxuICAgIH0sICFzdHJpbmdfcmVnZXhwX2Rpc3BhdGNoKTtcclxuXHJcbiAgLy8gMjEuMS4zLjE1IFN0cmluZy5wcm90b3R5cGUuc2VhcmNoICggcmVnZXhwIClcclxuICBkZWZpbmUoXHJcbiAgICBTdHJpbmcucHJvdG90eXBlLCAnc2VhcmNoJyxcclxuICAgIGZ1bmN0aW9uIHNlYXJjaChyZWdleHApIHtcclxuICAgICAgdmFyIG8gPSBzdHJpY3QodGhpcyk7XHJcbiAgICAgIHZhciBzdHJpbmcgPSBTdHJpbmcobyk7XHJcbiAgICAgIGlmIChIYXNQcm9wZXJ0eShyZWdleHAsICQkc2VhcmNoKSkgdmFyIHJ4ID0gcmVnZXhwO1xyXG4gICAgICBlbHNlIHJ4ID0gbmV3IFJlZ0V4cChyZWdleHApO1xyXG4gICAgICByZXR1cm4gcnhbJCRzZWFyY2hdKHN0cmluZyk7XHJcbiAgICB9LCAhc3RyaW5nX3JlZ2V4cF9kaXNwYXRjaCk7XHJcblxyXG4gIC8vIDIxLjEuMy4xNiBTdHJpbmcucHJvdG90eXBlLnNsaWNlICggc3RhcnQsIGVuZCApXHJcbiAgLy8gMjEuMS4zLjE3IFN0cmluZy5wcm90b3R5cGUuc3BsaXQgKCBzZXBhcmF0b3IsIGxpbWl0IClcclxuICBkZWZpbmUoXHJcbiAgICBTdHJpbmcucHJvdG90eXBlLCAnc3BsaXQnLFxyXG4gICAgZnVuY3Rpb24gc3BsaXQoc2VwYXJhdG9yLCBsaW1pdCkge1xyXG4gICAgICB2YXIgbyA9IHN0cmljdCh0aGlzKTtcclxuICAgICAgaWYgKEhhc1Byb3BlcnR5KHNlcGFyYXRvciwgJCRzcGxpdCkpXHJcbiAgICAgICAgcmV0dXJuIHNlcGFyYXRvclskJHNwbGl0XShvLCBsaW1pdCk7XHJcbiAgICAgIHJldHVybiBvcmlnX3NwbGl0LmNhbGwobywgc2VwYXJhdG9yLCBsaW1pdCk7XHJcbiAgICB9LCAhc3RyaW5nX3JlZ2V4cF9kaXNwYXRjaCk7XHJcblxyXG4gIC8vIDIxLjEuMy4xOCBTdHJpbmcucHJvdG90eXBlLnN0YXJ0c1dpdGggKCBzZWFyY2hTdHJpbmcgWywgcG9zaXRpb24gXSApXHJcbiAgZGVmaW5lKFxyXG4gICAgU3RyaW5nLnByb3RvdHlwZSwgJ3N0YXJ0c1dpdGgnLFxyXG4gICAgZnVuY3Rpb24gc3RhcnRzV2l0aChzZWFyY2hTdHJpbmcpIHtcclxuICAgICAgdmFyIHBvc2l0aW9uID0gYXJndW1lbnRzWzFdO1xyXG5cclxuICAgICAgdmFyIG8gPSBzdHJpY3QodGhpcyk7XHJcbiAgICAgIHZhciBzID0gU3RyaW5nKG8pO1xyXG4gICAgICB2YXIgc2VhcmNoU3RyID0gU3RyaW5nKHNlYXJjaFN0cmluZyk7XHJcbiAgICAgIHZhciBwb3MgPSBUb0ludGVnZXIocG9zaXRpb24pO1xyXG4gICAgICB2YXIgbGVuID0gcy5sZW5ndGg7XHJcbiAgICAgIHZhciBzdGFydCA9IG1pbihtYXgocG9zLCAwKSwgbGVuKTtcclxuICAgICAgdmFyIHNlYXJjaExlbmd0aCA9IHNlYXJjaFN0ci5sZW5ndGg7XHJcbiAgICAgIGlmIChzZWFyY2hMZW5ndGggKyBzdGFydCA+IGxlbikgcmV0dXJuIGZhbHNlO1xyXG4gICAgICBpZiAocy5zdWJzdHJpbmcoc3RhcnQsIHN0YXJ0ICsgc2VhcmNoTGVuZ3RoKSA9PT0gc2VhcmNoU3RyKSByZXR1cm4gdHJ1ZTtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfSk7XHJcblxyXG4gIC8vIDIxLjEuMy4xOSBTdHJpbmcucHJvdG90eXBlLnN1YnN0cmluZyAoIHN0YXJ0LCBlbmQgKVxyXG4gIC8vIDIxLjEuMy4yMCBTdHJpbmcucHJvdG90eXBlLnRvTG9jYWxlTG93ZXJDYXNlICggWyByZXNlcnZlZDEgWyAsIHJlc2VydmVkMiBdIF0gKVxyXG4gIC8vIDIxLjEuMy4yMSBTdHJpbmcucHJvdG90eXBlLnRvTG9jYWxlVXBwZXJDYXNlIChbIHJlc2VydmVkMSBbICwgcmVzZXJ2ZWQyIF0gXSApXHJcbiAgLy8gMjEuMS4zLjIyIFN0cmluZy5wcm90b3R5cGUudG9Mb3dlckNhc2UgKCApXHJcbiAgLy8gMjEuMS4zLjIzIFN0cmluZy5wcm90b3R5cGUudG9TdHJpbmcgKCApXHJcbiAgLy8gMjEuMS4zLjI0IFN0cmluZy5wcm90b3R5cGUudG9VcHBlckNhc2UgKCApXHJcbiAgLy8gMjEuMS4zLjI1IFN0cmluZy5wcm90b3R5cGUudHJpbSAoIClcclxuICAvLyAyMS4xLjMuMjYgU3RyaW5nLnByb3RvdHlwZS52YWx1ZU9mICggKVxyXG5cclxuICAvLyAyMS4xLjMuMjcgU3RyaW5nLnByb3RvdHlwZSBbIEBAaXRlcmF0b3IgXSggKVxyXG4gIGRlZmluZShcclxuICAgIFN0cmluZy5wcm90b3R5cGUsICQkaXRlcmF0b3IsXHJcbiAgICBmdW5jdGlvbiBlbnRyaWVzKCkge1xyXG4gICAgICByZXR1cm4gQ3JlYXRlU3RyaW5nSXRlcmF0b3IodGhpcywgJ3ZhbHVlJyk7XHJcbiAgICB9KTtcclxuXHJcbiAgLy8gMjEuMS40IFByb3BlcnRpZXMgb2YgU3RyaW5nIEluc3RhbmNlc1xyXG4gIC8vIDIxLjEuNC4xIGxlbmd0aFxyXG5cclxuICAvLyAyMS4xLjUgU3RyaW5nIEl0ZXJhdG9yIE9iamVjdHNcclxuICAvKiogQGNvbnN0cnVjdG9yICovXHJcbiAgZnVuY3Rpb24gU3RyaW5nSXRlcmF0b3IoKSB7fVxyXG5cclxuICAvLyAyMS4xLjUuMSBDcmVhdGVTdHJpbmdJdGVyYXRvciBBYnN0cmFjdCBPcGVyYXRpb25cclxuICBmdW5jdGlvbiBDcmVhdGVTdHJpbmdJdGVyYXRvcihzdHJpbmcsIGtpbmQpIHtcclxuICAgIHZhciBzID0gU3RyaW5nKHN0cmluZyk7XHJcbiAgICB2YXIgaXRlcmF0b3IgPSBuZXcgU3RyaW5nSXRlcmF0b3I7XHJcbiAgICBzZXRfaW50ZXJuYWwoaXRlcmF0b3IsICdbW0l0ZXJhdGVkU3RyaW5nXV0nLCBzKTtcclxuICAgIHNldF9pbnRlcm5hbChpdGVyYXRvciwgJ1tbU3RyaW5nSXRlcmF0b3JOZXh0SW5kZXhdXScsIDApO1xyXG4gICAgc2V0X2ludGVybmFsKGl0ZXJhdG9yLCAnW1tTdHJpbmdJdGVyYXRpb25LaW5kXV0nLCBraW5kKTtcclxuICAgIHJldHVybiBpdGVyYXRvcjtcclxuICB9XHJcblxyXG4gIC8vIDIxLjEuNS4yIFRoZSAlU3RyaW5nSXRlcmF0b3JQcm90b3R5cGUlIE9iamVjdFxyXG4gIHZhciAkU3RyaW5nSXRlcmF0b3JQcm90b3R5cGUkID0gT2JqZWN0LmNyZWF0ZSgkSXRlcmF0b3JQcm90b3R5cGUkKTtcclxuICBTdHJpbmdJdGVyYXRvci5wcm90b3R5cGUgPSAkU3RyaW5nSXRlcmF0b3JQcm90b3R5cGUkO1xyXG5cclxuICAvLyAyMS4xLjUuMi4xICVTdHJpbmdJdGVyYXRvclByb3RvdHlwZSUubmV4dCAoIClcclxuICBkZWZpbmUoXHJcbiAgICAkU3RyaW5nSXRlcmF0b3JQcm90b3R5cGUkLCAnbmV4dCcsXHJcbiAgICBmdW5jdGlvbiBuZXh0KCkge1xyXG4gICAgICB2YXIgbyA9IFRvT2JqZWN0KHRoaXMpO1xyXG4gICAgICB2YXIgcyA9IFN0cmluZyhvWydbW0l0ZXJhdGVkU3RyaW5nXV0nXSksXHJcbiAgICAgICAgICBpbmRleCA9IG9bJ1tbU3RyaW5nSXRlcmF0b3JOZXh0SW5kZXhdXSddLFxyXG4gICAgICAgICAgbGVuID0gcy5sZW5ndGg7XHJcbiAgICAgIGlmIChpbmRleCA+PSBsZW4pIHtcclxuICAgICAgICBzZXRfaW50ZXJuYWwobywgJ1tbU3RyaW5nSXRlcmF0b3JOZXh0SW5kZXhdXScsIEluZmluaXR5KTtcclxuICAgICAgICByZXR1cm4gQ3JlYXRlSXRlclJlc3VsdE9iamVjdCh1bmRlZmluZWQsIHRydWUpO1xyXG4gICAgICB9XHJcbiAgICAgIHZhciBjcCA9IHMuY29kZVBvaW50QXQoaW5kZXgpO1xyXG4gICAgICBzZXRfaW50ZXJuYWwobywgJ1tbU3RyaW5nSXRlcmF0b3JOZXh0SW5kZXhdXScsIGluZGV4ICsgKGNwID4gMHhGRkZGID8gMiA6IDEpKTtcclxuICAgICAgcmV0dXJuIENyZWF0ZUl0ZXJSZXN1bHRPYmplY3QoU3RyaW5nLmZyb21Db2RlUG9pbnQoY3ApLCBmYWxzZSk7XHJcbiAgICB9KTtcclxuXHJcbiAgLy8gMjEuMS41LjIuMiAlU3RyaW5nSXRlcmF0b3JQcm90b3R5cGUlIFsgQEB0b1N0cmluZ1RhZyBdXHJcbiAgZGVmaW5lKCRTdHJpbmdJdGVyYXRvclByb3RvdHlwZSQsICQkdG9TdHJpbmdUYWcsICdTdHJpbmcgSXRlcmF0b3InKTtcclxuXHJcbiAgLy8gMjEuMS41LjMgUHJvcGVydGllcyBvZiBTdHJpbmcgSXRlcmF0b3IgSW5zdGFuY2VzXHJcblxyXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gIC8vIDIxLjIgUmVnRXhwIChSZWd1bGFyIEV4cHJlc3Npb24pIE9iamVjdHNcclxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcbiAgLy8gMjEuMi4xIFBhdHRlcm5zXHJcbiAgLy8gMjEuMi4yIFBhdHRlcm4gU2VtYW50aWNzXHJcbiAgLy8gMjEuMi4yLjEgTm90YXRpb25cclxuICAvLyAyMS4yLjIuMiBQYXR0ZXJuXHJcbiAgLy8gMjEuMi4yLjMgRGlzanVuY3Rpb25cclxuICAvLyAyMS4yLjIuNCBBbHRlcm5hdGl2ZVxyXG4gIC8vIDIxLjIuMi41IFRlcm1cclxuICAvLyAyMS4yLjIuNiBBc3NlcnRpb25cclxuICAvLyAyMS4yLjIuNyBRdWFudGlmaWVyXHJcbiAgLy8gMjEuMi4yLjggQXRvbVxyXG4gIC8vIDIxLjIuMi45IEF0b21Fc2NhcGVcclxuICAvLyAyMS4yLjIuMTAgQ2hhcmFjdGVyRXNjYXBlXHJcbiAgLy8gMjEuMi4yLjExIERlY2ltYWxFc2NhcGVcclxuICAvLyAyMS4yLjIuMTIgQ2hhcmFjdGVyQ2xhc3NFc2NhcGVcclxuICAvLyAyMS4yLjIuMTMgQ2hhcmFjdGVyQ2xhc3NcclxuICAvLyAyMS4yLjIuMTQgQ2xhc3NSYW5nZXNcclxuICAvLyAyMS4yLjIuMTUgTm9uZW1wdHlDbGFzc1Jhbmdlc1xyXG4gIC8vIDIxLjIuMi4xNiBOb25lbXB0eUNsYXNzUmFuZ2VzTm9EYXNoXHJcbiAgLy8gMjEuMi4yLjE3IENsYXNzQXRvbVxyXG4gIC8vIDIxLjIuMi4xOCBDbGFzc0F0b21Ob0Rhc2hcclxuICAvLyAyMS4yLjIuMTkgQ2xhc3NFc2NhcGVcclxuICAvLyAyMS4yLjMgVGhlIFJlZ0V4cCBDb25zdHJ1Y3RvclxyXG4gIC8vIDIxLjIuMy4xIFJlZ0V4cCAoIHBhdHRlcm4sIGZsYWdzIClcclxuICAvLyAyMS4yLjMuMiBuZXcgUmVnRXhwKCAuLi5hcmd1bWVudHNMaXN0IClcclxuICAvLyAyMS4yLjMuMyBBYnN0cmFjdCBPcGVyYXRpb25zIGZvciB0aGUgUmVnRXhwIENvbnN0cnVjdG9yXHJcbiAgLy8gMjEuMi40IFByb3BlcnRpZXMgb2YgdGhlIFJlZ0V4cCBDb25zdHJ1Y3RvclxyXG4gIC8vIDIxLjIuNC4xIFJlZ0V4cC5wcm90b3R5cGVcclxuICAvLyAyMS4yLjUgUHJvcGVydGllcyBvZiB0aGUgUmVnRXhwIFByb3RvdHlwZSBPYmplY3RcclxuICAvLyAyMS4yLjUuMSBSZWdFeHAucHJvdG90eXBlLmNvbnN0cnVjdG9yXHJcbiAgLy8gMjEuMi41LjIgUmVnRXhwLnByb3RvdHlwZS5leGVjICggc3RyaW5nIClcclxuXHJcbiAgLy8gMjEuMi41LjMgZ2V0IFJlZ0V4cC5wcm90b3R5cGUuZmxhZ3NcclxuICBpZiAoISgnZmxhZ3MnIGluIFJlZ0V4cC5wcm90b3R5cGUpKSB7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoXHJcbiAgICAgIFJlZ0V4cC5wcm90b3R5cGUsICdmbGFncycsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgdmFyIHMgPSBTdHJpbmcodGhpcyk7XHJcbiAgICAgICAgICByZXR1cm4gcy5zdWJzdHJpbmcocy5sYXN0SW5kZXhPZignLycpICsgMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICB9XHJcblxyXG4gIC8vIDIxLjIuNS40IGdldCBSZWdFeHAucHJvdG90eXBlLmdsb2JhbFxyXG4gIC8vIDIxLjIuNS41IGdldCBSZWdFeHAucHJvdG90eXBlLmlnbm9yZUNhc2VcclxuXHJcbiAgLy8gMjEuMi41LjYgUmVnRXhwLnByb3RvdHlwZSBbIEBAbWF0Y2ggXSAoIHN0cmluZyApXHJcbiAgZGVmaW5lKFJlZ0V4cC5wcm90b3R5cGUsICQkbWF0Y2gsIGZ1bmN0aW9uKHN0cmluZykge1xyXG4gICAgdmFyIG8gPSBzdHJpY3QodGhpcyk7XHJcbiAgICByZXR1cm4gb3JpZ19tYXRjaC5jYWxsKHN0cmluZywgbyk7XHJcbiAgfSk7XHJcblxyXG4gIC8vIDIxLjIuNS43IGdldCBSZWdFeHAucHJvdG90eXBlLm11bHRpbGluZVxyXG5cclxuICAvLyAyMS4yLjUuOCBSZWdFeHAucHJvdG90eXBlIFsgQEByZXBsYWNlIF0gKCBzdHJpbmcsIHJlcGxhY2VWYWx1ZSApXHJcbiAgZGVmaW5lKFJlZ0V4cC5wcm90b3R5cGUsICQkcmVwbGFjZSwgZnVuY3Rpb24oc3RyaW5nLCByZXBsYWNlVmFsdWUpIHtcclxuICAgIHZhciBvID0gc3RyaWN0KHRoaXMpO1xyXG4gICAgcmV0dXJuIG9yaWdfcmVwbGFjZS5jYWxsKHN0cmluZywgbywgcmVwbGFjZVZhbHVlKTtcclxuICB9KTtcclxuXHJcbiAgLy8gMjEuMi41LjkgUmVnRXhwLnByb3RvdHlwZSBbIEBAc2VhcmNoIF0gKCBzdHJpbmcgKVxyXG4gIGRlZmluZShSZWdFeHAucHJvdG90eXBlLCAkJHNlYXJjaCwgZnVuY3Rpb24oc3RyaW5nKSB7XHJcbiAgICB2YXIgbyA9IHN0cmljdCh0aGlzKTtcclxuICAgIHJldHVybiBvcmlnX3NlYXJjaC5jYWxsKHN0cmluZywgbyk7XHJcbiAgfSk7XHJcblxyXG4gIC8vIDIxLjIuNS4xMCBnZXQgUmVnRXhwLnByb3RvdHlwZS5zb3VyY2VcclxuXHJcbiAgLy8gMjEuMi41LjExIFJlZ0V4cC5wcm90b3R5cGUgWyBAQHNwbGl0IF0gKCBzdHJpbmcsIGxpbWl0IClcclxuICBkZWZpbmUoUmVnRXhwLnByb3RvdHlwZSwgJCRzcGxpdCwgZnVuY3Rpb24oc3RyaW5nLCBsaW1pdCkge1xyXG4gICAgdmFyIG8gPSBzdHJpY3QodGhpcyk7XHJcbiAgICByZXR1cm4gb3JpZ19zcGxpdC5jYWxsKHN0cmluZywgbywgbGltaXQpO1xyXG4gIH0pO1xyXG5cclxuICAvLyAyMS4yLjUuMTIgZ2V0IFJlZ0V4cC5wcm90b3R5cGUuc3RpY2t5XHJcbiAgLy8gMjEuMi41LjEzIFJlZ0V4cC5wcm90b3R5cGUudGVzdCggUyApXHJcbiAgLy8gMjEuMi41LjE0IFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcgKCApXHJcbiAgLy8gMjEuMi41LjE1IGdldCBSZWdFeHAucHJvdG90eXBlLnVuaWNvZGVcclxuXHJcbiAgLy8gMjEuMi42IFByb3BlcnRpZXMgb2YgUmVnRXhwIEluc3RhbmNlc1xyXG4gIC8vIDIxLjIuNi4xIGxhc3RJbmRleFxyXG5cclxuICAvLyAoTm8gcG9seWZpbGxhYmxlIGNoYW5nZXMgZnJvbSBFUzUpXHJcblxyXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gIC8vIDIyIEluZGV4ZWQgQ29sbGVjdGlvbnNcclxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgLy8gMjIuMSBBcnJheSBPYmplY3RzXHJcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG4gIC8vIDIyLjEuMSBUaGUgQXJyYXkgQ29uc3RydWN0b3JcclxuICAvLyAyMi4xLjEuMSBBcnJheSAoIClcclxuICAvLyAyMi4xLjEuMiBBcnJheSAobGVuKVxyXG4gIC8vIDIyLjEuMS4zIEFycmF5ICguLi5pdGVtcyApXHJcblxyXG4gIC8vIDIyLjEuMiBQcm9wZXJ0aWVzIG9mIHRoZSBBcnJheSBDb25zdHJ1Y3RvclxyXG5cclxuICAvLyAyMi4xLjIuMSBBcnJheS5mcm9tICggaXRlbXMgWyAsIG1hcGZuIFsgLCB0aGlzQXJnIF0gXSApXHJcbiAgZGVmaW5lKFxyXG4gICAgQXJyYXksICdmcm9tJyxcclxuICAgIGZ1bmN0aW9uIGZyb20oaXRlbXMpIHtcclxuICAgICAgdmFyIG1hcGZuID0gYXJndW1lbnRzWzFdO1xyXG4gICAgICB2YXIgdGhpc0FyZyA9IGFyZ3VtZW50c1syXTtcclxuXHJcbiAgICAgIHZhciBjID0gc3RyaWN0KHRoaXMpO1xyXG4gICAgICBpZiAobWFwZm4gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHZhciBtYXBwaW5nID0gZmFsc2U7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaWYgKCFJc0NhbGxhYmxlKG1hcGZuKSkgdGhyb3cgVHlwZUVycm9yKCk7XHJcbiAgICAgICAgdmFyIHQgPSB0aGlzQXJnO1xyXG4gICAgICAgIG1hcHBpbmcgPSB0cnVlO1xyXG4gICAgICB9XHJcbiAgICAgIHZhciB1c2luZ0l0ZXJhdG9yID0gR2V0TWV0aG9kKGl0ZW1zLCAkJGl0ZXJhdG9yKTtcclxuICAgICAgaWYgKHVzaW5nSXRlcmF0b3IgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICBpZiAoSXNDb25zdHJ1Y3RvcihjKSkge1xyXG4gICAgICAgICAgdmFyIGEgPSBuZXcgYygpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBhID0gbmV3IEFycmF5KDApO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgaXRlcmF0b3IgPSBHZXRJdGVyYXRvcihpdGVtcywgdXNpbmdJdGVyYXRvcik7XHJcbiAgICAgICAgdmFyIGsgPSAwO1xyXG4gICAgICAgIHdoaWxlICh0cnVlKSB7XHJcbiAgICAgICAgICB2YXIgbmV4dCA9IEl0ZXJhdG9yU3RlcChpdGVyYXRvcik7XHJcbiAgICAgICAgICBpZiAobmV4dCA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgYS5sZW5ndGggPSBrO1xyXG4gICAgICAgICAgICByZXR1cm4gYTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHZhciBuZXh0VmFsdWUgPSBJdGVyYXRvclZhbHVlKG5leHQpO1xyXG4gICAgICAgICAgaWYgKG1hcHBpbmcpXHJcbiAgICAgICAgICAgIHZhciBtYXBwZWRWYWx1ZSA9IG1hcGZuLmNhbGwodCwgbmV4dFZhbHVlKTtcclxuICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgbWFwcGVkVmFsdWUgPSBuZXh0VmFsdWU7XHJcbiAgICAgICAgICBhW2tdID0gbWFwcGVkVmFsdWU7XHJcbiAgICAgICAgICBrICs9IDE7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHZhciBhcnJheUxpa2UgPSBUb09iamVjdChpdGVtcyk7XHJcbiAgICAgIHZhciBsZW5WYWx1ZSA9IGFycmF5TGlrZS5sZW5ndGg7XHJcbiAgICAgIHZhciBsZW4gPSBUb0xlbmd0aChsZW5WYWx1ZSk7XHJcbiAgICAgIGlmIChJc0NvbnN0cnVjdG9yKGMpKSB7XHJcbiAgICAgICAgYSA9IG5ldyBjKGxlbik7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgYSA9IG5ldyBBcnJheShsZW4pO1xyXG4gICAgICB9XHJcbiAgICAgIGsgPSAwO1xyXG4gICAgICB3aGlsZSAoayA8IGxlbikge1xyXG4gICAgICAgIHZhciBrVmFsdWUgPSBhcnJheUxpa2Vba107XHJcbiAgICAgICAgaWYgKG1hcHBpbmcpXHJcbiAgICAgICAgICBtYXBwZWRWYWx1ZSA9IG1hcGZuLmNhbGwodCwga1ZhbHVlLCBrKTtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICBtYXBwZWRWYWx1ZSA9IGtWYWx1ZTtcclxuICAgICAgICBhW2tdID0gbWFwcGVkVmFsdWU7XHJcbiAgICAgICAgayArPSAxO1xyXG4gICAgICB9XHJcbiAgICAgIGEubGVuZ3RoID0gbGVuO1xyXG4gICAgICByZXR1cm4gYTtcclxuICAgIH0pO1xyXG5cclxuICAvLyAyMi4xLjIuMiBBcnJheS5pc0FycmF5ICggYXJnIClcclxuXHJcbiAgLy8gMjIuMS4yLjMgQXJyYXkub2YgKCAuLi5pdGVtcyApXHJcbiAgZGVmaW5lKFxyXG4gICAgQXJyYXksICdvZicsXHJcbiAgICBmdW5jdGlvbiBvZigpIHtcclxuICAgICAgdmFyIGl0ZW1zID0gYXJndW1lbnRzO1xyXG5cclxuICAgICAgdmFyIGxlblZhbHVlID0gaXRlbXMubGVuZ3RoO1xyXG4gICAgICB2YXIgbGVuID0gVG9VaW50MzIobGVuVmFsdWUpO1xyXG4gICAgICB2YXIgYyA9IHN0cmljdCh0aGlzKSwgYTtcclxuICAgICAgaWYgKElzQ29uc3RydWN0b3IoYykpIHtcclxuICAgICAgICBhID0gbmV3IGMobGVuKTtcclxuICAgICAgICBhID0gVG9PYmplY3QoYSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgYSA9IG5ldyBBcnJheShsZW4pO1xyXG4gICAgICB9XHJcbiAgICAgIHZhciBrID0gMDtcclxuICAgICAgd2hpbGUgKGsgPCBsZW4pIHtcclxuICAgICAgICBhW2tdID0gaXRlbXNba107XHJcbiAgICAgICAgayArPSAxO1xyXG4gICAgICB9XHJcbiAgICAgIGEubGVuZ3RoID0gbGVuO1xyXG4gICAgICByZXR1cm4gYTtcclxuICAgIH0pO1xyXG5cclxuICAvLyAyMi4xLjIuNCBBcnJheS5wcm90b3R5cGVcclxuICAvLyAyMi4xLjIuNSBnZXQgQXJyYXkgWyBAQHNwZWNpZXMgXVxyXG4gIC8vIDIyLjEuMyBQcm9wZXJ0aWVzIG9mIHRoZSBBcnJheSBQcm90b3R5cGUgT2JqZWN0XHJcbiAgLy8gMjIuMS4zLjEgQXJyYXkucHJvdG90eXBlLmNvbmNhdCAoIC4uLmFyZ3VtZW50cyApXHJcbiAgLy8gMjIuMS4zLjEuMSBSdW50aW1lIFNlbWFudGljczogSXNDb25jYXRTcHJlYWRhYmxlICggTyApXHJcbiAgLy8gMjIuMS4zLjIgQXJyYXkucHJvdG90eXBlLmNvbnN0cnVjdG9yXHJcbiAgLy8gMjIuMS4zLjMgQXJyYXkucHJvdG90eXBlLmNvcHlXaXRoaW4gKHRhcmdldCwgc3RhcnQgWyAsIGVuZCBdIClcclxuICBkZWZpbmUoXHJcbiAgICBBcnJheS5wcm90b3R5cGUsICdjb3B5V2l0aGluJyxcclxuICAgIGZ1bmN0aW9uIGNvcHlXaXRoaW4odGFyZ2V0LCBzdGFydC8qLCBlbmQqLykge1xyXG4gICAgICB2YXIgZW5kID0gYXJndW1lbnRzWzJdO1xyXG5cclxuICAgICAgdmFyIG8gPSBUb09iamVjdCh0aGlzKTtcclxuICAgICAgdmFyIGxlblZhbCA9IG8ubGVuZ3RoO1xyXG4gICAgICB2YXIgbGVuID0gVG9MZW5ndGgobGVuVmFsKTtcclxuICAgICAgbGVuID0gbWF4KGxlbiwgMCk7XHJcbiAgICAgIHZhciByZWxhdGl2ZVRhcmdldCA9IFRvSW50ZWdlcih0YXJnZXQpO1xyXG4gICAgICB2YXIgdG87XHJcbiAgICAgIGlmIChyZWxhdGl2ZVRhcmdldCA8IDApXHJcbiAgICAgICAgdG8gPSBtYXgobGVuICsgcmVsYXRpdmVUYXJnZXQsIDApO1xyXG4gICAgICBlbHNlXHJcbiAgICAgICAgdG8gPSBtaW4ocmVsYXRpdmVUYXJnZXQsIGxlbik7XHJcbiAgICAgIHZhciByZWxhdGl2ZVN0YXJ0ID0gVG9JbnRlZ2VyKHN0YXJ0KTtcclxuICAgICAgdmFyIGZyb207XHJcbiAgICAgIGlmIChyZWxhdGl2ZVN0YXJ0IDwgMClcclxuICAgICAgICBmcm9tID0gbWF4KGxlbiArIHJlbGF0aXZlU3RhcnQsIDApO1xyXG4gICAgICBlbHNlXHJcbiAgICAgICAgZnJvbSA9IG1pbihyZWxhdGl2ZVN0YXJ0LCBsZW4pO1xyXG4gICAgICB2YXIgcmVsYXRpdmVFbmQ7XHJcbiAgICAgIGlmIChlbmQgPT09IHVuZGVmaW5lZClcclxuICAgICAgICByZWxhdGl2ZUVuZCA9IGxlbjtcclxuICAgICAgZWxzZVxyXG4gICAgICAgIHJlbGF0aXZlRW5kID0gVG9JbnRlZ2VyKGVuZCk7XHJcbiAgICAgIHZhciBmaW5hbDtcclxuICAgICAgaWYgKHJlbGF0aXZlRW5kIDwgMClcclxuICAgICAgICBmaW5hbCA9IG1heChsZW4gKyByZWxhdGl2ZUVuZCwgMCk7XHJcbiAgICAgIGVsc2VcclxuICAgICAgICBmaW5hbCA9IG1pbihyZWxhdGl2ZUVuZCwgbGVuKTtcclxuICAgICAgdmFyIGNvdW50ID0gbWluKGZpbmFsIC0gZnJvbSwgbGVuIC0gdG8pO1xyXG4gICAgICB2YXIgZGlyZWN0aW9uO1xyXG4gICAgICBpZiAoZnJvbSA8IHRvICYmIHRvIDwgZnJvbSArIGNvdW50KSB7XHJcbiAgICAgICAgZGlyZWN0aW9uID0gLTE7XHJcbiAgICAgICAgZnJvbSA9IGZyb20gKyBjb3VudCAtIDE7XHJcbiAgICAgICAgdG8gPSB0byArIGNvdW50IC0gMTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBkaXJlY3Rpb24gPSAxO1xyXG4gICAgICB9XHJcbiAgICAgIHdoaWxlIChjb3VudCA+IDApIHtcclxuICAgICAgICB2YXIgZnJvbUtleSA9IFN0cmluZyhmcm9tKTtcclxuICAgICAgICB2YXIgdG9LZXkgPSBTdHJpbmcodG8pO1xyXG4gICAgICAgIHZhciBmcm9tUHJlc2VudCA9IEhhc1Byb3BlcnR5KG8sIGZyb21LZXkpO1xyXG4gICAgICAgIGlmIChmcm9tUHJlc2VudCkge1xyXG4gICAgICAgICAgdmFyIGZyb21WYWwgPSBvW2Zyb21LZXldO1xyXG4gICAgICAgICAgb1t0b0tleV0gPSBmcm9tVmFsO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBkZWxldGUgb1t0b0tleV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZyb20gPSBmcm9tICsgZGlyZWN0aW9uO1xyXG4gICAgICAgIHRvID0gdG8gKyBkaXJlY3Rpb247XHJcbiAgICAgICAgY291bnQgPSBjb3VudCAtIDE7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIG87XHJcbiAgICB9KTtcclxuXHJcbiAgLy8gMjIuMS4zLjQgQXJyYXkucHJvdG90eXBlLmVudHJpZXMgKCApXHJcbiAgdmFyIG5hdGl2ZUFycmF5SXRlcmF0b3JNZXRob2RzID1cclxuICAgICAgICAoJ2VudHJpZXMnIGluIEFycmF5LnByb3RvdHlwZSAmJiAnbmV4dCcgaW4gW10uZW50cmllcygpKTtcclxuXHJcbiAgZGVmaW5lKFxyXG4gICAgQXJyYXkucHJvdG90eXBlLCAnZW50cmllcycsXHJcbiAgICBmdW5jdGlvbiBlbnRyaWVzKCkge1xyXG4gICAgICByZXR1cm4gQ3JlYXRlQXJyYXlJdGVyYXRvcih0aGlzLCAna2V5K3ZhbHVlJyk7XHJcbiAgICB9LCAhbmF0aXZlQXJyYXlJdGVyYXRvck1ldGhvZHMpO1xyXG5cclxuICAvLyAyMi4xLjMuNSBBcnJheS5wcm90b3R5cGUuZXZlcnkgKCBjYWxsYmFja2ZuIFsgLCB0aGlzQXJnXSApXHJcblxyXG4gIC8vIDIyLjEuMy42IEFycmF5LnByb3RvdHlwZS5maWxsICh2YWx1ZSBbICwgc3RhcnQgWyAsIGVuZCBdIF0gKVxyXG4gIGRlZmluZShcclxuICAgIEFycmF5LnByb3RvdHlwZSwgJ2ZpbGwnLFxyXG4gICAgZnVuY3Rpb24gZmlsbCh2YWx1ZS8qLCBzdGFydCwgZW5kKi8pIHtcclxuICAgICAgdmFyIHN0YXJ0ID0gYXJndW1lbnRzWzFdLFxyXG4gICAgICAgICAgZW5kID0gYXJndW1lbnRzWzJdO1xyXG5cclxuICAgICAgdmFyIG8gPSBUb09iamVjdCh0aGlzKTtcclxuICAgICAgdmFyIGxlblZhbCA9IG8ubGVuZ3RoO1xyXG4gICAgICB2YXIgbGVuID0gVG9MZW5ndGgobGVuVmFsKTtcclxuICAgICAgbGVuID0gbWF4KGxlbiwgMCk7XHJcbiAgICAgIHZhciByZWxhdGl2ZVN0YXJ0ID0gVG9JbnRlZ2VyKHN0YXJ0KTtcclxuICAgICAgdmFyIGs7XHJcbiAgICAgIGlmIChyZWxhdGl2ZVN0YXJ0IDwgMClcclxuICAgICAgICBrID0gbWF4KChsZW4gKyByZWxhdGl2ZVN0YXJ0KSwgMCk7XHJcbiAgICAgIGVsc2VcclxuICAgICAgICBrID0gbWluKHJlbGF0aXZlU3RhcnQsIGxlbik7XHJcbiAgICAgIHZhciByZWxhdGl2ZUVuZDtcclxuICAgICAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKVxyXG4gICAgICAgIHJlbGF0aXZlRW5kID0gbGVuO1xyXG4gICAgICBlbHNlXHJcbiAgICAgICAgcmVsYXRpdmVFbmQgPSBUb0ludGVnZXIoZW5kKTtcclxuICAgICAgdmFyIGZpbmFsO1xyXG4gICAgICBpZiAocmVsYXRpdmVFbmQgPCAwKVxyXG4gICAgICAgIGZpbmFsID0gbWF4KChsZW4gKyByZWxhdGl2ZUVuZCksIDApO1xyXG4gICAgICBlbHNlXHJcbiAgICAgICAgZmluYWwgPSBtaW4ocmVsYXRpdmVFbmQsIGxlbik7XHJcbiAgICAgIHdoaWxlIChrIDwgZmluYWwpIHtcclxuICAgICAgICB2YXIgcGsgPSBTdHJpbmcoayk7XHJcbiAgICAgICAgb1twa10gPSB2YWx1ZTtcclxuICAgICAgICBrICs9IDE7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIG87XHJcbiAgICB9KTtcclxuXHJcbiAgLy8gMjIuMS4zLjcgQXJyYXkucHJvdG90eXBlLmZpbHRlciAoIGNhbGxiYWNrZm4gWyAsIHRoaXNBcmcgXSApXHJcblxyXG4gIC8vIDIyLjEuMy44IEFycmF5LnByb3RvdHlwZS5maW5kICggcHJlZGljYXRlIFsgLCB0aGlzQXJnIF0gKVxyXG4gIGRlZmluZShcclxuICAgIEFycmF5LnByb3RvdHlwZSwgJ2ZpbmQnLFxyXG4gICAgZnVuY3Rpb24gZmluZChwcmVkaWNhdGUpIHtcclxuICAgICAgdmFyIG8gPSBUb09iamVjdCh0aGlzKTtcclxuICAgICAgdmFyIGxlblZhbHVlID0gby5sZW5ndGg7XHJcbiAgICAgIHZhciBsZW4gPSBUb0ludGVnZXIobGVuVmFsdWUpO1xyXG4gICAgICBpZiAoIUlzQ2FsbGFibGUocHJlZGljYXRlKSkgdGhyb3cgVHlwZUVycm9yKCk7XHJcbiAgICAgIHZhciB0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQ7XHJcbiAgICAgIHZhciBrID0gMDtcclxuICAgICAgd2hpbGUgKGsgPCBsZW4pIHtcclxuICAgICAgICB2YXIgcGsgPSBTdHJpbmcoayk7XHJcbiAgICAgICAgdmFyIGtQcmVzZW50ID0gSGFzUHJvcGVydHkobywgcGspO1xyXG4gICAgICAgIGlmIChrUHJlc2VudCkge1xyXG4gICAgICAgICAgdmFyIGtWYWx1ZSA9IG9bcGtdO1xyXG4gICAgICAgICAgdmFyIHRlc3RSZXN1bHQgPSBwcmVkaWNhdGUuY2FsbCh0LCBrVmFsdWUsIGssIG8pO1xyXG4gICAgICAgICAgaWYgKEJvb2xlYW4odGVzdFJlc3VsdCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGtWYWx1ZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgKytrO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICB9KTtcclxuXHJcbiAgLy8gMjIuMS4zLjkgQXJyYXkucHJvdG90eXBlLmZpbmRJbmRleCAoIHByZWRpY2F0ZSBbICwgdGhpc0FyZyBdIClcclxuICBkZWZpbmUoXHJcbiAgICBBcnJheS5wcm90b3R5cGUsICdmaW5kSW5kZXgnLFxyXG4gICAgZnVuY3Rpb24gZmluZEluZGV4KHByZWRpY2F0ZSkge1xyXG4gICAgICB2YXIgbyA9IFRvT2JqZWN0KHRoaXMpO1xyXG4gICAgICB2YXIgbGVuVmFsdWUgPSBvLmxlbmd0aDtcclxuICAgICAgdmFyIGxlbiA9IFRvTGVuZ3RoKGxlblZhbHVlKTtcclxuICAgICAgaWYgKCFJc0NhbGxhYmxlKHByZWRpY2F0ZSkpIHRocm93IFR5cGVFcnJvcigpO1xyXG4gICAgICB2YXIgdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkO1xyXG4gICAgICB2YXIgayA9IDA7XHJcbiAgICAgIHdoaWxlIChrIDwgbGVuKSB7XHJcbiAgICAgICAgdmFyIHBrID0gU3RyaW5nKGspO1xyXG4gICAgICAgIHZhciBrUHJlc2VudCA9IEhhc1Byb3BlcnR5KG8sIHBrKTtcclxuICAgICAgICBpZiAoa1ByZXNlbnQpIHtcclxuICAgICAgICAgIHZhciBrVmFsdWUgPSBvW3BrXTtcclxuICAgICAgICAgIHZhciB0ZXN0UmVzdWx0ID0gcHJlZGljYXRlLmNhbGwodCwga1ZhbHVlLCBrLCBvKTtcclxuICAgICAgICAgIGlmIChCb29sZWFuKHRlc3RSZXN1bHQpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBrO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICArK2s7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIC0xO1xyXG4gICAgfSk7XHJcblxyXG4gIC8vIDIyLjEuMy4xMCBBcnJheS5wcm90b3R5cGUuZm9yRWFjaCAoIGNhbGxiYWNrZm4gWyAsIHRoaXNBcmcgXSApXHJcbiAgLy8gMjIuMS4zLjExIEFycmF5LnByb3RvdHlwZS5pbmRleE9mICggc2VhcmNoRWxlbWVudCBbICwgZnJvbUluZGV4IF0gKVxyXG4gIC8vIDIyLjEuMy4xMiBBcnJheS5wcm90b3R5cGUuam9pbiAoc2VwYXJhdG9yKVxyXG5cclxuICAvLyAyMi4xLjMuMTMgQXJyYXkucHJvdG90eXBlLmtleXMgKCApXHJcbiAgZGVmaW5lKFxyXG4gICAgQXJyYXkucHJvdG90eXBlLCAna2V5cycsXHJcbiAgICBmdW5jdGlvbiBrZXlzKCkge1xyXG4gICAgICByZXR1cm4gQ3JlYXRlQXJyYXlJdGVyYXRvcih0aGlzLCAna2V5Jyk7XHJcbiAgICB9LCAhbmF0aXZlQXJyYXlJdGVyYXRvck1ldGhvZHMpO1xyXG5cclxuICAvLyAyMi4xLjMuMTQgQXJyYXkucHJvdG90eXBlLmxhc3RJbmRleE9mICggc2VhcmNoRWxlbWVudCBbICwgZnJvbUluZGV4IF0gKVxyXG4gIC8vIDIyLjEuMy4xNSBBcnJheS5wcm90b3R5cGUubWFwICggY2FsbGJhY2tmbiBbICwgdGhpc0FyZyBdIClcclxuICAvLyAyMi4xLjMuMTYgQXJyYXkucHJvdG90eXBlLnBvcCAoIClcclxuICAvLyAyMi4xLjMuMTcgQXJyYXkucHJvdG90eXBlLnB1c2ggKCAuLi5pdGVtcyApXHJcbiAgLy8gMjIuMS4zLjE4IEFycmF5LnByb3RvdHlwZS5yZWR1Y2UgKCBjYWxsYmFja2ZuIFsgLCBpbml0aWFsVmFsdWUgXSApXHJcbiAgLy8gMjIuMS4zLjE5IEFycmF5LnByb3RvdHlwZS5yZWR1Y2VSaWdodCAoIGNhbGxiYWNrZm4gWyAsIGluaXRpYWxWYWx1ZSBdIClcclxuICAvLyAyMi4xLjMuMjAgQXJyYXkucHJvdG90eXBlLnJldmVyc2UgKCApXHJcbiAgLy8gMjIuMS4zLjIxIEFycmF5LnByb3RvdHlwZS5zaGlmdCAoIClcclxuICAvLyAyMi4xLjMuMjIgQXJyYXkucHJvdG90eXBlLnNsaWNlIChzdGFydCwgZW5kKVxyXG4gIC8vIDIyLjEuMy4yMyBBcnJheS5wcm90b3R5cGUuc29tZSAoIGNhbGxiYWNrZm4gWyAsIHRoaXNBcmcgXSApXHJcbiAgLy8gMjIuMS4zLjI0IEFycmF5LnByb3RvdHlwZS5zb3J0IChjb21wYXJlZm4pXHJcbiAgLy8gMjIuMS4zLjI1IEFycmF5LnByb3RvdHlwZS5zcGxpY2UgKHN0YXJ0LCBkZWxldGVDb3VudCAsIC4uLml0ZW1zIClcclxuICAvLyAyMi4xLjMuMjYgQXJyYXkucHJvdG90eXBlLnRvTG9jYWxlU3RyaW5nICggWyByZXNlcnZlZDEgWyAsIHJlc2VydmVkMiBdIF0gKVxyXG4gIC8vIDIyLjEuMy4yNyBBcnJheS5wcm90b3R5cGUudG9TdHJpbmcgKCApXHJcbiAgLy8gMjIuMS4zLjI4IEFycmF5LnByb3RvdHlwZS51bnNoaWZ0ICggLi4uaXRlbXMgKVxyXG5cclxuICAvLyAyMi4xLjMuMjkgQXJyYXkucHJvdG90eXBlLnZhbHVlcyAoIClcclxuICBkZWZpbmUoXHJcbiAgICBBcnJheS5wcm90b3R5cGUsICd2YWx1ZXMnLFxyXG4gICAgZnVuY3Rpb24gdmFsdWVzKCkge1xyXG4gICAgICByZXR1cm4gQ3JlYXRlQXJyYXlJdGVyYXRvcih0aGlzLCAndmFsdWUnKTtcclxuICAgIH0sICFuYXRpdmVBcnJheUl0ZXJhdG9yTWV0aG9kcyk7XHJcblxyXG4gIC8vIDIyLjEuMy4zMCBBcnJheS5wcm90b3R5cGUgWyBAQGl0ZXJhdG9yIF0gKCApXHJcbiAgZGVmaW5lKFxyXG4gICAgQXJyYXkucHJvdG90eXBlLCAkJGl0ZXJhdG9yLFxyXG4gICAgQXJyYXkucHJvdG90eXBlLnZhbHVlc1xyXG4gICAgKTtcclxuXHJcbiAgLy8gMjIuMS4zLjMxIEFycmF5LnByb3RvdHlwZSBbIEBAdW5zY29wYWJsZXMgXVxyXG4gIC8vIDIyLjEuNCBQcm9wZXJ0aWVzIG9mIEFycmF5IEluc3RhbmNlc1xyXG4gIC8vIDIyLjEuNC4xIGxlbmd0aFxyXG5cclxuICAvLyAyMi4xLjUgQXJyYXkgSXRlcmF0b3IgT2JqZWN0c1xyXG4gIGZ1bmN0aW9uIEFycmF5SXRlcmF0b3IoKSB7fVxyXG5cclxuICAvLyAyMi4xLjUuMSBDcmVhdGVBcnJheUl0ZXJhdG9yIEFic3RyYWN0IE9wZXJhdGlvblxyXG4gIGZ1bmN0aW9uIENyZWF0ZUFycmF5SXRlcmF0b3IoYXJyYXksIGtpbmQpIHtcclxuICAgIHZhciBvID0gVG9PYmplY3QoYXJyYXkpO1xyXG4gICAgdmFyIGl0ZXJhdG9yID0gbmV3IEFycmF5SXRlcmF0b3I7XHJcbiAgICBzZXRfaW50ZXJuYWwoaXRlcmF0b3IsICdbW0l0ZXJhdGVkT2JqZWN0XV0nLCBvKTtcclxuICAgIHNldF9pbnRlcm5hbChpdGVyYXRvciwgJ1tbQXJyYXlJdGVyYXRvck5leHRJbmRleF1dJywgMCk7XHJcbiAgICBzZXRfaW50ZXJuYWwoaXRlcmF0b3IsICdbW0FycmF5SXRlcmF0aW9uS2luZF1dJywga2luZCk7XHJcbiAgICByZXR1cm4gaXRlcmF0b3I7XHJcbiAgfVxyXG5cclxuICAvLyAyMi4xLjUuMiBUaGUgJUFycmF5SXRlcmF0b3JQcm90b3R5cGUlIE9iamVjdFxyXG4gIHZhciAkQXJyYXlJdGVyYXRvclByb3RvdHlwZSQgPSBPYmplY3QuY3JlYXRlKCRJdGVyYXRvclByb3RvdHlwZSQpO1xyXG4gIEFycmF5SXRlcmF0b3IucHJvdG90eXBlID0gJEFycmF5SXRlcmF0b3JQcm90b3R5cGUkO1xyXG5cclxuICAvLyAyMi4xLjUuMi4xICVBcnJheUl0ZXJhdG9yUHJvdG90eXBlJS4gbmV4dCggKVxyXG4gIGRlZmluZShcclxuICAgICRBcnJheUl0ZXJhdG9yUHJvdG90eXBlJCwgJ25leHQnLFxyXG4gICAgZnVuY3Rpb24gbmV4dCgpIHtcclxuICAgICAgdmFyIG8gPSBzdHJpY3QodGhpcyk7XHJcbiAgICAgIGlmIChUeXBlKG8pICE9PSAnb2JqZWN0JykgdGhyb3cgVHlwZUVycm9yKCk7XHJcbiAgICAgIHZhciBhID0gb1snW1tJdGVyYXRlZE9iamVjdF1dJ10sXHJcbiAgICAgICAgICBpbmRleCA9IG9bJ1tbQXJyYXlJdGVyYXRvck5leHRJbmRleF1dJ10sXHJcbiAgICAgICAgICBpdGVtS2luZCA9IG9bJ1tbQXJyYXlJdGVyYXRpb25LaW5kXV0nXSxcclxuICAgICAgICAgIGxlblZhbHVlID0gYS5sZW5ndGgsXHJcbiAgICAgICAgICBsZW4gPSBUb1VpbnQzMihsZW5WYWx1ZSksXHJcbiAgICAgICAgICBlbGVtZW50S2V5LFxyXG4gICAgICAgICAgZWxlbWVudFZhbHVlO1xyXG4gICAgICBpZiAoaXRlbUtpbmQuaW5kZXhPZignc3BhcnNlJykgIT09IC0xKSB7XHJcbiAgICAgICAgdmFyIGZvdW5kID0gZmFsc2U7XHJcbiAgICAgICAgd2hpbGUgKCFmb3VuZCAmJiBpbmRleCA8IGxlbikge1xyXG4gICAgICAgICAgZWxlbWVudEtleSA9IFN0cmluZyhpbmRleCk7XHJcbiAgICAgICAgICBmb3VuZCA9IEhhc1Byb3BlcnR5KGEsIGVsZW1lbnRLZXkpO1xyXG4gICAgICAgICAgaWYgKCFmb3VuZCkge1xyXG4gICAgICAgICAgICBpbmRleCArPSAxO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBpZiAoaW5kZXggPj0gbGVuKSB7XHJcbiAgICAgICAgc2V0X2ludGVybmFsKG8sICdbW0FycmF5SXRlcmF0b3JOZXh0SW5kZXhdXScsIEluZmluaXR5KTtcclxuICAgICAgICByZXR1cm4gQ3JlYXRlSXRlclJlc3VsdE9iamVjdCh1bmRlZmluZWQsIHRydWUpO1xyXG4gICAgICB9XHJcbiAgICAgIGVsZW1lbnRLZXkgPSBpbmRleDtcclxuICAgICAgc2V0X2ludGVybmFsKG8sICdbW0FycmF5SXRlcmF0b3JOZXh0SW5kZXhdXScsIGluZGV4ICsgMSk7XHJcbiAgICAgIGlmIChpdGVtS2luZC5pbmRleE9mKCd2YWx1ZScpICE9PSAtMSlcclxuICAgICAgICBlbGVtZW50VmFsdWUgPSBhW2VsZW1lbnRLZXldO1xyXG4gICAgICBpZiAoaXRlbUtpbmQuaW5kZXhPZigna2V5K3ZhbHVlJykgIT09IC0xKVxyXG4gICAgICAgIHJldHVybiBDcmVhdGVJdGVyUmVzdWx0T2JqZWN0KFtlbGVtZW50S2V5LCBlbGVtZW50VmFsdWVdLCBmYWxzZSk7XHJcbiAgICAgIGlmIChpdGVtS2luZC5pbmRleE9mKCdrZXknKSAhPT0gLTEpXHJcbiAgICAgICAgcmV0dXJuIENyZWF0ZUl0ZXJSZXN1bHRPYmplY3QoZWxlbWVudEtleSwgZmFsc2UpO1xyXG4gICAgICBpZiAoaXRlbUtpbmQgPT09ICd2YWx1ZScpXHJcbiAgICAgICAgcmV0dXJuIENyZWF0ZUl0ZXJSZXN1bHRPYmplY3QoZWxlbWVudFZhbHVlLCBmYWxzZSk7XHJcbiAgICAgIHRocm93IEVycm9yKCdJbnRlcm5hbCBlcnJvcicpO1xyXG4gICAgfSk7XHJcblxyXG4gIC8vIDIyLjEuNS4yLjIgJUFycmF5SXRlcmF0b3JQcm90b3R5cGUlIFsgQEB0b1N0cmluZ1RhZyBdXHJcbiAgZGVmaW5lKCRBcnJheUl0ZXJhdG9yUHJvdG90eXBlJCwgJCR0b1N0cmluZ1RhZywgJ0FycmF5IEl0ZXJhdG9yJyk7XHJcblxyXG4gIC8vIDIyLjEuNS4zIFByb3BlcnRpZXMgb2YgQXJyYXkgSXRlcmF0b3IgSW5zdGFuY2VzXHJcblxyXG5cclxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAvLyAyMi4yIFR5cGVkQXJyYXkgT2JqZWN0c1xyXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cclxuICAvLyBTZWUgdHlwZWRhcnJheS5qcyBmb3IgVHlwZWRBcnJheSBwb2x5ZmlsbFxyXG5cclxuICBbJ0ludDhBcnJheScsICdVaW50OEFycmF5JywgJ1VpbnQ4Q2xhbXBlZEFycmF5JyxcclxuICAgJ0ludDE2QXJyYXknLCAnVWludDE2QXJyYXknLFxyXG4gICAnSW50MzJBcnJheScsICdVaW50MzJBcnJheScsXHJcbiAgICdGbG9hdDMyQXJyYXknLCAnRmxvYXQ2NEFycmF5J10uZm9yRWFjaChmdW5jdGlvbiAoJFR5cGVkQXJyYXlOYW1lJCkge1xyXG4gICAgIGlmICghKCRUeXBlZEFycmF5TmFtZSQgaW4gZ2xvYmFsKSlcclxuICAgICAgIHJldHVybjtcclxuICAgICB2YXIgJFR5cGVkQXJyYXkkID0gZ2xvYmFsWyRUeXBlZEFycmF5TmFtZSRdO1xyXG5cclxuICAgICAvLyAyMi4yLjEgVGhlICVUeXBlZEFycmF5JSBJbnRyaW5zaWMgT2JqZWN0XHJcbiAgICAgLy8gMjIuMi4xLjEgJVR5cGVkQXJyYXklICggbGVuZ3RoIClcclxuICAgICAvLyAyMi4yLjEuMiAlVHlwZWRBcnJheSUgKCB0eXBlZEFycmF5IClcclxuICAgICAvLyAyMi4yLjEuMyAlVHlwZWRBcnJheSUgKCBvYmplY3QgKVxyXG4gICAgIC8vIDIyLjIuMS40ICVUeXBlZEFycmF5JSAoIGJ1ZmZlciBbICwgYnl0ZU9mZnNldCBbICwgbGVuZ3RoIF0gXSApXHJcbiAgICAgLy8gMjIuMi4xLjUgJVR5cGVkQXJyYXklICggYWxsIG90aGVyIGFyZ3VtZW50IGNvbWJpbmF0aW9ucyApXHJcbiAgICAgLy8gMjIuMi4yIFByb3BlcnRpZXMgb2YgdGhlICVUeXBlZEFycmF5JSBJbnRyaW5zaWMgT2JqZWN0XHJcblxyXG4gICAgIC8vIDIyLjIuMi4xICVUeXBlZEFycmF5JS5mcm9tICggc291cmNlIFsgLCBtYXBmbiBbICwgdGhpc0FyZyBdIF0gKVxyXG4gICAgIGRlZmluZShcclxuICAgICAgICRUeXBlZEFycmF5JCwgJ2Zyb20nLFxyXG4gICAgICAgZnVuY3Rpb24gZnJvbShzb3VyY2UpIHtcclxuICAgICAgICAgdmFyIG1hcGZuID0gYXJndW1lbnRzWzFdO1xyXG4gICAgICAgICB2YXIgdGhpc0FyZyA9IGFyZ3VtZW50c1syXTtcclxuXHJcbiAgICAgICAgIHZhciBjID0gc3RyaWN0KHRoaXMpO1xyXG4gICAgICAgICBpZiAoIUlzQ29uc3RydWN0b3IoYykpIHRocm93IFR5cGVFcnJvcigpO1xyXG4gICAgICAgICBpZiAobWFwZm4gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgIHZhciBtYXBwaW5nID0gZmFsc2U7XHJcbiAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgaWYgKElzQ2FsbGFibGUobWFwZm4pKSB0aHJvdyBUeXBlRXJyb3IoKTtcclxuICAgICAgICAgICB2YXIgdCA9IHRoaXNBcmc7XHJcbiAgICAgICAgICAgbWFwcGluZyA9IHRydWU7XHJcbiAgICAgICAgIH1cclxuICAgICAgICAgdmFyIHVzaW5nSXRlcmF0b3IgPSBHZXRNZXRob2Qoc291cmNlLCAkJGl0ZXJhdG9yKTtcclxuICAgICAgICAgaWYgKHVzaW5nSXRlcmF0b3IgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgIHZhciBpdGVyYXRvciA9IEdldEl0ZXJhdG9yKHNvdXJjZSwgdXNpbmdJdGVyYXRvcik7XHJcbiAgICAgICAgICAgdmFyIHZhbHVlcyA9IFtdO1xyXG4gICAgICAgICAgIHZhciBuZXh0ID0gdHJ1ZTtcclxuICAgICAgICAgICB3aGlsZSAobmV4dCAhPT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgIG5leHQgPSBJdGVyYXRvclN0ZXAoaXRlcmF0b3IpO1xyXG4gICAgICAgICAgICAgaWYgKG5leHQgIT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgIHZhciBuZXh0VmFsdWUgPSBJdGVyYXRvclZhbHVlKG5leHQpO1xyXG4gICAgICAgICAgICAgICB2YWx1ZXMucHVzaChuZXh0VmFsdWUpO1xyXG4gICAgICAgICAgICAgfVxyXG4gICAgICAgICAgIH1cclxuICAgICAgICAgICB2YXIgbGVuID0gdmFsdWVzLmxlbmd0aDtcclxuICAgICAgICAgICB2YXIgbmV3T2JqID0gbmV3IGMobGVuKTtcclxuICAgICAgICAgICB2YXIgayA9IDA7XHJcbiAgICAgICAgICAgd2hpbGUgKGsgPCBsZW4pIHtcclxuICAgICAgICAgICAgIHZhciBrVmFsdWUgPSB2YWx1ZXMuc2hpZnQoKTtcclxuICAgICAgICAgICAgIGlmIChtYXBwaW5nKSB7XHJcbiAgICAgICAgICAgICAgIHZhciBtYXBwZWRWYWx1ZSA9IG1hcGZuLmNhbGwodCwga1ZhbHVlKTtcclxuICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgIG1hcHBlZFZhbHVlID0ga1ZhbHVlO1xyXG4gICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgbmV3T2JqW2tdID0gbWFwcGVkVmFsdWU7XHJcbiAgICAgICAgICAgICArK2s7XHJcbiAgICAgICAgICAgfVxyXG4gICAgICAgICAgIGNvbnNvbGUuYXNzZXJ0KHZhbHVlcy5sZW5ndGggPT09IDApO1xyXG4gICAgICAgICAgIHJldHVybiBuZXdPYmo7XHJcbiAgICAgICAgIH1cclxuICAgICAgICAgdmFyIGFycmF5TGlrZSA9IFRvT2JqZWN0KHNvdXJjZSk7XHJcbiAgICAgICAgIHZhciBsZW5WYWx1ZSA9IGFycmF5TGlrZS5sZW5ndGg7XHJcbiAgICAgICAgIGxlbiA9IFRvTGVuZ3RoKGxlblZhbHVlKTtcclxuICAgICAgICAgbmV3T2JqID0gbmV3IGMobGVuKTtcclxuICAgICAgICAgayA9IDA7XHJcbiAgICAgICAgIHdoaWxlIChrIDwgbGVuKSB7XHJcbiAgICAgICAgICAga1ZhbHVlID0gYXJyYXlMaWtlW2tdO1xyXG4gICAgICAgICAgIGlmIChtYXBwaW5nKSB7XHJcbiAgICAgICAgICAgICBtYXBwZWRWYWx1ZSA9IG1hcGZuLmNhbGwodCwga1ZhbHVlLCBrKTtcclxuICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgbWFwcGVkVmFsdWUgPSBrVmFsdWU7XHJcbiAgICAgICAgICAgfVxyXG4gICAgICAgICAgIG5ld09ialtrXSA9IG1hcHBlZFZhbHVlO1xyXG4gICAgICAgICAgICsraztcclxuICAgICAgICAgfVxyXG4gICAgICAgICByZXR1cm4gbmV3T2JqO1xyXG4gICAgICAgfSk7XHJcblxyXG4gICAgIC8vIDIyLjIuMi4yICVUeXBlZEFycmF5JS5vZiAoIC4uLml0ZW1zIClcclxuICAgICBkZWZpbmUoXHJcbiAgICAgICAkVHlwZWRBcnJheSQsICdvZicsXHJcbiAgICAgICBmdW5jdGlvbiBvZigpIHtcclxuICAgICAgICAgdmFyIGl0ZW1zID0gYXJndW1lbnRzO1xyXG5cclxuICAgICAgICAgdmFyIGxlbiA9IGl0ZW1zLmxlbmd0aDtcclxuICAgICAgICAgdmFyIGMgPSBzdHJpY3QodGhpcyk7XHJcbiAgICAgICAgIHZhciBuZXdPYmogPSBuZXcgYyhsZW4pO1xyXG4gICAgICAgICB2YXIgayA9IDA7XHJcbiAgICAgICAgIHdoaWxlIChrIDwgbGVuKSB7XHJcbiAgICAgICAgICAgbmV3T2JqW2tdID0gaXRlbXNba107XHJcbiAgICAgICAgICAgKytrO1xyXG4gICAgICAgICB9XHJcbiAgICAgICAgIHJldHVybiBuZXdPYmo7XHJcbiAgICAgICB9KTtcclxuXHJcbiAgICAgLy8gMjIuMi4yLjMgJVR5cGVkQXJyYXklLnByb3RvdHlwZVxyXG4gICAgIC8vIDIyLjIuMi40IGdldCAlVHlwZWRBcnJheSUgWyBAQHNwZWNpZXMgXVxyXG4gICAgIC8vIDIyLjIuMyBQcm9wZXJ0aWVzIG9mIHRoZSAlVHlwZWRBcnJheVByb3RvdHlwZSUgT2JqZWN0XHJcbiAgICAgLy8gMjIuMi4zLjEgZ2V0ICVUeXBlZEFycmF5JS5wcm90b3R5cGUuYnVmZmVyXHJcbiAgICAgLy8gMjIuMi4zLjIgZ2V0ICVUeXBlZEFycmF5JS5wcm90b3R5cGUuYnl0ZUxlbmd0aFxyXG4gICAgIC8vIDIyLjIuMy4zIGdldCAlVHlwZWRBcnJheSUucHJvdG90eXBlLmJ5dGVPZmZzZXRcclxuICAgICAvLyAyMi4yLjMuNCAlVHlwZWRBcnJheSUucHJvdG90eXBlLmNvbnN0cnVjdG9yXHJcblxyXG4gICAgIC8vIDIyLjIuMy41ICVUeXBlZEFycmF5JS5wcm90b3R5cGUuY29weVdpdGhpbiAodGFyZ2V0LCBzdGFydCBbLCBlbmQgXSApXHJcbiAgICAgZGVmaW5lKCRUeXBlZEFycmF5JC5wcm90b3R5cGUsICdjb3B5V2l0aGluJywgQXJyYXkucHJvdG90eXBlLmNvcHlXaXRoaW4pO1xyXG5cclxuICAgICAvLyAyMi4yLjMuNiAlVHlwZWRBcnJheSUucHJvdG90eXBlLmVudHJpZXMgKCApXHJcbiAgICAgZGVmaW5lKCRUeXBlZEFycmF5JC5wcm90b3R5cGUsICdlbnRyaWVzJywgQXJyYXkucHJvdG90eXBlLmVudHJpZXMpO1xyXG5cclxuICAgICAvLyAyMi4yLjMuNyAlVHlwZWRBcnJheSUucHJvdG90eXBlLmV2ZXJ5ICggY2FsbGJhY2tmbiBbICwgdGhpc0FyZyBdIClcclxuICAgICBkZWZpbmUoJFR5cGVkQXJyYXkkLnByb3RvdHlwZSwgJ2V2ZXJ5JywgQXJyYXkucHJvdG90eXBlLmV2ZXJ5KTtcclxuXHJcbiAgICAgLy8gMjIuMi4zLjggJVR5cGVkQXJyYXklLnByb3RvdHlwZS5maWxsICh2YWx1ZSBbICwgc3RhcnQgWyAsIGVuZCBdIF0gKVxyXG4gICAgIGRlZmluZShcclxuICAgICAgICRUeXBlZEFycmF5JC5wcm90b3R5cGUsICdmaWxsJyxcclxuICAgICAgIC8vQXJyYXkucHJvdG90eXBlLmZpbGwgLy8gRG9lc24ndCB3b3JrIGluIFNhZmFyaSA3XHJcbiAgICAgICBmdW5jdGlvbiBmaWxsKHZhbHVlLyosIHN0YXJ0LCBlbmQqLykge1xyXG4gICAgICAgICB2YXIgc3RhcnQgPSBhcmd1bWVudHNbMV0sXHJcbiAgICAgICAgICAgICBlbmQgPSBhcmd1bWVudHNbMl07XHJcblxyXG4gICAgICAgICB2YXIgbyA9IFRvT2JqZWN0KHRoaXMpO1xyXG4gICAgICAgICB2YXIgbGVuVmFsID0gby5sZW5ndGg7XHJcbiAgICAgICAgIHZhciBsZW4gPSBUb0xlbmd0aChsZW5WYWwpO1xyXG4gICAgICAgICBsZW4gPSBtYXgobGVuLCAwKTtcclxuICAgICAgICAgdmFyIHJlbGF0aXZlU3RhcnQgPSBUb0ludGVnZXIoc3RhcnQpO1xyXG4gICAgICAgICB2YXIgaztcclxuICAgICAgICAgaWYgKHJlbGF0aXZlU3RhcnQgPCAwKSBrID0gbWF4KChsZW4gKyByZWxhdGl2ZVN0YXJ0KSwgMCk7XHJcbiAgICAgICAgIGVsc2UgayA9IG1pbihyZWxhdGl2ZVN0YXJ0LCBsZW4pO1xyXG4gICAgICAgICB2YXIgcmVsYXRpdmVFbmQ7XHJcbiAgICAgICAgIGlmIChlbmQgPT09IHVuZGVmaW5lZCkgcmVsYXRpdmVFbmQgPSBsZW47XHJcbiAgICAgICAgIGVsc2UgcmVsYXRpdmVFbmQgPSBUb0ludGVnZXIoZW5kKTtcclxuICAgICAgICAgdmFyIGZpbmFsO1xyXG4gICAgICAgICBpZiAocmVsYXRpdmVFbmQgPCAwKSBmaW5hbCA9IG1heCgobGVuICsgcmVsYXRpdmVFbmQpLCAwKTtcclxuICAgICAgICAgZWxzZSBmaW5hbCA9IG1pbihyZWxhdGl2ZUVuZCwgbGVuKTtcclxuICAgICAgICAgd2hpbGUgKGsgPCBmaW5hbCkge1xyXG4gICAgICAgICAgIHZhciBwayA9IFN0cmluZyhrKTtcclxuICAgICAgICAgICBvW3BrXSA9IHZhbHVlO1xyXG4gICAgICAgICAgIGsgKz0gMTtcclxuICAgICAgICAgfVxyXG4gICAgICAgICByZXR1cm4gbztcclxuICAgICAgIH0pO1xyXG5cclxuICAgICAvLyAyMi4yLjMuOSAlVHlwZWRBcnJheSUucHJvdG90eXBlLmZpbHRlciAoIGNhbGxiYWNrZm4gWyAsIHRoaXNBcmcgXSApXHJcbiAgICAgZGVmaW5lKFxyXG4gICAgICAgJFR5cGVkQXJyYXkkLnByb3RvdHlwZSwgJ2ZpbHRlcicsXHJcbiAgICAgICBmdW5jdGlvbiBmaWx0ZXIoY2FsbGJhY2tmbikge1xyXG4gICAgICAgICB2YXIgdGhpc0FyZyA9IGFyZ3VtZW50c1sxXTtcclxuXHJcbiAgICAgICAgIHZhciBvID0gVG9PYmplY3QodGhpcyk7XHJcbiAgICAgICAgIHZhciBsZW5WYWwgPSBvLmxlbmd0aDtcclxuICAgICAgICAgdmFyIGxlbiA9IFRvTGVuZ3RoKGxlblZhbCk7XHJcbiAgICAgICAgIGlmICghSXNDYWxsYWJsZShjYWxsYmFja2ZuKSkgdGhyb3cgVHlwZUVycm9yKCk7XHJcbiAgICAgICAgIHZhciB0ID0gdGhpc0FyZztcclxuICAgICAgICAgdmFyIGMgPSBvLmNvbnN0cnVjdG9yO1xyXG4gICAgICAgICB2YXIga2VwdCA9IFtdO1xyXG4gICAgICAgICB2YXIgayA9IDA7XHJcbiAgICAgICAgIHZhciBjYXB0dXJlZCA9IDA7XHJcbiAgICAgICAgIHdoaWxlIChrIDwgbGVuKSB7XHJcbiAgICAgICAgICAgdmFyIGtWYWx1ZSA9IG9ba107XHJcbiAgICAgICAgICAgdmFyIHNlbGVjdGVkID0gY2FsbGJhY2tmbi5jYWxsKHQsIGtWYWx1ZSwgaywgbyk7XHJcbiAgICAgICAgICAgaWYgKHNlbGVjdGVkKSB7XHJcbiAgICAgICAgICAgICBrZXB0LnB1c2goa1ZhbHVlKTtcclxuICAgICAgICAgICAgICsrY2FwdHVyZWQ7XHJcbiAgICAgICAgICAgfVxyXG4gICAgICAgICAgICsraztcclxuICAgICAgICAgfVxyXG4gICAgICAgICB2YXIgYSA9IG5ldyBjKGNhcHR1cmVkKTtcclxuICAgICAgICAgdmFyIG4gPSAwO1xyXG4gICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtlcHQubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICB2YXIgZSA9IGtlcHRbaV07XHJcbiAgICAgICAgICAgYVtuXSA9IGU7XHJcbiAgICAgICAgICAgKytuO1xyXG4gICAgICAgICB9XHJcbiAgICAgICAgIHJldHVybiBhO1xyXG4gICAgICAgfSk7XHJcblxyXG4gICAgIC8vIDIyLjIuMy4xMCAlVHlwZWRBcnJheSUucHJvdG90eXBlLmZpbmQgKHByZWRpY2F0ZSBbICwgdGhpc0FyZyBdIClcclxuICAgICBkZWZpbmUoJFR5cGVkQXJyYXkkLnByb3RvdHlwZSwgJ2ZpbmQnLCBBcnJheS5wcm90b3R5cGUuZmluZCk7XHJcblxyXG4gICAgIC8vIDIyLjIuMy4xMSAlVHlwZWRBcnJheSUucHJvdG90eXBlLmZpbmRJbmRleCAoIHByZWRpY2F0ZSBbICwgdGhpc0FyZyBdIClcclxuICAgICBkZWZpbmUoJFR5cGVkQXJyYXkkLnByb3RvdHlwZSwgJ2ZpbmRJbmRleCcsIEFycmF5LnByb3RvdHlwZS5maW5kSW5kZXgpO1xyXG5cclxuICAgICAvLyAyMi4yLjMuMTIgJVR5cGVkQXJyYXklLnByb3RvdHlwZS5mb3JFYWNoICggY2FsbGJhY2tmbiBbICwgdGhpc0FyZyBdIClcclxuICAgICBkZWZpbmUoJFR5cGVkQXJyYXkkLnByb3RvdHlwZSwgJ2ZvckVhY2gnLCBBcnJheS5wcm90b3R5cGUuZm9yRWFjaCk7XHJcblxyXG4gICAgIC8vIDIyLjIuMy4xMyAlVHlwZWRBcnJheSUucHJvdG90eXBlLmluZGV4T2YgKHNlYXJjaEVsZW1lbnQgWyAsIGZyb21JbmRleCBdIClcclxuICAgICBkZWZpbmUoJFR5cGVkQXJyYXkkLnByb3RvdHlwZSwgJ2luZGV4T2YnLCBBcnJheS5wcm90b3R5cGUuaW5kZXhPZik7XHJcblxyXG4gICAgIC8vIDIyLjIuMy4xNCAlVHlwZWRBcnJheSUucHJvdG90eXBlLmpvaW4gKCBzZXBhcmF0b3IgKVxyXG4gICAgIGRlZmluZSgkVHlwZWRBcnJheSQucHJvdG90eXBlLCAnam9pbicsIEFycmF5LnByb3RvdHlwZS5qb2luKTtcclxuXHJcbiAgICAgLy8gMjIuMi4zLjE1ICVUeXBlZEFycmF5JS5wcm90b3R5cGUua2V5cyAoIClcclxuICAgICBkZWZpbmUoJFR5cGVkQXJyYXkkLnByb3RvdHlwZSwgJ2tleXMnLCBBcnJheS5wcm90b3R5cGUua2V5cyk7XHJcblxyXG4gICAgIC8vIDIyLjIuMy4xNiAlVHlwZWRBcnJheSUucHJvdG90eXBlLmxhc3RJbmRleE9mICggc2VhcmNoRWxlbWVudCBbICwgZnJvbUluZGV4IF0gKVxyXG4gICAgIGRlZmluZSgkVHlwZWRBcnJheSQucHJvdG90eXBlLCAnbGFzdEluZGV4T2YnLCBBcnJheS5wcm90b3R5cGUubGFzdEluZGV4T2YpO1xyXG5cclxuICAgICAvLyAyMi4yLjMuMTcgZ2V0ICVUeXBlZEFycmF5JS5wcm90b3R5cGUubGVuZ3RoXHJcblxyXG4gICAgIC8vIDIyLjIuMy4xOCAlVHlwZWRBcnJheSUucHJvdG90eXBlLm1hcCAoIGNhbGxiYWNrZm4gWyAsIHRoaXNBcmcgXSApXHJcbiAgICAgZGVmaW5lKFxyXG4gICAgICAgJFR5cGVkQXJyYXkkLnByb3RvdHlwZSwgJ21hcCcsXHJcbiAgICAgICBmdW5jdGlvbiBtYXAoY2FsbGJhY2tmbikge1xyXG4gICAgICAgICB2YXIgdGhpc0FyZyA9IGFyZ3VtZW50c1sxXTtcclxuXHJcbiAgICAgICAgIHZhciBvID0gVG9PYmplY3QodGhpcyk7XHJcbiAgICAgICAgIHZhciBsZW5WYWx1ZSA9IG8ubGVuZ3RoO1xyXG4gICAgICAgICB2YXIgbGVuID0gVG9MZW5ndGgobGVuVmFsdWUpO1xyXG4gICAgICAgICBpZiAoIUlzQ2FsbGFibGUoY2FsbGJhY2tmbikpIHRocm93IFR5cGVFcnJvcigpO1xyXG4gICAgICAgICB2YXIgdCA9IHRoaXNBcmc7XHJcbiAgICAgICAgIHZhciBhID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICB2YXIgYyA9IG8uY29uc3RydWN0b3I7XHJcbiAgICAgICAgIGlmIChJc0NvbnN0cnVjdG9yKGMpKVxyXG4gICAgICAgICAgIGEgPSBuZXcgYyhsZW4pO1xyXG4gICAgICAgICBpZiAoYSA9PT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgIGEgPSBuZXcgQXJyYXkobGVuKTtcclxuICAgICAgICAgdmFyIGsgPSAwO1xyXG4gICAgICAgICB3aGlsZSAoayA8IGxlbikge1xyXG4gICAgICAgICAgIHZhciBrUHJlc2VudCA9IEhhc1Byb3BlcnR5KG8sIGspO1xyXG4gICAgICAgICAgIGlmIChrUHJlc2VudCkge1xyXG4gICAgICAgICAgICAgdmFyIGtWYWx1ZSA9IG9ba107XHJcbiAgICAgICAgICAgICB2YXIgbWFwcGVkVmFsdWUgPSBjYWxsYmFja2ZuLmNhbGwodCwga1ZhbHVlLCBrLCBvKTtcclxuICAgICAgICAgICAgIGFba10gPSBtYXBwZWRWYWx1ZTtcclxuICAgICAgICAgICB9XHJcbiAgICAgICAgICAgKytrO1xyXG4gICAgICAgICB9XHJcbiAgICAgICAgIHJldHVybiBhO1xyXG4gICAgICAgfSk7XHJcblxyXG4gICAgIC8vIDIyLjIuMy4xOSAlVHlwZWRBcnJheSUucHJvdG90eXBlLnJlZHVjZSAoIGNhbGxiYWNrZm4gWywgaW5pdGlhbFZhbHVlXSApXHJcbiAgICAgZGVmaW5lKCRUeXBlZEFycmF5JC5wcm90b3R5cGUsICdyZWR1Y2UnLCBBcnJheS5wcm90b3R5cGUucmVkdWNlKTtcclxuXHJcbiAgICAgLy8gMjIuMi4zLjIwICVUeXBlZEFycmF5JS5wcm90b3R5cGUucmVkdWNlUmlnaHQgKCBjYWxsYmFja2ZuIFssIGluaXRpYWxWYWx1ZV0gKVxyXG4gICAgIGRlZmluZSgkVHlwZWRBcnJheSQucHJvdG90eXBlLCAncmVkdWNlUmlnaHQnLCBBcnJheS5wcm90b3R5cGUucmVkdWNlUmlnaHQpO1xyXG5cclxuICAgICAvLyAyMi4yLjMuMjEgJVR5cGVkQXJyYXklLnByb3RvdHlwZS5yZXZlcnNlICggKVxyXG4gICAgIGRlZmluZSgkVHlwZWRBcnJheSQucHJvdG90eXBlLCAncmV2ZXJzZScsIEFycmF5LnByb3RvdHlwZS5yZXZlcnNlKTtcclxuXHJcbiAgICAgLy8gMjIuMi4zLjIyICVUeXBlZEFycmF5JS5wcm90b3R5cGUuc2V0ICggb3ZlcmxvYWRlZCBbICwgb2Zmc2V0IF0pXHJcbiAgICAgLy8gMjIuMi4zLjIyLjEgJVR5cGVkQXJyYXklLnByb3RvdHlwZS5zZXQgKGFycmF5IFsgLCBvZmZzZXQgXSApXHJcbiAgICAgLy8gMjIuMi4zLjIyLjIgJVR5cGVkQXJyYXklLnByb3RvdHlwZS5zZXQodHlwZWRBcnJheSBbLCBvZmZzZXQgXSApXHJcblxyXG4gICAgIC8vIDIyLjIuMy4yMyAlVHlwZWRBcnJheSUucHJvdG90eXBlLnNsaWNlICggc3RhcnQsIGVuZCApXHJcbiAgICAgZGVmaW5lKFxyXG4gICAgICAgJFR5cGVkQXJyYXkkLnByb3RvdHlwZSwgJ3NsaWNlJyxcclxuICAgICAgIGZ1bmN0aW9uIHNsaWNlKHN0YXJ0LCBlbmQpIHtcclxuICAgICAgICAgdmFyIG8gPSBUb09iamVjdCh0aGlzKTtcclxuICAgICAgICAgdmFyIGxlblZhbCA9IG8ubGVuZ3RoO1xyXG4gICAgICAgICB2YXIgbGVuID0gVG9MZW5ndGgobGVuVmFsKTtcclxuICAgICAgICAgdmFyIHJlbGF0aXZlU3RhcnQgPSBUb0ludGVnZXIoc3RhcnQpO1xyXG4gICAgICAgICB2YXIgayA9IChyZWxhdGl2ZVN0YXJ0IDwgMCkgPyBtYXgobGVuICsgcmVsYXRpdmVTdGFydCwgMCkgOiBtaW4ocmVsYXRpdmVTdGFydCwgbGVuKTtcclxuICAgICAgICAgdmFyIHJlbGF0aXZlRW5kID0gKGVuZCA9PT0gdW5kZWZpbmVkKSA/IGxlbiA6IFRvSW50ZWdlcihlbmQpO1xyXG4gICAgICAgICB2YXIgZmluYWwgPSAocmVsYXRpdmVFbmQgPCAwKSA/IG1heChsZW4gKyByZWxhdGl2ZUVuZCwgMCkgOiBtaW4ocmVsYXRpdmVFbmQsIGxlbik7XHJcbiAgICAgICAgIHZhciBjb3VudCA9IGZpbmFsIC0gaztcclxuICAgICAgICAgdmFyIGMgPSBvLmNvbnN0cnVjdG9yO1xyXG4gICAgICAgICBpZiAoSXNDb25zdHJ1Y3RvcihjKSkge1xyXG4gICAgICAgICAgIHZhciBhID0gbmV3IGMoY291bnQpO1xyXG4gICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgIHRocm93IFR5cGVFcnJvcigpO1xyXG4gICAgICAgICB9XHJcbiAgICAgICAgIHZhciBuID0gMDtcclxuICAgICAgICAgd2hpbGUgKGsgPCBmaW5hbCkge1xyXG4gICAgICAgICAgIHZhciBrVmFsdWUgPSBvW2tdO1xyXG4gICAgICAgICAgIGFbbl0gPSBrVmFsdWU7XHJcbiAgICAgICAgICAgKytrO1xyXG4gICAgICAgICAgICsrbjtcclxuICAgICAgICAgfVxyXG4gICAgICAgICByZXR1cm4gYTtcclxuICAgICAgIH0pO1xyXG5cclxuICAgICAvLyAyMi4yLjMuMjQgJVR5cGVkQXJyYXklLnByb3RvdHlwZS5zb21lICggY2FsbGJhY2tmbiBbICwgdGhpc0FyZyBdIClcclxuICAgICBkZWZpbmUoJFR5cGVkQXJyYXkkLnByb3RvdHlwZSwgJ3NvbWUnLCBBcnJheS5wcm90b3R5cGUuc29tZSk7XHJcblxyXG4gICAgIC8vIDIyLjIuMy4yNSAlVHlwZWRBcnJheSUucHJvdG90eXBlLnNvcnQgKCBjb21wYXJlZm4gKVxyXG4gICAgIGRlZmluZShcclxuICAgICAgICRUeXBlZEFycmF5JC5wcm90b3R5cGUsICdzb3J0JyxcclxuICAgICAgIGZ1bmN0aW9uIHNvcnQoKSB7XHJcbiAgICAgICAgIHZhciBjb21wYXJlZm4gPSBhcmd1bWVudHNbMF07XHJcblxyXG4gICAgICAgICBmdW5jdGlvbiBzb3J0Q29tcGFyZSh4LCB5KSB7XHJcbiAgICAgICAgICAgY29uc29sZS5hc3NlcnQoVHlwZSh4KSA9PT0gJ251bWJlcicgJiYgVHlwZSh5KSA9PT0gJ251bWJlcicpO1xyXG4gICAgICAgICAgIGlmICh4ICE9PSB4ICYmIHkgIT09IHkpIHJldHVybiArMDtcclxuICAgICAgICAgICBpZiAoeCAhPT0geCkgcmV0dXJuIDE7XHJcbiAgICAgICAgICAgaWYgKHkgIT09IHkpIHJldHVybiAtMTtcclxuICAgICAgICAgICBpZiAoY29tcGFyZWZuICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgIHJldHVybiBjb21wYXJlZm4oeCwgeSk7XHJcbiAgICAgICAgICAgfVxyXG4gICAgICAgICAgIGlmICh4IDwgeSkgcmV0dXJuIC0xO1xyXG4gICAgICAgICAgIGlmICh4ID4geSkgcmV0dXJuIDE7XHJcbiAgICAgICAgICAgcmV0dXJuICswO1xyXG4gICAgICAgICB9XHJcbiAgICAgICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuc29ydC5jYWxsKHRoaXMsIHNvcnRDb21wYXJlKTtcclxuICAgICAgIH0pO1xyXG5cclxuICAgICAvLyAyMi4yLjMuMjYgJVR5cGVkQXJyYXklLnByb3RvdHlwZS5zdWJhcnJheSggWyBiZWdpbiBbICwgZW5kIF0gXSApXHJcbiAgICAgLy8gMjIuMi4zLjI3ICVUeXBlZEFycmF5JS5wcm90b3R5cGUudG9Mb2NhbGVTdHJpbmcgKFsgcmVzZXJ2ZWQxIFsgLCByZXNlcnZlZDIgXSBdKVxyXG4gICAgIC8vIDIyLjIuMy4yOCAlVHlwZWRBcnJheSUucHJvdG90eXBlLnRvU3RyaW5nICggKVxyXG5cclxuICAgICAvLyAyMi4yLjMuMjkgJVR5cGVkQXJyYXklLnByb3RvdHlwZS52YWx1ZXMgKCApXHJcbiAgICAgZGVmaW5lKCRUeXBlZEFycmF5JC5wcm90b3R5cGUsICd2YWx1ZXMnLCBBcnJheS5wcm90b3R5cGUudmFsdWVzKTtcclxuXHJcbiAgICAgLy8gMjIuMi4zLjMwICVUeXBlZEFycmF5JS5wcm90b3R5cGUgWyBAQGl0ZXJhdG9yIF0gKCApXHJcbiAgICAgZGVmaW5lKFxyXG4gICAgICAgJFR5cGVkQXJyYXkkLnByb3RvdHlwZSwgJCRpdGVyYXRvcixcclxuICAgICAgICRUeXBlZEFycmF5JC5wcm90b3R5cGUudmFsdWVzXHJcbiAgICAgKTtcclxuXHJcbiAgICAgLy8gMjIuMi4zLjMxIGdldCAlVHlwZWRBcnJheSUucHJvdG90eXBlIFsgQEB0b1N0cmluZ1RhZyBdXHJcbiAgICAgZGVmaW5lKCRUeXBlZEFycmF5JC5wcm90b3R5cGUsICQkdG9TdHJpbmdUYWcsICRUeXBlZEFycmF5TmFtZSQpO1xyXG5cclxuICAgICAvLyAyMi4yLjQgVGhlIFR5cGVkQXJyYXkgQ29uc3RydWN0b3JzXHJcbiAgICAgLy8gMjIuMi40LjFUeXBlZEFycmF5KCAuLi4gYXJndW1lbnRzTGlzdClcclxuICAgICAvLyAyMi4yLjUgUHJvcGVydGllcyBvZiB0aGUgVHlwZWRBcnJheSBDb25zdHJ1Y3RvcnNcclxuICAgICAvLyAyMi4yLjUuMSBUeXBlZEFycmF5LkJZVEVTX1BFUl9FTEVNRU5UXHJcbiAgICAgLy8gMjIuMi41LjIgVHlwZWRBcnJheS5wcm90b3R5cGVcclxuICAgICAvLyAyMi4yLjYgUHJvcGVydGllcyBvZiBUeXBlZEFycmF5IFByb3RvdHlwZSBPYmplY3RzXHJcbiAgICAgLy8gMjIuMi42LjEgVHlwZWRBcnJheS5wcm90b3R5cGUuQllURVNfUEVSX0VMRU1FTlRcclxuICAgICAvLyAyMi4yLjYuMiBUeXBlZEFycmF5LnByb3RvdHlwZS5jb25zdHJ1Y3RvclxyXG4gICAgIC8vIDIyLjIuNyBQcm9wZXJ0aWVzIG9mIFR5cGVkQXJyYXkgSW5zdGFuY2VzXHJcbiAgIH0pO1xyXG5cclxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAvLyAyMyBLZXllZCBDb2xsZWN0aW9uXHJcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gIC8vIDIzLjEgTWFwIE9iamVjdHNcclxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcbiAgKGZ1bmN0aW9uKCkge1xyXG4gICAgLy8gMjMuMS4xIFRoZSBNYXAgQ29uc3RydWN0b3JcclxuXHJcbiAgICAvLyAyMy4xLjEuMSBNYXAgKCBbIGl0ZXJhYmxlIF0gKVxyXG4gICAgLyoqIEBjb25zdHJ1Y3RvciAqL1xyXG4gICAgZnVuY3Rpb24gTWFwKC8qaXRlcmFibGUqLykge1xyXG4gICAgICB2YXIgbWFwID0gc3RyaWN0KHRoaXMpO1xyXG4gICAgICB2YXIgaXRlcmFibGUgPSBhcmd1bWVudHNbMF07XHJcblxyXG4gICAgICBpZiAoVHlwZShtYXApICE9PSAnb2JqZWN0JykgdGhyb3cgVHlwZUVycm9yKCk7XHJcbiAgICAgIGlmICgnW1tNYXBEYXRhXV0nIGluIG1hcCkgdGhyb3cgVHlwZUVycm9yKCk7XHJcblxyXG4gICAgICBpZiAoaXRlcmFibGUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHZhciBhZGRlciA9IG1hcFsnc2V0J107XHJcbiAgICAgICAgaWYgKCFJc0NhbGxhYmxlKGFkZGVyKSkgdGhyb3cgVHlwZUVycm9yKCk7XHJcbiAgICAgICAgdmFyIGl0ZXIgPSBHZXRJdGVyYXRvcihUb09iamVjdChpdGVyYWJsZSkpO1xyXG4gICAgICB9XHJcbiAgICAgIHNldF9pbnRlcm5hbChtYXAsICdbW01hcERhdGFdXScsIHsga2V5czogW10sIHZhbHVlczogW10gfSk7XHJcbiAgICAgIGlmIChpdGVyID09PSB1bmRlZmluZWQpIHJldHVybiBtYXA7XHJcbiAgICAgIHdoaWxlICh0cnVlKSB7XHJcbiAgICAgICAgdmFyIG5leHQgPSBJdGVyYXRvclN0ZXAoaXRlcik7XHJcbiAgICAgICAgaWYgKG5leHQgPT09IGZhbHNlKVxyXG4gICAgICAgICAgcmV0dXJuIG1hcDtcclxuICAgICAgICB2YXIgbmV4dEl0ZW0gPSBJdGVyYXRvclZhbHVlKG5leHQpO1xyXG4gICAgICAgIGlmIChUeXBlKG5leHRJdGVtKSAhPT0gJ29iamVjdCcpIHRocm93IFR5cGVFcnJvcigpO1xyXG4gICAgICAgIHZhciBrID0gbmV4dEl0ZW1bMF07XHJcbiAgICAgICAgdmFyIHYgPSBuZXh0SXRlbVsxXTtcclxuICAgICAgICBhZGRlci5jYWxsKG1hcCwgaywgdik7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBtYXA7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCEoJ01hcCcgaW4gZ2xvYmFsKSB8fCBPVkVSUklERV9OQVRJVkVfRk9SX1RFU1RJTkcgfHxcclxuICAgICAgICAoZnVuY3Rpb24oKSB7IHRyeSB7IG5ldyBnbG9iYWwuTWFwKFtdKTsgcmV0dXJuIGZhbHNlOyB9IGNhdGNoIChfKSB7IHJldHVybiB0cnVlOyB9IH0oKSkgfHxcclxuICAgICAgICAoZnVuY3Rpb24oKSB7IHRyeSB7IHJldHVybiAhbmV3IGdsb2JhbC5NYXAoKS5lbnRyaWVzKCkubmV4dDsgfSBjYXRjaCAoXykgeyByZXR1cm4gdHJ1ZTsgfSB9KCkpIHx8XHJcbiAgICAgICAgKG5ldyBnbG9iYWwuTWFwKFtbJ2EnLCAxXV0pLnNpemUgIT09IDEpKVxyXG4gICAgICBnbG9iYWwuTWFwID0gTWFwO1xyXG5cclxuXHJcbiAgICBmdW5jdGlvbiBNYXBEYXRhSW5kZXhPZihtYXBEYXRhLCBrZXkpIHtcclxuICAgICAgdmFyIGk7XHJcbiAgICAgIGlmIChrZXkgPT09IGtleSkgcmV0dXJuIG1hcERhdGEua2V5cy5pbmRleE9mKGtleSk7XHJcbiAgICAgIC8vIFNsb3cgY2FzZSBmb3IgTmFOXHJcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBtYXBEYXRhLmtleXMubGVuZ3RoOyBpICs9IDEpXHJcbiAgICAgICAgaWYgKFNhbWVWYWx1ZVplcm8obWFwRGF0YS5rZXlzW2ldLCBrZXkpKSByZXR1cm4gaTtcclxuICAgICAgcmV0dXJuIC0xO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIDIzLjEuMS4yIG5ldyBNYXAgKCAuLi4gYXJndW1lbnRzTGlzdCApXHJcbiAgICAvLyAyMy4xLjIgUHJvcGVydGllcyBvZiB0aGUgTWFwIENvbnN0cnVjdG9yXHJcbiAgICAvLyAyMy4xLjIuMSBNYXAucHJvdG90eXBlXHJcbiAgICB2YXIgJE1hcFByb3RvdHlwZSQgPSB7fTtcclxuICAgIE1hcC5wcm90b3R5cGUgPSAkTWFwUHJvdG90eXBlJDtcclxuXHJcbiAgICAvLyAyMy4xLjIuMiBnZXQgTWFwIFsgQEBzcGVjaWVzIF1cclxuXHJcbiAgICAvLyAyMy4xLjMgUHJvcGVydGllcyBvZiB0aGUgTWFwIFByb3RvdHlwZSBPYmplY3RcclxuICAgIC8vIDIzLjEuMy4xIE1hcC5wcm90b3R5cGUuY2xlYXIgKClcclxuICAgIGRlZmluZShcclxuICAgICAgTWFwLnByb3RvdHlwZSwgJ2NsZWFyJyxcclxuICAgICAgZnVuY3Rpb24gY2xlYXIoKSB7XHJcbiAgICAgICAgdmFyIG0gPSBzdHJpY3QodGhpcyk7XHJcbiAgICAgICAgaWYgKFR5cGUobSkgIT09ICdvYmplY3QnKSB0aHJvdyBUeXBlRXJyb3IoKTtcclxuICAgICAgICBpZiAoISgnW1tNYXBEYXRhXV0nIGluIG0pKSB0aHJvdyBUeXBlRXJyb3IoKTtcclxuICAgICAgICBpZiAobVsnW1tNYXBEYXRhXV0nXSA9PT0gdW5kZWZpbmVkKSB0aHJvdyBUeXBlRXJyb3IoKTtcclxuICAgICAgICB2YXIgZW50cmllcyA9IG1bJ1tbTWFwRGF0YV1dJ107XHJcbiAgICAgICAgZW50cmllcy5rZXlzLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgZW50cmllcy52YWx1ZXMubGVuZ3RoID0gMDtcclxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAvLyAyMy4xLjMuMiBNYXAucHJvdG90eXBlLmNvbnN0cnVjdG9yXHJcblxyXG4gICAgLy8gMjMuMS4zLjMgTWFwLnByb3RvdHlwZS5kZWxldGUgKCBrZXkgKVxyXG4gICAgZGVmaW5lKFxyXG4gICAgICBNYXAucHJvdG90eXBlLCAnZGVsZXRlJyxcclxuICAgICAgZnVuY3Rpb24gZGVsZXRlXyhrZXkpIHtcclxuICAgICAgICB2YXIgbSA9IHN0cmljdCh0aGlzKTtcclxuICAgICAgICBpZiAoVHlwZShtKSAhPT0gJ29iamVjdCcpIHRocm93IFR5cGVFcnJvcigpO1xyXG4gICAgICAgIGlmICghKCdbW01hcERhdGFdXScgaW4gbSkpIHRocm93IFR5cGVFcnJvcigpO1xyXG4gICAgICAgIGlmIChtWydbW01hcERhdGFdXSddID09PSB1bmRlZmluZWQpIHRocm93IFR5cGVFcnJvcigpO1xyXG4gICAgICAgIHZhciBlbnRyaWVzID0gbVsnW1tNYXBEYXRhXV0nXTtcclxuICAgICAgICB2YXIgaSA9IE1hcERhdGFJbmRleE9mKGVudHJpZXMsIGtleSk7XHJcbiAgICAgICAgaWYgKGkgPCAwKSByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgZW50cmllcy5rZXlzW2ldID0gZW1wdHk7XHJcbiAgICAgICAgZW50cmllcy52YWx1ZXNbaV0gPSBlbXB0eTtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgLy8gMjMuMS4zLjQgTWFwLnByb3RvdHlwZS5lbnRyaWVzICggKVxyXG4gICAgZGVmaW5lKFxyXG4gICAgICBNYXAucHJvdG90eXBlLCAnZW50cmllcycsXHJcbiAgICAgIGZ1bmN0aW9uIGVudHJpZXMoKSB7XHJcbiAgICAgICAgdmFyIG0gPSBzdHJpY3QodGhpcyk7XHJcbiAgICAgICAgaWYgKFR5cGUobSkgIT09ICdvYmplY3QnKSB0aHJvdyBUeXBlRXJyb3IoKTtcclxuICAgICAgICByZXR1cm4gQ3JlYXRlTWFwSXRlcmF0b3IobSwgJ2tleSt2YWx1ZScpO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAvLyAyMy4xLjMuNSBNYXAucHJvdG90eXBlLmZvckVhY2ggKCBjYWxsYmFja2ZuIFsgLCB0aGlzQXJnIF0gKVxyXG4gICAgZGVmaW5lKFxyXG4gICAgICBNYXAucHJvdG90eXBlLCAnZm9yRWFjaCcsXHJcbiAgICAgIGZ1bmN0aW9uIGZvckVhY2goY2FsbGJhY2tmbiAvKiwgdGhpc0FyZyovKSB7XHJcbiAgICAgICAgdmFyIHRoaXNBcmcgPSBhcmd1bWVudHNbMV07XHJcblxyXG4gICAgICAgIHZhciBtID0gc3RyaWN0KHRoaXMpO1xyXG4gICAgICAgIGlmIChUeXBlKG0pICE9PSAnb2JqZWN0JykgdGhyb3cgVHlwZUVycm9yKCk7XHJcbiAgICAgICAgaWYgKCEoJ1tbTWFwRGF0YV1dJyBpbiBtKSkgdGhyb3cgVHlwZUVycm9yKCk7XHJcbiAgICAgICAgaWYgKG1bJ1tbTWFwRGF0YV1dJ10gPT09IHVuZGVmaW5lZCkgdGhyb3cgVHlwZUVycm9yKCk7XHJcbiAgICAgICAgdmFyIGVudHJpZXMgPSBtWydbW01hcERhdGFdXSddO1xyXG5cclxuICAgICAgICBpZiAoIUlzQ2FsbGFibGUoY2FsbGJhY2tmbikpIHtcclxuICAgICAgICAgIHRocm93IFR5cGVFcnJvcignRmlyc3QgYXJndW1lbnQgdG8gZm9yRWFjaCBpcyBub3QgY2FsbGFibGUuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZW50cmllcy5rZXlzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICBpZiAoZW50cmllcy5rZXlzW2ldICE9PSBlbXB0eSkge1xyXG4gICAgICAgICAgICBjYWxsYmFja2ZuLmNhbGwodGhpc0FyZywgZW50cmllcy52YWx1ZXNbaV0sIGVudHJpZXMua2V5c1tpXSwgbSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgIC8vIDIzLjEuMy42IE1hcC5wcm90b3R5cGUuZ2V0ICgga2V5IClcclxuICAgIGRlZmluZShcclxuICAgICAgTWFwLnByb3RvdHlwZSwgJ2dldCcsXHJcbiAgICAgIGZ1bmN0aW9uIGdldChrZXkpIHtcclxuICAgICAgICB2YXIgbSA9IHN0cmljdCh0aGlzKTtcclxuICAgICAgICBpZiAoVHlwZShtKSAhPT0gJ29iamVjdCcpIHRocm93IFR5cGVFcnJvcigpO1xyXG4gICAgICAgIGlmICghKCdbW01hcERhdGFdXScgaW4gbSkpIHRocm93IFR5cGVFcnJvcigpO1xyXG4gICAgICAgIGlmIChtWydbW01hcERhdGFdXSddID09PSB1bmRlZmluZWQpIHRocm93IFR5cGVFcnJvcigpO1xyXG4gICAgICAgIHZhciBlbnRyaWVzID0gbVsnW1tNYXBEYXRhXV0nXTtcclxuICAgICAgICB2YXIgaSA9IE1hcERhdGFJbmRleE9mKGVudHJpZXMsIGtleSk7XHJcbiAgICAgICAgaWYgKGkgPj0gMCkgcmV0dXJuIGVudHJpZXMudmFsdWVzW2ldO1xyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgIC8vIDIzLjEuMy43IE1hcC5wcm90b3R5cGUuaGFzICgga2V5IClcclxuICAgIGRlZmluZShcclxuICAgICAgTWFwLnByb3RvdHlwZSwgJ2hhcycsXHJcbiAgICAgIGZ1bmN0aW9uIGhhcyhrZXkpIHtcclxuICAgICAgICB2YXIgbSA9IHN0cmljdCh0aGlzKTtcclxuICAgICAgICBpZiAoVHlwZShtKSAhPT0gJ29iamVjdCcpIHRocm93IFR5cGVFcnJvcigpO1xyXG4gICAgICAgIGlmICghKCdbW01hcERhdGFdXScgaW4gbSkpIHRocm93IFR5cGVFcnJvcigpO1xyXG4gICAgICAgIGlmIChtWydbW01hcERhdGFdXSddID09PSB1bmRlZmluZWQpIHRocm93IFR5cGVFcnJvcigpO1xyXG4gICAgICAgIHZhciBlbnRyaWVzID0gbVsnW1tNYXBEYXRhXV0nXTtcclxuICAgICAgICBpZiAoTWFwRGF0YUluZGV4T2YoZW50cmllcywga2V5KSA+PSAwKSByZXR1cm4gdHJ1ZTtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgIC8vIDIzLjEuMy44IE1hcC5wcm90b3R5cGUua2V5cyAoIClcclxuICAgIGRlZmluZShcclxuICAgICAgTWFwLnByb3RvdHlwZSwgJ2tleXMnLFxyXG4gICAgICBmdW5jdGlvbiBrZXlzKCkge1xyXG4gICAgICAgIHZhciBtID0gc3RyaWN0KHRoaXMpO1xyXG4gICAgICAgIGlmIChUeXBlKG0pICE9PSAnb2JqZWN0JykgdGhyb3cgVHlwZUVycm9yKCk7XHJcbiAgICAgICAgcmV0dXJuIENyZWF0ZU1hcEl0ZXJhdG9yKG0sICdrZXknKTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgLy8gMjMuMS4zLjkgTWFwLnByb3RvdHlwZS5zZXQgKCBrZXkgLCB2YWx1ZSApXHJcbiAgICBkZWZpbmUoXHJcbiAgICAgIE1hcC5wcm90b3R5cGUsICdzZXQnLFxyXG4gICAgICBmdW5jdGlvbiBzZXQoa2V5LCB2YWx1ZSkge1xyXG4gICAgICAgIHZhciBtID0gc3RyaWN0KHRoaXMpO1xyXG4gICAgICAgIGlmIChUeXBlKG0pICE9PSAnb2JqZWN0JykgdGhyb3cgVHlwZUVycm9yKCk7XHJcbiAgICAgICAgaWYgKCEoJ1tbTWFwRGF0YV1dJyBpbiBtKSkgdGhyb3cgVHlwZUVycm9yKCk7XHJcbiAgICAgICAgaWYgKG1bJ1tbTWFwRGF0YV1dJ10gPT09IHVuZGVmaW5lZCkgdGhyb3cgVHlwZUVycm9yKCk7XHJcbiAgICAgICAgdmFyIGVudHJpZXMgPSBtWydbW01hcERhdGFdXSddO1xyXG4gICAgICAgIHZhciBpID0gTWFwRGF0YUluZGV4T2YoZW50cmllcywga2V5KTtcclxuICAgICAgICBpZiAoaSA8IDApIGkgPSBlbnRyaWVzLmtleXMubGVuZ3RoO1xyXG4gICAgICAgIGlmIChTYW1lVmFsdWUoa2V5LCAtMCkpIGtleSA9IDA7XHJcbiAgICAgICAgZW50cmllcy5rZXlzW2ldID0ga2V5O1xyXG4gICAgICAgIGVudHJpZXMudmFsdWVzW2ldID0gdmFsdWU7XHJcbiAgICAgICAgcmV0dXJuIG07XHJcbiAgICAgIH0pO1xyXG5cclxuICAgIC8vIDIzLjEuMy4xMCBnZXQgTWFwLnByb3RvdHlwZS5zaXplXHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoXHJcbiAgICAgIE1hcC5wcm90b3R5cGUsICdzaXplJywge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICB2YXIgbSA9IHN0cmljdCh0aGlzKTtcclxuICAgICAgICAgIGlmIChUeXBlKG0pICE9PSAnb2JqZWN0JykgdGhyb3cgVHlwZUVycm9yKCk7XHJcbiAgICAgICAgICBpZiAoISgnW1tNYXBEYXRhXV0nIGluIG0pKSB0aHJvdyBUeXBlRXJyb3IoKTtcclxuICAgICAgICAgIGlmIChtWydbW01hcERhdGFdXSddID09PSB1bmRlZmluZWQpIHRocm93IFR5cGVFcnJvcigpO1xyXG4gICAgICAgICAgdmFyIGVudHJpZXMgPSBtWydbW01hcERhdGFdXSddO1xyXG4gICAgICAgICAgdmFyIGNvdW50ID0gMDtcclxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZW50cmllcy5rZXlzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgIGlmIChlbnRyaWVzLmtleXNbaV0gIT09IGVtcHR5KVxyXG4gICAgICAgICAgICAgIGNvdW50ID0gY291bnQgKyAxO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgcmV0dXJuIGNvdW50O1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcblxyXG4gICAgLy8gMjMuMS4zLjExIE1hcC5wcm90b3R5cGUudmFsdWVzICggKVxyXG4gICAgZGVmaW5lKFxyXG4gICAgICBNYXAucHJvdG90eXBlLCAndmFsdWVzJyxcclxuICAgICAgZnVuY3Rpb24gdmFsdWVzKCkge1xyXG4gICAgICAgIHZhciBtID0gc3RyaWN0KHRoaXMpO1xyXG4gICAgICAgIGlmIChUeXBlKG0pICE9PSAnb2JqZWN0JykgdGhyb3cgVHlwZUVycm9yKCk7XHJcbiAgICAgICAgcmV0dXJuIENyZWF0ZU1hcEl0ZXJhdG9yKG0sICd2YWx1ZScpO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAvLyAyMy4xLjMuMTIgTWFwLnByb3RvdHlwZSBbIEBAaXRlcmF0b3IgXSggKVxyXG4gICAgZGVmaW5lKFxyXG4gICAgICBNYXAucHJvdG90eXBlLCAkJGl0ZXJhdG9yLFxyXG4gICAgICBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgbSA9IHN0cmljdCh0aGlzKTtcclxuICAgICAgICBpZiAoVHlwZShtKSAhPT0gJ29iamVjdCcpIHRocm93IFR5cGVFcnJvcigpO1xyXG4gICAgICAgIHJldHVybiBDcmVhdGVNYXBJdGVyYXRvcihtLCAna2V5K3ZhbHVlJyk7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgIC8vIDIzLjEuMy4xMyBNYXAucHJvdG90eXBlIFsgQEB0b1N0cmluZ1RhZyBdXHJcbiAgICBkZWZpbmUoZ2xvYmFsLk1hcC5wcm90b3R5cGUsICQkdG9TdHJpbmdUYWcsICdNYXAnKTtcclxuXHJcbiAgICAvLyAyMy4xLjQgUHJvcGVydGllcyBvZiBNYXAgSW5zdGFuY2VzXHJcbiAgICAvLyAyMy4xLjUgTWFwIEl0ZXJhdG9yIE9iamVjdHNcclxuXHJcbiAgICAvKiogQGNvbnN0cnVjdG9yICovXHJcbiAgICBmdW5jdGlvbiBNYXBJdGVyYXRvcigpIHt9XHJcblxyXG4gICAgLy8gMjMuMS41LjEgQ3JlYXRlTWFwSXRlcmF0b3IgQWJzdHJhY3QgT3BlcmF0aW9uXHJcbiAgICBmdW5jdGlvbiBDcmVhdGVNYXBJdGVyYXRvcihtYXAsIGtpbmQpIHtcclxuICAgICAgaWYgKFR5cGUobWFwKSAhPT0gJ29iamVjdCcpIHRocm93IFR5cGVFcnJvcigpO1xyXG4gICAgICBpZiAoISgnW1tNYXBEYXRhXV0nIGluIG1hcCkpIHRocm93IFR5cGVFcnJvcigpO1xyXG4gICAgICBpZiAobWFwWydbW01hcERhdGFdXSddID09PSB1bmRlZmluZWQpIHRocm93IFR5cGVFcnJvcigpO1xyXG4gICAgICB2YXIgaXRlcmF0b3IgPSBuZXcgTWFwSXRlcmF0b3I7XHJcbiAgICAgIHNldF9pbnRlcm5hbChpdGVyYXRvciwgJ1tbTWFwXV0nLCBtYXApO1xyXG4gICAgICBzZXRfaW50ZXJuYWwoaXRlcmF0b3IsICdbW01hcE5leHRJbmRleF1dJywgMCk7XHJcbiAgICAgIHNldF9pbnRlcm5hbChpdGVyYXRvciwgJ1tbTWFwSXRlcmF0aW9uS2luZF1dJywga2luZCk7XHJcbiAgICAgIHJldHVybiBpdGVyYXRvcjtcclxuICAgIH1cclxuXHJcbiAgICAvLyAyMy4xLjUuMiBUaGUgJU1hcEl0ZXJhdG9yUHJvdG90eXBlJSBPYmplY3RcclxuICAgIHZhciAkTWFwSXRlcmF0b3JQcm90b3R5cGUkID0gT2JqZWN0LmNyZWF0ZSgkSXRlcmF0b3JQcm90b3R5cGUkKTtcclxuICAgIE1hcEl0ZXJhdG9yLnByb3RvdHlwZSA9ICRNYXBJdGVyYXRvclByb3RvdHlwZSQ7XHJcblxyXG4gICAgLy8gMjMuMS41LjIuMSAlTWFwSXRlcmF0b3JQcm90b3R5cGUlLm5leHQgKCApXHJcbiAgICBkZWZpbmUoXHJcbiAgICAgICRNYXBJdGVyYXRvclByb3RvdHlwZSQsICduZXh0JyxcclxuICAgICAgZnVuY3Rpb24gbmV4dCgpIHtcclxuICAgICAgICB2YXIgbyA9IHN0cmljdCh0aGlzKTtcclxuICAgICAgICBpZiAoVHlwZShvKSAhPT0gJ29iamVjdCcpIHRocm93IFR5cGVFcnJvcigpO1xyXG4gICAgICAgIHZhciBtID0gb1snW1tNYXBdXSddLFxyXG4gICAgICAgICAgICBpbmRleCA9IG9bJ1tbTWFwTmV4dEluZGV4XV0nXSxcclxuICAgICAgICAgICAgaXRlbUtpbmQgPSBvWydbW01hcEl0ZXJhdGlvbktpbmRdXSddLFxyXG4gICAgICAgICAgICBlbnRyaWVzID0gbVsnW1tNYXBEYXRhXV0nXTtcclxuICAgICAgICB3aGlsZSAoaW5kZXggPCBlbnRyaWVzLmtleXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICB2YXIgZSA9IHtrZXk6IGVudHJpZXMua2V5c1tpbmRleF0sIHZhbHVlOiBlbnRyaWVzLnZhbHVlc1tpbmRleF19O1xyXG4gICAgICAgICAgaW5kZXggPSBpbmRleCArPSAxO1xyXG4gICAgICAgICAgc2V0X2ludGVybmFsKG8sICdbW01hcE5leHRJbmRleF1dJywgaW5kZXgpO1xyXG4gICAgICAgICAgaWYgKGUua2V5ICE9PSBlbXB0eSkge1xyXG4gICAgICAgICAgICBpZiAoaXRlbUtpbmQgPT09ICdrZXknKSB7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIENyZWF0ZUl0ZXJSZXN1bHRPYmplY3QoZS5rZXksIGZhbHNlKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChpdGVtS2luZCA9PT0gJ3ZhbHVlJykge1xyXG4gICAgICAgICAgICAgIHJldHVybiBDcmVhdGVJdGVyUmVzdWx0T2JqZWN0KGUudmFsdWUsIGZhbHNlKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICByZXR1cm4gQ3JlYXRlSXRlclJlc3VsdE9iamVjdChbZS5rZXksIGUudmFsdWVdLCBmYWxzZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIENyZWF0ZUl0ZXJSZXN1bHRPYmplY3QodW5kZWZpbmVkLCB0cnVlKTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgLy8gMjMuMS41LjIuMiAlTWFwSXRlcmF0b3JQcm90b3R5cGUlIFsgQEB0b1N0cmluZ1RhZyBdXHJcbiAgICBkZWZpbmUoJE1hcEl0ZXJhdG9yUHJvdG90eXBlJCwgJCR0b1N0cmluZ1RhZywgJ01hcCBJdGVyYXRvcicpO1xyXG5cclxuICAgIC8vIDIzLjEuNS4zIFByb3BlcnRpZXMgb2YgTWFwIEl0ZXJhdG9yIEluc3RhbmNlc1xyXG4gIH0oKSk7XHJcblxyXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gIC8vIDIzLjIgU2V0IE9iamVjdHNcclxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcbiAgKGZ1bmN0aW9uKCkge1xyXG4gICAgLy8gMjMuMi4xIFRoZSBTZXQgQ29uc3RydWN0b3JcclxuICAgIC8vIDIzLjIuMS4xIFNldCAoIFsgaXRlcmFibGUgXSApXHJcblxyXG4gICAgLyoqIEBjb25zdHJ1Y3RvciAqL1xyXG4gICAgZnVuY3Rpb24gU2V0KC8qaXRlcmFibGUqLykge1xyXG4gICAgICB2YXIgc2V0ID0gc3RyaWN0KHRoaXMpO1xyXG4gICAgICB2YXIgaXRlcmFibGUgPSBhcmd1bWVudHNbMF07XHJcblxyXG4gICAgICBpZiAoVHlwZShzZXQpICE9PSAnb2JqZWN0JykgdGhyb3cgVHlwZUVycm9yKCk7XHJcbiAgICAgIGlmICgnW1tTZXREYXRhXV0nIGluIHNldCkgdGhyb3cgVHlwZUVycm9yKCk7XHJcblxyXG4gICAgICBpZiAoaXRlcmFibGUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHZhciBhZGRlciA9IHNldFsnYWRkJ107XHJcbiAgICAgICAgaWYgKCFJc0NhbGxhYmxlKGFkZGVyKSkgdGhyb3cgVHlwZUVycm9yKCk7XHJcbiAgICAgICAgdmFyIGl0ZXIgPSBHZXRJdGVyYXRvcihUb09iamVjdChpdGVyYWJsZSkpO1xyXG4gICAgICB9XHJcbiAgICAgIHNldF9pbnRlcm5hbChzZXQsICdbW1NldERhdGFdXScsIFtdKTtcclxuICAgICAgaWYgKGl0ZXIgPT09IHVuZGVmaW5lZCkgcmV0dXJuIHNldDtcclxuICAgICAgd2hpbGUgKHRydWUpIHtcclxuICAgICAgICB2YXIgbmV4dCA9IEl0ZXJhdG9yU3RlcChpdGVyKTtcclxuICAgICAgICBpZiAobmV4dCA9PT0gZmFsc2UpXHJcbiAgICAgICAgICByZXR1cm4gc2V0O1xyXG4gICAgICAgIHZhciBuZXh0VmFsdWUgPSBJdGVyYXRvclZhbHVlKG5leHQpO1xyXG4gICAgICAgIGFkZGVyLmNhbGwoc2V0LCBuZXh0VmFsdWUpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gc2V0O1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghKCdTZXQnIGluIGdsb2JhbCkgfHwgT1ZFUlJJREVfTkFUSVZFX0ZPUl9URVNUSU5HIHx8XHJcbiAgICAgICAgKGZ1bmN0aW9uKCkgeyB0cnkgeyByZXR1cm4gIW5ldyBnbG9iYWwuU2V0KCkuZW50cmllcygpLm5leHQ7IH0gY2F0Y2ggKF8pIHsgcmV0dXJuIHRydWU7IH0gfSgpKSB8fFxyXG4gICAgICAgIChuZXcgZ2xvYmFsLlNldChbMV0pLnNpemUgIT09IDEpKVxyXG4gICAgICBnbG9iYWwuU2V0ID0gU2V0O1xyXG5cclxuICAgIGZ1bmN0aW9uIFNldERhdGFJbmRleE9mKHNldERhdGEsIGtleSkge1xyXG4gICAgICB2YXIgaTtcclxuICAgICAgaWYgKGtleSA9PT0ga2V5KVxyXG4gICAgICAgIHJldHVybiBzZXREYXRhLmluZGV4T2Yoa2V5KTtcclxuICAgICAgLy8gU2xvdyBjYXNlIGZvciBOYU5cclxuICAgICAgZm9yIChpID0gMDsgaSA8IHNldERhdGEubGVuZ3RoOyBpICs9IDEpXHJcbiAgICAgICAgaWYgKFNhbWVWYWx1ZVplcm8oc2V0RGF0YVtpXSwga2V5KSkgcmV0dXJuIGk7XHJcbiAgICAgIHJldHVybiAtMTtcclxuICAgIH1cclxuXHJcbiAgICAvLyAyMy4yLjEuMiBuZXcgU2V0ICggLi4uYXJndW1lbnRzTGlzdCApXHJcbiAgICAvLyAyMy4yLjIgUHJvcGVydGllcyBvZiB0aGUgU2V0IENvbnN0cnVjdG9yXHJcblxyXG4gICAgLy8gMjMuMi4yLjEgU2V0LnByb3RvdHlwZVxyXG4gICAgdmFyICRTZXRQcm90b3R5cGUkID0gIHt9O1xyXG4gICAgU2V0LnByb3RvdHlwZSA9ICRTZXRQcm90b3R5cGUkO1xyXG5cclxuICAgIC8vIDIzLjIuMi4yIGdldCBTZXQgWyBAQHNwZWNpZXMgXVxyXG4gICAgLy8gMjMuMi4zIFByb3BlcnRpZXMgb2YgdGhlIFNldCBQcm90b3R5cGUgT2JqZWN0XHJcblxyXG4gICAgLy8gMjMuMi4zLjEgU2V0LnByb3RvdHlwZS5hZGQgKHZhbHVlIClcclxuICAgIGRlZmluZShcclxuICAgICAgU2V0LnByb3RvdHlwZSwgJ2FkZCcsXHJcbiAgICAgIGZ1bmN0aW9uIGFkZCh2YWx1ZSkge1xyXG4gICAgICAgIHZhciBzID0gc3RyaWN0KHRoaXMpO1xyXG4gICAgICAgIGlmIChUeXBlKHMpICE9PSAnb2JqZWN0JykgdGhyb3cgVHlwZUVycm9yKCk7XHJcbiAgICAgICAgaWYgKCEoJ1tbU2V0RGF0YV1dJyBpbiBzKSkgdGhyb3cgVHlwZUVycm9yKCk7XHJcbiAgICAgICAgaWYgKHNbJ1tbU2V0RGF0YV1dJ10gPT09IHVuZGVmaW5lZCkgdGhyb3cgVHlwZUVycm9yKCk7XHJcbiAgICAgICAgaWYgKFNhbWVWYWx1ZSh2YWx1ZSwgLTApKSB2YWx1ZSA9IDA7XHJcbiAgICAgICAgdmFyIGVudHJpZXMgPSBzWydbW1NldERhdGFdXSddO1xyXG4gICAgICAgIHZhciBpID0gU2V0RGF0YUluZGV4T2YoZW50cmllcywgdmFsdWUpO1xyXG4gICAgICAgIGlmIChpIDwgMCkgaSA9IHNbJ1tbU2V0RGF0YV1dJ10ubGVuZ3RoO1xyXG4gICAgICAgIHNbJ1tbU2V0RGF0YV1dJ11baV0gPSB2YWx1ZTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHM7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgIC8vIDIzLjIuMy4yIFNldC5wcm90b3R5cGUuY2xlYXIgKClcclxuICAgIGRlZmluZShcclxuICAgICAgU2V0LnByb3RvdHlwZSwgJ2NsZWFyJyxcclxuICAgICAgZnVuY3Rpb24gY2xlYXIoKSB7XHJcbiAgICAgICAgdmFyIHMgPSBzdHJpY3QodGhpcyk7XHJcbiAgICAgICAgaWYgKFR5cGUocykgIT09ICdvYmplY3QnKSB0aHJvdyBUeXBlRXJyb3IoKTtcclxuICAgICAgICBpZiAoISgnW1tTZXREYXRhXV0nIGluIHMpKSB0aHJvdyBUeXBlRXJyb3IoKTtcclxuICAgICAgICBpZiAoc1snW1tTZXREYXRhXV0nXSA9PT0gdW5kZWZpbmVkKSB0aHJvdyBUeXBlRXJyb3IoKTtcclxuICAgICAgICB2YXIgZW50cmllcyA9IHNbJ1tbU2V0RGF0YV1dJ107XHJcbiAgICAgICAgZW50cmllcy5sZW5ndGggPSAwO1xyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgIC8vIDIzLjIuMy4zIFNldC5wcm90b3R5cGUuY29uc3RydWN0b3JcclxuICAgIC8vIDIzLjIuMy40IFNldC5wcm90b3R5cGUuZGVsZXRlICggdmFsdWUgKVxyXG4gICAgZGVmaW5lKFxyXG4gICAgICBTZXQucHJvdG90eXBlLCAnZGVsZXRlJyxcclxuICAgICAgZnVuY3Rpb24gZGVsZXRlXyh2YWx1ZSkge1xyXG4gICAgICAgIHZhciBzID0gc3RyaWN0KHRoaXMpO1xyXG4gICAgICAgIGlmIChUeXBlKHMpICE9PSAnb2JqZWN0JykgdGhyb3cgVHlwZUVycm9yKCk7XHJcbiAgICAgICAgaWYgKCEoJ1tbU2V0RGF0YV1dJyBpbiBzKSkgdGhyb3cgVHlwZUVycm9yKCk7XHJcbiAgICAgICAgaWYgKHNbJ1tbU2V0RGF0YV1dJ10gPT09IHVuZGVmaW5lZCkgdGhyb3cgVHlwZUVycm9yKCk7XHJcbiAgICAgICAgdmFyIGVudHJpZXMgPSBzWydbW1NldERhdGFdXSddO1xyXG4gICAgICAgIHZhciBpID0gU2V0RGF0YUluZGV4T2YoZW50cmllcywgdmFsdWUpO1xyXG4gICAgICAgIGlmIChpIDwgMCkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIGVudHJpZXNbaV0gPSBlbXB0eTtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgLy8gMjMuMi4zLjUgU2V0LnByb3RvdHlwZS5lbnRyaWVzICggKVxyXG4gICAgZGVmaW5lKFxyXG4gICAgICBTZXQucHJvdG90eXBlLCAnZW50cmllcycsXHJcbiAgICAgIGZ1bmN0aW9uIGVudHJpZXMoKSB7XHJcbiAgICAgICAgdmFyIHMgPSBzdHJpY3QodGhpcyk7XHJcbiAgICAgICAgaWYgKFR5cGUocykgIT09ICdvYmplY3QnKSB0aHJvdyBUeXBlRXJyb3IoKTtcclxuICAgICAgICByZXR1cm4gQ3JlYXRlU2V0SXRlcmF0b3IocywgJ2tleSt2YWx1ZScpO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAvLyAyMy4yLjMuNiBTZXQucHJvdG90eXBlLmZvckVhY2ggKCBjYWxsYmFja2ZuIFsgLCB0aGlzQXJnIF0gKVxyXG4gICAgZGVmaW5lKFxyXG4gICAgICBTZXQucHJvdG90eXBlLCAnZm9yRWFjaCcsXHJcbiAgICAgIGZ1bmN0aW9uIGZvckVhY2goY2FsbGJhY2tmbi8qLCB0aGlzQXJnKi8pIHtcclxuICAgICAgICB2YXIgdGhpc0FyZyA9IGFyZ3VtZW50c1sxXTtcclxuXHJcbiAgICAgICAgdmFyIHMgPSBzdHJpY3QodGhpcyk7XHJcbiAgICAgICAgaWYgKFR5cGUocykgIT09ICdvYmplY3QnKSB0aHJvdyBUeXBlRXJyb3IoKTtcclxuICAgICAgICBpZiAoISgnW1tTZXREYXRhXV0nIGluIHMpKSB0aHJvdyBUeXBlRXJyb3IoKTtcclxuICAgICAgICBpZiAoc1snW1tTZXREYXRhXV0nXSA9PT0gdW5kZWZpbmVkKSB0aHJvdyBUeXBlRXJyb3IoKTtcclxuICAgICAgICB2YXIgZW50cmllcyA9IHNbJ1tbU2V0RGF0YV1dJ107XHJcblxyXG4gICAgICAgIGlmICghSXNDYWxsYWJsZShjYWxsYmFja2ZuKSkge1xyXG4gICAgICAgICAgdGhyb3cgVHlwZUVycm9yKCdGaXJzdCBhcmd1bWVudCB0byBmb3JFYWNoIGlzIG5vdCBjYWxsYWJsZS4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbnRyaWVzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICBpZiAoZW50cmllc1tpXSAhPT0gZW1wdHkpIHtcclxuICAgICAgICAgICAgY2FsbGJhY2tmbi5jYWxsKHRoaXNBcmcsIGVudHJpZXNbaV0sIGVudHJpZXNbaV0sIHMpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcblxyXG4gICAgLy8gMjMuMi4zLjcgU2V0LnByb3RvdHlwZS5oYXMgKCB2YWx1ZSApXHJcbiAgICBkZWZpbmUoXHJcbiAgICAgIFNldC5wcm90b3R5cGUsICdoYXMnLFxyXG4gICAgICBmdW5jdGlvbiBoYXMoa2V5KSB7XHJcbiAgICAgICAgdmFyIHMgPSBzdHJpY3QodGhpcyk7XHJcbiAgICAgICAgaWYgKFR5cGUocykgIT09ICdvYmplY3QnKSB0aHJvdyBUeXBlRXJyb3IoKTtcclxuICAgICAgICBpZiAoISgnW1tTZXREYXRhXV0nIGluIHMpKSB0aHJvdyBUeXBlRXJyb3IoKTtcclxuICAgICAgICBpZiAoc1snW1tTZXREYXRhXV0nXSA9PT0gdW5kZWZpbmVkKSB0aHJvdyBUeXBlRXJyb3IoKTtcclxuICAgICAgICB2YXIgZW50cmllcyA9IHNbJ1tbU2V0RGF0YV1dJ107XHJcbiAgICAgICAgcmV0dXJuIFNldERhdGFJbmRleE9mKGVudHJpZXMsIGtleSkgIT09IC0xO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAvLyAyMy4yLjMuOCBTZXQucHJvdG90eXBlLmtleXMgKCApXHJcbiAgICAvLyBTZWUgU2V0LnByb3RvdHlwZS52YWx1ZXNcclxuXHJcbiAgICAvLyAyMy4yLjMuOSBnZXQgU2V0LnByb3RvdHlwZS5zaXplXHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoXHJcbiAgICAgIFNldC5wcm90b3R5cGUsICdzaXplJywge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICB2YXIgcyA9IHN0cmljdCh0aGlzKTtcclxuICAgICAgICAgIGlmIChUeXBlKHMpICE9PSAnb2JqZWN0JykgdGhyb3cgVHlwZUVycm9yKCk7XHJcbiAgICAgICAgICBpZiAoISgnW1tTZXREYXRhXV0nIGluIHMpKSB0aHJvdyBUeXBlRXJyb3IoKTtcclxuICAgICAgICAgIGlmIChzWydbW1NldERhdGFdXSddID09PSB1bmRlZmluZWQpIHRocm93IFR5cGVFcnJvcigpO1xyXG4gICAgICAgICAgdmFyIGVudHJpZXMgPSBzWydbW1NldERhdGFdXSddO1xyXG4gICAgICAgICAgdmFyIGNvdW50ID0gMDtcclxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZW50cmllcy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICBpZiAoZW50cmllc1tpXSAhPT0gZW1wdHkpXHJcbiAgICAgICAgICAgICAgY291bnQgPSBjb3VudCArIDE7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICByZXR1cm4gY291bnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuXHJcbiAgICAvLyAyMy4yLjMuMTAgU2V0LnByb3RvdHlwZS52YWx1ZXMgKCApXHJcbiAgICBkZWZpbmUoXHJcbiAgICAgIFNldC5wcm90b3R5cGUsICd2YWx1ZXMnLFxyXG4gICAgICBmdW5jdGlvbiB2YWx1ZXMoKSB7XHJcbiAgICAgICAgdmFyIHMgPSBzdHJpY3QodGhpcyk7XHJcbiAgICAgICAgaWYgKFR5cGUocykgIT09ICdvYmplY3QnKSB0aHJvdyBUeXBlRXJyb3IoKTtcclxuICAgICAgICByZXR1cm4gQ3JlYXRlU2V0SXRlcmF0b3IocywgJ3ZhbHVlJyk7XHJcbiAgICAgIH0pO1xyXG4gICAgLy8gTk9URTogZnVuY3Rpb24gbmFtZSBpcyBzdGlsbCAndmFsdWVzJzpcclxuICAgIFNldC5wcm90b3R5cGUua2V5cyA9IFNldC5wcm90b3R5cGUudmFsdWVzO1xyXG5cclxuICAgIC8vIDIzLjIuMy4xMSBTZXQucHJvdG90eXBlIFtAQGl0ZXJhdG9yIF0gKCApXHJcbiAgICBkZWZpbmUoXHJcbiAgICAgIFNldC5wcm90b3R5cGUsICQkaXRlcmF0b3IsXHJcbiAgICAgIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBzID0gc3RyaWN0KHRoaXMpO1xyXG4gICAgICAgIGlmIChUeXBlKHMpICE9PSAnb2JqZWN0JykgdGhyb3cgVHlwZUVycm9yKCk7XHJcbiAgICAgICAgcmV0dXJuIENyZWF0ZVNldEl0ZXJhdG9yKHMpO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAvLyAyMy4yLjMuMTIgU2V0LnByb3RvdHlwZSBbIEBAdG9TdHJpbmdUYWcgXVxyXG4gICAgZGVmaW5lKGdsb2JhbC5TZXQucHJvdG90eXBlLCAkJHRvU3RyaW5nVGFnLCAnU2V0Jyk7XHJcblxyXG4gICAgLy8gMjMuMi40IFByb3BlcnRpZXMgb2YgU2V0IEluc3RhbmNlc1xyXG4gICAgLy8gMjMuMi41IFNldCBJdGVyYXRvciBPYmplY3RzXHJcbiAgICAvKiogQGNvbnN0cnVjdG9yICovXHJcbiAgICBmdW5jdGlvbiBTZXRJdGVyYXRvcigpIHt9XHJcblxyXG4gICAgLy8gMjMuMi41LjEgQ3JlYXRlU2V0SXRlcmF0b3IgQWJzdHJhY3QgT3BlcmF0aW9uXHJcbiAgICBmdW5jdGlvbiBDcmVhdGVTZXRJdGVyYXRvcihzZXQsIGtpbmQpIHtcclxuICAgICAgaWYgKFR5cGUoc2V0KSAhPT0gJ29iamVjdCcpIHRocm93IFR5cGVFcnJvcigpO1xyXG4gICAgICBpZiAoISgnW1tTZXREYXRhXV0nIGluIHNldCkpIHRocm93IFR5cGVFcnJvcigpO1xyXG4gICAgICBpZiAoc2V0WydbW1NldERhdGFdXSddID09PSB1bmRlZmluZWQpIHRocm93IFR5cGVFcnJvcigpO1xyXG4gICAgICB2YXIgaXRlcmF0b3IgPSBuZXcgU2V0SXRlcmF0b3I7XHJcbiAgICAgIHNldF9pbnRlcm5hbChpdGVyYXRvciwgJ1tbSXRlcmF0ZWRTZXRdXScsIHNldCk7XHJcbiAgICAgIHNldF9pbnRlcm5hbChpdGVyYXRvciwgJ1tbU2V0TmV4dEluZGV4XV0nLCAwKTtcclxuICAgICAgc2V0X2ludGVybmFsKGl0ZXJhdG9yLCAnW1tTZXRJdGVyYXRpb25LaW5kXV0nLCBraW5kKTtcclxuICAgICAgcmV0dXJuIGl0ZXJhdG9yO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIDIzLjIuNS4yIFRoZSAlU2V0SXRlcmF0b3JQcm90b3R5cGUlIE9iamVjdFxyXG4gICAgdmFyICRTZXRJdGVyYXRvclByb3RvdHlwZSQgPSBPYmplY3QuY3JlYXRlKCRJdGVyYXRvclByb3RvdHlwZSQpO1xyXG4gICAgU2V0SXRlcmF0b3IucHJvdG90eXBlID0gJFNldEl0ZXJhdG9yUHJvdG90eXBlJDtcclxuXHJcbiAgICAvLyAyMy4yLjUuMi4xICVTZXRJdGVyYXRvclByb3RvdHlwZSUubmV4dCggKVxyXG4gICAgZGVmaW5lKFxyXG4gICAgICAkU2V0SXRlcmF0b3JQcm90b3R5cGUkLCAnbmV4dCcsXHJcbiAgICAgIGZ1bmN0aW9uIG5leHQoKSB7XHJcbiAgICAgICAgdmFyIG8gPSBzdHJpY3QodGhpcyk7XHJcbiAgICAgICAgaWYgKFR5cGUobykgIT09ICdvYmplY3QnKSB0aHJvdyBUeXBlRXJyb3IoKTtcclxuICAgICAgICB2YXIgcyA9IG9bJ1tbSXRlcmF0ZWRTZXRdXSddLFxyXG4gICAgICAgICAgICBpbmRleCA9IG9bJ1tbU2V0TmV4dEluZGV4XV0nXSxcclxuICAgICAgICAgICAgaXRlbUtpbmQgPSBvWydbW1NldEl0ZXJhdGlvbktpbmRdXSddLFxyXG4gICAgICAgICAgICBlbnRyaWVzID0gc1snW1tTZXREYXRhXV0nXTtcclxuICAgICAgICB3aGlsZSAoaW5kZXggPCBlbnRyaWVzLmxlbmd0aCkge1xyXG4gICAgICAgICAgdmFyIGUgPSBlbnRyaWVzW2luZGV4XTtcclxuICAgICAgICAgIGluZGV4ID0gaW5kZXggKz0gMTtcclxuICAgICAgICAgIHNldF9pbnRlcm5hbChvLCAnW1tTZXROZXh0SW5kZXhdXScsIGluZGV4KTtcclxuICAgICAgICAgIGlmIChlICE9PSBlbXB0eSkge1xyXG4gICAgICAgICAgICBpZiAoaXRlbUtpbmQgPT09ICdrZXkrdmFsdWUnKVxyXG4gICAgICAgICAgICAgIHJldHVybiBDcmVhdGVJdGVyUmVzdWx0T2JqZWN0KFtlLCBlXSwgZmFsc2UpO1xyXG4gICAgICAgICAgICByZXR1cm4gQ3JlYXRlSXRlclJlc3VsdE9iamVjdChlLCBmYWxzZSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBDcmVhdGVJdGVyUmVzdWx0T2JqZWN0KHVuZGVmaW5lZCwgdHJ1ZSk7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgIC8vIDIzLjIuNS4yLjIgJVNldEl0ZXJhdG9yUHJvdG90eXBlJSBbIEBAdG9TdHJpbmdUYWcgXVxyXG4gICAgZGVmaW5lKCRTZXRJdGVyYXRvclByb3RvdHlwZSQsICQkdG9TdHJpbmdUYWcsICdTZXQgSXRlcmF0b3InKTtcclxuXHJcbiAgICAvLyAyMy4yLjUuMyBQcm9wZXJ0aWVzIG9mIFNldCBJdGVyYXRvciBJbnN0YW5jZXNcclxuXHJcbiAgfSgpKTtcclxuXHJcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgLy8gMjMuMyBXZWFrTWFwIE9iamVjdHNcclxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcbiAgKGZ1bmN0aW9uKCkge1xyXG4gICAgLy8gMjMuMy4xIFRoZSBXZWFrTWFwIENvbnN0cnVjdG9yXHJcbiAgICAvLyAyMy4zLjEuMSBXZWFrTWFwICggWyBpdGVyYWJsZSBdIClcclxuICAgIC8qKiBAY29uc3RydWN0b3IgKi9cclxuICAgIGZ1bmN0aW9uIFdlYWtNYXAoLyppdGVyYWJsZSovKSB7XHJcbiAgICAgIHZhciBtYXAgPSBzdHJpY3QodGhpcyk7XHJcbiAgICAgIHZhciBpdGVyYWJsZSA9IGFyZ3VtZW50c1swXTtcclxuXHJcbiAgICAgIGlmIChUeXBlKG1hcCkgIT09ICdvYmplY3QnKSB0aHJvdyBUeXBlRXJyb3IoKTtcclxuICAgICAgaWYgKCdbW1dlYWtNYXBEYXRhXV0nIGluIG1hcCkgdGhyb3cgVHlwZUVycm9yKCk7XHJcblxyXG4gICAgICBpZiAoaXRlcmFibGUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHZhciBhZGRlciA9IG1hcFsnc2V0J107XHJcbiAgICAgICAgaWYgKCFJc0NhbGxhYmxlKGFkZGVyKSkgdGhyb3cgVHlwZUVycm9yKCk7XHJcbiAgICAgICAgdmFyIGl0ZXIgPSBHZXRJdGVyYXRvcihUb09iamVjdChpdGVyYWJsZSkpO1xyXG4gICAgICB9XHJcbiAgICAgIHNldF9pbnRlcm5hbChtYXAsICdbW1dlYWtNYXBEYXRhXV0nLCBuZXcgRXBoZW1lcm9uVGFibGUpO1xyXG4gICAgICBpZiAoaXRlciA9PT0gdW5kZWZpbmVkKSByZXR1cm4gbWFwO1xyXG4gICAgICB3aGlsZSAodHJ1ZSkge1xyXG4gICAgICAgIHZhciBuZXh0ID0gSXRlcmF0b3JTdGVwKGl0ZXIpO1xyXG4gICAgICAgIGlmIChuZXh0ID09PSBmYWxzZSlcclxuICAgICAgICAgIHJldHVybiBtYXA7XHJcbiAgICAgICAgdmFyIG5leHRWYWx1ZSA9IEl0ZXJhdG9yVmFsdWUobmV4dCk7XHJcbiAgICAgICAgaWYgKFR5cGUobmV4dFZhbHVlKSAhPT0gJ29iamVjdCcpIHRocm93IFR5cGVFcnJvcigpO1xyXG4gICAgICAgIHZhciBrID0gbmV4dFZhbHVlWzBdO1xyXG4gICAgICAgIHZhciB2ID0gbmV4dFZhbHVlWzFdO1xyXG4gICAgICAgIGFkZGVyLmNhbGwobWFwLCBrLCB2KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIG1hcDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoISgnV2Vha01hcCcgaW4gZ2xvYmFsKSB8fCBPVkVSUklERV9OQVRJVkVfRk9SX1RFU1RJTkcpXHJcbiAgICAgIGdsb2JhbC5XZWFrTWFwID0gV2Vha01hcDtcclxuXHJcbiAgICAvLyAyMy4zLjIgUHJvcGVydGllcyBvZiB0aGUgV2Vha01hcCBDb25zdHJ1Y3RvclxyXG4gICAgLy8gMjMuMy4yLjEgV2Vha01hcC5wcm90b3R5cGVcclxuICAgIHZhciAkV2Vha01hcFByb3RvdHlwZSQgPSB7fTtcclxuICAgIFdlYWtNYXAucHJvdG90eXBlID0gJFdlYWtNYXBQcm90b3R5cGUkO1xyXG5cclxuXHJcblxyXG4gICAvLyAyMy4zLjIuMiBXZWFrTWFwWyBAQGNyZWF0ZSBdICggKVxyXG4gICAgLy8gMjMuMy4zIFByb3BlcnRpZXMgb2YgdGhlIFdlYWtNYXAgUHJvdG90eXBlIE9iamVjdFxyXG5cclxuICAgIC8vIDIzLjMuMy4xIFdlYWtNYXAucHJvdG90eXBlLmNvbnN0cnVjdG9yXHJcblxyXG4gICAgLy8gMjMuMy4zLjIgV2Vha01hcC5wcm90b3R5cGUuZGVsZXRlICgga2V5IClcclxuICAgIGRlZmluZShcclxuICAgICAgV2Vha01hcC5wcm90b3R5cGUsICdkZWxldGUnLFxyXG4gICAgICBmdW5jdGlvbiBkZWxldGVfKGtleSkge1xyXG4gICAgICAgIHZhciBNID0gc3RyaWN0KHRoaXMpO1xyXG4gICAgICAgIGlmIChUeXBlKE0pICE9PSAnb2JqZWN0JykgdGhyb3cgVHlwZUVycm9yKCk7XHJcbiAgICAgICAgaWYgKE1bJ1tbV2Vha01hcERhdGFdXSddID09PSB1bmRlZmluZWQpIHRocm93IFR5cGVFcnJvcigpO1xyXG4gICAgICAgIGlmIChUeXBlKGtleSkgIT09ICdvYmplY3QnKSB0aHJvdyBUeXBlRXJyb3IoJ0V4cGVjdGVkIG9iamVjdCcpO1xyXG4gICAgICAgIHJldHVybiBNWydbW1dlYWtNYXBEYXRhXV0nXS5yZW1vdmUoa2V5KTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgLy8gMjMuMy4zLjMgV2Vha01hcC5wcm90b3R5cGUuZ2V0ICgga2V5IClcclxuICAgIGRlZmluZShcclxuICAgICAgV2Vha01hcC5wcm90b3R5cGUsICdnZXQnLFxyXG4gICAgICBmdW5jdGlvbiBnZXQoa2V5LCBkZWZhdWx0VmFsdWUpIHtcclxuICAgICAgICB2YXIgTSA9IHN0cmljdCh0aGlzKTtcclxuICAgICAgICBpZiAoVHlwZShNKSAhPT0gJ29iamVjdCcpIHRocm93IFR5cGVFcnJvcigpO1xyXG4gICAgICAgIGlmIChNWydbW1dlYWtNYXBEYXRhXV0nXSA9PT0gdW5kZWZpbmVkKSB0aHJvdyBUeXBlRXJyb3IoKTtcclxuICAgICAgICBpZiAoVHlwZShrZXkpICE9PSAnb2JqZWN0JykgdGhyb3cgVHlwZUVycm9yKCdFeHBlY3RlZCBvYmplY3QnKTtcclxuICAgICAgICByZXR1cm4gTVsnW1tXZWFrTWFwRGF0YV1dJ10uZ2V0KGtleSwgZGVmYXVsdFZhbHVlKTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgLy8gMjMuMy4zLjQgV2Vha01hcC5wcm90b3R5cGUuaGFzICgga2V5IClcclxuICAgIGRlZmluZShcclxuICAgICAgV2Vha01hcC5wcm90b3R5cGUsICdoYXMnLFxyXG4gICAgICBmdW5jdGlvbiBoYXMoa2V5KSB7XHJcbiAgICAgICAgdmFyIE0gPSBzdHJpY3QodGhpcyk7XHJcbiAgICAgICAgaWYgKFR5cGUoTSkgIT09ICdvYmplY3QnKSB0aHJvdyBUeXBlRXJyb3IoKTtcclxuICAgICAgICBpZiAoTVsnW1tXZWFrTWFwRGF0YV1dJ10gPT09IHVuZGVmaW5lZCkgdGhyb3cgVHlwZUVycm9yKCk7XHJcbiAgICAgICAgaWYgKFR5cGUoa2V5KSAhPT0gJ29iamVjdCcpIHRocm93IFR5cGVFcnJvcignRXhwZWN0ZWQgb2JqZWN0Jyk7XHJcbiAgICAgICAgcmV0dXJuIE1bJ1tbV2Vha01hcERhdGFdXSddLmhhcyhrZXkpO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAvLyAyMy4zLjMuNSBXZWFrTWFwLnByb3RvdHlwZS5zZXQgKCBrZXkgLCB2YWx1ZSApXHJcbiAgICBkZWZpbmUoXHJcbiAgICAgIFdlYWtNYXAucHJvdG90eXBlLCAnc2V0JyxcclxuICAgICAgZnVuY3Rpb24gc2V0KGtleSwgdmFsdWUpIHtcclxuICAgICAgICB2YXIgTSA9IHN0cmljdCh0aGlzKTtcclxuICAgICAgICBpZiAoVHlwZShNKSAhPT0gJ29iamVjdCcpIHRocm93IFR5cGVFcnJvcigpO1xyXG4gICAgICAgIGlmIChNWydbW1dlYWtNYXBEYXRhXV0nXSA9PT0gdW5kZWZpbmVkKSB0aHJvdyBUeXBlRXJyb3IoKTtcclxuICAgICAgICBpZiAoVHlwZShrZXkpICE9PSAnb2JqZWN0JykgdGhyb3cgVHlwZUVycm9yKCdFeHBlY3RlZCBvYmplY3QnKTtcclxuICAgICAgICBNWydbW1dlYWtNYXBEYXRhXV0nXS5zZXQoa2V5LCB2YWx1ZSk7XHJcbiAgICAgICAgcmV0dXJuIE07XHJcbiAgICAgIH0pO1xyXG5cclxuICAgIC8vIDIzLjMuMy42IFdlYWtNYXAucHJvdG90eXBlIFsgQEB0b1N0cmluZ1RhZyBdXHJcbiAgICBkZWZpbmUoZ2xvYmFsLldlYWtNYXAucHJvdG90eXBlLCAkJHRvU3RyaW5nVGFnLCAnV2Vha01hcCcpO1xyXG5cclxuICAgIC8vIDIzLjMuNCBQcm9wZXJ0aWVzIG9mIFdlYWtNYXAgSW5zdGFuY2VzXHJcblxyXG4gICAgLy8gUG9seWZpbGxzIGZvciBpbmNvbXBsZXRlIG5hdGl2ZSBpbXBsZW1lbnRhdGlvbnM6XHJcbiAgICAoZnVuY3Rpb24oKSB7XHJcbiAgICAgIHZhciB3bSA9IG5ldyBnbG9iYWwuV2Vha01hcCgpO1xyXG4gICAgICB2YXIgb3JpZyA9IGdsb2JhbC5XZWFrTWFwLnByb3RvdHlwZS5zZXQ7XHJcbiAgICAgIGRlZmluZShnbG9iYWwuV2Vha01hcC5wcm90b3R5cGUsICdzZXQnLCBmdW5jdGlvbiBzZXQoKSB7XHJcbiAgICAgICAgb3JpZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICB9LCB3bS5zZXQoe30sIDApICE9PSB3bSk7XHJcbiAgICB9KCkpO1xyXG4gIH0oKSk7XHJcblxyXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gIC8vIDIzLjQgV2Vha1NldCBPYmplY3RzXHJcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG4gIChmdW5jdGlvbigpIHtcclxuICAgIC8vIDIzLjQuMSBUaGUgV2Vha1NldCBDb25zdHJ1Y3RvclxyXG4gICAgLy8gMjMuNC4xLjEgV2Vha1NldCAoIFsgaXRlcmFibGUgXSApXHJcbiAgICAvKiogQGNvbnN0cnVjdG9yICovXHJcbiAgICBmdW5jdGlvbiBXZWFrU2V0KC8qaXRlcmFibGUqLykge1xyXG4gICAgICB2YXIgc2V0ID0gc3RyaWN0KHRoaXMpO1xyXG4gICAgICB2YXIgaXRlcmFibGUgPSBhcmd1bWVudHNbMF07XHJcblxyXG4gICAgICBpZiAoVHlwZShzZXQpICE9PSAnb2JqZWN0JykgdGhyb3cgVHlwZUVycm9yKCk7XHJcbiAgICAgIGlmICgnW1tXZWFrU2V0RGF0YV1dJyBpbiBzZXQpIHRocm93IFR5cGVFcnJvcigpO1xyXG5cclxuICAgICAgaWYgKGl0ZXJhYmxlICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICB2YXIgYWRkZXIgPSBzZXRbJ2FkZCddO1xyXG4gICAgICAgIGlmICghSXNDYWxsYWJsZShhZGRlcikpIHRocm93IFR5cGVFcnJvcigpO1xyXG4gICAgICAgIHZhciBpdGVyID0gR2V0SXRlcmF0b3IoVG9PYmplY3QoaXRlcmFibGUpKTtcclxuICAgICAgfVxyXG4gICAgICBzZXRfaW50ZXJuYWwoc2V0LCAnW1tXZWFrU2V0RGF0YV1dJywgbmV3IEVwaGVtZXJvblRhYmxlKTtcclxuICAgICAgaWYgKGl0ZXIgPT09IHVuZGVmaW5lZCkgcmV0dXJuIHNldDtcclxuICAgICAgd2hpbGUgKHRydWUpIHtcclxuICAgICAgICB2YXIgbmV4dCA9IEl0ZXJhdG9yU3RlcChpdGVyKTtcclxuICAgICAgICBpZiAobmV4dCA9PT0gZmFsc2UpXHJcbiAgICAgICAgICByZXR1cm4gc2V0O1xyXG4gICAgICAgIHZhciBuZXh0VmFsdWUgPSBJdGVyYXRvclZhbHVlKG5leHQpO1xyXG4gICAgICAgIGFkZGVyLmNhbGwoc2V0LCBuZXh0VmFsdWUpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gc2V0O1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghKCdXZWFrU2V0JyBpbiBnbG9iYWwpIHx8IE9WRVJSSURFX05BVElWRV9GT1JfVEVTVElORylcclxuICAgICAgZ2xvYmFsLldlYWtTZXQgPSBXZWFrU2V0O1xyXG5cclxuICAgIC8vIDIzLjQuMiBQcm9wZXJ0aWVzIG9mIHRoZSBXZWFrU2V0IENvbnN0cnVjdG9yXHJcbiAgICAvLyAyMy40LjIuMSBXZWFrU2V0LnByb3RvdHlwZVxyXG4gICAgdmFyICRXZWFrU2V0UHJvdG90eXBlJCA9IHt9O1xyXG4gICAgV2Vha1NldC5wcm90b3R5cGUgPSAkV2Vha1NldFByb3RvdHlwZSQ7XHJcblxyXG4gICAgLy8gMjMuNC4zIFByb3BlcnRpZXMgb2YgdGhlIFdlYWtTZXQgUHJvdG90eXBlIE9iamVjdFxyXG4gICAgLy8gMjMuNC4zLjEgV2Vha1NldC5wcm90b3R5cGUuYWRkICh2YWx1ZSApXHJcbiAgICBkZWZpbmUoXHJcbiAgICAgIFdlYWtTZXQucHJvdG90eXBlLCAnYWRkJyxcclxuICAgICAgZnVuY3Rpb24gYWRkKHZhbHVlKSB7XHJcbiAgICAgICAgdmFyIFMgPSBzdHJpY3QodGhpcyk7XHJcbiAgICAgICAgaWYgKFR5cGUoUykgIT09ICdvYmplY3QnKSB0aHJvdyBUeXBlRXJyb3IoKTtcclxuICAgICAgICBpZiAoU1snW1tXZWFrU2V0RGF0YV1dJ10gPT09IHVuZGVmaW5lZCkgdGhyb3cgVHlwZUVycm9yKCk7XHJcbiAgICAgICAgaWYgKFR5cGUodmFsdWUpICE9PSAnb2JqZWN0JykgdGhyb3cgVHlwZUVycm9yKCdFeHBlY3RlZCBvYmplY3QnKTtcclxuICAgICAgICBTWydbW1dlYWtTZXREYXRhXV0nXS5zZXQodmFsdWUsIHRydWUpO1xyXG4gICAgICAgIHJldHVybiBTO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAvLyAyMy40LjMuMiBXZWFrU2V0LnByb3RvdHlwZS5jb25zdHJ1Y3RvclxyXG4gICAgLy8gMjMuNC4zLjMgV2Vha1NldC5wcm90b3R5cGUuZGVsZXRlICggdmFsdWUgKVxyXG4gICAgZGVmaW5lKFxyXG4gICAgICBXZWFrU2V0LnByb3RvdHlwZSwgJ2RlbGV0ZScsXHJcbiAgICAgIGZ1bmN0aW9uIGRlbGV0ZV8odmFsdWUpIHtcclxuICAgICAgICB2YXIgUyA9IHN0cmljdCh0aGlzKTtcclxuICAgICAgICBpZiAoVHlwZShTKSAhPT0gJ29iamVjdCcpIHRocm93IFR5cGVFcnJvcigpO1xyXG4gICAgICAgIGlmIChTWydbW1dlYWtTZXREYXRhXV0nXSA9PT0gdW5kZWZpbmVkKSB0aHJvdyBUeXBlRXJyb3IoKTtcclxuICAgICAgICBpZiAoVHlwZSh2YWx1ZSkgIT09ICdvYmplY3QnKSB0aHJvdyBUeXBlRXJyb3IoJ0V4cGVjdGVkIG9iamVjdCcpO1xyXG4gICAgICAgIHJldHVybiBTWydbW1dlYWtTZXREYXRhXV0nXS5yZW1vdmUodmFsdWUpO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAvLyAyMy40LjMuNCBXZWFrU2V0LnByb3RvdHlwZS5oYXMgKCB2YWx1ZSApXHJcbiAgICBkZWZpbmUoXHJcbiAgICAgIFdlYWtTZXQucHJvdG90eXBlLCAnaGFzJyxcclxuICAgICAgZnVuY3Rpb24gaGFzKGtleSkge1xyXG4gICAgICAgIHZhciBTID0gc3RyaWN0KHRoaXMpO1xyXG4gICAgICAgIGlmIChUeXBlKFMpICE9PSAnb2JqZWN0JykgdGhyb3cgVHlwZUVycm9yKCk7XHJcbiAgICAgICAgaWYgKFNbJ1tbV2Vha1NldERhdGFdXSddID09PSB1bmRlZmluZWQpIHRocm93IFR5cGVFcnJvcigpO1xyXG4gICAgICAgIGlmIChUeXBlKGtleSkgIT09ICdvYmplY3QnKSB0aHJvdyBUeXBlRXJyb3IoJ0V4cGVjdGVkIG9iamVjdCcpO1xyXG4gICAgICAgIHJldHVybiBTWydbW1dlYWtTZXREYXRhXV0nXS5oYXMoa2V5KTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgLy8gMjMuNC4zLjUgV2Vha1NldC5wcm90b3R5cGUgWyBAQHRvU3RyaW5nVGFnIF1cclxuICAgIGRlZmluZShnbG9iYWwuV2Vha1NldC5wcm90b3R5cGUsICQkdG9TdHJpbmdUYWcsICdXZWFrU2V0Jyk7XHJcblxyXG4gICAgLy8gMjMuNC40IFByb3BlcnRpZXMgb2YgV2Vha1NldCBJbnN0YW5jZXNcclxuXHJcbiAgICAvLyBQb2x5ZmlsbHMgZm9yIGluY29tcGxldGUgbmF0aXZlIGltcGxlbWVudGF0aW9uczpcclxuICAgIChmdW5jdGlvbigpIHtcclxuICAgICAgdmFyIHdzID0gbmV3IGdsb2JhbC5XZWFrU2V0KCk7XHJcbiAgICAgIHZhciBvcmlnID0gZ2xvYmFsLldlYWtTZXQucHJvdG90eXBlLmFkZDtcclxuICAgICAgZGVmaW5lKGdsb2JhbC5XZWFrU2V0LnByb3RvdHlwZSwgJ2FkZCcsIGZ1bmN0aW9uIGFkZCgpIHtcclxuICAgICAgICBvcmlnLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgIH0sIHdzLmFkZCh7fSkgIT09IHdzKTtcclxuICAgIH0oKSk7XHJcbiAgfSgpKTtcclxuXHJcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgLy8gMjQgU3RydWN0dXJlZCBEYXRhXHJcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gIC8vIDI0LjEgQXJyYXlCdWZmZXIgT2JqZWN0c1xyXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cclxuICAvLyBTZWUgdHlwZWRhcnJheS5qcyBmb3IgVHlwZWRBcnJheSBwb2x5ZmlsbFxyXG5cclxuICAoZnVuY3Rpb24oKSB7XHJcbiAgICBpZiAoISgnQXJyYXlCdWZmZXInIGluIGdsb2JhbCkpXHJcbiAgICAgIHJldHVybjtcclxuXHJcbiAgICAvLyAyNC4xLjEgQWJzdHJhY3QgT3BlcmF0aW9ucyBGb3IgQXJyYXlCdWZmZXIgT2JqZWN0c1xyXG4gICAgLy8gMjQuMS4xLjEgQWxsb2NhdGVBcnJheUJ1ZmZlciggY29uc3RydWN0b3IsIGJ5dGVMZW5ndGggKVxyXG4gICAgLy8gMjQuMS4xLjIgSXNEZXRhY2hlZEJ1ZmZlciggYXJyYXlCdWZmZXIgKVxyXG4gICAgLy8gMjQuMS4xLjMgRGV0YWNoQXJyYXlCdWZmZXIoIGFycmF5QnVmZmVyIClcclxuICAgIC8vIDI0LjEuMS40IENsb25lQXJyYXlCdWZmZXIoIHNyY0J1ZmZlciwgc3JjQnl0ZU9mZnNldCBbLCBjbG9uZUNvbnN0cnVjdG9yXSApXHJcbiAgICAvLyAyNC4xLjEuNSBHZXRWYWx1ZUZyb21CdWZmZXIgKCBhcnJheUJ1ZmZlciwgYnl0ZUluZGV4LCB0eXBlLCBpc0xpdHRsZUVuZGlhbiApXHJcbiAgICAvLyAyNC4xLjEuNiBTZXRWYWx1ZUluQnVmZmVyICggYXJyYXlCdWZmZXIsIGJ5dGVJbmRleCwgdHlwZSwgdmFsdWUsIGlzTGl0dGxlRW5kaWFuIClcclxuICAgIC8vIDI0LjEuMiBUaGUgQXJyYXlCdWZmZXIgQ29uc3RydWN0b3JcclxuICAgIC8vIDI0LjEuMi4xIEFycmF5QnVmZmVyKCBsZW5ndGggKVxyXG4gICAgLy8gMjQuMS4zIFByb3BlcnRpZXMgb2YgdGhlIEFycmF5QnVmZmVyIENvbnN0cnVjdG9yXHJcblxyXG4gICAgLy8gMjQuMS4zLjEgQXJyYXlCdWZmZXIuaXNWaWV3ICggYXJnIClcclxuICAgIGRlZmluZShcclxuICAgICAgQXJyYXlCdWZmZXIsICdpc1ZpZXcnLFxyXG4gICAgICBmdW5jdGlvbiBpc1ZpZXcoYXJnKSB7XHJcbiAgICAgICAgaWYgKFR5cGUoYXJnKSAhPT0gJ29iamVjdCcpIHJldHVybiBmYWxzZTtcclxuICAgICAgICBpZiAoJ2J1ZmZlcicgaW4gYXJnICYmIGFyZy5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAvLyAyNC4xLjMuMiBBcnJheUJ1ZmZlci5wcm90b3R5cGVcclxuICAgIC8vIDI0LjEuMy4zIGdldCBBcnJheUJ1ZmZlciBbIEBAc3BlY2llcyBdXHJcbiAgICAvLyAyNC4xLjQgUHJvcGVydGllcyBvZiB0aGUgQXJyYXlCdWZmZXIgUHJvdG90eXBlIE9iamVjdFxyXG4gICAgLy8gMjQuMS40LjEgZ2V0IEFycmF5QnVmZmVyLnByb3RvdHlwZS5ieXRlTGVuZ3RoXHJcbiAgICAvLyAyNC4xLjQuMiBBcnJheUJ1ZmZlci5wcm90b3R5cGUuY29uc3RydWN0b3JcclxuICAgIC8vIDI0LjEuNC4zIEFycmF5QnVmZmVyLnByb3RvdHlwZS5zbGljZSAoIHN0YXJ0ICwgZW5kKVxyXG5cclxuICAgIC8vIDI0LjEuNC40IEFycmF5QnVmZmVyLnByb3RvdHlwZSBbIEBAdG9TdHJpbmdUYWcgXVxyXG4gICAgZGVmaW5lKEFycmF5QnVmZmVyLnByb3RvdHlwZSwgJCR0b1N0cmluZ1RhZywgJ0FycmF5QnVmZmVyJyk7XHJcblxyXG4gICAgLy8gMjQuMS41IFByb3BlcnRpZXMgb2YgdGhlIEFycmF5QnVmZmVyIEluc3RhbmNlc1xyXG4gIH0oKSk7XHJcblxyXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gIC8vIDI0LjIgRGF0YVZpZXcgT2JqZWN0c1xyXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cclxuICAvLyBTZWUgdHlwZWRhcnJheS5qcyBmb3IgVHlwZWRBcnJheSBwb2x5ZmlsbFxyXG5cclxuICAoZnVuY3Rpb24oKSB7XHJcbiAgICBpZiAoISgnRGF0YVZpZXcnIGluIGdsb2JhbCkpXHJcbiAgICAgIHJldHVybjtcclxuXHJcbiAgICAvLyAyNC4yLjEgQWJzdHJhY3QgT3BlcmF0aW9ucyBGb3IgRGF0YVZpZXcgT2JqZWN0c1xyXG4gICAgLy8gMjQuMi4xLjEgR2V0Vmlld1ZhbHVlKHZpZXcsIHJlcXVlc3RJbmRleCwgaXNMaXR0bGVFbmRpYW4sIHR5cGUpXHJcbiAgICAvLyAyNC4yLjEuMiBTZXRWaWV3VmFsdWUodmlldywgcmVxdWVzdEluZGV4LCBpc0xpdHRsZUVuZGlhbiwgdHlwZSwgdmFsdWUpXHJcbiAgICAvLyAyNC4yLjIgVGhlIERhdGFWaWV3IENvbnN0cnVjdG9yXHJcbiAgICAvLyAyNC4yLjIuMSBEYXRhVmlldyAoYnVmZmVyIFsgLCBieXRlT2Zmc2V0IFsgLCBieXRlTGVuZ3RoIF0gXSApXHJcbiAgICAvLyAyNC4yLjMgUHJvcGVydGllcyBvZiB0aGUgRGF0YVZpZXcgQ29uc3RydWN0b3JcclxuICAgIC8vIDI0LjIuMy4xIERhdGFWaWV3LnByb3RvdHlwZVxyXG4gICAgLy8gMjQuMi40IFByb3BlcnRpZXMgb2YgdGhlIERhdGFWaWV3IFByb3RvdHlwZSBPYmplY3RcclxuICAgIC8vIDI0LjIuNC4xIGdldCBEYXRhVmlldy5wcm90b3R5cGUuYnVmZmVyXHJcbiAgICAvLyAyNC4yLjQuMiBnZXQgRGF0YVZpZXcucHJvdG90eXBlLmJ5dGVMZW5ndGhcclxuICAgIC8vIDI0LjIuNC4zIGdldCBEYXRhVmlldy5wcm90b3R5cGUuYnl0ZU9mZnNldFxyXG4gICAgLy8gMjQuMi40LjQgRGF0YVZpZXcucHJvdG90eXBlLmNvbnN0cnVjdG9yXHJcbiAgICAvLyAyNC4yLjQuNSBEYXRhVmlldy5wcm90b3R5cGUuZ2V0RmxvYXQzMiAoIGJ5dGVPZmZzZXQgWyAsIGxpdHRsZUVuZGlhbiBdIClcclxuICAgIC8vIDI0LjIuNC42IERhdGFWaWV3LnByb3RvdHlwZS5nZXRGbG9hdDY0ICggYnl0ZU9mZnNldCBbICwgbGl0dGxlRW5kaWFuIF0gKVxyXG4gICAgLy8gMjQuMi40LjcgRGF0YVZpZXcucHJvdG90eXBlLmdldEludDggKCBieXRlT2Zmc2V0IClcclxuICAgIC8vIDI0LjIuNC44IERhdGFWaWV3LnByb3RvdHlwZS5nZXRJbnQxNiAoIGJ5dGVPZmZzZXQgWyAsIGxpdHRsZUVuZGlhbiBdIClcclxuICAgIC8vIDI0LjIuNC45IERhdGFWaWV3LnByb3RvdHlwZS5nZXRJbnQzMiAoIGJ5dGVPZmZzZXQgWyAsIGxpdHRsZUVuZGlhbiBdIClcclxuICAgIC8vIDI0LjIuNC4xMCBEYXRhVmlldy5wcm90b3R5cGUuZ2V0VWludDggKCBieXRlT2Zmc2V0IClcclxuICAgIC8vIDI0LjIuNC4xMSBEYXRhVmlldy5wcm90b3R5cGUuZ2V0VWludDE2ICggYnl0ZU9mZnNldCBbICwgbGl0dGxlRW5kaWFuIF0gKVxyXG4gICAgLy8gMjQuMi40LjEyIERhdGFWaWV3LnByb3RvdHlwZS5nZXRVaW50MzIgKCBieXRlT2Zmc2V0IFsgLCBsaXR0bGVFbmRpYW4gXSApXHJcbiAgICAvLyAyNC4yLjQuMTMgRGF0YVZpZXcucHJvdG90eXBlLnNldEZsb2F0MzIgKCBieXRlT2Zmc2V0LCB2YWx1ZSBbICwgbGl0dGxlRW5kaWFuIF0gKVxyXG4gICAgLy8gMjQuMi40LjE0IERhdGFWaWV3LnByb3RvdHlwZS5zZXRGbG9hdDY0ICggYnl0ZU9mZnNldCwgdmFsdWUgWyAsIGxpdHRsZUVuZGlhbiBdIClcclxuICAgIC8vIDI0LjIuNC4xNSBEYXRhVmlldy5wcm90b3R5cGUuc2V0SW50OCAoIGJ5dGVPZmZzZXQsIHZhbHVlIClcclxuICAgIC8vIDI0LjIuNC4xNiBEYXRhVmlldy5wcm90b3R5cGUuc2V0SW50MTYgKCBieXRlT2Zmc2V0LCB2YWx1ZSBbICwgbGl0dGxlRW5kaWFuIF0gKVxyXG4gICAgLy8gMjQuMi40LjE3IERhdGFWaWV3LnByb3RvdHlwZS5zZXRJbnQzMiAoIGJ5dGVPZmZzZXQsIHZhbHVlIFsgLCBsaXR0bGVFbmRpYW4gXSApXHJcbiAgICAvLyAyNC4yLjQuMTggRGF0YVZpZXcucHJvdG90eXBlLnNldFVpbnQ4ICggYnl0ZU9mZnNldCwgdmFsdWUgKVxyXG4gICAgLy8gMjQuMi40LjE5IERhdGFWaWV3LnByb3RvdHlwZS5zZXRVaW50MTYgKCBieXRlT2Zmc2V0LCB2YWx1ZSBbICwgbGl0dGxlRW5kaWFuIF0gKVxyXG4gICAgLy8gMjQuMi40LjIwIERhdGFWaWV3LnByb3RvdHlwZS5zZXRVaW50MzIgKCBieXRlT2Zmc2V0LCB2YWx1ZSBbICwgbGl0dGxlRW5kaWFuIF0gKVxyXG5cclxuICAgIC8vIDI0LjIuNC4yMSBEYXRhVmlldy5wcm90b3R5cGVbIEBAdG9TdHJpbmdUYWcgXVxyXG4gICAgZGVmaW5lKERhdGFWaWV3LnByb3RvdHlwZSwgJCR0b1N0cmluZ1RhZywgJ0RhdGFWaWV3Jyk7XHJcblxyXG4gICAgLy8gMjQuMi41IFByb3BlcnRpZXMgb2YgRGF0YVZpZXcgSW5zdGFuY2VzXHJcbiAgfSgpKTtcclxuXHJcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgLy8gMjQuMyBUaGUgSlNPTiBPYmplY3RcclxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcbiAgLy8gMjQuMy4xIEpTT04ucGFyc2UgKCB0ZXh0IFsgLCByZXZpdmVyIF0gKVxyXG4gIC8vIDI0LjMuMiBKU09OLnN0cmluZ2lmeSAoIHZhbHVlIFsgLCByZXBsYWNlciBbICwgc3BhY2UgXSBdIClcclxuICAvLyAyNC4zLjMgSlNPTiBbIEBAdG9TdHJpbmdUYWcgXVxyXG4gIGRlZmluZShKU09OLCAkJHRvU3RyaW5nVGFnLCAnSlNPTicpO1xyXG5cclxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAvLyAyNS4xIEl0ZXJhdGlvblxyXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cclxuICAvLyAyNS4xLjEgQ29tbW9uIEl0ZXJhdGlvbiBJbnRlcmZhY2VzXHJcbiAgLy8gMjUuMS4xLjEgVGhlIEl0ZXJhYmxlIEludGVyZmFjZVxyXG4gIC8vIDI1LjEuMS4yIFRoZSBJdGVyYXRvciBJbnRlcmZhY2VcclxuICAvLyAyNS4xLjEuMyBUaGUgSXRlcmF0b3JSZXN1bHQgSW50ZXJmYWNlXHJcblxyXG4gIC8vIDI1LjEuMiBUaGUgJUl0ZXJhdG9yUHJvdG90eXBlJSBPYmplY3RcclxuICAvLyBEZWZpbmVkIGVhcmxpZXIsIHNvIG90aGVyIHByb3RvdHlwZXMgY2FuIHJlZmVyZW5jZSBpdC5cclxuICAvLyAyNS4xLjIuMSAlSXRlcmF0b3JQcm90b3R5cGUlIFsgQEBpdGVyYXRvciBdICggKVxyXG4gIGRlZmluZSgkSXRlcmF0b3JQcm90b3R5cGUkLCAkJGl0ZXJhdG9yLCBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH0pO1xyXG5cclxuXHJcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgLy8gMjUuNCBQcm9taXNlIE9iamVjdHNcclxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcbiAgKGZ1bmN0aW9uKCkge1xyXG4gICAgLy8gMjUuNCBQcm9taXNlIE9iamVjdHNcclxuXHJcbiAgICAvLyAyNS40LjEgUHJvbWlzZSBBYnN0cmFjdCBPcGVyYXRpb25zXHJcblxyXG4gICAgLy8gMjUuNC4xLjEgUHJvbWlzZUNhcGFiaWxpdHkgUmVjb3Jkc1xyXG4gICAgLy8gMjUuNC4xLjEuMSBJZkFicnVwdFJlamVjdFByb21pc2UgKCB2YWx1ZSwgY2FwYWJpbGl0eSApXHJcblxyXG4gICAgZnVuY3Rpb24gSWZBYnJ1cHRSZWplY3RQcm9taXNlKHZhbHVlLCBjYXBhYmlsaXR5KSB7XHJcbiAgICAgIHZhciByZWplY3RSZXN1bHQgPSBjYXBhYmlsaXR5WydbW1JlamVjdF1dJ10uY2FsbCh1bmRlZmluZWQsIHZhbHVlKTtcclxuICAgICAgcmV0dXJuIGNhcGFiaWxpdHlbJ1tbUHJvbWlzZV1dJ107XHJcbiAgICB9XHJcblxyXG4gICAgLy8gMjUuNC4xLjIgUHJvbWlzZVJlYWN0aW9uIFJlY29yZHNcclxuXHJcbiAgICAvLyAyNS40LjEuMyBDcmVhdGVSZXNvbHZpbmdGdW5jdGlvbnMgKCBwcm9taXNlIClcclxuXHJcbiAgICBmdW5jdGlvbiBDcmVhdGVSZXNvbHZpbmdGdW5jdGlvbnMocHJvbWlzZSkge1xyXG4gICAgICB2YXIgYWxyZWFkeVJlc29sdmVkID0geydbW3ZhbHVlXV0nOiBmYWxzZX07XHJcbiAgICAgIHZhciByZXNvbHZlID0gUHJvbWlzZVJlc29sdmVGdW5jdGlvbigpO1xyXG4gICAgICBzZXRfaW50ZXJuYWwocmVzb2x2ZSwgJ1tbUHJvbWlzZV1dJywgIHByb21pc2UpO1xyXG4gICAgICBzZXRfaW50ZXJuYWwocmVzb2x2ZSwgJ1tbQWxyZWFkeVJlc29sdmVkXV0nLCBhbHJlYWR5UmVzb2x2ZWQpO1xyXG4gICAgICB2YXIgcmVqZWN0ID0gUHJvbWlzZVJlamVjdEZ1bmN0aW9uKCk7XHJcbiAgICAgIHNldF9pbnRlcm5hbChyZWplY3QsICdbW1Byb21pc2VdXScsIHByb21pc2UpO1xyXG4gICAgICBzZXRfaW50ZXJuYWwocmVqZWN0LCAnW1tBbHJlYWR5UmVzb2x2ZWRdXScsIGFscmVhZHlSZXNvbHZlZCk7XHJcbiAgICAgIHJldHVybiB7ICdbW1Jlc29sdmVdXSc6IHJlc29sdmUsICdbW1JlamVjdF1dJzogcmVqZWN0fTtcclxuICAgIH1cclxuXHJcbiAgICAvLyAyNS40LjEuMy4xIFByb21pc2UgUmVqZWN0IEZ1bmN0aW9uc1xyXG5cclxuICAgIGZ1bmN0aW9uIFByb21pc2VSZWplY3RGdW5jdGlvbigpIHtcclxuICAgICAgdmFyIEYgPSBmdW5jdGlvbihyZWFzb24pIHtcclxuICAgICAgICBjb25zb2xlLmFzc2VydChUeXBlKEZbJ1tbUHJvbWlzZV1dJ10pID09PSAnb2JqZWN0Jyk7XHJcbiAgICAgICAgdmFyIHByb21pc2UgPSBGWydbW1Byb21pc2VdXSddO1xyXG4gICAgICAgIHZhciBhbHJlYWR5UmVzb2x2ZWQgPSBGWydbW0FscmVhZHlSZXNvbHZlZF1dJ107XHJcbiAgICAgICAgaWYgKGFscmVhZHlSZXNvbHZlZFsnW1t2YWx1ZV1dJ10pIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgc2V0X2ludGVybmFsKGFscmVhZHlSZXNvbHZlZCwgJ1tbdmFsdWVdXScsIHRydWUpO1xyXG4gICAgICAgIHJldHVybiBSZWplY3RQcm9taXNlKHByb21pc2UsIHJlYXNvbik7XHJcbiAgICAgIH07XHJcbiAgICAgIHJldHVybiBGO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIDI1LjQuMS4zLjIgUHJvbWlzZSBSZXNvbHZlIEZ1bmN0aW9uc1xyXG5cclxuICAgIGZ1bmN0aW9uIFByb21pc2VSZXNvbHZlRnVuY3Rpb24oKSB7XHJcbiAgICAgIHZhciBGID0gZnVuY3Rpb24ocmVzb2x1dGlvbikge1xyXG4gICAgICAgIGNvbnNvbGUuYXNzZXJ0KFR5cGUoRlsnW1tQcm9taXNlXV0nXSkgPT09ICdvYmplY3QnKTtcclxuICAgICAgICB2YXIgcHJvbWlzZSA9IEZbJ1tbUHJvbWlzZV1dJ107XHJcbiAgICAgICAgdmFyIGFscmVhZHlSZXNvbHZlZCA9IEZbJ1tbQWxyZWFkeVJlc29sdmVkXV0nXTtcclxuICAgICAgICBpZiAoYWxyZWFkeVJlc29sdmVkWydbW3ZhbHVlXV0nXSkgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICBzZXRfaW50ZXJuYWwoYWxyZWFkeVJlc29sdmVkLCAnW1t2YWx1ZV1dJywgdHJ1ZSk7XHJcblxyXG4gICAgICAgIGlmIChTYW1lVmFsdWUocmVzb2x1dGlvbiwgcHJvbWlzZSkpICB7XHJcbiAgICAgICAgICB2YXIgc2VsZlJlc29sdXRpb25FcnJvciA9IFR5cGVFcnJvcigpO1xyXG4gICAgICAgICAgcmV0dXJuIFJlamVjdFByb21pc2UocHJvbWlzZSwgc2VsZlJlc29sdXRpb25FcnJvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChUeXBlKHJlc29sdXRpb24pICE9PSAnb2JqZWN0JylcclxuICAgICAgICAgIHJldHVybiBGdWxmaWxsUHJvbWlzZShwcm9taXNlLCByZXNvbHV0aW9uKTtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgdmFyIHRoZW4gPSByZXNvbHV0aW9uWyd0aGVuJ107XHJcbiAgICAgICAgfSBjYXRjaCh0aGVuKSB7XHJcbiAgICAgICAgICByZXR1cm4gUmVqZWN0UHJvbWlzZShwcm9taXNlLCB0aGVuKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFJc0NhbGxhYmxlKHRoZW4pKVxyXG4gICAgICAgICAgcmV0dXJuIEZ1bGZpbGxQcm9taXNlKHByb21pc2UsIHJlc29sdXRpb24pO1xyXG4gICAgICAgIEVucXVldWVKb2IoJ1Byb21pc2VKb2JzJywgUHJvbWlzZVJlc29sdmVUaGVuYWJsZUpvYiwgW3Byb21pc2UsIHJlc29sdXRpb24sIHRoZW5dKTtcclxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICB9O1xyXG4gICAgICByZXR1cm4gRjtcclxuICAgIH1cclxuXHJcbiAgICAvLyAyNS40LjEuNCBGdWxmaWxsUHJvbWlzZSAoIHByb21pc2UsIHZhbHVlIClcclxuXHJcbiAgICBmdW5jdGlvbiBGdWxmaWxsUHJvbWlzZShwcm9taXNlLCB2YWx1ZSkge1xyXG4gICAgICBjb25zb2xlLmFzc2VydChwcm9taXNlWydbW1Byb21pc2VTdGF0ZV1dJ10gPT09ICdwZW5kaW5nJyk7XHJcbiAgICAgIHZhciByZWFjdGlvbnMgPSBwcm9taXNlWydbW1Byb21pc2VGdWxmaWxsUmVhY3Rpb25zXV0nXTtcclxuICAgICAgc2V0X2ludGVybmFsKHByb21pc2UsICdbW1Byb21pc2VSZXN1bHRdXScsIHZhbHVlKTtcclxuICAgICAgc2V0X2ludGVybmFsKHByb21pc2UsICdbW1Byb21pc2VGdWxmaWxsUmVhY3Rpb25zXV0nLCB1bmRlZmluZWQpO1xyXG4gICAgICBzZXRfaW50ZXJuYWwocHJvbWlzZSwgJ1tbUHJvbWlzZVJlamVjdFJlYWN0aW9uc11dJywgdW5kZWZpbmVkKTtcclxuICAgICAgc2V0X2ludGVybmFsKHByb21pc2UsICdbW1Byb21pc2VTdGF0ZV1dJywgJ2Z1bGZpbGxlZCcpO1xyXG4gICAgICByZXR1cm4gVHJpZ2dlclByb21pc2VSZWFjdGlvbnMocmVhY3Rpb25zLCB2YWx1ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gMjUuNC4xLjUgTmV3UHJvbWlzZUNhcGFiaWxpdHkgKCBDIClcclxuXHJcbiAgICBmdW5jdGlvbiBOZXdQcm9taXNlQ2FwYWJpbGl0eShjKSB7XHJcbiAgICAgIC8vIFRvIGtlZXAgUHJvbWlzZSBoZXJtZXRpYywgdGhpcyBkb2Vzbid0IGxvb2sgbXVjaCBsaWtlIHRoZSBzcGVjLlxyXG4gICAgICByZXR1cm4gQ3JlYXRlUHJvbWlzZUNhcGFiaWxpdHlSZWNvcmQodW5kZWZpbmVkLCBjKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyAyNS40LjEuNS4xIENyZWF0ZVByb21pc2VDYXBhYmlsaXR5UmVjb3JkICggcHJvbWlzZSwgY29uc3RydWN0b3IgKVxyXG5cclxuICAgIGZ1bmN0aW9uIENyZWF0ZVByb21pc2VDYXBhYmlsaXR5UmVjb3JkKHByb21pc2UsIGNvbnN0cnVjdG9yKSB7XHJcbiAgICAgIC8vIFRvIGtlZXAgUHJvbWlzZSBoZXJtZXRpYywgdGhpcyBkb2Vzbid0IGxvb2sgbXVjaCBsaWtlIHRoZSBzcGVjLlxyXG4gICAgICBjb25zb2xlLmFzc2VydChJc0NvbnN0cnVjdG9yKGNvbnN0cnVjdG9yKSk7XHJcbiAgICAgIHZhciBwcm9taXNlQ2FwYWJpbGl0eSA9IHt9O1xyXG4gICAgICBzZXRfaW50ZXJuYWwocHJvbWlzZUNhcGFiaWxpdHksICdbW1Byb21pc2VdXScsIHByb21pc2UpO1xyXG4gICAgICBzZXRfaW50ZXJuYWwocHJvbWlzZUNhcGFiaWxpdHksICdbW1Jlc29sdmVdXScsIHVuZGVmaW5lZCk7XHJcbiAgICAgIHNldF9pbnRlcm5hbChwcm9taXNlQ2FwYWJpbGl0eSwgJ1tbUmVqZWN0XV0nLCB1bmRlZmluZWQpO1xyXG4gICAgICB2YXIgZXhlY3V0b3IgPSBHZXRDYXBhYmlsaXRpZXNFeGVjdXRvcigpO1xyXG4gICAgICBzZXRfaW50ZXJuYWwoZXhlY3V0b3IsICdbW0NhcGFiaWxpdHldXScsIHByb21pc2VDYXBhYmlsaXR5KTtcclxuXHJcbiAgICAgIC8vIE5PVEU6IERpZmZlcnMgZnJvbSBzcGVjOyBvYmplY3QgaXMgY29uc3RydWN0ZWQgaGVyZVxyXG4gICAgICB2YXIgY29uc3RydWN0b3JSZXN1bHQgPSBwcm9taXNlID0gbmV3IGNvbnN0cnVjdG9yKGV4ZWN1dG9yKTtcclxuICAgICAgc2V0X2ludGVybmFsKHByb21pc2VDYXBhYmlsaXR5LCAnW1tQcm9taXNlXV0nLCBwcm9taXNlKTtcclxuXHJcbiAgICAgIGlmICghSXNDYWxsYWJsZShwcm9taXNlQ2FwYWJpbGl0eVsnW1tSZXNvbHZlXV0nXSkpIHRocm93IFR5cGVFcnJvcigpO1xyXG4gICAgICBpZiAoIUlzQ2FsbGFibGUocHJvbWlzZUNhcGFiaWxpdHlbJ1tbUmVqZWN0XV0nXSkpIHRocm93IFR5cGVFcnJvcigpO1xyXG4gICAgICBpZiAoVHlwZShjb25zdHJ1Y3RvclJlc3VsdCkgPT09ICdvYmplY3QnICYmICFTYW1lVmFsdWUocHJvbWlzZSwgY29uc3RydWN0b3JSZXN1bHQpKSB0aHJvdyBUeXBlRXJyb3IoKTtcclxuICAgICAgcmV0dXJuIHByb21pc2VDYXBhYmlsaXR5O1xyXG4gICAgfVxyXG5cclxuICAgIC8vIDI1LjQuMS41LjIgR2V0Q2FwYWJpbGl0aWVzRXhlY3V0b3IgRnVuY3Rpb25zXHJcblxyXG4gICAgZnVuY3Rpb24gR2V0Q2FwYWJpbGl0aWVzRXhlY3V0b3IoKSB7XHJcbiAgICAgIHZhciBGID0gZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgY29uc29sZS5hc3NlcnQoRlsnW1tDYXBhYmlsaXR5XV0nXSk7XHJcbiAgICAgICAgdmFyIHByb21pc2VDYXBhYmlsaXR5ID0gRlsnW1tDYXBhYmlsaXR5XV0nXTtcclxuICAgICAgICBpZiAocHJvbWlzZUNhcGFiaWxpdHlbJ1tbUmVzb2x2ZV1dJ10gIT09IHVuZGVmaW5lZCkgdGhyb3cgVHlwZUVycm9yKCk7XHJcbiAgICAgICAgaWYgKHByb21pc2VDYXBhYmlsaXR5WydbW1JlamVjdF1dJ10gIT09IHVuZGVmaW5lZCkgdGhyb3cgVHlwZUVycm9yKCk7XHJcbiAgICAgICAgc2V0X2ludGVybmFsKHByb21pc2VDYXBhYmlsaXR5LCAnW1tSZXNvbHZlXV0nLCByZXNvbHZlKTtcclxuICAgICAgICBzZXRfaW50ZXJuYWwocHJvbWlzZUNhcGFiaWxpdHksICdbW1JlamVjdF1dJywgcmVqZWN0KTtcclxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICB9O1xyXG4gICAgICByZXR1cm4gRjtcclxuICAgIH1cclxuXHJcbiAgICAvLyAyNS40LjEuNiBJc1Byb21pc2UgKCB4IClcclxuXHJcbiAgICBmdW5jdGlvbiBJc1Byb21pc2UoeCkge1xyXG4gICAgICBpZiAoVHlwZSh4KSAhPT0gJ29iamVjdCcpIHJldHVybiBmYWxzZTtcclxuICAgICAgaWYgKCEoJ1tbUHJvbWlzZVN0YXRlXV0nIGluIHgpKSByZXR1cm4gZmFsc2U7XHJcbiAgICAgIGlmICh4WydbW1Byb21pc2VTdGF0ZV1dJ10gPT09IHVuZGVmaW5lZCkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyAyNS40LjEuNyBSZWplY3RQcm9taXNlICggcHJvbWlzZSwgcmVhc29uIClcclxuXHJcbiAgICBmdW5jdGlvbiBSZWplY3RQcm9taXNlKHByb21pc2UsIHJlYXNvbikge1xyXG4gICAgICBjb25zb2xlLmFzc2VydChwcm9taXNlWydbW1Byb21pc2VTdGF0ZV1dJ10gPT09ICdwZW5kaW5nJyk7XHJcbiAgICAgIHZhciByZWFjdGlvbnMgPSBwcm9taXNlWydbW1Byb21pc2VSZWplY3RSZWFjdGlvbnNdXSddO1xyXG4gICAgICBzZXRfaW50ZXJuYWwocHJvbWlzZSwgJ1tbUHJvbWlzZVJlc3VsdF1dJywgcmVhc29uKTtcclxuICAgICAgc2V0X2ludGVybmFsKHByb21pc2UsICdbW1Byb21pc2VGdWxmaWxsUmVhY3Rpb25zXV0nLCB1bmRlZmluZWQpO1xyXG4gICAgICBzZXRfaW50ZXJuYWwocHJvbWlzZSwgJ1tbUHJvbWlzZVJlamVjdFJlYWN0aW9uc11dJywgdW5kZWZpbmVkKTtcclxuICAgICAgc2V0X2ludGVybmFsKHByb21pc2UsICdbW1Byb21pc2VTdGF0ZV1dJywgJ3JlamVjdGVkJyk7XHJcbiAgICAgIHJldHVybiBUcmlnZ2VyUHJvbWlzZVJlYWN0aW9ucyhyZWFjdGlvbnMsIHJlYXNvbik7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gMjUuNC4xLjggVHJpZ2dlclByb21pc2VSZWFjdGlvbnMgKCByZWFjdGlvbnMsIGFyZ3VtZW50IClcclxuXHJcbiAgICBmdW5jdGlvbiBUcmlnZ2VyUHJvbWlzZVJlYWN0aW9ucyhyZWFjdGlvbnMsIGFyZ3VtZW50KSB7XHJcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSByZWFjdGlvbnMubGVuZ3RoOyBpIDwgbGVuOyArK2kpXHJcbiAgICAgICAgRW5xdWV1ZUpvYignUHJvbWlzZUpvYnMnLCBQcm9taXNlUmVhY3Rpb25Kb2IsIFtyZWFjdGlvbnNbaV0sIGFyZ3VtZW50XSk7XHJcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gMjUuNC4yIFByb21pc2UgSm9ic1xyXG5cclxuICAgIC8vIDI1LjQuMi4xIFByb21pc2VSZWFjdGlvbkpvYiAoIHJlYWN0aW9uLCBhcmd1bWVudCApXHJcblxyXG4gICAgZnVuY3Rpb24gUHJvbWlzZVJlYWN0aW9uSm9iKHJlYWN0aW9uLCBhcmd1bWVudCkge1xyXG4gICAgICB2YXIgcHJvbWlzZUNhcGFiaWxpdHkgPSByZWFjdGlvblsnW1tDYXBhYmlsaXRpZXNdXSddO1xyXG4gICAgICB2YXIgaGFuZGxlciA9IHJlYWN0aW9uWydbW0hhbmRsZXJdXSddO1xyXG4gICAgICB2YXIgaGFuZGxlclJlc3VsdCwgc3RhdHVzO1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGlmIChoYW5kbGVyID09PSAnSWRlbnRpdHknKSBoYW5kbGVyUmVzdWx0ID0gYXJndW1lbnQ7XHJcbiAgICAgICAgZWxzZSBpZiAoaGFuZGxlciA9PT0gJ1Rocm93ZXInKSB0aHJvdyBhcmd1bWVudDtcclxuICAgICAgICBlbHNlIGhhbmRsZXJSZXN1bHQgPSBoYW5kbGVyLmNhbGwodW5kZWZpbmVkLCBhcmd1bWVudCk7XHJcbiAgICAgIH0gY2F0Y2ggKGhhbmRsZXJSZXN1bHQpIHtcclxuICAgICAgICBzdGF0dXMgPSBwcm9taXNlQ2FwYWJpbGl0eVsnW1tSZWplY3RdXSddLmNhbGwodW5kZWZpbmVkLCBoYW5kbGVyUmVzdWx0KTtcclxuICAgICAgICBOZXh0Sm9iKHN0YXR1cyk7IHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICBzdGF0dXMgPSBwcm9taXNlQ2FwYWJpbGl0eVsnW1tSZXNvbHZlXV0nXS5jYWxsKHVuZGVmaW5lZCwgaGFuZGxlclJlc3VsdCk7XHJcbiAgICAgIE5leHRKb2Ioc3RhdHVzKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyAyNS40LjIuMiBQcm9taXNlUmVzb2x2ZVRoZW5hYmxlSm9iICggcHJvbWlzZVRvUmVzb2x2ZSwgdGhlbmFibGUsIHRoZW4pXHJcblxyXG4gICAgZnVuY3Rpb24gUHJvbWlzZVJlc29sdmVUaGVuYWJsZUpvYihwcm9taXNlVG9SZXNvbHZlLCB0aGVuYWJsZSwgdGhlbikge1xyXG4gICAgICAvLyBTUEVDIEJVRzogcHJvbWlzZSB2cy4gcHJvbWlzZVRvUmVzb2x2ZVxyXG4gICAgICB2YXIgcmVzb2x2aW5nRnVuY3Rpb25zID0gQ3JlYXRlUmVzb2x2aW5nRnVuY3Rpb25zKHByb21pc2VUb1Jlc29sdmUpO1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIHZhciB0aGVuQ2FsbFJlc3VsdCA9IHRoZW4uY2FsbCh0aGVuYWJsZSwgcmVzb2x2aW5nRnVuY3Rpb25zWydbW1Jlc29sdmVdXSddLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZpbmdGdW5jdGlvbnNbJ1tbUmVqZWN0XV0nXSk7XHJcbiAgICAgIH0gY2F0Y2ggKHRoZW5DYWxsUmVzdWx0KSB7XHJcbiAgICAgICAgdmFyIHN0YXR1cyA9IHJlc29sdmluZ0Z1bmN0aW9uc1snW1tSZWplY3RdXSddLmNhbGwodW5kZWZpbmVkLCB0aGVuQ2FsbFJlc3VsdCk7XHJcbiAgICAgICAgTmV4dEpvYihzdGF0dXMpOyByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgTmV4dEpvYih0aGVuQ2FsbFJlc3VsdCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gMjUuNC4zIFRoZSBQcm9taXNlIENvbnN0cnVjdG9yXHJcblxyXG4gICAgLy8gMjUuNC4zLjEgUHJvbWlzZSAoIGV4ZWN1dG9yIClcclxuXHJcbiAgICBmdW5jdGlvbiBQcm9taXNlKGV4ZWN1dG9yKSB7XHJcbiAgICAgIHZhciBjb25maWcgPSB7IGNvbmZpZ3VyYWJsZTogZmFsc2UsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IHVuZGVmaW5lZCB9O1xyXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ1tbUHJvbWlzZVN0YXRlXV0nLCBjb25maWcpO1xyXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ1tbUHJvbWlzZUNvbnN0cnVjdG9yXV0nLCBjb25maWcpO1xyXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ1tbUHJvbWlzZVJlc3VsdF1dJywgY29uZmlnKTtcclxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdbW1Byb21pc2VGdWxmaWxsUmVhY3Rpb25zXV0nLCBjb25maWcpO1xyXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ1tbUHJvbWlzZVJlamVjdFJlYWN0aW9uc11dJywgY29uZmlnKTtcclxuXHJcbiAgICAgIHZhciBwcm9taXNlID0gdGhpcztcclxuICAgICAgaWYgKFR5cGUocHJvbWlzZSkgIT09ICdvYmplY3QnKSB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XHJcbiAgICAgIGlmICghKCdbW1Byb21pc2VTdGF0ZV1dJyBpbiBwcm9taXNlKSkgdGhyb3cgVHlwZUVycm9yKCk7XHJcbiAgICAgIGlmIChwcm9taXNlWydbW1Byb21pc2VTdGF0ZV1dJ10gIT09IHVuZGVmaW5lZCkgdGhyb3cgVHlwZUVycm9yKCk7XHJcbiAgICAgIGlmICghSXNDYWxsYWJsZShleGVjdXRvcikpIHRocm93IFR5cGVFcnJvcigpO1xyXG5cclxuICAgICAgc2V0X2ludGVybmFsKHByb21pc2UsICdbW1Byb21pc2VDb25zdHJ1Y3Rvcl1dJywgUHJvbWlzZSk7XHJcblxyXG4gICAgICByZXR1cm4gSW5pdGlhbGl6ZVByb21pc2UocHJvbWlzZSwgZXhlY3V0b3IpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIDI1LjQuMy4xLjEgSW5pdGlhbGl6ZVByb21pc2UgKCBwcm9taXNlLCBleGVjdXRvciApXHJcblxyXG4gICAgZnVuY3Rpb24gSW5pdGlhbGl6ZVByb21pc2UocHJvbWlzZSwgZXhlY3V0b3IpIHtcclxuICAgICAgY29uc29sZS5hc3NlcnQoJ1tbUHJvbWlzZVN0YXRlXV0nIGluIHByb21pc2UpO1xyXG4gICAgICBjb25zb2xlLmFzc2VydChJc0NhbGxhYmxlKGV4ZWN1dG9yKSk7XHJcbiAgICAgIHNldF9pbnRlcm5hbChwcm9taXNlLCAnW1tQcm9taXNlU3RhdGVdXScsICdwZW5kaW5nJyk7XHJcbiAgICAgIHNldF9pbnRlcm5hbChwcm9taXNlLCAnW1tQcm9taXNlRnVsZmlsbFJlYWN0aW9uc11dJywgW10pO1xyXG4gICAgICBzZXRfaW50ZXJuYWwocHJvbWlzZSwgJ1tbUHJvbWlzZVJlamVjdFJlYWN0aW9uc11dJywgW10pO1xyXG4gICAgICB2YXIgcmVzb2x2aW5nRnVuY3Rpb25zID0gQ3JlYXRlUmVzb2x2aW5nRnVuY3Rpb25zKHByb21pc2UpO1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIHZhciBjb21wbGV0aW9uID0gZXhlY3V0b3IuY2FsbCh1bmRlZmluZWQsIHJlc29sdmluZ0Z1bmN0aW9uc1snW1tSZXNvbHZlXV0nXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2aW5nRnVuY3Rpb25zWydbW1JlamVjdF1dJ10pO1xyXG4gICAgICB9IGNhdGNoIChjb21wbGV0aW9uKSB7XHJcbiAgICAgICAgdmFyIHN0YXR1cyA9IHJlc29sdmluZ0Z1bmN0aW9uc1snW1tSZWplY3RdXSddLmNhbGwodW5kZWZpbmVkLCBjb21wbGV0aW9uKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gcHJvbWlzZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyAyNS40LjQgUHJvcGVydGllcyBvZiB0aGUgUHJvbWlzZSBDb25zdHJ1Y3RvclxyXG4gICAgLy8gMjUuNC40LjEgUHJvbWlzZS5hbGwgKCBpdGVyYWJsZSApXHJcblxyXG4gICAgZGVmaW5lKFByb21pc2UsICdhbGwnLCBmdW5jdGlvbiBhbGwoaXRlcmFibGUpIHtcclxuICAgICAgdmFyIGMgPSBzdHJpY3QodGhpcyk7XHJcbiAgICAgIHZhciBwcm9taXNlQ2FwYWJpbGl0eSA9IE5ld1Byb21pc2VDYXBhYmlsaXR5KGMpO1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIHZhciBpdGVyYXRvciA9IEdldEl0ZXJhdG9yKGl0ZXJhYmxlKTtcclxuICAgICAgfSBjYXRjaCAodmFsdWUpIHtcclxuICAgICAgICBwcm9taXNlQ2FwYWJpbGl0eVsnW1tSZWplY3RdXSddLmNhbGwodW5kZWZpbmVkLCB2YWx1ZSk7XHJcbiAgICAgICAgcmV0dXJuIHByb21pc2VDYXBhYmlsaXR5WydbW1Byb21pc2VdXSddO1xyXG4gICAgICB9XHJcbiAgICAgIHZhciB2YWx1ZXMgPSBbXTtcclxuICAgICAgdmFyIHJlbWFpbmluZ0VsZW1lbnRzQ291bnQgPSB7IHZhbHVlOiAxIH07XHJcbiAgICAgIHZhciBpbmRleCA9IDA7XHJcbiAgICAgIHdoaWxlICh0cnVlKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIHZhciBuZXh0ID0gSXRlcmF0b3JTdGVwKGl0ZXJhdG9yKTtcclxuICAgICAgICB9IGNhdGNoICh2YWx1ZSkge1xyXG4gICAgICAgICAgcHJvbWlzZUNhcGFiaWxpdHlbJ1tbUmVqZWN0XV0nXS5jYWxsKHVuZGVmaW5lZCwgdmFsdWUpO1xyXG4gICAgICAgICAgcmV0dXJuIHByb21pc2VDYXBhYmlsaXR5WydbW1Byb21pc2VdXSddO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIW5leHQpIHtcclxuICAgICAgICAgIHJlbWFpbmluZ0VsZW1lbnRzQ291bnQudmFsdWUgLT0gMTtcclxuICAgICAgICAgIGlmIChyZW1haW5pbmdFbGVtZW50c0NvdW50LnZhbHVlID09PSAwKSB7XHJcbiAgICAgICAgICAgIHZhciByZXNvbHZlUmVzdWx0ID0gcHJvbWlzZUNhcGFiaWxpdHlbJ1tbUmVzb2x2ZV1dJ10uYXBwbHkodW5kZWZpbmVkLCB2YWx1ZXMpO1xyXG5cclxuXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICByZXR1cm4gcHJvbWlzZUNhcGFiaWxpdHlbJ1tbUHJvbWlzZV1dJ107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICB2YXIgbmV4dFZhbHVlID0gSXRlcmF0b3JWYWx1ZShuZXh0KTtcclxuICAgICAgICB9IGNhdGNoICh2YWx1ZSkge1xyXG4gICAgICAgICAgcHJvbWlzZUNhcGFiaWxpdHlbJ1tbUmVqZWN0XV0nXS5jYWxsKHVuZGVmaW5lZCwgdmFsdWUpO1xyXG4gICAgICAgICAgcmV0dXJuIHByb21pc2VDYXBhYmlsaXR5WydbW1Byb21pc2VdXSddO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgdmFyIG5leHRQcm9taXNlID0gYy5yZXNvbHZlKG5leHRWYWx1ZSk7XHJcbiAgICAgICAgfSBjYXRjaCAodmFsdWUpIHtcclxuICAgICAgICAgIHByb21pc2VDYXBhYmlsaXR5WydbW1JlamVjdF1dJ10uY2FsbCh1bmRlZmluZWQsIHZhbHVlKTtcclxuICAgICAgICAgIHJldHVybiBwcm9taXNlQ2FwYWJpbGl0eVsnW1tQcm9taXNlXV0nXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHJlc29sdmVFbGVtZW50ID0gUHJvbWlzZUFsbFJlc29sdmVFbGVtZW50RnVuY3Rpb24oKTtcclxuICAgICAgICBzZXRfaW50ZXJuYWwocmVzb2x2ZUVsZW1lbnQsICdbW0FscmVhZHlDYWxsZWRdXScsIHsgdmFsdWU6IGZhbHNlIH0pO1xyXG4gICAgICAgIHNldF9pbnRlcm5hbChyZXNvbHZlRWxlbWVudCwgJ1tbSW5kZXhdXScsIGluZGV4KTtcclxuICAgICAgICBzZXRfaW50ZXJuYWwocmVzb2x2ZUVsZW1lbnQsICdbW1ZhbHVlc11dJywgdmFsdWVzKTtcclxuICAgICAgICBzZXRfaW50ZXJuYWwocmVzb2x2ZUVsZW1lbnQsICdbW0NhcGFiaWxpdGllc11dJywgcHJvbWlzZUNhcGFiaWxpdHkpO1xyXG4gICAgICAgIHNldF9pbnRlcm5hbChyZXNvbHZlRWxlbWVudCwgJ1tbUmVtYWluaW5nRWxlbWVudHNdXScsIHJlbWFpbmluZ0VsZW1lbnRzQ291bnQpO1xyXG4gICAgICAgIHJlbWFpbmluZ0VsZW1lbnRzQ291bnQudmFsdWUgKz0gMTtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgdmFyIHJlc3VsdCA9IG5leHRQcm9taXNlLnRoZW4ocmVzb2x2ZUVsZW1lbnQsIHByb21pc2VDYXBhYmlsaXR5WydbW1JlamVjdF1dJ10pO1xyXG4gICAgICAgIH0gY2F0Y2ggKHZhbHVlKSB7XHJcbiAgICAgICAgICBwcm9taXNlQ2FwYWJpbGl0eVsnW1tSZWplY3RdXSddLmNhbGwodW5kZWZpbmVkLCB2YWx1ZSk7XHJcbiAgICAgICAgICByZXR1cm4gcHJvbWlzZUNhcGFiaWxpdHlbJ1tbUHJvbWlzZV1dJ107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGluZGV4ICs9IDE7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIC8vIDI1LjQuNC4xLjEgUHJvbWlzZS5hbGwgUmVzb2x2ZSBFbGVtZW50IEZ1bmN0aW9uc1xyXG5cclxuICAgIGZ1bmN0aW9uIFByb21pc2VBbGxSZXNvbHZlRWxlbWVudEZ1bmN0aW9uKCkge1xyXG4gICAgICB2YXIgRiA9IGZ1bmN0aW9uKHgpIHtcclxuICAgICAgICB2YXIgYWxyZWFkeUNhbGxlZCA9IEZbJ1tbQWxyZWFkeUNhbGxlZF1dJ107XHJcbiAgICAgICAgaWYgKGFscmVhZHlDYWxsZWQudmFsdWUpIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgYWxyZWFkeUNhbGxlZC52YWx1ZSA9IHRydWU7XHJcbiAgICAgICAgdmFyIGluZGV4ID0gRlsnW1tJbmRleF1dJ107XHJcbiAgICAgICAgdmFyIHZhbHVlcyA9IEZbJ1tbVmFsdWVzXV0nXTtcclxuICAgICAgICB2YXIgcHJvbWlzZUNhcGFiaWxpdHkgPSBGWydbW0NhcGFiaWxpdGllc11dJ107XHJcbiAgICAgICAgdmFyIHJlbWFpbmluZ0VsZW1lbnRzQ291bnQgPSBGWydbW1JlbWFpbmluZ0VsZW1lbnRzXV0nXTtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgdmFsdWVzW2luZGV4XSA9IHg7XHJcbiAgICAgICAgfSBjYXRjaCAocmVzdWx0KSB7XHJcbiAgICAgICAgICBwcm9taXNlQ2FwYWJpbGl0eVsnW1tSZWplY3RdXSddLmNhbGwodW5kZWZpbmVkLCByZXN1bHQpO1xyXG4gICAgICAgICAgcmV0dXJuIHByb21pc2VDYXBhYmlsaXR5WydbW1Byb21pc2VdXSddO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZW1haW5pbmdFbGVtZW50c0NvdW50LnZhbHVlIC09IDE7XHJcbiAgICAgICAgaWYgKHJlbWFpbmluZ0VsZW1lbnRzQ291bnQudmFsdWUgPT09IDApXHJcbiAgICAgICAgICByZXR1cm4gcHJvbWlzZUNhcGFiaWxpdHlbJ1tbUmVzb2x2ZV1dJ10uY2FsbCh1bmRlZmluZWQsIHZhbHVlcyk7XHJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgfTtcclxuICAgICAgcmV0dXJuIEY7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gMjUuNC40LjIgUHJvbWlzZS5wcm90b3R5cGVcclxuXHJcbiAgICBQcm9taXNlLnByb3RvdHlwZSA9IHt9O1xyXG5cclxuICAgIC8vIDI1LjQuNC4zIFByb21pc2UucmFjZSAoIGl0ZXJhYmxlIClcclxuXHJcbiAgICBkZWZpbmUoUHJvbWlzZSwgJ3JhY2UnLCBmdW5jdGlvbiByYWNlKGl0ZXJhYmxlKSB7XHJcbiAgICAgIHZhciBjID0gc3RyaWN0KHRoaXMpO1xyXG4gICAgICB2YXIgcHJvbWlzZUNhcGFiaWxpdHkgPSBOZXdQcm9taXNlQ2FwYWJpbGl0eShjKTtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICB2YXIgaXRlcmF0b3IgPSBHZXRJdGVyYXRvcihpdGVyYWJsZSk7XHJcbiAgICAgIH0gY2F0Y2ggKHZhbHVlKSB7XHJcbiAgICAgICAgcHJvbWlzZUNhcGFiaWxpdHlbJ1tbUmVqZWN0XV0nXS5jYWxsKHVuZGVmaW5lZCwgdmFsdWUpO1xyXG4gICAgICAgIHJldHVybiBwcm9taXNlQ2FwYWJpbGl0eVsnW1tQcm9taXNlXV0nXTtcclxuICAgICAgfVxyXG4gICAgICB3aGlsZSAodHJ1ZSkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICB2YXIgbmV4dCA9IEl0ZXJhdG9yU3RlcChpdGVyYXRvcik7XHJcbiAgICAgICAgfSBjYXRjaCAodmFsdWUpIHtcclxuICAgICAgICAgIHByb21pc2VDYXBhYmlsaXR5WydbW1JlamVjdF1dJ10uY2FsbCh1bmRlZmluZWQsIHZhbHVlKTtcclxuICAgICAgICAgIHJldHVybiBwcm9taXNlQ2FwYWJpbGl0eVsnW1tQcm9taXNlXV0nXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFuZXh0KSByZXR1cm4gcHJvbWlzZUNhcGFiaWxpdHlbJ1tbUHJvbWlzZV1dJ107XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIHZhciBuZXh0VmFsdWUgPSBJdGVyYXRvclZhbHVlKG5leHQpO1xyXG4gICAgICAgIH0gY2F0Y2ggKHZhbHVlKSB7XHJcbiAgICAgICAgICBwcm9taXNlQ2FwYWJpbGl0eVsnW1tSZWplY3RdXSddLmNhbGwodW5kZWZpbmVkLCB2YWx1ZSk7XHJcbiAgICAgICAgICByZXR1cm4gcHJvbWlzZUNhcGFiaWxpdHlbJ1tbUHJvbWlzZV1dJ107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICB2YXIgbmV4dFByb21pc2UgPSBjLnJlc29sdmUobmV4dFZhbHVlKTtcclxuICAgICAgICB9IGNhdGNoICh2YWx1ZSkge1xyXG4gICAgICAgICAgcHJvbWlzZUNhcGFiaWxpdHlbJ1tbUmVqZWN0XV0nXS5jYWxsKHVuZGVmaW5lZCwgdmFsdWUpO1xyXG4gICAgICAgICAgcmV0dXJuIHByb21pc2VDYXBhYmlsaXR5WydbW1Byb21pc2VdXSddO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgbmV4dFByb21pc2UudGhlbihwcm9taXNlQ2FwYWJpbGl0eVsnW1tSZXNvbHZlXV0nXSwgcHJvbWlzZUNhcGFiaWxpdHlbJ1tbUmVqZWN0XV0nXSk7XHJcbiAgICAgICAgfSBjYXRjaCAodmFsdWUpIHtcclxuICAgICAgICAgIHByb21pc2VDYXBhYmlsaXR5WydbW1JlamVjdF1dJ10uY2FsbCh1bmRlZmluZWQsIHZhbHVlKTtcclxuICAgICAgICAgIHJldHVybiBwcm9taXNlQ2FwYWJpbGl0eVsnW1tQcm9taXNlXV0nXTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIC8vIDI1LjQuNC40IFByb21pc2UucmVqZWN0ICggciApXHJcblxyXG4gICAgZGVmaW5lKFByb21pc2UsICdyZWplY3QnLCBmdW5jdGlvbiByZWplY3Qocikge1xyXG4gICAgICB2YXIgYyA9IHN0cmljdCh0aGlzKTtcclxuICAgICAgdmFyIHByb21pc2VDYXBhYmlsaXR5ID0gTmV3UHJvbWlzZUNhcGFiaWxpdHkoYyk7XHJcbiAgICAgIHZhciByZWplY3RSZXN1bHQgPSBwcm9taXNlQ2FwYWJpbGl0eVsnW1tSZWplY3RdXSddLmNhbGwodW5kZWZpbmVkLCByKTtcclxuICAgICAgcmV0dXJuIHByb21pc2VDYXBhYmlsaXR5WydbW1Byb21pc2VdXSddO1xyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gMjUuNC40LjUgUHJvbWlzZS5yZXNvbHZlICggeCApXHJcblxyXG4gICAgZGVmaW5lKFByb21pc2UsICdyZXNvbHZlJywgZnVuY3Rpb24gcmVzb2x2ZSh4KSB7XHJcbiAgICAgIHZhciBjID0gc3RyaWN0KHRoaXMpO1xyXG4gICAgICBpZiAoSXNQcm9taXNlKHgpKSB7XHJcbiAgICAgICAgdmFyIGNvbnN0cnVjdG9yID0geFsnW1tQcm9taXNlQ29uc3RydWN0b3JdXSddO1xyXG4gICAgICAgIGlmIChTYW1lVmFsdWUoY29uc3RydWN0b3IsIGMpKSByZXR1cm4geDtcclxuICAgICAgfVxyXG4gICAgICB2YXIgcHJvbWlzZUNhcGFiaWxpdHkgPSBOZXdQcm9taXNlQ2FwYWJpbGl0eShjKTtcclxuICAgICAgdmFyIHJlc29sdmVSZXN1bHQgPSBwcm9taXNlQ2FwYWJpbGl0eVsnW1tSZXNvbHZlXV0nXS5jYWxsKHVuZGVmaW5lZCwgeCk7XHJcbiAgICAgIHJldHVybiBwcm9taXNlQ2FwYWJpbGl0eVsnW1tQcm9taXNlXV0nXTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIDI1LjQuNC42IFByb21pc2UgWyBAQGNyZWF0ZSBdICggKVxyXG4gICAgLy8gMjUuNC40LjYuMSBBbGxvY2F0ZVByb21pc2UgKCBjb25zdHJ1Y3RvciApXHJcbiAgICAvLyAyNS40LjUgUHJvcGVydGllcyBvZiB0aGUgUHJvbWlzZSBQcm90b3R5cGUgT2JqZWN0XHJcbiAgICAvLyAyNS40LjUuMSBQcm9taXNlLnByb3RvdHlwZS5jYXRjaCAoIG9uUmVqZWN0ZWQgKVxyXG5cclxuICAgIGRlZmluZShQcm9taXNlLnByb3RvdHlwZSwgJ2NhdGNoJywgZnVuY3Rpb24gY2F0Y2hfKG9uUmVqZWN0ZWQpIHtcclxuICAgICAgdmFyIHByb21pc2UgPSB0aGlzO1xyXG4gICAgICByZXR1cm4gcHJvbWlzZS50aGVuKHVuZGVmaW5lZCwgb25SZWplY3RlZCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyAyNS40LjUuMiBQcm9taXNlLnByb3RvdHlwZS5jb25zdHJ1Y3RvclxyXG5cclxuICAgIFByb21pc2UucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUHJvbWlzZTtcclxuXHJcbiAgICAvLyAyNS40LjUuMyBQcm9taXNlLnByb3RvdHlwZS50aGVuICggb25GdWxmaWxsZWQgLCBvblJlamVjdGVkIClcclxuXHJcbiAgICBkZWZpbmUoUHJvbWlzZS5wcm90b3R5cGUsICd0aGVuJywgZnVuY3Rpb24gdGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkge1xyXG4gICAgICB2YXIgcHJvbWlzZSA9IHRoaXM7XHJcbiAgICAgIGlmICghSXNQcm9taXNlKHByb21pc2UpKSB0aHJvdyBUeXBlRXJyb3IoKTtcclxuICAgICAgaWYgKCFJc0NhbGxhYmxlKG9uRnVsZmlsbGVkKSkgb25GdWxmaWxsZWQgPSAnSWRlbnRpdHknO1xyXG4gICAgICBpZiAoIUlzQ2FsbGFibGUob25SZWplY3RlZCkpIG9uUmVqZWN0ZWQgPSAnVGhyb3dlcic7XHJcbiAgICAgIHZhciBjID0gcHJvbWlzZS5jb25zdHJ1Y3RvcjtcclxuICAgICAgdmFyIHByb21pc2VDYXBhYmlsaXR5ID0gTmV3UHJvbWlzZUNhcGFiaWxpdHkoYyk7XHJcbiAgICAgIHZhciBmdWxmaWxsUmVhY3Rpb24gPSB7ICdbW0NhcGFiaWxpdGllc11dJzogcHJvbWlzZUNhcGFiaWxpdHksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdbW0hhbmRsZXJdXSc6IG9uRnVsZmlsbGVkIH07XHJcbiAgICAgIHZhciByZWplY3RSZWFjdGlvbiA9IHsgJ1tbQ2FwYWJpbGl0aWVzXV0nOiBwcm9taXNlQ2FwYWJpbGl0eSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnW1tIYW5kbGVyXV0nOiBvblJlamVjdGVkIH07XHJcbiAgICAgIGlmIChwcm9taXNlWydbW1Byb21pc2VTdGF0ZV1dJ10gPT09ICdwZW5kaW5nJykge1xyXG4gICAgICAgIHByb21pc2VbJ1tbUHJvbWlzZUZ1bGZpbGxSZWFjdGlvbnNdXSddLnB1c2goZnVsZmlsbFJlYWN0aW9uKTtcclxuICAgICAgICBwcm9taXNlWydbW1Byb21pc2VSZWplY3RSZWFjdGlvbnNdXSddLnB1c2gocmVqZWN0UmVhY3Rpb24pO1xyXG4gICAgICB9IGVsc2UgaWYgKHByb21pc2VbJ1tbUHJvbWlzZVN0YXRlXV0nXSA9PT0gJ2Z1bGZpbGxlZCcpIHtcclxuICAgICAgICB2YXIgdmFsdWUgPSBwcm9taXNlWydbW1Byb21pc2VSZXN1bHRdXSddO1xyXG4gICAgICAgIEVucXVldWVKb2IoJ1Byb21pc2VKb2JzJywgUHJvbWlzZVJlYWN0aW9uSm9iLCBbZnVsZmlsbFJlYWN0aW9uLCB2YWx1ZV0pO1xyXG4gICAgICB9IGVsc2UgaWYgKHByb21pc2VbJ1tbUHJvbWlzZVN0YXRlXV0nXSA9PT0gJ3JlamVjdGVkJykge1xyXG4gICAgICAgIHZhciByZWFzb24gPSBwcm9taXNlWydbW1Byb21pc2VSZXN1bHRdXSddO1xyXG4gICAgICAgIEVucXVldWVKb2IoJ1Byb21pc2VKb2JzJywgUHJvbWlzZVJlYWN0aW9uSm9iLCBbcmVqZWN0UmVhY3Rpb24sIHJlYXNvbl0pO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBwcm9taXNlQ2FwYWJpbGl0eVsnW1tQcm9taXNlXV0nXTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIDI1LjQuNiBQcm9wZXJ0aWVzIG9mIFByb21pc2UgSW5zdGFuY2VzXHJcblxyXG4gICAgaWYgKCEoJ1Byb21pc2UnIGluIGdsb2JhbCkgfHwgT1ZFUlJJREVfTkFUSVZFX0ZPUl9URVNUSU5HKVxyXG4gICAgICBnbG9iYWwuUHJvbWlzZSA9IFByb21pc2U7XHJcblxyXG4gICAgLy8gUGF0Y2ggZWFybHkgUHJvbWlzZS5jYXN0IHZzLiBQcm9taXNlLnJlc29sdmUgaW1wbGVtZW50YXRpb25zXHJcbiAgICBpZiAoJ2Nhc3QnIGluIGdsb2JhbC5Qcm9taXNlKSBnbG9iYWwuUHJvbWlzZS5yZXNvbHZlID0gZ2xvYmFsLlByb21pc2UuY2FzdDtcclxuICB9KCkpO1xyXG5cclxuICAvLyAyNS40LjUuMSBQcm9taXNlLnByb3RvdHlwZSBbIEBAdG9TdHJpbmdUYWcgXVxyXG4gIGRlZmluZShQcm9taXNlLnByb3RvdHlwZSwgJCR0b1N0cmluZ1RhZywgJ1Byb21pc2UnKTtcclxuXHJcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgLy8gMjYgUmVmbGVjdGlvblxyXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cclxuICAoZnVuY3Rpb24oKSB7XHJcbiAgICAvLyAyNi4xIFRoZSBSZWZsZWN0IE9iamVjdFxyXG4gICAgaWYgKCEoJ1JlZmxlY3QnIGluIGdsb2JhbCkgfHwgT1ZFUlJJREVfTkFUSVZFX0ZPUl9URVNUSU5HKVxyXG4gICAgICBnbG9iYWwuUmVmbGVjdCA9IHt9O1xyXG5cclxuICAgIC8vIDI2LjEuMSBSZWZsZWN0LmFwcGx5ICggdGFyZ2V0LCB0aGlzQXJndW1lbnQsIGFyZ3VtZW50c0xpc3QgKVxyXG4gICAgZGVmaW5lKFxyXG4gICAgICBSZWZsZWN0LCAnYXBwbHknLFxyXG4gICAgICBmdW5jdGlvbiBhcHBseSh0YXJnZXQsIHRoaXNBcmd1bWVudCwgYXJndW1lbnRzTGlzdCkge1xyXG4gICAgICAgIGlmICghSXNDYWxsYWJsZSh0YXJnZXQpKSB0aHJvdyBUeXBlRXJyb3IoKTtcclxuICAgICAgICByZXR1cm4gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwodGFyZ2V0LCB0aGlzQXJndW1lbnQsIGFyZ3VtZW50c0xpc3QpO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAvLyAyNi4xLjIgUmVmbGVjdC5jb25zdHJ1Y3QgKCB0YXJnZXQsIGFyZ3VtZW50c0xpc3QgWywgbmV3VGFyZ2V0XSApXHJcbiAgICBkZWZpbmUoXHJcbiAgICAgIFJlZmxlY3QsICdjb25zdHJ1Y3QnLFxyXG4gICAgICBmdW5jdGlvbiBjb25zdHJ1Y3QodGFyZ2V0LCBhcmd1bWVudHNMaXN0KSB7XHJcbiAgICAgICAgcmV0dXJuIF9fY29ucyh0YXJnZXQsIGFyZ3VtZW50c0xpc3QpO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAvLyAyNi4xLjMgUmVmbGVjdC5kZWZpbmVQcm9wZXJ0eSAoIHRhcmdldCwgcHJvcGVydHlLZXksIGF0dHJpYnV0ZXMgKVxyXG4gICAgZGVmaW5lKFxyXG4gICAgICBSZWZsZWN0LCAnZGVmaW5lUHJvcGVydHknLFxyXG4gICAgICBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIHByb3BlcnR5S2V5LCBhdHRyaWJ1dGVzKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIHByb3BlcnR5S2V5LCBhdHRyaWJ1dGVzKTtcclxuICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH0gY2F0Y2ggKF8pIHtcclxuICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG5cclxuICAgIC8vIDI2LjEuNCBSZWZsZWN0LmRlbGV0ZVByb3BlcnR5ICggdGFyZ2V0LCBwcm9wZXJ0eUtleSApXHJcbiAgICBkZWZpbmUoXHJcbiAgICAgIFJlZmxlY3QsICdkZWxldGVQcm9wZXJ0eScsXHJcbiAgICAgIGZ1bmN0aW9uIGRlbGV0ZVByb3BlcnR5KHRhcmdldCxuYW1lKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIGRlbGV0ZSB0YXJnZXRbbmFtZV07XHJcbiAgICAgICAgICByZXR1cm4gIUhhc093blByb3BlcnR5KHRhcmdldCwgbmFtZSk7XHJcbiAgICAgICAgfSBjYXRjaCAoXykge1xyXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcblxyXG4gICAgLy8gMjYuMS41IFJlZmxlY3QuZW51bWVyYXRlICggdGFyZ2V0IClcclxuICAgIGRlZmluZShcclxuICAgICAgUmVmbGVjdCwgJ2VudW1lcmF0ZScsXHJcbiAgICAgIGZ1bmN0aW9uIGVudW1lcmF0ZSh0YXJnZXQpIHtcclxuICAgICAgICB0YXJnZXQgPSBUb09iamVjdCh0YXJnZXQpO1xyXG4gICAgICAgIHZhciBpdGVyYXRvciA9IEVudW1lcmF0ZSh0YXJnZXQpO1xyXG4gICAgICAgIHJldHVybiBpdGVyYXRvcjtcclxuICAgICAgfSk7XHJcblxyXG4gICAgLy8gMjYuMS42IFJlZmxlY3QuZ2V0ICggdGFyZ2V0LCBwcm9wZXJ0eUtleSBbICwgcmVjZWl2ZXIgXSlcclxuICAgIGRlZmluZShcclxuICAgICAgUmVmbGVjdCwgJ2dldCcsXHJcbiAgICAgIGZ1bmN0aW9uIGdldCh0YXJnZXQsIG5hbWUsIHJlY2VpdmVyKSB7XHJcbiAgICAgICAgdGFyZ2V0ID0gVG9PYmplY3QodGFyZ2V0KTtcclxuICAgICAgICBuYW1lID0gU3RyaW5nKG5hbWUpO1xyXG4gICAgICAgIHJlY2VpdmVyID0gKHJlY2VpdmVyID09PSB1bmRlZmluZWQpID8gdGFyZ2V0IDogVG9PYmplY3QocmVjZWl2ZXIpO1xyXG4gICAgICAgIHZhciBkZXNjID0gZ2V0UHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwgbmFtZSk7XHJcbiAgICAgICAgaWYgKGRlc2MgJiYgJ2dldCcgaW4gZGVzYylcclxuICAgICAgICAgIHJldHVybiBGdW5jdGlvbi5wcm90b3R5cGUuY2FsbC5jYWxsKGRlc2NbJ2dldCddLCByZWNlaXZlcik7XHJcbiAgICAgICAgcmV0dXJuIHRhcmdldFtuYW1lXTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgLy8gMjYuMS43IFJlZmxlY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yICggdGFyZ2V0LCBwcm9wZXJ0eUtleSApXHJcbiAgICBkZWZpbmUoXHJcbiAgICAgIFJlZmxlY3QsICdnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3InLFxyXG4gICAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKTtcclxuXHJcbiAgICAvLyAyNi4xLjggUmVmbGVjdC5nZXRQcm90b3R5cGVPZiAoIHRhcmdldCApXHJcbiAgICBkZWZpbmUoXHJcbiAgICAgIFJlZmxlY3QsICdnZXRQcm90b3R5cGVPZicsXHJcbiAgICAgIE9iamVjdC5nZXRQcm90b3R5cGVPZik7XHJcblxyXG4gICAgLy8gMjYuMS45IFJlZmxlY3QuaGFzICggdGFyZ2V0LCBwcm9wZXJ0eUtleSApXHJcbiAgICBkZWZpbmUoXHJcbiAgICAgIFJlZmxlY3QsICdoYXMnLFxyXG4gICAgICBmdW5jdGlvbiBoYXModGFyZ2V0LG5hbWUpIHtcclxuICAgICAgICByZXR1cm4gU3RyaW5nKG5hbWUpIGluIFRvT2JqZWN0KHRhcmdldCk7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgIC8vIDI2LjEuMTAgUmVmbGVjdC5pc0V4dGVuc2libGUgKHRhcmdldClcclxuICAgIGRlZmluZShcclxuICAgICAgUmVmbGVjdCwgJ2lzRXh0ZW5zaWJsZScsXHJcbiAgICAgIE9iamVjdC5pc0V4dGVuc2libGUpO1xyXG5cclxuICAgIC8vIDI2LjEuMTEgUmVmbGVjdC5vd25LZXlzICggdGFyZ2V0IClcclxuICAgIGRlZmluZShcclxuICAgICAgUmVmbGVjdCwgJ293bktleXMnLFxyXG4gICAgICBmdW5jdGlvbiBvd25LZXlzKHRhcmdldCkge1xyXG4gICAgICAgIHZhciBvYmogPSBUb09iamVjdCh0YXJnZXQpO1xyXG4gICAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvYmopO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAvLyAyNi4xLjEyIFJlZmxlY3QucHJldmVudEV4dGVuc2lvbnMgKCB0YXJnZXQgKVxyXG4gICAgZGVmaW5lKFxyXG4gICAgICBSZWZsZWN0LCAncHJldmVudEV4dGVuc2lvbnMnLFxyXG4gICAgICBmdW5jdGlvbiBwcmV2ZW50RXh0ZW5zaW9ucyh0YXJnZXQpIHtcclxuICAgICAgICB0cnkgeyBPYmplY3QucHJldmVudEV4dGVuc2lvbnModGFyZ2V0KTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKF8pIHsgcmV0dXJuIGZhbHNlOyB9XHJcbiAgICAgIH0pO1xyXG5cclxuICAgIC8vIDI2LjEuMTMgUmVmbGVjdC5zZXQgKCB0YXJnZXQsIHByb3BlcnR5S2V5LCBWIFsgLCByZWNlaXZlciBdIClcclxuICAgIGRlZmluZShcclxuICAgICAgUmVmbGVjdCwgJ3NldCcsXHJcbiAgICAgIGZ1bmN0aW9uIHNldCh0YXJnZXQsIG5hbWUsIHZhbHVlLCByZWNlaXZlcikge1xyXG4gICAgICAgIHRhcmdldCA9IFRvT2JqZWN0KHRhcmdldCk7XHJcbiAgICAgICAgbmFtZSA9IFN0cmluZyhuYW1lKTtcclxuICAgICAgICByZWNlaXZlciA9IChyZWNlaXZlciA9PT0gdW5kZWZpbmVkKSA/IHRhcmdldCA6IFRvT2JqZWN0KHJlY2VpdmVyKTtcclxuICAgICAgICB2YXIgZGVzYyA9IGdldFByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIG5hbWUpO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICBpZiAoZGVzYyAmJiAnc2V0JyBpbiBkZXNjKVxyXG4gICAgICAgICAgICBGdW5jdGlvbi5wcm90b3R5cGUuY2FsbC5jYWxsKGRlc2NbJ3NldCddLCByZWNlaXZlciwgdmFsdWUpO1xyXG4gICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB0YXJnZXRbbmFtZV0gPSB2YWx1ZTtcclxuICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH0gY2F0Y2ggKF8pIHtcclxuICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG5cclxuICAgIC8vIDI2LjEuMTQgUmVmbGVjdC5zZXRQcm90b3R5cGVPZiAoIHRhcmdldCwgcHJvdG8gKVxyXG4gICAgZGVmaW5lKFxyXG4gICAgICBSZWZsZWN0LCAnc2V0UHJvdG90eXBlT2YnLFxyXG4gICAgICBmdW5jdGlvbiBzZXRQcm90b3R5cGVPZih0YXJnZXQsIHByb3RvKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIHRhcmdldC5fX3Byb3RvX18gPSBwcm90bztcclxuICAgICAgICAgIHJldHVybiBSZWZsZWN0LmdldFByb3RvdHlwZU9mKHRhcmdldCkgPT09IHByb3RvO1xyXG4gICAgICAgIH0gY2F0Y2goXykge1xyXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcblxyXG4gIH0oKSk7XHJcblxyXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gIC8vIDI2LjIgUHJveHkgT2JqZWN0c1xyXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cclxuICAvLyBOb3QgcG9seWZpbGxhYmxlLlxyXG5cclxufShzZWxmKSk7XHJcblxyXG4vLyBUaGlzIGhlbHBlciBpcyBkZWZpbmVkIG91dHNpZGUgdGhlIG1haW4gc2NvcGUgc28gdGhhdCB0aGUgdXNlIG9mXHJcbi8vICdldmFsJyBkb2VzIG5vdCB0YWludCB0aGUgc2NvcGUgZm9yIG1pbmlmaWVycy5cclxuZnVuY3Rpb24gX19jb25zKHQsIGEpIHtcclxuICByZXR1cm4gZXZhbCgnbmV3IHQoJyArIGEubWFwKGZ1bmN0aW9uKF8sIGkpIHsgcmV0dXJuICdhWycgKyBpICsgJ10nOyB9KS5qb2luKCcsJykgKyAnKScpO1xyXG59XHJcbiIsInJlcXVpcmUoXCIuL3NoaW0vYXJyYXlcIilcclxucmVxdWlyZShcIi4vc2hpbS9vYmplY3RcIilcclxuIiwiLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmluY2x1ZGVzXHJcbmlmICghQXJyYXkucHJvdG90eXBlLmluY2x1ZGVzKSB7XHJcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFycmF5LnByb3RvdHlwZSwgJ2luY2x1ZGVzJywge1xyXG4gICAgdmFsdWU6IGZ1bmN0aW9uKHNlYXJjaEVsZW1lbnQsIGZyb21JbmRleCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5pbmRleE9mKHNlYXJjaEVsZW1lbnQsIGZyb21JbmRleCkgIT09IC0xXHJcbiAgICB9XHJcbiAgfSk7XHJcbn1cclxuIiwiLy9odHRwczovL3RjMzkuZXMvcHJvcG9zYWwtb2JqZWN0LXZhbHVlcy1lbnRyaWVzL1xyXG4vL2h0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLW9iamVjdC12YWx1ZXMtZW50cmllc1xyXG5pZiAoIU9iamVjdC5lbnRyaWVzKSB7XHJcbiAgT2JqZWN0LmVudHJpZXMgPSBmdW5jdGlvbiggb2JqICl7XHJcbiAgICB2YXIgb3duUHJvcHMgPSBPYmplY3Qua2V5cyggb2JqICksXHJcbiAgICAgIGkgPSBvd25Qcm9wcy5sZW5ndGgsXHJcbiAgICAgIHJlc0FycmF5ID0gbmV3IEFycmF5KGkpOyAvLyBwcmVhbGxvY2F0ZSB0aGUgQXJyYXlcclxuICAgIHdoaWxlIChpLS0pIHtcclxuICAgICAgcmVzQXJyYXlbaV0gPSBbb3duUHJvcHNbaV0sIG9ialtvd25Qcm9wc1tpXV1dO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICByZXR1cm4gcmVzQXJyYXk7XHJcbiAgfTtcclxufVxyXG4iLCJyZXF1aXJlKCcuLi9mcmFtZXdvcmtzL3NoaW0nKVxyXG5yZXF1aXJlKCdqcy1wb2x5ZmlsbHMvZXM1JylcclxucmVxdWlyZSgnanMtcG9seWZpbGxzL2VzNicpXHJcblxyXG5pZiAoZ2xvYmFsLnJoID09PSB1bmRlZmluZWQpIHtcclxuICBnbG9iYWwucmggPSB7fTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBnbG9iYWwucmhcclxuIiwibGV0IHJoID0gcmVxdWlyZShcIi4uLy4uL2xpYi9yaFwiKVxyXG5sZXQgbm9kZVV0aWxzID0gcmVxdWlyZShcIi4uL3V0aWxzL25vZGVfdXRpbHNcIilcclxubGV0ICQgPSByaC4kXHJcbmxldCBfID0gcmguXztcclxuY2xhc3MgTW9kYWxEaWFsb2cge1xyXG5cclxuICBjcmVhdGVDaGlsZFdpZGdldCgpIHtcclxuICAgIHRoaXMubm9kZSA9ICQuY3JlYXRlRWxlbWVudCgnZGl2JywgdGhpcy50ZW1wbGF0ZSlcclxuICAgIG5vZGVVdGlscy5hcHBlbmRDaGlsZChkb2N1bWVudC5ib2R5LCB0aGlzLm5vZGUpO1xyXG4gICAgdGhpcy53aWRnZXQgPSBuZXcgcmguV2lkZ2V0KHtub2RlOiB0aGlzLm5vZGV9KVxyXG4gICAgdGhpcy53aWRnZXQuaW5pdCgpXHJcbiAgfVxyXG5cclxuXHJcbiAgZ2V0IHRlbXBsYXRlKCkge1xyXG4gICAgbGV0IGluaXRpYWxTdHlsZSA9IHRoaXMuaW5pdGlhbFN0eWxlKClcclxuXHJcbiAgICByZXR1cm4gYFxyXG4gICAgPGRpdiBjbGFzcz1cInJoLW1vZGFsXCI+XHJcbiAgICAgICAgPGRpdiBjbGFzcz1cInJoLW1vZGFsLWNvbnRhaW5lclwiICR7aW5pdGlhbFN0eWxlfT5cclxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJyaC1tb2RhbC1jb250ZW50XCIgZGF0YS1odG1sPVwiY29udGVudFwiPjwvZGl2PlxyXG4gICAgICAgICAgPGRpdiBjbGFzcz1cInJoLW1vZGFsLWNsb3NlXCIgZGF0YS1jbGljaz1cIkBjbG9zZSh0cnVlKVwiPiA8L2Rpdj5cclxuICAgICAgICA8L2Rpdj5cclxuICAgIDwvZGl2PmA7XHJcbiAgfVxyXG5cclxuICBzZXRPbkltYWdlTG9hZCgpe1xyXG4gICAgbGV0IG1vZGFsQ29udGVudCA9ICQuZmluZCh0aGlzLm5vZGUsICcucmgtbW9kYWwtY29udGVudCcpWzBdXHJcbiAgICBpZighbW9kYWxDb250ZW50KSB7XHJcbiAgICAgIHJldHVyblxyXG4gICAgfVxyXG4gICAgdGhpcy5tb2RhbENvbnRlbnQgPSBtb2RhbENvbnRlbnRcclxuICAgIGxldCBpbWcgPSAkLmZpbmQobW9kYWxDb250ZW50LCAnaW1nJylbMF1cclxuICAgIGlmKGltZyl7XHJcbiAgICAgIHRoaXMuaW1nID0gaW1nXHJcbiAgICAgIGltZy5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgdGhpcy5zZXRNb2RhbFNpemUuYmluZCh0aGlzKSlcclxuICAgICAgaW1nLmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgdGhpcy5zZXRNb2RhbFNpemUuYmluZCh0aGlzKSlcclxuICAgIH1cclxuICB9XHJcbiAgc2V0TW9kYWxTaXplKCl7XHJcbiAgICB0aGlzLmltYWdlV2lkdGggPSB0aGlzLmltZy5uYXR1cmFsV2lkdGhcclxuICAgIHRoaXMuaW1hZ2VIZWlnaHQgPSB0aGlzLmltZy5uYXR1cmFsSGVpZ2h0XHJcbiAgICBsZXQgcG9zaXRpb24gPSB0aGlzLmNhbGN1bGF0ZVBvc2l0aW9uKHRoaXMuaW1hZ2VXaWR0aCwgdGhpcy5pbWFnZUhlaWdodClcclxuICAgIGxldCBtb2RhbENvbnRhaW5lciA9ICQuZmluZCh0aGlzLm5vZGUsICcucmgtbW9kYWwtY29udGFpbmVyJylbMF1cclxuICAgIGlmKG1vZGFsQ29udGFpbmVyKXtcclxuICAgICAgdGhpcy5zZXRDb250YWluZXJTdHlsZShtb2RhbENvbnRhaW5lciwgcG9zaXRpb24pXHJcbiAgICB9XHJcbiAgfVxyXG4gIHNldENvbnRhaW5lclN0eWxlKG1vZGFsQ29udGFpbmVyLCBwb3NpdGlvbil7XHJcbiAgICBsZXQgdG9wID0gTWF0aC5yb3VuZChwb3NpdGlvbi50b3ApXHJcbiAgICBsZXQgbGVmdCA9IE1hdGgucm91bmQocG9zaXRpb24ubGVmdClcclxuXHJcbiAgICAkLmNzcyhtb2RhbENvbnRhaW5lciwgJ2xlZnQnLCBsZWZ0LnRvU3RyaW5nKCkgKyAncHgnKVxyXG4gICAgJC5jc3MobW9kYWxDb250YWluZXIsICd0b3AnLCB0b3AudG9TdHJpbmcoKSArICdweCcpXHJcblxyXG4gICAgaWYodGhpcy5tb2RhbENvbnRlbnQpIHtcclxuICAgICAgdGhpcy5zZXRJbWFnZVNpemUocG9zaXRpb24ud2lkdGgsIHBvc2l0aW9uLmhlaWdodClcclxuICAgIH1cclxuICAgICQuY3NzKG1vZGFsQ29udGFpbmVyLCAnZGlzcGxheScsIFwiYmxvY2tcIilcclxuXHJcbiAgfVxyXG4gIGNhbGN1bGF0ZUltYWdlU2l6ZShzaXplKXtcclxuICAgIGxldCBhc3BlY3QgPSBzaXplLmltYWdlV2lkdGgvc2l6ZS5pbWFnZUhlaWdodFxyXG4gICAgaWYoc2l6ZS5pbWFnZVdpZHRoIDwgc2l6ZS5wYWdlV2lkdGggJiYgc2l6ZS5pbWFnZUhlaWdodCA8IHNpemUucGFnZUhlaWdodCl7XHJcbiAgICAgIHJldHVybiB7d2lkdGg6IHNpemUuaW1hZ2VXaWR0aCwgaGVpZ2h0OiBzaXplLmltYWdlSGVpZ2h0fVxyXG4gICAgfVxyXG5cclxuICAgIGlmKHNpemUuaW1hZ2VXaWR0aCA+PSBzaXplLnBhZ2VXaWR0aCAmJiBzaXplLmltYWdlSGVpZ2h0IDw9IHNpemUucGFnZUhlaWdodCl7XHJcbiAgICAgIHJldHVybiB7aGVpZ2h0OiBzaXplLnBhZ2VXaWR0aC9hc3BlY3QsIHdpZHRoOiBzaXplLnBhZ2VXaWR0aH1cclxuICAgIH1cclxuICAgIGlmKHNpemUuaW1hZ2VXaWR0aCA8PSBzaXplLnBhZ2VXaWR0aCAmJiBzaXplLmltYWdlSGVpZ2h0ID49IHNpemUucGFnZUhlaWdodCl7XHJcbiAgICAgIHJldHVybiB7aGVpZ2h0OiBzaXplLnBhZ2VIZWlnaHQsIHdpZHRoOiBzaXplLnBhZ2VIZWlnaHQqYXNwZWN0XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGlmKHNpemUuaW1hZ2VXaWR0aCA+PSBzaXplLnBhZ2VXaWR0aCAmJiBzaXplLmltYWdlSGVpZ2h0ID49IHNpemUucGFnZUhlaWdodCl7XHJcbiAgICAgIHJldHVybiB0aGlzLl9jYWxjdWxhdGVGdWxseUV4Y2VlZFNpemUoc2l6ZSwgYXNwZWN0KVxyXG4gICAgfVxyXG4gIH1cclxuICBfY2FsY3VsYXRlRnVsbHlFeGNlZWRTaXplKHNpemUsIGFzcGVjdCl7XHJcbiAgICBsZXQgcGFnZUFzcGVjdCA9IHNpemUucGFnZVdpZHRoL3NpemUucGFnZUhlaWdodFxyXG4gICAgaWYoYXNwZWN0IDwgcGFnZUFzcGVjdCl7XHJcbiAgICAgIHJldHVybiB7aGVpZ2h0OiBzaXplLnBhZ2VIZWlnaHQsIHdpZHRoOiBzaXplLnBhZ2VIZWlnaHQqYXNwZWN0fVxyXG4gICAgfVxyXG4gICAgZWxzZXtcclxuICAgICAgcmV0dXJueyBoZWlnaHQ6IHNpemUucGFnZVdpZHRoL2FzcGVjdCwgd2lkdGg6IHNpemUucGFnZVdpZHRofVxyXG4gICAgfVxyXG4gIH1cclxuXHJcblxyXG5cclxuICBjYWxjdWxhdGVQb3NpdGlvbihpbWFnZVdpZHRoLCBpbWFnZUhlaWdodCl7XHJcbiAgICBsZXQgcGFnZVdpZHRoID0gd2luZG93LmlubmVyV2lkdGggfHwgZG9jdW1lbnQuYm9keS5jbGllbnRXaWR0aFxyXG4gICAgbGV0IHBhZ2VIZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQgfHwgZG9jdW1lbnQuYm9keS5jbGllbnRIZWlnaHRcclxuICAgIHBhZ2VXaWR0aCAtPSA3MFxyXG4gICAgcGFnZUhlaWdodCAtPSA3MFxyXG4gICAgcGFnZVdpZHRoID0gKHBhZ2VXaWR0aCA+PSAwKT8gIHBhZ2VXaWR0aDogMFxyXG4gICAgcGFnZUhlaWdodCA9IChwYWdlSGVpZ2h0ID49IDApPyAgcGFnZUhlaWdodDogMFxyXG5cclxuICAgIGxldCBzaXplID0ge2ltYWdlV2lkdGg6aW1hZ2VXaWR0aCwgaW1hZ2VIZWlnaHQ6aW1hZ2VIZWlnaHQsIHBhZ2VXaWR0aDpwYWdlV2lkdGgsIHBhZ2VIZWlnaHQ6cGFnZUhlaWdodH1cclxuICAgIGxldCBpbWFnZV9zaXplID0gdGhpcy5jYWxjdWxhdGVJbWFnZVNpemUoc2l6ZSlcclxuICAgIGltYWdlV2lkdGggPSBpbWFnZV9zaXplLndpZHRoXHJcbiAgICBpbWFnZUhlaWdodCA9IGltYWdlX3NpemUuaGVpZ2h0XHJcbiAgICBsZXQgbGVmdCA9IE1hdGgubWF4KDUsIChwYWdlV2lkdGggLSBpbWFnZVdpZHRoKS8yIClcclxuICAgIGxldCB0b3AgPSBNYXRoLm1heCg1LCAocGFnZUhlaWdodCAtIGltYWdlSGVpZ2h0KS8yIClcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBsZWZ0OiBsZWZ0LFxyXG4gICAgICB0b3A6IHRvcCxcclxuICAgICAgd2lkdGg6IGltYWdlV2lkdGgsXHJcbiAgICAgIGhlaWdodDogaW1hZ2VIZWlnaHQsXHJcbiAgICAgIHBhZ2VXaWR0aDogcGFnZVdpZHRoLFxyXG4gICAgICBwYWdlSGVpZ2h0OiBwYWdlSGVpZ2h0XHJcbiAgICB9XHJcbiAgfVxyXG4gIGluaXRpYWxTdHlsZSgpe1xyXG4gICAgcmV0dXJuICh0aGlzLmlzSW1hZ2UpPyBgc3R5bGU9XCJkaXNwbGF5Om5vbmVcImAgOiAnJ1xyXG4gIH1cclxuXHJcbiAgU2hvd01vZGFsKGNvbmZpZykge1xyXG4gICAgdGhpcy5pc0ltYWdlID0gY29uZmlnLmlzSW1hZ2VcclxuICAgIHRoaXMuY3JlYXRlQ2hpbGRXaWRnZXQoKVxyXG4gICAgdGhpcy53aWRnZXQuc3Vic2NyaWJlKCdjbG9zZScsIHRoaXMuX2Nsb3NlLmJpbmQodGhpcykpXHJcbiAgICB0aGlzLndpZGdldC5wdWJsaXNoKCdjb250ZW50JywgY29uZmlnLmNvbnRlbnQpXHJcbiAgICBfLmRlZmVyKHRoaXMuc2V0T25JbWFnZUxvYWQuYmluZCh0aGlzKSlcclxuXHJcbiAgfVxyXG5cclxuICBzZXRJbWFnZVNpemUobWF4V2lkdGgsIG1heEhlaWdodCl7XHJcbiAgICBpZih0aGlzLmltYWdlV2lkdGggPiBtYXhXaWR0aCl7XHJcbiAgICAgICQuY3NzKHRoaXMuaW1nLCAnd2lkdGgnLCBgJHtNYXRoLnJvdW5kKG1heFdpZHRoKX1weGApXHJcbiAgICB9XHJcbiAgICBpZih0aGlzLmltYWdlSGVpZ2h0ID4gbWF4SGVpZ2h0KXtcclxuICAgICAgJC5jc3ModGhpcy5pbWcsICdoZWlnaHQnLCBgJHtNYXRoLnJvdW5kKG1heEhlaWdodCl9cHhgKVxyXG4gICAgfVxyXG4gIH1cclxuICBfY2xvc2UoKXtcclxuICAgIHRoaXMud2lkZ2V0LmRlc3RydWN0KCk7XHJcbiAgICB0aGlzLndpZGdldCA9IHVuZGVmaW5lZDtcclxuICAgIG5vZGVVdGlscy5yZW1vdmVDaGlsZCh0aGlzLm5vZGUpO1xyXG4gICAgdGhpcy5ub2RlID0gdW5kZWZpbmVkO1xyXG4gIH1cclxufVxyXG5cclxuXHJcbmlmICghXy5pc0lmcmFtZSgpKSB7XHJcbiAgcmgubW9kZWwuY3N1YnNjcmliZSgnU0hPV19NT0RBTCcsIGNvbmZpZyA9PiB7XHJcbiAgICBsZXQgbW9kZWwgPSBuZXcgTW9kYWxEaWFsb2coKVxyXG4gICAgbW9kZWwuU2hvd01vZGFsKGNvbmZpZylcclxuICB9KVxyXG59XHJcblxyXG5yaC5tb2RlbC5jc3Vic2NyaWJlKCdTSE9XX01PREFMX0lOX1RPUElDJywgY29uZmlnID0+IHtcclxuICBsZXQgbW9kZWwgPSBuZXcgTW9kYWxEaWFsb2coKVxyXG4gIG1vZGVsLlNob3dNb2RhbChjb25maWcpXHJcbn0pXHJcbiIsInJlcXVpcmUoXCIuLi9saWIvcmhcIilcclxucmVxdWlyZShcIi4uLy4uL2xlbmllbnRfc3JjL3JvYm9oZWxwL3RvcGljL3VybF91dGlsc1wiKVxyXG5yZXF1aXJlKFwiLi4vLi4vbGVuaWVudF9zcmMvcm9ib2hlbHAvdG9waWMvdG9waWNfZXZlbnRzXCIpXHJcbnJlcXVpcmUoXCIuLi8uLi9sZW5pZW50X3NyYy9yb2JvaGVscC90b3BpYy9waG9uZWdhcFwiKVxyXG5yZXF1aXJlKFwiLi90b3BpYy9pbml0XCIpXHJcbnJlcXVpcmUoXCIuL3RvcGljL3dpZGdldHMvZHJvcGRvd25fdGV4dFwiKVxyXG5yZXF1aXJlKFwiLi90b3BpYy93aWRnZXRzL2V4cGFuZGluZ190ZXh0XCIpXHJcbnJlcXVpcmUoXCIuL3RvcGljL3dpZGdldHMvcG9wb3ZlclwiKVxyXG5yZXF1aXJlKFwiLi90b3BpYy93aWRnZXRzL2h5cGVybGlua19wb3BvdmVyXCIpXHJcbnJlcXVpcmUoXCIuL3RvcGljL3dpZGdldHMvdGV4dF9wb3BvdmVyXCIpXHJcbnJlcXVpcmUoXCIuL3RvcGljL3dpZGdldHMvdHJpZ2dlclwiKVxyXG5yZXF1aXJlKFwiLi90b3BpYy9oaWdobGlnaHRcIilcclxucmVxdWlyZShcIi4uLy4uL2xlbmllbnRfc3JjL3JvYm9oZWxwL3RvcGljL3RvcGljX2V2ZW50c1wiKVxyXG5yZXF1aXJlKFwiLi9sYXlvdXQvbW9kYWxfZGlhbG9nXCIpXHJcbiIsImxldCByaCA9IHJlcXVpcmUoXCIuLi8uLi9saWIvcmhcIilcclxubGV0IF8gPSByaC5fXHJcbmxldCAkID0gcmguJFxyXG5cclxuXy5yZW1vdmVIaWdobGlnaHQgPSAoKSA9PiB7XHJcbiAgbGV0ICRib2R5ID0gJCgnYm9keScsIDApXHJcbiAgbGV0ICRoaWdobGlnaHRfZWxlbWVudHMgPSAkLmZpbmQoJGJvZHksICdzcGFuW2RhdGEtaGlnaGxpZ2h0XScpIHx8IFtdXHJcbiAgXy5lYWNoKCRoaWdobGlnaHRfZWxlbWVudHMsIChub2RlKSA9PiB7XHJcbiAgICAkLnJlbW92ZUF0dHJpYnV0ZShub2RlLCAnc3R5bGUnKVxyXG4gIH0pXHJcbn1cclxuXHJcbnJoLm1vZGVsLmNzdWJzY3JpYmUoJ0VWVF9SRU1PVkVfSElHSExJR0hUJywgXy5yZW1vdmVIaWdobGlnaHQpXHJcblxyXG4iLCJsZXQgcmggPSByZXF1aXJlKFwiLi4vLi4vbGliL3JoXCIpO1xyXG5sZXQgTm9kZXNVdGlsID0gcmVxdWlyZShcIi4uLy4uL3Jlc3BvbnNpdmVfaGVscC91dGlscy9ub2RlX3V0aWxzXCIpXHJcbmxldCBfID0gcmguXztcclxubGV0IGNvbnN0cyA9IHJoLmNvbnN0cztcclxubGV0ICQgPSByaC4kO1xyXG5sZXQgbW9kZWwgPSByaC5tb2RlbDtcclxubGV0IEV2ZW50SGFuZGxlcnMsIGVIYW5kbGVycywgcmVnaXN0ZXJlZEV2ZW50cztcclxuXHJcbl8ub25Ub3BpY0xvYWQgPSAoKSA9PiB7XHJcbiAgbGV0IHBhcmFtc1N0ciA9IF8uZXh0cmFjdFBhcmFtU3RyaW5nKGRvY3VtZW50LmxvY2F0aW9uLmhyZWYpO1xyXG4gIGxldCBwYXJhbXNNYXAgPSBfLnVybFBhcmFtcyhwYXJhbXNTdHIpO1xyXG4gIGxldCByZWRpcmVjdGF0dHIgPSBjb25zdHMoJ1JIX0ZVTExfTEFZT1VUX1BBUkFNJyk7XHJcbiAgbGV0ICRodG1sID0gJCgnaHRtbCcsMCk7XHJcbiAgbGV0IGxhbmcgPSBtb2RlbC5nZXQoY29uc3RzKCdLRVlfTE5HX05BTUUnKSlcclxuICBpZigkaHRtbCAmJiBsYW5nICYmIGxhbmcgIT09ICcnKXsgIFxyXG4gICAgJC5zZXRBdHRyaWJ1dGUoJGh0bWwsICdsYW5nJywgbGFuZylcclxuICB9XHJcbiAgaWYgKHJlZGlyZWN0YXR0ciBpbiBwYXJhbXNNYXApIHtcclxuICAgIF8uYWRkUHJvamVjdERhdGEoXy5nb1RvRnVsbExheW91dClcclxuICB9XHJcbiAgZWxzZXtcclxuICAgIF8uYWRkR29Ub0xheW91dCgpO1xyXG4gICAgXy5yZW1vdmVfY2J0KCk7XHJcbiAgfVxyXG59O1xyXG5cclxuXy5yZW1vdmVfY2J0ID0gKCkgPT57XHJcbiAgbGV0ICRib2R5ID0gJCgnYm9keScsMCk7XHJcbiAgbGV0ICRjYnRfZWxlbWVudHMgPSAkLmZpbmQoJGJvZHksICdbZGF0YS1yaHRhZ3NdJyk7XHJcbiAgaWYoJGNidF9lbGVtZW50cyl7XHJcbiAgICBfLmVhY2goJGNidF9lbGVtZW50cywgKG5vZGUpID0+e1xyXG4gICAgICAkLnJlbW92ZUNsYXNzKG5vZGUsICdyaC1oaWRlJyk7XHJcbiAgICB9KTtcclxuICB9XHJcbn07XHJcblxyXG5fLnNob3dEZWZhdWx0VGV4dCA9IHNob3VsZFNob3cgPT4ge1xyXG4gIGxldCBkZWZhdWx0VGV4dERpdiwgREVGQVVMVF9URVhUX0lEID0gJ3JoLWRlZmF1bHQtdGV4dCdcclxuICBsZXQgbG5nID0gbW9kZWwuZ2V0KGNvbnN0cygnS0VZX0xORycpKVxyXG4gIGlmIChzaG91bGRTaG93ICYmICQuZmluZChkb2N1bWVudC5oZWFkLCAnbWV0YVtuYW1lPVwiY29uZGl0aW9uLXRhZ3NcIl0nKS5sZW5ndGghPT0wICkge1xyXG4gICAgaWYgKCFkb2N1bWVudC5nZXRFbGVtZW50QnlJZChERUZBVUxUX1RFWFRfSUQpKSB7IFxyXG4gICAgICBkZWZhdWx0VGV4dERpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXHJcbiAgICAgICQuc2V0QXR0cmlidXRlKGRlZmF1bHRUZXh0RGl2LCAnaWQnLCBERUZBVUxUX1RFWFRfSUQpXHJcbiAgICAgIGRlZmF1bHRUZXh0RGl2LmlubmVySFRNTCA9IGxuZy5Ub3BpY0hpZGRlblRleHQgfHwgXCJUaGUgY3VycmVudCB0b3BpYyBpcyBoaWRkZW4gZm9yIHRoZSBzZWxlY3RlZCBmaWx0ZXJzLlwiXHJcbiAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZGVmYXVsdFRleHREaXYpXHJcbiAgICB9XHJcbiAgfSBlbHNlIHsgXHJcbiAgICBkZWZhdWx0VGV4dERpdiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKERFRkFVTFRfVEVYVF9JRClcclxuICAgIE5vZGVzVXRpbC5yZW1vdmVDaGlsZChkZWZhdWx0VGV4dERpdilcclxuICB9XHJcbn1cclxuXHJcbl8uZ2V0UmVsYXRpdmVUb3BpY1BhdGggPSAoKSA9PiB7XHJcbiAgbGV0IHBhdGggPSBfLm1ha2VSZWxhdGl2ZVVybChfLmdldFJvb3RVcmwoKSwgXy5maWxlUGF0aCgpKTtcclxuICBsZXQgaW5kZXggPSBwYXRoLmxhc3RJbmRleE9mKCcvJyk7XHJcbiAgcmV0dXJuIGluZGV4ICE9PSAtMSA/IF8ucGFyZW50UGF0aChwYXRoKSA6IFwiXCI7XHJcbn1cclxuXHJcbl8uYWRkTGF5b3V0SFRNTCA9ICgpID0+e1xyXG5cclxuICBtb2RlbC5zdWJzY3JpYmVPbmNlKFtjb25zdHMoJ0tFWV9IRUFERVJfSFRNTCcpXSwgKCkgPT4ge1xyXG4gICAgbGV0IGZvcm1hdCA9IG1vZGVsLmdldChjb25zdHMoJ0tFWV9IRUFERVJfSFRNTCcpKTtcclxuXHJcbiAgICBpZihmb3JtYXQgJiYgZm9ybWF0ICE9PSBcIlwiKXtcclxuXHJcbiAgICAgIG1vZGVsLnN1YnNjcmliZU9uY2UoW2NvbnN0cygnS0VZX0hFQURFUl9USVRMRScpLCBjb25zdHMoJ0tFWV9MTkcnKV0sICgpID0+IHtcclxuICAgICAgICBsZXQgdGl0bGUgPSBtb2RlbC5nZXQoY29uc3RzKCdLRVlfSEVBREVSX1RJVExFJykpO1xyXG4gICAgICAgIGxldCBsYWJlbCA9IG1vZGVsLmdldChjb25zdHMoJ0tFWV9MTkcnKSkuU2hvd1RvcGljSW5Db250ZXh0O1xyXG4gICAgICAgIGxhYmVsID0gbGFiZWwgPyBsYWJlbCA6IFwiQ2xpY2sgaGVyZSB0byBzZWUgdGhpcyBwYWdlIGluIGZ1bGwgY29udGV4dFwiO1xyXG4gICAgICAgIGxldCB0b29sdGlwID0gbGFiZWw7XHJcbiAgICAgICAgbGV0IGxvZ28gPSBtb2RlbC5nZXQoY29uc3RzKCdLRVlfSEVBREVSX0xPR09fUEFUSCcpKTtcclxuICAgICAgICBsb2dvID0gXy5nZXRSZWxhdGl2ZVRvcGljUGF0aCgpICsgbG9nbztcclxuICAgICAgICBsZXQgaHRtbCA9IF8ucmVzb2x2ZUVuY2xvc2VkVmFyKGZvcm1hdCwgKHZhcmlhYmxlKSA9PiB7XHJcbiAgICAgICAgICBpZih2YXJpYWJsZSA9PT0gXCJsYWJlbFwiKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBsYWJlbDtcclxuICAgICAgICAgIH0gZWxzZSBpZiAodmFyaWFibGUgPT09IFwidG9vbHRpcFwiKXtcclxuICAgICAgICAgICAgcmV0dXJuIHRvb2x0aXA7XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKHZhcmlhYmxlID09PSBcInRpdGxlXCIpe1xyXG4gICAgICAgICAgICByZXR1cm4gdGl0bGU7XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKHZhcmlhYmxlID09PSBcImxvZ29cIil7XHJcbiAgICAgICAgICAgIHJldHVybiBsb2dvO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGxldCAkYm9keSA9ICQoJ2JvZHknLDApO1xyXG4gICAgICAgIGxldCAkZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcclxuICAgICAgICAkZGl2LmlubmVySFRNTCA9IGh0bWw7XHJcbiAgICAgICAgJGJvZHkuaW5zZXJ0QmVmb3JlKCRkaXYsICRib2R5LmNoaWxkTm9kZXNbMF0pO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9KTtcclxufTtcclxuXHJcbl8uYWRkTGF5b3V0Q1NTID0gKCkgPT57XHJcblxyXG4gIG1vZGVsLnN1YnNjcmliZU9uY2UoW2NvbnN0cygnS0VZX0hFQURFUl9DU1MnKV0sICgpID0+IHtcclxuICAgIGxldCBmb3JtYXQgPSBtb2RlbC5nZXQoY29uc3RzKCdLRVlfSEVBREVSX0NTUycpKTtcclxuXHJcbiAgICBpZihmb3JtYXQgJiYgZm9ybWF0ICE9PSBcIlwiKXtcclxuXHJcbiAgICAgIG1vZGVsLnN1YnNjcmliZU9uY2UoW2NvbnN0cygnS0VZX0hFQURFUl9MT0dPX1BBVEgnKSxcclxuICAgICAgICBjb25zdHMoJ0tFWV9IRUFERVJfVElUTEVfQ09MT1InKSwgY29uc3RzKCdLRVlfSEVBREVSX0JBQ0tHUk9VTkRfQ09MT1InKSwgY29uc3RzKCdLRVlfTEFZT1VUX0ZPTlRfRkFNSUxZJyldLCAoKSA9PiB7XHJcbiAgICAgICAgbGV0IGJhY2tncm91bmRDb2xvciA9IG1vZGVsLmdldChjb25zdHMoJ0tFWV9IRUFERVJfQkFDS0dST1VORF9DT0xPUicpKTtcclxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3IgPSBiYWNrZ3JvdW5kQ29sb3IgPyBiYWNrZ3JvdW5kQ29sb3IgOiBtb2RlbC5nZXQoY29uc3RzKCdLRVlfSEVBREVSX0RFRkFVTFRfQkFDS0dST1VORF9DT0xPUicpKTtcclxuICAgICAgICBsZXQgY29sb3IgPSBtb2RlbC5nZXQoY29uc3RzKCdLRVlfSEVBREVSX1RJVExFX0NPTE9SJykpO1xyXG4gICAgICAgIGNvbG9yID0gY29sb3IgPyBjb2xvciA6IG1vZGVsLmdldChjb25zdHMoJ0tFWV9IRUFERVJfREVGQVVMVF9USVRMRV9DT0xPUicpKTtcclxuICAgICAgICBsZXQgZm9udEZhbWlseSA9IG1vZGVsLmdldChjb25zdHMoJ0tFWV9MQVlPVVRfRk9OVF9GQU1JTFknKSk7XHJcbiAgICAgICAgZm9udEZhbWlseSA9IGZvbnRGYW1pbHkgPyBmb250RmFtaWx5IDogbW9kZWwuZ2V0KGNvbnN0cygnS0VZX0xBWU9VVF9ERUZBVUxUX0ZPTlRfRkFNSUxZJykpO1xyXG4gICAgICAgIGxldCBjc3MgPSBfLnJlc29sdmVFbmNsb3NlZFZhcihmb3JtYXQsICh2YXJpYWJsZSkgPT4ge1xyXG4gICAgICAgICAgaWYodmFyaWFibGUgPT09IFwiYmFja2dyb3VuZC1jb2xvclwiKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBiYWNrZ3JvdW5kQ29sb3I7XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKHZhcmlhYmxlID09PSBcImNvbG9yXCIpe1xyXG4gICAgICAgICAgICByZXR1cm4gY29sb3I7XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKHZhcmlhYmxlID09PSBcImZvbnQtZmFtaWx5XCIpe1xyXG4gICAgICAgICAgICByZXR1cm4gZm9udEZhbWlseTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBsZXQgJHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xyXG4gICAgICAgICRzdHlsZS50eXBlID0gJ3RleHQvY3NzJ1xyXG4gICAgICAgICRzdHlsZS5pbm5lckhUTUwgPSBjc3M7XHJcbiAgICAgICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZCgkc3R5bGUpO1xyXG4gICAgICAgIFxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9KTtcclxufTtcclxuXHJcbl8uYWRkUHJvamVjdERhdGEgPSAoY2FsbGJhY2spID0+IHtcclxuICBjYWxsYmFjayA9IGNhbGxiYWNrIHx8ICgoKSA9Pnt9KVxyXG4gIGxldCBzcmMgPSBfLmdldFJlbGF0aXZlVG9waWNQYXRoKCkgKyBcInRlbXBsYXRlL3NjcmlwdHMvcHJvamVjdGRhdGEuanNcIjtcclxuICBfLmxvYWRTY3JpcHQoc3JjLCBudWxsLCBjYWxsYmFjaylcclxufVxyXG5cclxuXy5hZGRHb1RvTGF5b3V0ID0gKCkgPT4ge1xyXG4gIF8uYWRkUHJvamVjdERhdGEoKTtcclxuICBfLnNob3dUb3BpY0hlYWRlcigpO1xyXG4gIF8uYWRkTGF5b3V0SFRNTCgpO1xyXG4gIF8uYWRkTGF5b3V0Q1NTKCk7XHJcbn07XHJcblxyXG5fLnNob3dUb3BpY0hlYWRlciA9ICgpID0+IHtcclxuICBsZXQgaGVhZGVyTm9kZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdyaC10b3BpYy1oZWFkZXInKSxcclxuICAgIGhlYWRlclNoYWRvd05vZGUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncmgtdG9waWMtaGVhZGVyLXNoYWRvdycpXHJcbiAgXy5lYWNoKFtoZWFkZXJOb2RlLCBoZWFkZXJTaGFkb3dOb2RlXSwgbm9kZSA9PiB7IFxyXG4gICAgaWYgKG5vZGUpIHtcclxuICAgICAgJC5yZW1vdmVDbGFzcyhub2RlLCAncmgtaGlkZScpXHJcbiAgICB9XHJcbiAgfSlcclxufTtcclxuXHJcbm1vZGVsLnB1Ymxpc2goY29uc3RzKCdLRVlfU0hBUkVEX0lOUFVUJyksIFtcclxuICBjb25zdHMoJ0tFWV9QUk9KRUNUX1RBR19DT01CSU5BVElPTlMnKSxcclxuICBjb25zdHMoJ0tFWV9UQUdfRVhQUkVTU0lPTicpLFxyXG4gIGNvbnN0cygnS0VZX1RPUElDX0lOX0lGUkFNRScpLFxyXG4gIHtcclxuICAgIGtleTogY29uc3RzKCdFVlRfU0NST0xMX1RPX1RPUCcpLFxyXG4gICAgbmVzdGVkOiBmYWxzZVxyXG4gIH0sXHJcbiAgY29uc3RzKCdFVlRfUFJJTlRfVE9QSUMnKSxcclxuICBjb25zdHMoJ0tFWV9NRVJHRURfUFJPSkVDVF9NQVAnKSxcclxuICBjb25zdHMoJ0tFWV9QUk9KRUNUX0xJU1QnKSxcclxuICBjb25zdHMoJ0tFWV9TSE9XX1RBR1MnKSxcclxuICBjb25zdHMoJ0tFWV9JRlJBTUVfRVZFTlRTJyksXHJcbiAgY29uc3RzKCdFVlRfUkVMT0FEX1RPUElDJyksXHJcbiAgY29uc3RzKCdLRVlfTU9CSUxFX0FQUF9NT0RFJyksXHJcbiAgY29uc3RzKCdLRVlfSEVBREVSX0xPR09fUEFUSCcpLFxyXG4gIGNvbnN0cygnS0VZX0hFQURFUl9USVRMRScpLFxyXG4gIGNvbnN0cygnS0VZX0hFQURFUl9USVRMRV9DT0xPUicpLFxyXG4gIGNvbnN0cygnS0VZX0hFQURFUl9CQUNLR1JPVU5EX0NPTE9SJyksXHJcbiAgY29uc3RzKCdLRVlfTEFZT1VUX0ZPTlRfRkFNSUxZJyksXHJcbiAgY29uc3RzKCdLRVlfSEVBREVSX0hUTUwnKSxcclxuICBjb25zdHMoJ0tFWV9IRUFERVJfQ1NTJyksXHJcbiAgY29uc3RzKCdLRVlfSEVBREVSX0RFRkFVTFRfQkFDS0dST1VORF9DT0xPUicpLFxyXG4gIGNvbnN0cygnS0VZX0hFQURFUl9ERUZBVUxUX1RJVExFX0NPTE9SJyksXHJcbiAgY29uc3RzKCdLRVlfTEFZT1VUX0RFRkFVTFRfRk9OVF9GQU1JTFknKSxcclxuICBjb25zdHMoJ0tFWV9UT0NfT1JERVInKSxcclxuICBjb25zdHMoJ0tFWV9MTkdfTkFNRScpLFxyXG4gIGNvbnN0cygnRVZUX0NPTExBUFNFX0FMTCcpLFxyXG4gIGNvbnN0cygnRVZUX0VYUEFORF9BTEwnKSxcclxuICBjb25zdHMoJ0tFWV9TRUFSQ0hfSElHSExJR0hUX0NPTE9SJyksXHJcbiAgY29uc3RzKCdLRVlfU0VBUkNIX0JHX0NPTE9SJyksXHJcbiAgY29uc3RzKCdLRVlfU0hPV19TQ1JPTExfVE9fVE9QJyksXHJcbiAgY29uc3RzKCdLRVlfRE9fTk9UX1BSRVNFUlZFX0FSJyksXHJcbiAgY29uc3RzKCdFVlRfUkVNT1ZFX0hJR0hMSUdIVCcpLFxyXG4gIGNvbnN0cygnS0VZX1NVQlNUUl9TRUFSQ0gnKSxcclxuICBjb25zdHMoJ0tFWV9TSE9XX0NPTlRFWFQnKVxyXG5dKTtcclxuXHJcbm1vZGVsLnB1Ymxpc2goY29uc3RzKCdLRVlfU0hBUkVEX09VVFBVVCcpLCBbXHJcbiAgY29uc3RzKCdLRVlfVE9QSUNfVVJMJyksXHJcbiAgY29uc3RzKCdLRVlfVE9QSUNfSUQnKSxcclxuICBjb25zdHMoJ0tFWV9UT1BJQ19USVRMRScpLFxyXG4gIGNvbnN0cygnS0VZX1RPUElDX0JSU01BUCcpLFxyXG4gIGNvbnN0cygnU0hPV19NT0RBTCcpLFxyXG4gIGNvbnN0cygnRVZUX05BVklHQVRFX1RPX1VSTCcpLFxyXG4gIGNvbnN0cygnRVZUX0NMSUNLX0lOU0lERV9JRlJBTUUnKSxcclxuICBjb25zdHMoJ0VWVF9TQ1JPTExfSU5TSURFX0lGUkFNRScpLFxyXG4gIGNvbnN0cygnRVZUX0lOU0lERV9JRlJBTUVfRE9NX0NPTlRFTlRMT0FERUQnKSxcclxuICBjb25zdHMoJ0tFWV9UT1BJQ19IRUlHSFQnKSxcclxuICBjb25zdHMoJ0tFWV9UT1BJQ19DT05URU5UX1NJWkUnKSxcclxuICBjb25zdHMoJ0dPX1RPX0RFRkFVTFRfVE9QSUMnKSxcclxuICBjb25zdHMoJ0VWVF9UT1BJQ19XSURHRVRfTE9BREVEJyldXHJcbiAgKTtcclxuXHJcbnJoLmlmcmFtZS5pbml0KCk7XHJcblxyXG5FdmVudEhhbmRsZXJzID0gKCgoKSA9PiB7XHJcbiAgbGV0IGxhc3RTY3JvbGxUb3AsIHB1Ymxpc2hTY3JvbGxJbmZvO1xyXG5cclxuICBjbGFzcyBFdmVudEhhbmRsZXJzIHtcclxuICAgIGhhbmRsZV9jbGljayhldmVudCkge1xyXG4gICAgICBpZiAoIWV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcclxuICAgICAgICBtb2RlbC5wdWJsaXNoKGNvbnN0cygnRVZUX0NMSUNLX0lOU0lERV9JRlJBTUUnKSwgbnVsbCk7XHJcbiAgICAgICAgcmV0dXJuIF8uaG9va0NsaWNrKGV2ZW50KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGhhbmRsZV9zY3JvbGwoKSB7XHJcbiAgICAgIGxldCBjdXJTY3JvbGxUb3AsIGRpcjtcclxuICAgICAgY3VyU2Nyb2xsVG9wID0gZG9jdW1lbnQuYm9keS5zY3JvbGxUb3A7XHJcbiAgICAgIGlmIChjdXJTY3JvbGxUb3AgPiBsYXN0U2Nyb2xsVG9wKSB7XHJcbiAgICAgICAgZGlyID0gJ2Rvd24nO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGRpciA9ICd1cCc7XHJcbiAgICAgIH1cclxuICAgICAgbGFzdFNjcm9sbFRvcCA9IGN1clNjcm9sbFRvcDtcclxuICAgICAgcmV0dXJuIHB1Ymxpc2hTY3JvbGxJbmZvKGRpcik7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBsYXN0U2Nyb2xsVG9wID0gLTE7XHJcblxyXG4gIHB1Ymxpc2hTY3JvbGxJbmZvID0gXy50aHJvdHRsZShkaXIgPT4ge1xyXG4gICAgbGV0IGJvZHksIGluZm87XHJcbiAgICBib2R5ID0gZG9jdW1lbnQuYm9keTtcclxuICAgIGluZm8gPSB7XHJcbiAgICAgIHNjcm9sbFRvcDogYm9keS5zY3JvbGxUb3AsXHJcbiAgICAgIHNjcm9sbEhlaWdodDogYm9keS5zY3JvbGxIZWlnaHQsXHJcbiAgICAgIGRpclxyXG4gICAgfTtcclxuICAgIHJldHVybiBtb2RlbC5wdWJsaXNoKGNvbnN0cygnRVZUX1NDUk9MTF9JTlNJREVfSUZSQU1FJyksIGluZm8pO1xyXG4gIH0sIDIwMCk7XHJcblxyXG4gIHJldHVybiBFdmVudEhhbmRsZXJzO1xyXG59KSkoKTtcclxuXHJcbmVIYW5kbGVycyA9IG5ldyBFdmVudEhhbmRsZXJzKCk7XHJcblxyXG5yZWdpc3RlcmVkRXZlbnRzID0ge307XHJcblxyXG5tb2RlbC5zdWJzY3JpYmUoY29uc3RzKCdFVlRfV0lER0VUX0xPQURFRCcpLCBfLm9uZSgoKSA9PiB7XHJcbiAgbW9kZWwuc3Vic2NyaWJlKGNvbnN0cygnS0VZX0lGUkFNRV9FVkVOVFMnKSwgb2JqID0+IHtcclxuICAgIGlmIChvYmogPT09IG51bGwpIHtcclxuICAgICAgb2JqID0ge307XHJcbiAgICB9XHJcbiAgICByZXR1cm4gXy5lYWNoKFsnY2xpY2snLCAnc2Nyb2xsJ10sIGVOYW1lID0+IHtcclxuICAgICAgaWYgKG9ialtlTmFtZV0pIHtcclxuICAgICAgICBfLmFkZEV2ZW50TGlzdGVuZXIoZG9jdW1lbnQsIGVOYW1lLCBlSGFuZGxlcnNbYGhhbmRsZV8ke2VOYW1lfWBdKTtcclxuICAgICAgICByZWdpc3RlcmVkRXZlbnRzW2VOYW1lXSA9IHRydWU7XHJcbiAgICAgIH0gZWxzZSBpZiAocmVnaXN0ZXJlZEV2ZW50c1tlTmFtZV0pIHtcclxuICAgICAgICBfLnJlbW92ZUV2ZW50TGlzdGVuZXIoZG9jdW1lbnQsIGVOYW1lLCBlSGFuZGxlcnNbYGhhbmRsZV8ke2VOYW1lfWBdKTtcclxuICAgICAgICByZWdpc3RlcmVkRXZlbnRzW2VOYW1lXSA9IGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9KTtcclxuICByZXR1cm4gXy5kZWxheSgoKSA9PiB7XHJcbiAgICBsZXQgaGVpZ2h0ID0gJC5wYWdlSGVpZ2h0KClcclxuICAgIGxldCB3aWR0aCA9ICQucGFnZVdpZHRoKClcclxuICAgIG1vZGVsLnB1Ymxpc2goY29uc3RzKCdLRVlfVE9QSUNfSEVJR0hUJyksIGhlaWdodClcclxuICAgIG1vZGVsLnB1Ymxpc2goY29uc3RzKCdLRVlfVE9QSUNfQ09OVEVOVF9TSVpFJyksIHtoZWlnaHQsd2lkdGh9KVxyXG4gIH0sIDEwMClcclxufSkpO1xyXG5cclxubW9kZWwuc3Vic2NyaWJlT25jZShbcmguY29uc3RzKCdLRVlfVE9DX09SREVSJyksIHJoLmNvbnN0cygnRVZUX1BST0pFQ1RfTE9BREVEJyldLCAoKSA9PiB7XHJcbiAgbGV0IG9yZGVyRGF0YSA9IHJoLm1vZGVsLmdldChyaC5jb25zdHMoJ0tFWV9UT0NfT1JERVInKSlcclxuICBsZXQgdXJsID0gcmguXy5wYXJlbnRQYXRoKHJoLl8uZmlsZVBhdGgoKS5zdWJzdHJpbmcocmguXy5nZXRIb3N0Rm9sZGVyKCkubGVuZ3RoKSlcclxuICB1cmwgPSAodXJsLmxlbmd0aCAmJiB1cmxbdXJsLmxlbmd0aC0xXSA9PT0gJy8nKSA/IHVybC5zdWJzdHJpbmcoMCwgdXJsLmxlbmd0aC0xKSA6IHVybFxyXG4gIHdoaWxlKG9yZGVyRGF0YVt1cmxdID09PSB1bmRlZmluZWQpIHtcclxuICAgIHVybCA9ICB1cmwuc3Vic3RyaW5nKDAsIHVybC5sYXN0SW5kZXhPZignLycpKVxyXG4gIH1cclxuICBsZXQgb3JkZXIgPSB1cmwgJiYgb3JkZXJEYXRhW3VybF0ub3JkZXJcclxuICByaC5tb2RlbC5wdWJsaXNoKHJoLmNvbnN0cygnS0VZX1RPQ19DSElMRF9PUkRFUicpLCBvcmRlcilcclxufSk7XHJcblxyXG5tb2RlbC5zdWJzY3JpYmUoY29uc3RzKCdFVlRfUkVMT0FEX1RPUElDJyksICgpID0+IGRvY3VtZW50LmxvY2F0aW9uLnJlbG9hZCgpKTtcclxuXHJcbm1vZGVsLnN1YnNjcmliZU9uY2UoW2NvbnN0cygnRVZUX1dJTkRPV19MT0FERUQnKSwgY29uc3RzKCdLRVlfVEFHX0VYUFJFU1NJT04nKSwgY29uc3RzKCdLRVlfVE9QSUNfT1JJR0lOJyldLFxyXG4gICgpID0+IF8uZGVmZXIoKCkgPT4ge1xyXG4gICAgbGV0IGJvb2ttYXJrID0gZGVjb2RlVVJJQ29tcG9uZW50KGRvY3VtZW50LmxvY2F0aW9uLmhhc2gpO1xyXG4gICAgaWYgKGJvb2ttYXJrICE9PSB1bmRlZmluZWQgJiYgYm9va21hcmsgIT09IFwiXCIgJiYgYm9va21hcmsgIT09IFwiI1wiKXtcclxuICAgICAgbGV0IGJvb2ttYXJrX25hbWUgPSAgZXNjYXBlKGJvb2ttYXJrLnN1YnN0cmluZygxKSk7XHJcbiAgICAgIGxldCAkZWxlbWVudHMgPSAocmgucXVlcnkoXCIjXCIgKyBib29rbWFya19uYW1lICsgXCIsYVtuYW1lPVwiICsgYm9va21hcmtfbmFtZSArXCJdXCIpKTtcclxuICAgICAgaWYoJGVsZW1lbnRzLmxlbmd0aCA+IDApe1xyXG4gICAgICAgICRlbGVtZW50c1swXS5zY3JvbGxJbnRvVmlldyh0cnVlKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0pXHJcbik7XHJcblxyXG5tb2RlbC5zdWJzY3JpYmUoY29uc3RzKCdLRVlfVE9QSUNfSEVJR0hUJyksICgpID0+IHtcclxuICBfLmRlbGF5KCgpID0+IHtcclxuICAgIG1vZGVsLnB1Ymxpc2goY29uc3RzKCdFVlRfV0lORE9XX0xPQURFRCcpLCBudWxsKVxyXG4gIH0sIDEwMDApXHJcblxyXG59KTtcclxuXHJcbm1vZGVsLnN1YnNjcmliZShbY29uc3RzKCdLRVlfVE9QSUNfSU5fSUZSQU1FJyksIGNvbnN0cygnS0VZX1RPUElDX09SSUdJTicpLCBjb25zdHMoJ0tFWV9UQUdfRVhQUkVTU0lPTicpXSwgKCkgPT4ge1xyXG4gIF8uZGVmZXIoKCkgPT5cclxuICB7XHJcbiAgICBsZXQgdGFnRXhwcnMgPSBtb2RlbC5nZXQoY29uc3RzKCdLRVlfVEFHX0VYUFJFU1NJT04nKSlcclxuICAgIGxldCBvcmlnaW4gPSBtb2RlbC5nZXQoY29uc3RzKCdLRVlfVE9QSUNfT1JJR0lOJykpO1xyXG4gICAgbGV0IGNUYWdOb2RlID0gJC5maW5kKGRvY3VtZW50LmhlYWQsICdtZXRhW25hbWU9XCJjb25kaXRpb24tdGFnc1wiXScpWzBdXHJcbiAgICBsZXQgbm9kZXMgPSAkLmZpbmQoZG9jdW1lbnQsICdbZGF0YS1yaHRhZ3NdJylcclxuICAgIGxldCBzaG93RGVmYXVsdFRleHQgPSB0cnVlXHJcbiAgICBfLmFueShub2Rlcywgbm9kZSA9PlxyXG4gICAge1xyXG4gICAgICBsZXQgdGFnSW5kZXggPSBOdW1iZXIucGFyc2VJbnQoJC5nZXRBdHRyaWJ1dGUobm9kZSwgJ2RhdGEtcmh0YWdzJykpXHJcbiAgICAgIGlmICghTnVtYmVyLmlzTmFOKHRhZ0luZGV4KSAmJiBfLmV2YWxUYWdFeHByZXNzaW9uKFt0YWdJbmRleF0sIHRhZ0V4cHJzLCBvcmlnaW4pKVxyXG4gICAgICB7XHJcbiAgICAgICAgc2hvd0RlZmF1bHRUZXh0ID0gZmFsc2VcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgfSlcclxuXHJcbiAgICBpZiAoY1RhZ05vZGUpXHJcbiAgICB7XHJcbiAgICAgIGxldCB0YWdJbmRleCA9IE51bWJlci5wYXJzZUludCgkLmdldEF0dHJpYnV0ZShjVGFnTm9kZSwgJ2RhdGEtcmh0YWdzJykpXHJcbiAgICAgIGlmICghTnVtYmVyLmlzTmFOKHRhZ0luZGV4KSlcclxuICAgICAge1xyXG4gICAgICAgIF8uc2hvd0RlZmF1bHRUZXh0KCFfLmV2YWxUYWdFeHByZXNzaW9uKFt0YWdJbmRleF0sIHRhZ0V4cHJzLCBvcmlnaW4pICYmIHNob3dEZWZhdWx0VGV4dCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9KVxyXG59KTtcclxuXHJcbl8uYWRkRXZlbnRMaXN0ZW5lcihkb2N1bWVudCwgJ0RPTUNvbnRlbnRMb2FkZWQnLCAoKSA9PiBtb2RlbC5wdWJsaXNoKGNvbnN0cygnRVZUX0lOU0lERV9JRlJBTUVfRE9NX0NPTlRFTlRMT0FERUQnKSwgbnVsbCkpO1xyXG5cclxuXy5hZGRFdmVudExpc3RlbmVyKHdpbmRvdywgJ3Jlc2l6ZScsICgoKCkgPT4ge1xyXG4gIGxldCB0cmlnZ2VyZWRCeU1lO1xyXG4gIHRyaWdnZXJlZEJ5TWUgPSBmYWxzZTtcclxuICByZXR1cm4gXy5kZWJvdW5jZSgoKSA9PiB7XHJcbiAgICBsZXQgaGVpZ2h0O1xyXG4gICAgaWYgKHRyaWdnZXJlZEJ5TWUpIHtcclxuICAgICAgdHJpZ2dlcmVkQnlNZSA9IGZhbHNlO1xyXG4gICAgICByZXR1cm4gdHJpZ2dlcmVkQnlNZTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGhlaWdodCA9ICQucGFnZUhlaWdodCgpO1xyXG4gICAgICBpZiAoaGVpZ2h0ICE9PSBtb2RlbC5nZXQoY29uc3RzKCdLRVlfVE9QSUNfSEVJR0hUJykpKSB7XHJcbiAgICAgICAgdHJpZ2dlcmVkQnlNZSA9IHRydWU7XHJcbiAgICAgICAgcmV0dXJuIG1vZGVsLnB1Ymxpc2goY29uc3RzKCdLRVlfVE9QSUNfSEVJR0hUJyksICQucGFnZUhlaWdodCgpKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0sIDI1MCk7XHJcbn0pKSgpKTtcclxuIiwibGV0IHJoID0gcmVxdWlyZShcIi4uLy4uLy4uL2xpYi9yaFwiKSxcclxuICAkID0gcmguJCxcclxuICBfID0gcmguX1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRHJvcGRvd25UZXh0IGV4dGVuZHMgcmguV2lkZ2V0IHtcclxuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcclxuICAgIHN1cGVyKGNvbmZpZylcclxuICAgIHRoaXMuY29udGVudENsYXNzID0gJ2Ryb3Bkb3duLWNvbnRlbnQnXHJcbiAgICB0aGlzLnRpdGxlQ2xhc3MgPSAnZHJvcGRvd24tdGl0bGUnXHJcbiAgICB0aGlzLmluaXROb2RlcygpXHJcbiAgfVxyXG5cclxuICBpbml0Tm9kZXMoKSB7XHJcbiAgICBsZXQgY29udGVudE5vZGVzID0gW11cclxuICAgICQuZWFjaENoaWxkTm9kZSh0aGlzLm5vZGUsIGNoaWxkID0+IHtcclxuICAgICAgaWYoJC5oYXNDbGFzcyhjaGlsZCwgdGhpcy5jb250ZW50Q2xhc3MpKSB7XHJcbiAgICAgICAgY29udGVudE5vZGVzLnB1c2goY2hpbGQpXHJcbiAgICAgIH1cclxuICAgIH0pXHJcbiAgICBsZXQgbm9kZUhvbGRlciA9IG5ldyByaC5Ob2RlSG9sZGVyKGNvbnRlbnROb2RlcylcclxuICAgIG5vZGVIb2xkZXIuaGlkZSgpXHJcbiAgICAkLmVhY2hDaGlsZE5vZGUodGhpcy5ub2RlLCBjaGlsZCA9PiB7XHJcbiAgICAgIGlmKCQuaGFzQ2xhc3MoY2hpbGQsIHRoaXMudGl0bGVDbGFzcykpIHtcclxuICAgICAgICBfLmFkZEV2ZW50TGlzdGVuZXIoY2hpbGQsICdjbGljaycsIGV2dCA9PiB7XHJcbiAgICAgICAgICBpZighZXZ0LmRlZmF1bHRQcmV2ZW50ZWQpIHtcclxuICAgICAgICAgICAgdGhpcy50b2dnbGVTdGF0ZShub2RlSG9sZGVyKVxyXG4gICAgICAgICAgICByZXR1cm4gXy5wcmV2ZW50RGVmYXVsdChldnQpXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuICAgICAgfVxyXG4gICAgfSlcclxuXHJcbiAgICByaC5tb2RlbC5jc3Vic2NyaWJlKCdFVlRfQ09MTEFQU0VfQUxMJywgKCkgPT4ge1xyXG4gICAgICB0aGlzLmhpZGUobm9kZUhvbGRlcilcclxuICAgIH0pXHJcblxyXG4gICAgcmgubW9kZWwuY3N1YnNjcmliZSgnRVZUX0VYUEFORF9BTEwnLCAoKSA9PiB7XHJcbiAgICAgIHRoaXMuc2hvdyhub2RlSG9sZGVyKVxyXG4gICAgfSlcclxuICB9XHJcblxyXG4gIGhpZGUobm9kZUhvbGRlcikge1xyXG4gICAgJC5yZW1vdmVDbGFzcyh0aGlzLm5vZGUsICdleHBhbmRlZCcpXHJcbiAgICBub2RlSG9sZGVyLmhpZGUoKVxyXG4gIH1cclxuXHJcbiAgc2hvdyhub2RlSG9sZGVyKSB7XHJcbiAgICBpZighJC5oYXNDbGFzcyh0aGlzLm5vZGUsICdleHBhbmRlZCcpKSB7XHJcbiAgICAgICQuYWRkQ2xhc3ModGhpcy5ub2RlLCAnZXhwYW5kZWQnKVxyXG4gICAgfVxyXG4gICAgbm9kZUhvbGRlci5zaG93KClcclxuICB9XHJcblxyXG4gIHRvZ2dsZVN0YXRlKG5vZGVIb2xkZXIpIHtcclxuICAgIGlmKCQuaGFzQ2xhc3ModGhpcy5ub2RlLCAnZXhwYW5kZWQnKSkge1xyXG4gICAgICB0aGlzLmhpZGUobm9kZUhvbGRlcilcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMuc2hvdyhub2RlSG9sZGVyKVxyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxucmgud2lkZ2V0cy5Ecm9wZG93blRleHQgPSBEcm9wZG93blRleHRcclxuIiwiaW1wb3J0IHJoIGZyb20gJy4uLy4uLy4uL2xpYi9yaCdcclxuaW1wb3J0IERyb3Bkb3duVGV4dCBmcm9tICcuL2Ryb3Bkb3duX3RleHQnXHJcblxyXG5jbGFzcyBFeHBhbmRpbmdUZXh0IGV4dGVuZHMgRHJvcGRvd25UZXh0IHtcclxuICBpbml0Tm9kZXMoKSB7XHJcbiAgICB0aGlzLmNvbnRlbnRDbGFzcyA9ICdleHBhbmRpbmctY29udGVudCdcclxuICAgIHRoaXMudGl0bGVDbGFzcyA9ICdleHBhbmRpbmctdGl0bGUnXHJcbiAgICBzdXBlci5pbml0Tm9kZXMoKVxyXG4gIH1cclxufVxyXG5cclxucmgud2lkZ2V0cy5FeHBhbmRpbmdUZXh0ID0gRXhwYW5kaW5nVGV4dFxyXG4iLCJsZXQgcmggPSByZXF1aXJlKFwiLi4vLi4vLi4vbGliL3JoXCIpLFxyXG4gIG5vZGVVdGlscyA9IHJlcXVpcmUoXCIuLi8uLi91dGlscy9ub2RlX3V0aWxzXCIpLFxyXG4gICQgPSByaC4kLFxyXG4gIF8gPSByaC5fLFxyXG4gIGluc3RhbmNlQ291bnQgPSAwXHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBIeXBlcmxpbmtQb3BvdmVyIGV4dGVuZHMgcmguV2lkZ2V0IHtcclxuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcclxuICAgIHN1cGVyKGNvbmZpZylcclxuICAgIGluc3RhbmNlQ291bnQgPSBpbnN0YW5jZUNvdW50ICsgMVxyXG4gICAgXy5hZGRFdmVudExpc3RlbmVyKHRoaXMubm9kZSwgJ2NsaWNrJywgZXZ0ID0+IHtcclxuICAgICAgdGhpcy5zaG93UG9wb3ZlcihldnQpXHJcbiAgICAgIHJldHVybiBfLnByZXZlbnREZWZhdWx0KGV2dClcclxuICAgIH0pXHJcblxyXG4gICAgcmgubW9kZWwuc3Vic2NyaWJlKHJoLmNvbnN0cygnS0VZX1RPUElDX0NPTlRFTlRfU0laRScpLCBzaXplID0+IHtcclxuICAgICAgaWYgKHRoaXMucG9wdXBOb2RlKSB7XHJcbiAgICAgICAgaWYgKHRoaXMubm9kZS5nZXRBdHRyaWJ1dGUoJ2RhdGEtd2lkdGgnKSAmJiB0aGlzLm5vZGUuZ2V0QXR0cmlidXRlKCdkYXRhLWhlaWdodCcpKSB7XHJcbiAgICAgICAgICAkLmRhdGFzZXQodGhpcy5wb3B1cE5vZGUsICdoZWlnaHQnLCAkLmRhdGFzZXQodGhpcy5ub2RlLCAnaGVpZ2h0JykpXHJcbiAgICAgICAgICAkLmRhdGFzZXQodGhpcy5wb3B1cE5vZGUsICd3aWR0aCcsICQuZGF0YXNldCh0aGlzLm5vZGUsICd3aWR0aCcpKVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgIGxldCB7IF9oZWlnaHQsIF93aWR0aCB9ID0gdGhpcy5yZVNpemUodGhpcy5wb3B1cE5vZGUsIHBhcnNlSW50KHNpemUuaGVpZ2h0KSwgcGFyc2VJbnQoc2l6ZS53aWR0aCkpXHJcbiAgICAgICAgICAkLmFkZFN0eWxlKHRoaXMucG9wdXBOb2RlLCAnd2lkdGgnLCBgJHtfd2lkdGh9cHhgKVxyXG4gICAgICAgICAgJC5hZGRTdHlsZSh0aGlzLnBvcHVwTm9kZSwgJ21heFdpZHRoICcsIGAke193aWR0aH1weGApXHJcbiAgICAgICAgICAkLmFkZFN0eWxlKHRoaXMucG9wdXBOb2RlLCAnaGVpZ2h0JywgYCR7X2hlaWdodH1weGApXHJcbiAgICAgICAgICAkLmFkZFN0eWxlKHRoaXMucG9wdXBOb2RlLCAnbWF4SGVpZ2h0JywgYCR7X2hlaWdodH1weGApXHJcbiAgICAgICAgICAkLmFkZFN0eWxlKHRoaXMucG9wdXBOb2RlLCAnbWFyZ2luJywgXCIxMHB4XCIpXHJcbiAgICAgICAgICBcclxuICAgICAgICAgICQuZGF0YXNldCh0aGlzLnBvcHVwTm9kZSwgJ2hlaWdodCcsIF9oZWlnaHQpXHJcbiAgICAgICAgICAkLmRhdGFzZXQodGhpcy5wb3B1cE5vZGUsICd3aWR0aCcsIF93aWR0aClcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFfLmlzRXh0ZXJuYWxVcmwodGhpcy5oeXBlcmxpbmspKSB7ICQuYWRkU3R5bGUodGhpcy5wb3B1cE5vZGUsICd2aXNpYmlsaXR5JywgJ3Zpc2libGUnKSB9XHJcbiAgICAgIH1cclxuICAgIH0pXHJcbiAgfVxyXG5cclxuICByZVNpemUobm9kZSwgaGVpZ2h0LCB3aWR0aCkge1xyXG4gICAgbGV0IGFyZWFcclxuICAgIGxldCByZXN1bHQgPSB7IF9oZWlnaHQ6IGhlaWdodCwgX3dpZHRoOiB3aWR0aCB9XHJcbiAgICBhcmVhID0gaGVpZ2h0ICogd2lkdGhcclxuICAgIHJlc3VsdC5fd2lkdGggPSBNYXRoLm1heChwYXJzZUludChub2RlLnN0eWxlLndpZHRoKSwgTWF0aC5zcXJ0KCg0ICogYXJlYSkgLyAzKSlcclxuICAgIHJlc3VsdC5faGVpZ2h0ID0gYXJlYSAvIHJlc3VsdC5fd2lkdGhcclxuXHJcbiAgICByZXR1cm4gcmVzdWx0XHJcbiAgfVxyXG5cclxuICBnZXQgaHlwZXJsaW5rKCkge1xyXG4gICAgcmV0dXJuICQuZ2V0QXR0cmlidXRlKHRoaXMubm9kZSwgJ2hyZWYnKVxyXG4gIH1cclxuXHJcbiAgZ2V0IGlmcmFtZUlEKCkge1xyXG4gICAgcmV0dXJuIGBSaFBvcG92ZXJJZnJhbWUke2luc3RhbmNlQ291bnR9YFxyXG4gIH1cclxuXHJcbiAgY3JlYXRlUG9wdXBOb2RlKCkge1xyXG4gICAgdGhpcy5wb3B1cE5vZGUgPSAkLmNyZWF0ZUVsZW1lbnQoJ2RpdicpXHJcbiAgICAkLmFkZENsYXNzKHRoaXMucG9wdXBOb2RlLCAncmgtcG9wb3ZlcicpXHJcbiAgICAkLmRhdGFzZXQodGhpcy5wb3B1cE5vZGUsICdoZWlnaHQnLCAkLmRhdGFzZXQodGhpcy5ub2RlLCAnaGVpZ2h0JykpXHJcbiAgICAkLmRhdGFzZXQodGhpcy5wb3B1cE5vZGUsICd3aWR0aCcsICQuZGF0YXNldCh0aGlzLm5vZGUsICd3aWR0aCcpKVxyXG4gICAgJC5kYXRhc2V0KHRoaXMucG9wdXBOb2RlLCAncGxhY2VtZW50JywgJC5kYXRhc2V0KHRoaXMubm9kZSwgJ3BsYWNlbWVudCcpKVxyXG4gICAgdGhpcy5wb3B1cE5vZGUuaW5uZXJIVE1MID0gYDxkaXYgY2xhc3M9XCJyaC1wb3BvdmVyLWNvbnRlbnRcIj5cclxuICAgICAgPGlmcmFtZSBjbGFzcz1cInBvcG92ZXItdG9waWNcIiBpZD1cIiR7dGhpcy5pZnJhbWVJRH1cIiBzcmM9XCIke3RoaXMuaHlwZXJsaW5rfVwiIGZyYW1lYm9yZGVyPVwiMFwiIHNjcm9sbGluZz1cImF1dG9cIlxyXG4gICAgICBvbmxvYWQ9XCJyaC5fLnJlc2V0SWZyYW1lU2l6ZSgnIyR7dGhpcy5pZnJhbWVJRH0nKVwiID48L2lmcmFtZT5cclxuICAgIDwvZGl2PmBcclxuICAgIGlmICghXy5pc0V4dGVybmFsVXJsKHRoaXMuaHlwZXJsaW5rKSkgeyAkLmFkZFN0eWxlKHRoaXMucG9wdXBOb2RlLCAndmlzaWJpbGl0eScsICdoaWRkZW4nKSB9XHJcblxyXG4gIH1cclxuXHJcblxyXG4gIHNob3dQb3BvdmVyKGV2dCkge1xyXG4gICAgdGhpcy5jcmVhdGVQb3B1cE5vZGUoKVxyXG4gICAgbm9kZVV0aWxzLmFwcGVuZENoaWxkKGRvY3VtZW50LmJvZHksIHRoaXMucG9wdXBOb2RlKTtcclxuICAgIHRoaXMucG9wb3ZlcldpZGdldCA9IG5ldyByaC53aWRnZXRzLlBvcG92ZXIoeyBub2RlOiB0aGlzLnBvcHVwTm9kZSB9KVxyXG4gICAgdGhpcy5wb3BvdmVyV2lkZ2V0LmluaXQoKVxyXG4gICAgdGhpcy5wb3BvdmVyV2lkZ2V0LmluaXRQb3NpdGlvbih0aGlzLm5vZGUsIGV2dClcclxuICB9XHJcbn1cclxuXHJcbnJoLndpZGdldHMuSHlwZXJsaW5rUG9wb3ZlciA9IEh5cGVybGlua1BvcG92ZXJcclxuIiwibGV0IHJoID0gcmVxdWlyZShcIi4uLy4uLy4uL2xpYi9yaFwiKSxcclxuICBub2RlVXRpbHMgPSByZXF1aXJlKFwiLi4vLi4vdXRpbHMvbm9kZV91dGlsc1wiKSxcclxuICBwYWdlVXRpbCA9IHJlcXVpcmUoXCIuLi8uLi91dGlscy9wYWdlX3V0aWxzXCIpLFxyXG4gIF8gPSByaC5fLFxyXG4gICQgPSByaC4kXHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQb3BvdmVyIGV4dGVuZHMgcmguV2lkZ2V0IHtcclxuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcclxuICAgIHN1cGVyKGNvbmZpZylcclxuICAgIHRoaXMucGxhY2VtZW50ID0gJC5kYXRhc2V0KHRoaXMubm9kZSwgJ3BsYWNlbWVudCcpXHJcbiAgICB0aGlzLmhlaWdodCA9IF8ucGFyc2VJbnQoJC5kYXRhc2V0KHRoaXMubm9kZSwgJ2hlaWdodCcpLCAzMDApXHJcbiAgICB0aGlzLndpZHRoID0gXy5wYXJzZUludCgkLmRhdGFzZXQodGhpcy5ub2RlLCAnd2lkdGgnKSwgNDAwKVxyXG4gICAgdGhpcy5kb05vdFJlc2l6ZSA9IGNvbmZpZyAmJiBjb25maWcuZG9Ob3RSZXNpemVcclxuXHJcbiAgICBfLmRlbGF5KCgpID0+IHtcclxuICAgICAgdGhpcy5oYW5kbGVDbGljayA9IGV2dCA9PiB0aGlzLl9oYW5kbGVDbGljayhldnQpXHJcbiAgICAgIF8uYWRkRXZlbnRMaXN0ZW5lcihkb2N1bWVudCwgJ2NsaWNrJywgdGhpcy5oYW5kbGVDbGljaylcclxuICAgIH0sIDI1MClcclxuICB9XHJcblxyXG4gIGRlc3RydWN0KCkge1xyXG4gICAgXy5yZW1vdmVFdmVudExpc3RlbmVyKGRvY3VtZW50LCAnY2xpY2snLCB0aGlzLmhhbmRsZUNsaWNrKVxyXG4gICAgc3VwZXIuZGVzdHJ1Y3QoKVxyXG4gICAgbm9kZVV0aWxzLnJlbW92ZUNoaWxkKHRoaXMubm9kZSlcclxuICB9XHJcblxyXG4gIGV2ZW50VG9SZWN0KGV2dCkge1xyXG4gICAgaWYoIWV2dCkge1xyXG4gICAgICByZXR1cm5cclxuICAgIH1cclxuICAgIGxldCBjbGllbnRYID0gZXZ0LmNsaWVudFggKyBfLmdldFNjcm9sbCgpWzBdLCBjbGllbnRZID0gZXZ0LmNsaWVudFkgKyBfLmdldFNjcm9sbCgpWzFdXHJcbiAgICBpZihjbGllbnRYICYmIGNsaWVudFkpIHtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICB4OiBjbGllbnRYLFxyXG4gICAgICAgIHk6IGNsaWVudFksXHJcbiAgICAgICAgdG9wOiBjbGllbnRZLFxyXG4gICAgICAgIGJvdHRvbTogY2xpZW50WSxcclxuICAgICAgICBsZWZ0OiBjbGllbnRYLFxyXG4gICAgICAgIHJpZ2h0OiBjbGllbnRYXHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIGluaXRQb3NpdGlvbih0YXJnZXQsIGV2dCkge1xyXG4gICAgbGV0IHJlY3QgPSB0aGlzLmV2ZW50VG9SZWN0KGV2dCkgfHwgdGFyZ2V0ICYmIHRhcmdldC5nZXRDbGllbnRSZWN0cygpWzBdXHJcbiAgICBpZihyZWN0KSB7XHJcbiAgICAgIHRoaXMuc2V0UG9zaXRpb24ocmVjdClcclxuICAgICAgaWYodGhpcy5kb05vdFJlc2l6ZSkge1xyXG4gICAgICAgIHJldHVyblxyXG4gICAgICB9XHJcblxyXG4gICAgICBpZih0aGlzLmhlaWdodCkge1xyXG4gICAgICAgIHRoaXMubm9kZS5zdHlsZS5oZWlnaHQgPSBgJHtfLm1pbihbdGhpcy5oZWlnaHQsIHBhZ2VVdGlsLmlubmVySGVpZ2h0KCldKX1weGBcclxuICAgICAgfVxyXG4gICAgICBpZih0aGlzLndpZHRoKSB7XHJcbiAgICAgICAgdGhpcy5ub2RlLnN0eWxlLndpZHRoID0gYCR7Xy5taW4oW3RoaXMud2lkdGgsIHBhZ2VVdGlsLmlubmVyV2lkdGgoKV0pfXB4YFxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuXHJcbiAgc2V0UG9zaXRpb24ocmVjdCkge1xyXG4gICAgbGV0IHBhZ2VIZWlnaHQgPSBwYWdlVXRpbC5wYWdlTWF4SGVpZ2h0KCksIHBhZ2VXaWR0aCA9IHBhZ2VVdGlsLnBhZ2VNYXhXaWR0aCgpXHJcbiAgICBpZih0aGlzLnBsYWNlbWVudCA9PT0gJ3RvcCcpIHtcclxuICAgICAgdGhpcy5zaG93VG9wKHJlY3QsIHBhZ2VIZWlnaHQpXHJcbiAgICAgIHRoaXMuc2V0QXV0b0hvcml6b250YWxQb3NpdGlvbihyZWN0LCBwYWdlV2lkdGgpXHJcbiAgICB9IGVsc2UgaWYodGhpcy5wbGFjZW1lbnQgPT09ICdib3R0b20nKSB7XHJcbiAgICAgIHRoaXMuc2hvd0JvdHRvbShyZWN0KVxyXG4gICAgICB0aGlzLnNldEF1dG9Ib3Jpem9udGFsUG9zaXRpb24ocmVjdCwgcGFnZVdpZHRoKVxyXG4gICAgfSBlbHNlIGlmKHRoaXMucGxhY2VtZW50ID09PSAnbGVmdCcpIHtcclxuICAgICAgdGhpcy5zZXRBdXRvVmVydGljYWxQb3NpdGlvbihyZWN0LCBwYWdlSGVpZ2h0KVxyXG4gICAgICB0aGlzLnNob3dMZWZ0KHJlY3QsIHBhZ2VXaWR0aClcclxuICAgIH0gZWxzZSBpZih0aGlzLnBsYWNlbWVudCA9PT0gJ3JpZ2h0Jykge1xyXG4gICAgICB0aGlzLnNldEF1dG9WZXJ0aWNhbFBvc2l0aW9uKHJlY3QsIHBhZ2VIZWlnaHQpXHJcbiAgICAgIHRoaXMuc2hvd1JpZ2h0KHJlY3QpXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLnNldEF1dG9Ib3Jpem9udGFsUG9zaXRpb24ocmVjdCwgcGFnZVdpZHRoKVxyXG4gICAgICB0aGlzLnNldEF1dG9WZXJ0aWNhbFBvc2l0aW9uKHJlY3QsIHBhZ2VIZWlnaHQpXHJcbiAgICB9XHJcbiAgICB0aGlzLm5vZGUuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnXHJcbiAgfVxyXG5cclxuICBjYW5TaG93VG9wKHJlY3QpIHtcclxuICAgIHJldHVybiAocmVjdC50b3AgLSBwYWdlVXRpbC5ub2RlSGVpZ2h0KHRoaXMubm9kZSkpID4gMFxyXG4gIH1cclxuXHJcbiAgY2FuU2hvd0JvdHRvbShyZWN0LCBwYWdlSGVpZ2h0KSB7XHJcbiAgICByZXR1cm4gKHBhZ2VIZWlnaHQgLSByZWN0LmJvdHRvbSAtIHBhZ2VVdGlsLm5vZGVIZWlnaHQodGhpcy5ub2RlKSkgPiAwXHJcbiAgfVxyXG5cclxuICBjYW5TaG93TGVmdChyZWN0KSB7XHJcbiAgICByZXR1cm4gKHJlY3QubGVmdCAtIHBhZ2VVdGlsLm5vZGVXaWR0aCh0aGlzLm5vZGUpKSA+IDBcclxuICB9XHJcblxyXG4gIGNhblNob3dSaWdodChyZWN0LCBwYWdlV2lkdGgpIHtcclxuICAgIHJldHVybiAocGFnZVdpZHRoIC0gcmVjdC5yaWdodCAtIHBhZ2VVdGlsLm5vZGVXaWR0aCh0aGlzLm5vZGUpKSA+IDBcclxuICB9XHJcblxyXG4gIHNob3dUb3AocmVjdCkge1xyXG4gICAgdGhpcy5ub2RlLnN0eWxlLnRvcCA9IGAke18ubWF4KFtyZWN0LnRvcCAtIHBhZ2VVdGlsLm5vZGVIZWlnaHQodGhpcy5ub2RlKSAtIDIsIDBdKX1weGBcclxuICB9XHJcblxyXG4gIHNob3dCb3R0b20ocmVjdCkge1xyXG4gICAgdGhpcy5ub2RlLnN0eWxlLnRvcCA9IGAke3JlY3QuYm90dG9tfXB4YFxyXG4gIH1cclxuXHJcbiAgc2hvd1JpZ2h0KHJlY3QpIHtcclxuICAgIHRoaXMubm9kZS5zdHlsZS5sZWZ0ID0gYCR7cmVjdC5yaWdodCArIDJ9cHhgXHJcbiAgfVxyXG5cclxuICBzaG93TGVmdChyZWN0KSB7XHJcbiAgICB0aGlzLm5vZGUuc3R5bGUubGVmdCA9IGAke18ubWF4KFtyZWN0LnJpZ2h0IC0gcGFnZVV0aWwubm9kZVdpZHRoKHRoaXMubm9kZSkgLSAyLCAwXSl9cHhgXHJcbiAgfVxyXG5cclxuICBzZXRBdXRvSG9yaXpvbnRhbFBvc2l0aW9uKHJlY3QsIHBhZ2VXaWR0aCkge1xyXG4gICAgaWYodGhpcy5jYW5TaG93UmlnaHQocmVjdCwgcGFnZVdpZHRoKSkge1xyXG4gICAgICB0aGlzLnNob3dSaWdodChyZWN0KVxyXG4gICAgfSBlbHNlIGlmKHRoaXMuY2FuU2hvd0xlZnQocmVjdCkpIHtcclxuICAgICAgdGhpcy5zaG93TGVmdChyZWN0LCBwYWdlV2lkdGgpXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLm5vZGUuc3R5bGUubGVmdCA9IGAke3JlY3QubGVmdH1weGBcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHNldEF1dG9WZXJ0aWNhbFBvc2l0aW9uKHJlY3QsIHBhZ2VIZWlnaHQpIHtcclxuICAgIGlmKHRoaXMuY2FuU2hvd0JvdHRvbShyZWN0LCBwYWdlSGVpZ2h0KSkge1xyXG4gICAgICB0aGlzLnNob3dCb3R0b20ocmVjdClcclxuICAgIH0gZWxzZSBpZih0aGlzLmNhblNob3dUb3AocmVjdCkpIHtcclxuICAgICAgdGhpcy5zaG93VG9wKHJlY3QsIHBhZ2VIZWlnaHQpXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLm5vZGUuc3R5bGUudG9wID0gYCR7cmVjdC50b3B9cHhgXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBfaGFuZGxlQ2xpY2soZXZ0KSB7XHJcbiAgICB0aGlzLmRlc3RydWN0KClcclxuICAgIHJldHVybiBfLnByZXZlbnREZWZhdWx0KGV2dClcclxuICB9XHJcbn1cclxuXHJcbnJoLndpZGdldHMuUG9wb3ZlciA9IFBvcG92ZXJcclxuIiwibGV0IHJoID0gcmVxdWlyZShcIi4uLy4uLy4uL2xpYi9yaFwiKSxcclxuICBub2RlVXRpbHMgPSByZXF1aXJlKFwiLi4vLi4vdXRpbHMvbm9kZV91dGlsc1wiKSxcclxuICAkID0gcmguJCxcclxuICBfID0gcmguXyxcclxuICBpbnN0YW5jZUNvdW50ID0gMFxyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGV4dFBvcE92ZXIgZXh0ZW5kcyByaC5XaWRnZXQge1xyXG4gIGNvbnN0cnVjdG9yKGNvbmZpZykge1xyXG4gICAgc3VwZXIoY29uZmlnKVxyXG4gICAgaW5zdGFuY2VDb3VudCA9IGluc3RhbmNlQ291bnQgKyAxXHJcbiAgICBfLmFkZEV2ZW50TGlzdGVuZXIodGhpcy5ub2RlLCAnY2xpY2snLCBldnQgPT4ge1xyXG4gICAgICB0aGlzLnNob3dQb3BvdmVyKGV2dClcclxuICAgICAgcmV0dXJuIF8ucHJldmVudERlZmF1bHQoZXZ0KVxyXG4gICAgfSlcclxuICB9XHJcblxyXG4gIGdldCB0ZXh0KCkge1xyXG4gICAgcmV0dXJuICQuZGF0YXNldCh0aGlzLm5vZGUsICdwb3BvdmVydGV4dCcpXHJcbiAgfVxyXG5cclxuICBnZXQgY29udGVudElEKCkge1xyXG4gICAgcmV0dXJuIGBSaC10ZXh0UG9wT3ZlciR7aW5zdGFuY2VDb3VudH1gXHJcbiAgfVxyXG5cclxuICBjcmVhdGVQb3B1cE5vZGUoKSB7XHJcbiAgICBsZXQgbm9kZSA9ICQuY3JlYXRlRWxlbWVudCgnZGl2JylcclxuICAgICQuYWRkQ2xhc3Mobm9kZSwgJ3JoLXBvcG92ZXInKVxyXG4gICAgJC5kYXRhc2V0KG5vZGUsICdoZWlnaHQnLCAkLmRhdGFzZXQodGhpcy5ub2RlLCAnaGVpZ2h0JykpXHJcbiAgICAkLmRhdGFzZXQobm9kZSwgJ3dpZHRoJywgJC5kYXRhc2V0KHRoaXMubm9kZSwgJ3dpZHRoJykpXHJcbiAgICAkLmRhdGFzZXQobm9kZSwgJ3BsYWNlbWVudCcsICQuZGF0YXNldCh0aGlzLm5vZGUsICdwbGFjZW1lbnQnKSlcclxuXHJcbiAgICBub2RlLmlubmVySFRNTCA9IGA8ZGl2IGNsYXNzPVwicmgtcG9wb3Zlci1jb250ZW50XCI+XHJcbiAgICAgIDxwIGNsYXNzPVwicG9wb3Zlci10ZXh0XCIgaWQ9XCIke3RoaXMuY29udGVudElEfVwiPiR7dGhpcy50ZXh0fTwvcD5cclxuICAgIDwvZGl2PmBcclxuICAgIHJldHVybiBub2RlXHJcbiAgfVxyXG5cclxuICBzaG93UG9wb3ZlcihldnQpIHtcclxuICAgIGxldCBub2RlID0gdGhpcy5jcmVhdGVQb3B1cE5vZGUoKVxyXG4gICAgbm9kZVV0aWxzLmFwcGVuZENoaWxkKGRvY3VtZW50LmJvZHksIG5vZGUpO1xyXG4gICAgdGhpcy5wb3BvdmVyV2lkZ2V0ID0gbmV3IHJoLndpZGdldHMuUG9wb3Zlcih7bm9kZTogbm9kZSwgZG9Ob3RSZXNpemU6IHRydWV9KVxyXG4gICAgdGhpcy5wb3BvdmVyV2lkZ2V0LmluaXQoKVxyXG4gICAgdGhpcy5wb3BvdmVyV2lkZ2V0LmluaXRQb3NpdGlvbih0aGlzLm5vZGUsIGV2dClcclxuICB9XHJcbn1cclxuXHJcbnJoLndpZGdldHMuVGV4dFBvcE92ZXIgPSBUZXh0UG9wT3ZlclxyXG5cclxuLyo8YSBkYXRhLXJod2lkZ2V0PVwiVGV4dFBvcE92ZXJcIiBkYXRhLXBvcG92ZXJ0ZXh0PVwidGhpcyBpcyBkZWZpbml0aW9uXCIgaHJlZj1cIiNcIj4gdGVybSA8L2E+ICovXHJcbiIsImxldCByaCA9IHJlcXVpcmUoXCIuLi8uLi8uLi9saWIvcmhcIiksXHJcbiAgJCA9IHJoLiQsXHJcbiAgXyA9IHJoLl9cclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRyaWdnZXIgZXh0ZW5kcyByaC5XaWRnZXQge1xyXG4gIGNvbnN0cnVjdG9yKGNvbmZpZykge1xyXG4gICAgc3VwZXIoY29uZmlnKVxyXG4gICAgdGhpcy5pbml0VGFyZ2V0cygpXHJcbiAgICB0aGlzLnVwZGF0ZVRyaWdnZXJMYWJlbHMoKVxyXG4gIH1cclxuXHJcbiAgaW5pdEV4cGFuZGVkKG5vZGVIb2xkZXIpIHtcclxuICAgIGxldCBpc0V4cGFuZGVkID0gJC5nZXRBdHRyaWJ1dGUodGhpcy5ub2RlLCAnZGF0YS1leHBhbmRlZCcpXHJcbiAgICBpZihpc0V4cGFuZGVkID09PSAndHJ1ZScpIHtcclxuICAgICAgdGhpcy5zaG93KG5vZGVIb2xkZXIpXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLmhpZGUobm9kZUhvbGRlcilcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHVwZGF0ZVRyaWdnZXJMYWJlbHMoKSB7XHJcbiAgICBsZXQgcHJlc3NlZCA9ICQuaGFzQ2xhc3ModGhpcy5ub2RlLCAncHJlc3NlZCcpXHJcbiAgICBsZXQgb3BlblRleHQgPSAkLmZpbmQodGhpcy5ub2RlLCBgc3BhbltkYXRhLW9wZW4tdGV4dF1gKVswXVxyXG4gICAgbGV0IGNsb3NlVGV4dCA9ICQuZmluZCh0aGlzLm5vZGUsIGBzcGFuW2RhdGEtY2xvc2UtdGV4dF1gKVswXVxyXG4gICAgdGhpcy5zaG93VHJpZ2dlckxhYmVsKG9wZW5UZXh0LCBwcmVzc2VkKVxyXG4gICAgdGhpcy5zaG93VHJpZ2dlckxhYmVsKGNsb3NlVGV4dCwgIXByZXNzZWQpXHJcbiAgfVxyXG5cclxuICBzaG93VHJpZ2dlckxhYmVsKHRleHQsIHNob3cpIHtcclxuICAgIGlmKHRleHQpIHtcclxuICAgICAgbGV0IHRleHRIb2xkZXIgPSBuZXcgcmguTm9kZUhvbGRlcihbdGV4dF0pXHJcbiAgICAgIHJldHVybiBzaG93ID8gdGV4dEhvbGRlci5zaG93KCkgOiB0ZXh0SG9sZGVyLmhpZGUoKVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZ2V0VGFyZ2V0Tm9kZXMoKSB7XHJcbiAgICBsZXQgdGFyZ2V0TmFtZXMgPSBfLnNwbGl0QW5kVHJpbSgkLmRhdGFzZXQodGhpcy5ub2RlLCAndGFyZ2V0JyksICcgJylcclxuICAgIGxldCB0YXJnZXROb2RlcyA9IFtdXHJcbiAgICBfLmVhY2godGFyZ2V0TmFtZXMsIHRhcmdldE5hbWUgPT4ge1xyXG4gICAgICBsZXQgbm9kZXMgPSAkLmZpbmQoZG9jdW1lbnQsIGBbZGF0YS10YXJnZXRuYW1lPVwiJHt0YXJnZXROYW1lfVwiXWApXHJcbiAgICAgIF8uZWFjaChub2Rlcywgbm9kZSA9PiB7XHJcbiAgICAgICAgdGFyZ2V0Tm9kZXMucHVzaChub2RlKVxyXG4gICAgICB9KVxyXG4gICAgfSlcclxuICAgIHJldHVybiB0YXJnZXROb2Rlc1xyXG4gIH1cclxuXHJcbiAgaW5pdFRhcmdldHMoKSAge1xyXG4gICAgbGV0IHRhcmdldE5vZGVzID0gdGhpcy5nZXRUYXJnZXROb2RlcygpXHJcbiAgICBfLmVhY2godGFyZ2V0Tm9kZXMsIG5vZGUgPT4ge1xyXG4gICAgICBpZighJC5kYXRhc2V0KG5vZGUsICd0YXJnZXRzZXQnKSkge1xyXG4gICAgICAgICQuZGF0YXNldChub2RlLCAndGFyZ2V0c2V0JywgdHJ1ZSlcclxuICAgICAgfVxyXG4gICAgfSlcclxuICAgIGxldCBub2RlSG9sZGVyID0gbmV3IHJoLk5vZGVIb2xkZXIodGFyZ2V0Tm9kZXMpXHJcbiAgICBub2RlSG9sZGVyLmhpZGUoKVxyXG4gICAgXy5hZGRFdmVudExpc3RlbmVyKHRoaXMubm9kZSwgJ2NsaWNrJywgZXZ0ID0+IHtcclxuICAgICAgaWYoIWV2dC5kZWZhdWx0UHJldmVudGVkKSB7XHJcbiAgICAgICAgdGhpcy50b2dnbGVTdGF0ZShub2RlSG9sZGVyKVxyXG4gICAgICAgIHJldHVybiBfLnByZXZlbnREZWZhdWx0KGV2dClcclxuICAgICAgfVxyXG4gICAgfSlcclxuICAgIF8uYWRkRXZlbnRMaXN0ZW5lcih0aGlzLm5vZGUsICdvcGVuJywgZXZ0ID0+e1xyXG4gICAgICBpZiAoIWV2dC5kZWZhdWx0UHJldmVudGVkKVxyXG4gICAgICB7XHJcbiAgICAgICAgaWYgKCEkLmhhc0NsYXNzKHRoaXMubm9kZSwgJ3ByZXNzZWQnKSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICB0aGlzLnNob3cobm9kZUhvbGRlcilcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIF8ucHJldmVudERlZmF1bHQoZXZ0KVxyXG4gICAgICB9XHJcbiAgICB9KVxyXG4gICAgcmgubW9kZWwuY3N1YnNjcmliZSgnRVZUX0NPTExBUFNFX0FMTCcsICgpID0+IHtcclxuICAgICAgdGhpcy5oaWRlKG5vZGVIb2xkZXIpXHJcbiAgICB9KVxyXG5cclxuICAgIHJoLm1vZGVsLmNzdWJzY3JpYmUoJ0VWVF9FWFBBTkRfQUxMJywgKCkgPT4ge1xyXG4gICAgICB0aGlzLnNob3cobm9kZUhvbGRlcilcclxuICAgIH0pXHJcbiAgICB0aGlzLmluaXRFeHBhbmRlZChub2RlSG9sZGVyKVxyXG4gIH1cclxuXHJcbiAgaGlkZShub2RlSG9sZGVyKSB7XHJcbiAgICAkLnJlbW92ZUNsYXNzKHRoaXMubm9kZSwgJ3ByZXNzZWQnKVxyXG4gICAgbm9kZUhvbGRlci5oaWRlKClcclxuICAgIG5vZGVIb2xkZXIudXBkYXRlQ2xhc3MoW10pXHJcbiAgICB0aGlzLnVwZGF0ZVRyaWdnZXJMYWJlbHMoKVxyXG4gIH1cclxuXHJcbiAgc2hvdyhub2RlSG9sZGVyKSB7XHJcbiAgICBpZighJC5oYXNDbGFzcyh0aGlzLm5vZGUsICdwcmVzc2VkJykpIHtcclxuICAgICAgJC5hZGRDbGFzcyh0aGlzLm5vZGUsICdwcmVzc2VkJylcclxuICAgIH1cclxuICAgIG5vZGVIb2xkZXIuc2hvdygpXHJcbiAgICBub2RlSG9sZGVyLnVwZGF0ZUNsYXNzKFsnc2hvdyddKVxyXG4gICAgdGhpcy51cGRhdGVUcmlnZ2VyTGFiZWxzKClcclxuICB9XHJcblxyXG4gIHRvZ2dsZVN0YXRlKG5vZGVIb2xkZXIpIHtcclxuICAgIGlmKCQuaGFzQ2xhc3ModGhpcy5ub2RlLCAncHJlc3NlZCcpKSB7XHJcbiAgICAgIHRoaXMuaGlkZShub2RlSG9sZGVyKVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5zaG93KG5vZGVIb2xkZXIpXHJcbiAgICB9XHJcbiAgICB0aGlzLnVwZGF0ZVRyaWdnZXJMYWJlbHMoKVxyXG4gIH1cclxufVxyXG5cclxucmgud2lkZ2V0cy5UcmlnZ2VyID0gVHJpZ2dlclxyXG5yaC53aWRnZXRzLkRyb3BTcG90ID0gVHJpZ2dlclxyXG5yaC53aWRnZXRzLkV4cGFuZFNwb3QgPSBUcmlnZ2VyXHJcbiIsImxldCByaCA9IHJlcXVpcmUoXCIuLi8uLi9saWIvcmhcIilcclxubGV0ICQgPSByaC4kXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG5cclxuICBub2RlVHlwZToge1xyXG4gICAgRUxFTUVOVF9OT0RFOiAxLFxyXG4gICAgQVRUUklCVVRFX05PREU6IDIsXHJcbiAgICBURVhUX05PREU6IDMsXHJcbiAgICBDREFUQV9TRUNUSU9OX05PREU6IDQsXHJcbiAgICBFTlRJVFlfUkVGRVJFTkNFX05PREU6IDUsXHJcbiAgICBFTlRJVFlfTk9ERTogNixcclxuICAgIFBST0NFU1NJTkdfSU5TVFJVQ1RJT05fTk9ERTogNyxcclxuICAgIENPTU1FTlRfTk9ERTogOCxcclxuICAgIERPQ1VNRU5UX05PREU6IDksXHJcbiAgICBET0NVTUVOVF9UWVBFX05PREU6IDEwLFxyXG4gICAgRE9DVU1FTlRfRlJBR01FTlRfTk9ERTogMTEsXHJcbiAgICBOT1RBVElPTl9OT0RFOiAxMlxyXG4gIH0sXHJcblxyXG4gIHJlbW92ZUNoaWxkKG5vZGUsIHBhcmVudCA9IHRoaXMucGFyZW50Tm9kZShub2RlKSkge1xyXG4gICAgcmV0dXJuIHBhcmVudCAmJiBwYXJlbnQucmVtb3ZlQ2hpbGQgJiYgcGFyZW50LnJlbW92ZUNoaWxkKG5vZGUpXHJcbiAgfSxcclxuICBhcHBlbmRDaGlsZChwYXJlbnQsIG5ld05vZGUpIHtcclxuICAgIHJldHVybiBwYXJlbnQgJiYgcGFyZW50LmFwcGVuZENoaWxkICYmIHBhcmVudC5hcHBlbmRDaGlsZChuZXdOb2RlKVxyXG4gIH0sXHJcbiAgcGFyZW50Tm9kZShub2RlKSB7XHJcbiAgICByZXR1cm4gbm9kZSAmJiBub2RlLnBhcmVudE5vZGVcclxuICB9LFxyXG4gIGNoaWxkTm9kZXMobm9kZSkge1xyXG4gICAgcmV0dXJuIG5vZGUgJiYgbm9kZS5jaGlsZE5vZGVzIHx8IFtdXHJcbiAgfSxcclxuICB0b0h0bWxOb2RlKGh0bWwpIHtcclxuICAgIHJldHVybiB0aGlzLmNoaWxkTm9kZXMoJC5jcmVhdGVFbGVtZW50KCdkaXYnLCBodG1sKSlcclxuICB9LFxyXG4gIG91dGVySFRNTChub2RlKSB7XHJcbiAgICByZXR1cm4gbm9kZSAmJiBub2RlLm91dGVySFRNTCB8fCAnJ1xyXG4gIH0sXHJcbiAgaW5zZXJ0QWZ0ZXIobm9kZSwgbmV3Tm9kZSl7XHJcbiAgICByZXR1cm4gbm9kZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZShuZXdOb2RlLCBub2RlLm5leHRTaWJsaW5nKVxyXG4gIH0sXHJcbiAgdmFsdWUobm9kZSkge1xyXG4gICAgcmV0dXJuIG5vZGUgJiYgbm9kZS5ub2RlVmFsdWVcclxuICB9LFxyXG4gIG5hbWUobm9kZSkge1xyXG4gICAgcmV0dXJuIG5vZGUgJiYgbm9kZS5ub2RlTmFtZVxyXG4gIH0sXHJcbiAgdHlwZShub2RlKSB7XHJcbiAgICByZXR1cm4gbm9kZSAmJiBub2RlLm5vZGVUeXBlXHJcbiAgfSxcclxuICBpc0VsZW1lbnROb2RlKG5vZGUpIHtcclxuICAgIHJldHVybiB0aGlzLnR5cGUobm9kZSkgPT09IHRoaXMubm9kZVR5cGUuRUxFTUVOVF9OT0RFXHJcbiAgfSxcclxuICBpc1RleHROb2RlKG5vZGUpIHtcclxuICAgIHJldHVybiB0aGlzLnR5cGUobm9kZSkgPT09IHRoaXMubm9kZVR5cGUuVEVYVF9OT0RFXHJcbiAgfVxyXG59IiwibGV0IHJoID0gcmVxdWlyZShcIi4uLy4uL2xpYi9yaFwiKSxcclxuICBfID0gcmguX1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgaW5uZXJXaWR0aCgpIHtcclxuICAgIGxldCBpbm5lcldpZHRoID0gZ2xvYmFsLmlubmVyV2lkdGhcclxuICAgIGlmKCFfLmlzRGVmaW5lZChpbm5lcldpZHRoKSkge1xyXG4gICAgICBsZXQgY2xpZW50V2lkdGggPSBfLmdldChkb2N1bWVudCwgJ2RvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aCcpXHJcbiAgICAgIGNsaWVudFdpZHRoID0gXy5pc0RlZmluZWQoY2xpZW50V2lkdGgpID8gY2xpZW50V2lkdGggOiBfLmdldChkb2N1bWVudCwgJ2JvZHkuY2xpZW50V2lkdGgnKVxyXG4gICAgICBpZihfLmlzRGVmaW5lZChjbGllbnRXaWR0aCkpIHtcclxuICAgICAgICBpbm5lcldpZHRoID0gY2xpZW50V2lkdGhcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGlubmVyV2lkdGhcclxuICAgIFxyXG4gIH0sXHJcbiAgaW5uZXJIZWlnaHQoKSB7XHJcbiAgICBsZXQgaW5uZXJIZWlnaHQgPSBnbG9iYWwuaW5uZXJIZWlnaHRcclxuICAgIGlmKCFfLmlzRGVmaW5lZChpbm5lckhlaWdodCkpIHtcclxuICAgICAgbGV0IGNsaWVudEhlaWdodCA9IF8uZ2V0KGRvY3VtZW50LCAnZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCcpXHJcbiAgICAgIGNsaWVudEhlaWdodCA9IF8uaXNEZWZpbmVkKGNsaWVudEhlaWdodCkgPyBjbGllbnRIZWlnaHQgOiBfLmdldChkb2N1bWVudCwgJ2JvZHkuY2xpZW50SGVpZ2h0JylcclxuICAgICAgaWYoXy5pc0RlZmluZWQoY2xpZW50SGVpZ2h0KSkge1xyXG4gICAgICAgIGlubmVySGVpZ2h0ID0gY2xpZW50SGVpZ2h0XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBpbm5lckhlaWdodFxyXG4gIH0sXHJcbiAgbm9kZVdpZHRoKG5vZGUpIHtcclxuICAgIGxldCB3aWR0aCA9IG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0ICYmIG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGhcclxuICAgIHJldHVybiB3aWR0aCB8fCBub2RlLmNsaWVudFdpZHRoIHx8IDBcclxuICB9LFxyXG4gIG5vZGVIZWlnaHQobm9kZSkge1xyXG4gICAgbGV0IGhlaWdodCA9IG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0ICYmIG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0XHJcbiAgICByZXR1cm4gaGVpZ2h0IHx8IG5vZGUuY2xpZW50SGVpZ2h0IHx8IDBcclxuICB9LFxyXG4gIHBhZ2VNYXhIZWlnaHQoKSB7XHJcbiAgICBpZiAoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICYmIHdpbmRvdy5pbm5lckhlaWdodCkge1xyXG4gICAgICByZXR1cm4gXy5tYXgoW2RvY3VtZW50LmRvY3VtZW50RWxlbWVudC5vZmZzZXRIZWlnaHQsIHdpbmRvdy5pbm5lckhlaWdodF0pXHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpIHtcclxuICAgICAgcmV0dXJuIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5vZmZzZXRIZWlnaHRcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICByZXR1cm4gd2luZG93LmlubmVySGVpZ2h0XHJcbiAgICB9XHJcbiAgfSxcclxuICBwYWdlTWF4V2lkdGgoKSB7XHJcbiAgICBpZiAoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICYmIHdpbmRvdy5pbm5lcldpZHRoKSB7XHJcbiAgICAgIHJldHVybiBfLm1heChbZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50Lm9mZnNldFdpZHRoLCB3aW5kb3cuaW5uZXJXaWR0aF0pXHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpIHtcclxuICAgICAgcmV0dXJuIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5vZmZzZXRXaWR0aFxyXG4gICAgfVxyXG4gICAgZWxzZSB7IFxyXG4gICAgICByZXR1cm4gd2luZG93LmlubmVyV2lkdGhcclxuICAgIH1cclxuICB9XHJcblxyXG59XHJcbiJdfQ==
