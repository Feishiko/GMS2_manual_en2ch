(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
'use strict';

var _window = window,
    rh = _window.rh;
var _ = rh._;
var $ = rh.$;
var consts = rh.consts;
var model = rh.model;


var HASH_KEY_RH_SEARCH = consts('HASH_KEY_RH_SEARCH');
var HASH_KEY_TOPIC = consts('HASH_KEY_TOPIC');
var HASH_KEY_UIMODE = consts('HASH_KEY_UIMODE');
var HASH_KEY_RH_TOCID = consts('HASH_KEY_RH_TOCID');
var HASH_KEY_RH_HIGHLIGHT = consts('HASH_KEY_RH_HIGHLIGHT');
var HASH_KEY_RANDOM = consts('HASH_KEY_RANDOM');
var hashQueryKeys = [HASH_KEY_RH_HIGHLIGHT, consts('HASH_KEY_RH_SYNS'), HASH_KEY_RH_TOCID];

// Helper methods
var getMergedParamsMap = function getMergedParamsMap(topicUrl) {
  var paramsMap = _.urlParams(_.extractParamString(topicUrl));
  var hashMap = _.hashParams(_.extractHashString(topicUrl));
  return _.extend(paramsMap, hashMap);
};

var getTopicURL = function getTopicURL(newMap, topicUrl) {
  topicUrl = topicUrl;
  var filePath = _.filePath(topicUrl);
  var bookMark = _.extractHashString(topicUrl);
  if (bookMark.length > 0) {
    bookMark = '#' + bookMark;
  }

  var paramsMap = _.urlParams(_.extractParamString(topicUrl));
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = Array.from(hashQueryKeys)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var key = _step.value;
      if (newMap[key] != null) {
        paramsMap[key] = newMap[key];
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  if (model.get(consts('KEY_SCREEN_IOS'))) {
    paramsMap[HASH_KEY_RANDOM] = _.uniqueId();
  }
  var params = _.mapToEncodedString(paramsMap);
  if (params.length > 0) {
    params = '?' + params;
  }

  return '' + filePath + params + bookMark;
};

var queueUpdateHashMap = _.queueUpdateHashMap;


var fixHashMapForTopic = function fixHashMapForTopic(hashMap) {
  if (hashMap == null) {
    hashMap = {};
  }
  hashMap[HASH_KEY_UIMODE] = null;
  hashMap[HASH_KEY_RANDOM] = null;
  if (!hashMap[HASH_KEY_RH_TOCID]) {
    hashMap[HASH_KEY_RH_TOCID] = null;
  }
  if (!hashMap[HASH_KEY_RH_HIGHLIGHT]) {
    hashMap[HASH_KEY_RH_HIGHLIGHT] = null;
  }
  return hashMap;
};

var showTopic = function showTopic(relUrl, addToHistory) {
  relUrl = _.fixRelativeUrl(relUrl);
  var hashMap = _.urlParams(_.extractParamString(relUrl));
  hashMap[HASH_KEY_TOPIC] = _.stripParam(relUrl);
  hashMap = fixHashMapForTopic(hashMap);
  return queueUpdateHashMap(hashMap, addToHistory);
};

var showNonTopic = function showNonTopic(url, addToHistory) {
  var hashMap = {};
  hashMap[HASH_KEY_TOPIC] = url;
  hashMap = fixHashMapForTopic(hashMap);
  return queueUpdateHashMap(hashMap, addToHistory);
};

({
  isSameTopic: function isSameTopic(url1, url2) {}
});

//Event Handlers

var hashChanged = function hashChanged(obj) {
  var searchTermChanged = void 0;
  var newMap = obj.newMap;
  var oldMap = obj.oldMap;

  var oldUiMode = oldMap[HASH_KEY_UIMODE];
  var uiMode = newMap[HASH_KEY_UIMODE];

  return _.getDefaultTopic(function (defaultTopic) {
    if (HASH_KEY_RH_SEARCH in newMap) {
      var searchTerm = newMap[HASH_KEY_RH_SEARCH];
      searchTermChanged = searchTerm !== model.get(consts('KEY_SEARCHED_TERM'));
      model.publish(consts('KEY_SEARCH_TERM'), searchTerm, { sync: true });
    }

    if (uiMode === 'search') {
      if (searchTermChanged && window.gHost) {
        model.publish(consts('EVT_QUERY_SEARCH_RESULTS'), true);
      }
    }

    if (!uiMode || newMap[HASH_KEY_TOPIC]) {
      var topicUrl = void 0;
      var oldTopicUrl = model.get(consts('KEY_TOPIC_IN_IFRAME'));
      if (HASH_KEY_TOPIC in newMap) {
        topicUrl = newMap[HASH_KEY_TOPIC];
      }
      if (!topicUrl) {
        topicUrl = oldTopicUrl;
      }
      var feature = rh.model.get(rh.consts('KEY_FEATURE'));

      if (!topicUrl && (!feature || feature.showDefTopic !== false)) {
        topicUrl = defaultTopic;
      }
      var changed = topicUrl && (topicUrl !== oldTopicUrl || oldUiMode !== uiMode || oldMap[HASH_KEY_RH_HIGHLIGHT] !== newMap[HASH_KEY_RH_HIGHLIGHT] || oldMap[HASH_KEY_RH_TOCID] !== newMap[HASH_KEY_RH_TOCID]);
      if (changed) {
        if (_.stripBookmark(topicUrl) !== _.stripBookmark(oldTopicUrl)) {
          _.runTopicLoadingAnimation(true);
        }
        model.publish(consts('KEY_TOPIC_IN_IFRAME'), topicUrl);
        window.loadTopic(getTopicURL(newMap, topicUrl));
      }
    }

    return model.publish(consts('KEY_UI_MODE'), newMap[HASH_KEY_UIMODE]);
  });
};

var topicChanged = function topicChanged(topicUrl) {
  var hashMap = _.hashParams();
  if (topicUrl && !hashMap[HASH_KEY_UIMODE]) {
    var decodedURI = decodeURI(document.location.href);
    var relUrl = window._getRelativeFileName(decodedURI, topicUrl);
    var oldUrl = hashMap[HASH_KEY_TOPIC];
    if (!oldUrl || _.filePath(relUrl) !== _.filePath(oldUrl)) {
      model.publish(consts('KEY_TOPIC_IN_IFRAME'), relUrl);
      return showTopic(relUrl, false);
    }
  }
};

var splitParams = function splitParams(params) {
  var queryParams = {};
  var queryParamList = [consts("RHMAPID"), consts("RHMAPNO"), consts("RHWINDOW"), consts("RHCSHMODE")];
  _.each(params, function (value, key) {
    if (queryParamList.includes(key)) {
      queryParams[key] = value;
      delete params[key];
    }
  });

  return { queryParams: queryParams, hashParams: params };
};
var navigateToUrl = function navigateToUrl(obj) {
  var url = obj.absUrl;
  if (_.isRootUrl()) {
    if (_.isUrlAllowdInIframe(url)) {
      url = _.makeRelativeUrl(_.fixRelativeUrl(url));
      if (_.isHomeUrl(url)) {
        return document.location.href = url;
      }
      var fileName = url && _.filePath(url);
      if (fileName === consts('START_FILEPATH')) {
        url = url.substring(fileName.length); //never pass start file inside iframe
      } else if (!url) {
        url = '#ux';
      }

      if (url[0] === '#' || url[0] === '?') {
        var hashMap = _.hashParams(_.extractHashString(url));
        if (!(HASH_KEY_UIMODE in hashMap)) {
          hashMap[HASH_KEY_UIMODE] = null;
        }
        return queueUpdateHashMap(hashMap, true);
      } else if (url) {
        return showTopic(url, true);
      }
    } else {
      return showNonTopic(url, true);
    }
  } else {
    if (!_.isRootUrl(url)) {
      var params = void 0,
          relUrl = void 0;
      var rootUrl = _.getRootUrl();
      if (_.isExternalUrl(url)) {
        relUrl = url;
      } else {
        relUrl = _.fixRelativeUrl(_.makeRelativePath(url, rootUrl));
        params = _.urlParams(_.extractParamString(relUrl));
        params[HASH_KEY_TOPIC] = _.stripParam(relUrl);
        params = fixHashMapForTopic(params);

        var _splitParams = splitParams(params),
            queryParams = _splitParams.queryParams,
            hashParams = _splitParams.hashParams;

        url = rootUrl + '?' + _.mapToEncodedString(queryParams) + '#' + _.mapToEncodedString(hashParams);
      }
    }
    return document.location.href = url;
  }
};

model.subscribe(consts('EVT_WIDGET_LOADED'), function () {
  _.addEventListener(document, 'click', _.hookClick);

  model.subscribe(consts('EVT_HASH_CHANGE'), hashChanged);

  model.subscribe(consts('KEY_TOPIC_URL'), topicChanged);

  model.subscribe(consts('EVT_NAVIGATE_TO_URL'), navigateToUrl);

  // call to update old layout specific variables
  model.subscribe(consts('KEY_TOPIC_IN_IFRAME'), function (topicUrl) {
    if ('' + window.gHost + window.gHostPath !== '/') {
      // wait to resolve gHostPath
      if (window.setTopic) {
        window.setTopic();
      }
      if (window.changeTopicLink) {
        return window.changeTopicLink(document.location.toString());
      }
    }
  });

  model.subscribe(consts('EVT_TOPIC_LOADED'), function () {
    return _.runTopicLoadingAnimation(false);
  });

  return model.subscribe(consts('EVT_INSIDE_IFRAME_DOM_CONTENTLOADED'), function () {
    return _.runTopicLoadingAnimation(false);
  });
});

},{}],2:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _window = window,
    rh = _window.rh;
var model = rh.model;
var _ = rh._;
var consts = rh.consts;
var apiClient = rh.apiClient;


var GlossaryController = function () {
  var entrys = undefined;
  GlossaryController = function (_rh$NavController) {
    _inherits(GlossaryController, _rh$NavController);

    _createClass(GlossaryController, null, [{
      key: 'initClass',
      value: function initClass() {

        entrys = 'entrys';
      }
    }]);

    function GlossaryController(widget) {
      _classCallCheck(this, GlossaryController);

      var _this = _possibleConstructorReturn(this, (GlossaryController.__proto__ || Object.getPrototypeOf(GlossaryController)).call(this));

      _this.data = [];
      _this.chunkCount = 0;
      _this.count = 0;
      _this.keys = '';
      _this.alhpabet = '';
      _this.loadNavData('glo');
      _this.filter = '';
      _this.widget = widget;
      _this.widget.publish('show', {});
      return _this;
    }

    _createClass(GlossaryController, [{
      key: 'addElement',
      value: function addElement(elements, list) {
        var _this2 = this;

        return function () {
          var result = [];
          _.each(elements[entrys], function (element) {
            if (element != null) {
              if (!_this2.lookup(list, element)) {
                result.push(list.push(element));
              } else {
                result.push(undefined);
              }
            }
          }, _this2);
          return result;
        }();
      }
    }, {
      key: 'getEscapedString',
      value: function getEscapedString(str) {
        return str.replace(/\\"/g, '"').replace(/\\\\/g, '\\');
      }
    }, {
      key: 'exists',
      value: function exists(name) {
        var ch = this.alphaText(name);
        if (this.alhpabet.indexOf(ch) > -1) {
          return true;
        }
        this.alhpabet += ch;
        return false;
      }
    }, {
      key: 'isFiltered',
      value: function isFiltered(name, modelKey) {
        var filter = modelKey ? model.get(modelKey) : this.filter;
        return filter && name.toLocaleLowerCase().indexOf(filter.toLocaleLowerCase()) === -1;
      }
    }, {
      key: 'alphaText',
      value: function alphaText(name) {
        return name.toUpperCase().charAt(0);
      }
    }, {
      key: 'filterGlo',
      value: function filterGlo(value) {
        this.filter = value.toLocaleLowerCase();
        this.alhpabet = '';
        return model.publish(consts('PROJECT_GLOSSARY_DATA'), model.get(consts('PROJECT_GLOSSARY_DATA')));
      }
    }]);

    return GlossaryController;
  }(rh.NavController);
  GlossaryController.initClass();
  return GlossaryController;
}();

rh.controller('GlossaryController', GlossaryController);

},{}],3:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _window = window,
    rh = _window.rh;
var model = rh.model;
var _ = rh._;
var consts = rh.consts;
var apiClient = rh.apiClient;
var rhs = rh.rhs;

var topics = 'topics';

var NavController = function () {
  function NavController() {
    _classCallCheck(this, NavController);

    this.updateData = this.updateData.bind(this);
  }

  _createClass(NavController, [{
    key: 'lookup',
    value: function lookup(children, key) {
      var element = void 0;
      if (children != null && key != null) {
        _.any(children, function (child) {
          if (child != null) {
            if (key.type === child.type && key.name === child.name && _.isEqual(key.url, child.url)) {
              element = child;
            }
            return element != null;
          }
        }, this);
      }
      return element;
    }
  }, {
    key: 'sort',
    value: function sort(array) {
      return array.sort(function (first, second) {
        return window.compare(first.name, second.name);
      });
    }
  }, {
    key: 'updateData',
    value: function updateData(event, constKey, projectUrl) {
      var curData = _.extractTempData(event, this.widget, {});
      this.addElement(curData, this.data, projectUrl, this.keys);
      if (--this.chunkCount === 0 && this.count === 0) {
        if (constKey === 'PROJECT_INDEX_DATA') {
          this.data = this.sortIndexData(this.data);
        } else {
          this.sort(this.data);
        }
        return model.publish(consts(constKey), this.data);
      }
    }
  }, {
    key: 'sortIndexData',
    value: function sortIndexData(data) {
      var _this = this;

      var grpedData = _.groupBy(data, 'name');
      var mergedData = _.map(grpedData, function (keyWrdItems) {
        return _this.mergedKeyWords(keyWrdItems);
      });
      return mergedData = this.sort(mergedData);
    }
  }, {
    key: 'mergedKeyWords',
    value: function mergedKeyWords(keyWrdItems) {
      var _this2 = this;

      return _.reduce(keyWrdItems, function (result, item) {
        result.name = item.name;
        result.type = item.type;
        result.url = item.url;
        result['data-rhtags'] = item['data-rhtags'];
        if (item.type === 'key') {
          result.topics = _this2.sortIndexData((result.topics || []).concat(item.topics || []));
          result.keys = _this2.sortIndexData(_this2.getKeys(result).concat(item.keys || []));
        }
        return result;
      }, {});
    }
  }, {
    key: 'getKeys',
    value: function getKeys(result) {
      if (Array.isArray(result.keys)) {
        return result.keys;
      }
      return [];
    }
  }, {
    key: 'getChunkData',
    value: function getChunkData(event, projectUrl, key) {
      this.count--;
      var tempData = _.extractTempData(event, this.widget, {});
      var arr = __guard__(tempData, function (x) {
        return x['chunkinfos'];
      }) || [];
      this.chunkCount += arr.length;
      return _.each(arr, function (chunk) {
        var _this3 = this;

        if (projectUrl) {
          projectUrl = _.ensureSlash(projectUrl);
        }
        return _.loadScript(projectUrl + 'whxdata/' + chunk.node + '.new.js', false, function (event) {
          return _this3.updateData(event, key, projectUrl);
        });
      }, this);
    }
  }, {
    key: 'loadNavData',
    value: function loadNavData(type) {
      var _this4 = this;

      return model.subscribe(consts('KEY_PROJECT_LIST'), function (list) {
        _this4.alhpabet = '';
        _this4.count += list.length;
        return _.each(list, function (projectUrl) {
          var _this5 = this;

          if (projectUrl) {
            projectUrl = _.ensureSlash(projectUrl);
          }
          return _.loadScript(projectUrl + 'whxdata/' + (type === 'ndx' ? 'idx' : 'glo') + '.new.js', false, function (event) {
            return _this5.getChunkData(event, projectUrl, type === 'ndx' ? 'PROJECT_INDEX_DATA' : 'PROJECT_GLOSSARY_DATA');
          });
        }, _this4);
      });
    }
  }]);

  return NavController;
}();

rh.NavController = NavController;

var IndexController = function () {
  var defProject = undefined;
  IndexController = function (_rh$NavController) {
    _inherits(IndexController, _rh$NavController);

    _createClass(IndexController, null, [{
      key: 'initClass',
      value: function initClass() {
        defProject = '';
      }
    }]);

    function IndexController(widget) {
      _classCallCheck(this, IndexController);

      var _this6 = _possibleConstructorReturn(this, (IndexController.__proto__ || Object.getPrototypeOf(IndexController)).call(this));

      _this6.data = [];
      _this6.chunkCount = 0;
      _this6.count = 0;
      _this6.alhpabet = '';
      _this6.filter = '';
      _this6.keys = 'keys';
      _this6.widget = widget;

      model.subscribeOnce(consts('EVT_PROJECT_LOADED'), function () {
        _this6.loadNavData('ndx');
        _this6.getIndexData();
        return model.subscribe(consts('KEY_INDEX_FILTER'), function () {
          return _this6.alhpabet = '';
        });
      });
      return _this6;
    }

    _createClass(IndexController, [{
      key: 'addElement',
      value: function addElement(element, list, projectUrl, data) {
        var _this7 = this;

        if (element[data] != null) {
          return function () {
            var result = [];
            _.each(element[data], function (child) {
              if (child != null) {
                var existing;

                if (!(existing = _this7.lookup(list, child))) {
                  var obj = { type: child.type, name: child.name };
                  if (child['data-rhtags']) {
                    obj['data-rhtags'] = child['data-rhtags'] + '+' + projectUrl;
                  }
                  if (!child.url) {
                    obj[topics] = [];
                  }
                  var relUrl = _.makeRelativeUrl('' + projectUrl, defProject);
                  if (child.url != null) {
                    obj.url = '' + encodeURI(relUrl) + child.url;
                  }
                  if (child.url == null) {
                    obj[_this7.keys] = [];
                  }
                  list.push(obj);
                  existing = list[list.length - 1];
                }
                _this7.addElement(child, existing[_this7.keys], projectUrl, _this7.keys);
                result.push(_this7.addElement(child, existing[topics], projectUrl, topics));
              }
            }, _this7);
            return result;
          }();
        }
      }
    }, {
      key: 'showItem',
      value: function showItem(name) {
        var filter = model.get(consts('KEY_INDEX_FILTER'));
        return !filter || name.toLocaleLowerCase().indexOf(filter.toLocaleLowerCase()) !== -1;
      }
    }, {
      key: 'showCategory',
      value: function showCategory(name, level) {
        if (level > 0) {
          return false;
        }
        var ch = this.alphaText(name);
        if (this.alhpabet.indexOf(ch) > -1) {
          return false;
        }
        this.alhpabet += ch;
        return true;
      }
    }, {
      key: 'showNextLevel',
      value: function showNextLevel(node) {
        var id = node.getAttribute('data-indexid');
        var old = this.widget.get('show.' + id);
        var childData = _defineProperty({}, id, !old);
        while (id) {
          id = id.substr(0, id.lastIndexOf('_'));
          childData[id] = true;
        }
        return this.widget.publish('show', childData);
      }
    }, {
      key: 'alphaText',
      value: function alphaText(name) {
        return name.toUpperCase().charAt(0);
      }
    }, {
      key: 'getIndexData',
      value: function getIndexData() {
        return model.subscribeOnce(consts('KEY_PUBLISH_BASE_URL'), function () {
          try {
            var baseUrl = model.get(consts('KEY_PUBLISH_BASE_URL'));
            var baseUrlParts = rh._.splitUrl(baseUrl);
            var baseContext = baseUrlParts.pathname;
            if (baseContext && !_.isEmptyString(baseContext)) {
              var hashString = _.mapToEncodedString(_.extend(_.addPathNameKey({ area: rhs.area(),
                prj: rhs.project(), type: rhs.type(), agt: 'ndx', mgr: 'agm'
              })));
              return apiClient.get(baseContext + '?' + hashString).success(function (data, status) {
                data = JSON.parse(data);
                var list = [];
                var rootPrjs = [];
                var projects = data.allProjects;
                var _data = data,
                    masterProjects = _data.masterProjects;

                if (projects.length) {
                  projects[0] = _.ensureSlash(projects[0]);
                }
                var makelist = function makelist(projectList, outList) {
                  return _.each(projectList, function (item) {
                    return outList.push(_.makeRelativeUrl(item, projects[0]));
                  });
                };
                makelist(projects, list);
                makelist(masterProjects, rootPrjs);
                var updateList = function updateList(item, index, list) {
                  if (_.isEmptyString(item)) {
                    list[index] = '.';
                  }
                };
                _.each(list, updateList);
                _.each(rootPrjs, updateList);
                model.publish(consts('KEY_PROJECT_LIST'), list);
                return model.publish(consts('KEY_MASTER_PROJECT_LIST'), rootPrjs);
              });
            }
          } catch (err) {
            if (rh._debug) {
              return rh._d('warn', err.message);
            }
          }
        });
      }
    }]);

    return IndexController;
  }(rh.NavController);
  IndexController.initClass();
  return IndexController;
}();

rh.controller('IndexController', IndexController);

function __guard__(value, transform) {
  return typeof value !== 'undefined' && value !== null ? transform(value) : undefined;
}

},{}],4:[function(require,module,exports){
"use strict";

var rh = require("../../src/lib/rh");
var _ = rh._;

_.findEditDist = function (first, second) {
  if (first == second) return 0;
  var prevDist = [];
  var dist = [];
  for (var i = 0; i < second.length + 1; i++) {
    prevDist.push(i);
    dist.push(0); //just to create a array of size second.length+1
  }

  for (var i = 0; i < first.length; i++) {
    dist[0] = i + 1;

    for (var j = 0; j < second.length; j++) {
      var curr = void 0;
      if (first[i] == second[j]) curr = 0;else curr = 1;

      dist[j + 1] = Math.min(dist[j] + 1, prevDist[j + 1] + 1, prevDist[j] + curr);
    }

    for (var j = 0; j < prevDist.length; j++) {
      prevDist[j] = dist[j];
    }
  }
  return dist[dist.length - 1];
};

},{"../../src/lib/rh":25}],5:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var bind = function bind(fn, me) {
  return function () {
    return fn.apply(me, arguments);
  };
};

var rh = require("../../src/lib/rh");
var nodeUtil = require('../../src/responsive_help/utils/node_utils');
var _ = rh._;
var $ = rh.$;
var model = rh.model;
var consts = rh.consts;
var KEY_TOC_DRILL_DOWN = consts('KEY_TOC_DRILL_DOWN');
var ANIM_TIME = 700;
var SyncToc = void 0;
var TocController = void 0;

SyncToc = function () {
  var SyncToc = function () {
    function SyncToc() {
      _classCallCheck(this, SyncToc);
    }

    _createClass(SyncToc, [{
      key: 'sync',
      value: function sync(tc, info) {
        var node = void 0;
        tc.updateActiveBookInfo(0, '_');

        node = tc.widget.node;
        //tc.updateBreadcrumbInfo(tc.widget.node);

        this.reset(info);
        return this.syncToProjectToc(tc, node.children, function (_this) {
          return function (nodes) {
            return _this.syncToTocItem(tc, nodes);
          };
        }(this));
      }
    }, {
      key: 'reset',
      value: function reset(info) {
        var idx = void 0;
        this.parseTocInfo(info);
        idx = this.order.lastIndexOf('@');
        return this.parentOrder = idx !== -1 ? this.order.substring(0, idx) : '';
      }
    }, {
      key: 'parseTocInfo',
      value: function parseTocInfo(info) {
        var path = void 0;
        this.order = info.childOrder || '';
        path = _.splitAndTrim(info.childPrefix, '.');
        this.tocPath = _.reduce(path, function (result, prefix) {
          var arr = void 0,
              bookNo = void 0;
          arr = _.splitAndTrim(prefix, '@');
          if (bookNo = arr.shift()) {
            result.push({
              bookNo: _.parseInt(bookNo, 0),
              order: arr.length > 0 ? '@' + arr.join('@') : ''
            });
          }
          return result;
        }, []);
        path = _.splitAndTrim(info.topicID || '0', '_');
        this.bookNos = _.map(path.shift().split('.'), function (item) {
          return _.parseInt(item, 0);
        });
        return this.pageNo = _.parseInt(path.shift(), 0);
      }
    }, {
      key: 'syncToProjectToc',
      value: function syncToProjectToc(tc, nodes, success) {
        var curBookNo = void 0,
            idx = void 0,
            path = void 0;
        if (this.tocPath.length > 0) {
          curBookNo = 0;
          path = this.tocPath.shift();
          idx = _.findIndex(nodes, function (child) {
            var childOrder = void 0;
            childOrder = $.dataset(child, 'childorder') || '';
            if (childOrder === path.order && tc.isBookNode(child)) {
              curBookNo++;
              if (curBookNo === path.bookNo) {
                return true;
              }
            }
            return false;
          });
          if (idx !== -1) {
            return tc.openBook(nodes[idx], true, function (_this) {
              return function () {
                return _.defer(function () {
                  var child = void 0,
                      childNodes = void 0;
                  child = nodes[idx + 1];
                  if (childNodes = child.children && child.children[0]) {
                    return _this.syncToProjectToc(tc, childNodes.children, success);
                  }
                });
              };
            }(this));
          }
        } else if (success) {
          return success(nodes);
        }
      }
    }, {
      key: 'syncToTocItem',
      value: function syncToTocItem(tc, nodes, wait) {
        var curBookNo = void 0,
            curPageNo = void 0,
            lastBookNode = void 0;
        if (wait == null) {
          wait = 1;
        }
        curPageNo = 0;
        curBookNo = 0;
        lastBookNode = null;
        return _.any(nodes, function (_this) {
          return function (child) {
            var bookNode = void 0,
                childOrder = void 0,
                hasChild = void 0,
                pageNode = void 0,
                topicNode = void 0;
            childOrder = $.dataset(child, 'childorder') || '';
            if (childOrder !== _this.order) {
              return;
            }
            if (tc.isBookNode(child)) {
              bookNode = child;
              lastBookNode = bookNode;
            }
            if (bookNode) {
              curBookNo++;
            }
            if (_this.bookNos[0] !== curBookNo) {
              return;
            }
            if (tc.isPageNode(child)) {
              pageNode = child;
            }
            if (pageNode) {
              curPageNo++;
            }
            if (_this.bookNos.length === 1) {
              if (_this.pageNo === 0) {
                topicNode = child;
                if (lastBookNode) {
                  tc.openBook(lastBookNode, true, function () {
                    return tc.updateBookInfo();
                  });
                }
              } else if (pageNode && curPageNo === _this.pageNo) {
                topicNode = child;
              }
              tc.updateBookInfo();
              if (topicNode) {
                tc.selectLink(topicNode, true, wait);
              }
            } else if (lastBookNode && (hasChild = $.hasClass(child, 'child'))) {
              _this.bookNos.shift();
              tc.openBook(lastBookNode, true, function () {
                return _.defer(function () {
                  var childNodes = void 0;
                  if (childNodes = child.children && child.children[0]) {
                    return _this.syncToTocItem(tc, childNodes.children, ANIM_TIME);
                  }
                });
              });
              return true;
            }
            return topicNode != null;
          };
        }(this));
      }
    }]);

    return SyncToc;
  }();

  return SyncToc;
}();

TocController = function () {
  var ACTIVE_CLASS = void 0,
      COLLAPSING_CLASS = void 0,
      EXPANDED_CLASS = void 0,
      EXPANDING_CLASS = void 0,
      KEY_ACTIVE_BOOKID = void 0,
      KEY_ACTIVE_BOOK_LEVEL = void 0,
      KEY_BOOKID = void 0,
      KEY_BOOK_LEVEL = void 0,
      KEY_SHOW_CHILD = void 0,
      KEY_TOC = void 0,
      LOADING_BOOK = void 0,
      SELECTED_CLASS = void 0;

  EXPANDED_CLASS = 'expanded';

  ACTIVE_CLASS = 'active';

  COLLAPSING_CLASS = 'collapsing';

  EXPANDING_CLASS = 'expanding';

  LOADING_BOOK = 'loading-book';

  SELECTED_CLASS = 'selected';

  KEY_SHOW_CHILD = 'show_child';

  KEY_BOOKID = 'bookid';

  KEY_ACTIVE_BOOKID = 'active_bookid';

  KEY_BOOK_LEVEL = 'level';

  KEY_ACTIVE_BOOK_LEVEL = 'active_level';

  KEY_TOC = '.p.toc';
  var CURRENT_TOC_KEY = 'curtoc',
      TOC_ITEM_ATTR = 'data-tocitem';

  var KEY_BREADCRUMBS = consts('KEY_TOC_BREADCRUMBS');

  var TocController = function () {
    function TocController(widget) {
      var _this2 = this;

      _classCallCheck(this, TocController);

      this.widget = widget;
      this.subscribeTopicID = bind(this.subscribeTopicID, this);
      this.urls = [];

      this.onClick = bind(this.onClick, this);
      this.updateBookInfo = bind(this.updateBookInfo, this);
      this._data = {};
      this.projectAbsRef = [];
      if (this.syncToc == null) {
        this.syncToc = new SyncToc();
      }
      this.widget.publish(KEY_BOOK_LEVEL, 0);
      this.widget.publish(KEY_BOOKID, '_');
      rh.model.subscribe(KEY_TOC, function (data) {
        _this2.widget.publish(CURRENT_TOC_KEY, data);
        _this2.widget.publish('curlevel', 0);
      });
      this.widget.subscribe(consts('KEY_TOC_SELECT_ITEM'), this.selectTocItem.bind(this));
      model.subscribe(consts('KEY_TOC_BACK_BUTTON_PRESSED'), this.onBackButtonClicked.bind(this));
      model.subscribeOnce([consts('EVT_PROJECT_LOADED'), consts('KEY_TOC_ORDER')], function (_this) {
        return function () {
          if (model.get(consts('KEY_PUBLISH_MODE'))) {
            return _this.getTOCData();
          } else {
            return _this.loadToc(KEY_TOC, '', function () {
              _this.widget.publish(consts('EVT_TOC_LOADED'), true);
              return _.defer(function () {
                return _this.widget.subscribe(rh.consts('KEY_TOPIC_ID'), _this.subscribeTopicID);
              });
            });
          }
        };
      }(this));
    }

    _createClass(TocController, [{
      key: 'expandBook',
      value: function expandBook(level, id, node, item) {
        this.selectTocItem({ 'id': id });
        var key = $.getAttribute(node, 'data-itemkey');
        rh.model.publish('EVT_TOC_LOADED' + 'gototab', { 'tab': 0, 'key': key, 'item': item });
      }
    }, {
      key: 'updateBookInfo',
      value: function updateBookInfo() {
        var id = void 0,
            newLevel = void 0;
        id = this.widget.get(KEY_ACTIVE_BOOKID);
        if (id != null && id !== this.widget.get(KEY_BOOKID)) {
          this.widget.publish(KEY_BOOKID, id);
        }
        newLevel = this.widget.get(KEY_ACTIVE_BOOK_LEVEL);
        if (newLevel != null && newLevel !== this.widget.get(KEY_BOOK_LEVEL)) {
          return this.widget.publish(KEY_BOOK_LEVEL, newLevel);
        }
      }
    }, {
      key: 'updateActiveBookInfo',
      value: function updateActiveBookInfo(level, id) {
        this.widget.publish(KEY_ACTIVE_BOOKID, id);

        return this.widget.publish(KEY_ACTIVE_BOOK_LEVEL, level);
      }
      /*
      _addBookmark(node){
        let that = this.this;
        if(!Array.isArray(this.path) || this.path.length === 0){
          return false;
        }
        if(that.isTOCItem(node)){
          if(this.currIndex === this.path[0]){
            let index = this.path.shift();
            this.curr_path += (this.curr_path === "")? index.toString() : "_" + index.toString();
            let text = that.getText(node);
            this.bookmarks.push({text: text, path: this.curr_path });
            this.index = 0;
          }
          else{
          //traverseChild =false;
            this.currIndex += 1;
          }
        }
      }
      */

    }, {
      key: 'getText',
      value: function getText(node) {
        return node.textContent.trim();
      }
    }, {
      key: '_getPreviousItemNode',
      value: function _getPreviousItemNode(node) {
        var pid = this.pid($.getAttribute(node, 'data-itemid'));
        return $.find(this.widget.node, '[data-itemid=\"' + pid + '\"]')[0];
      }
    }, {
      key: 'updateBreadcrumbInfo',
      value: function updateBreadcrumbInfo(node) {
        var $leafnode = node;
        var $node = void 0;
        var breadcrumbs = [];
        if (!this.isTOCItem(node)) {
          return;
        }
        breadcrumbs.push(this._createBreadcrumbItem($leafnode));
        while ($node = this._getPreviousItemNode($leafnode)) {
          breadcrumbs.push(this._createBreadcrumbItem($node));
          $leafnode = $node;
        }
        breadcrumbs.reverse();
        if (breadcrumbs.length > 0) {
          breadcrumbs[breadcrumbs.length - 1].lastNode = true;
        }
        breadcrumbs.curlevel = this.widget.get("curlevel");
        this.widget.publish(KEY_BREADCRUMBS, breadcrumbs);
      }
    }, {
      key: '_createBreadcrumbItem',
      value: function _createBreadcrumbItem(node) {
        var linkNode = node;
        if (!this.hasTOCItemLink(node)) {
          linkNode = this._findFirstLink(node);
        }
        var url = linkNode && ($.getAttribute(linkNode, 'href') || $.getAttribute(linkNode, 'link')) || '#';
        return { id: $.getAttribute(node, 'data-itemid'),
          text: this.getText(node),
          url: url,
          hasUrl: this.hasTOCItemLink(node),
          lastNode: false };
      }
    }, {
      key: 'isTOCItem',
      value: function isTOCItem(node) {

        return $.nodeName(node) === 'LI' || $.getAttribute(node, TOC_ITEM_ATTR);
      }
    }, {
      key: '_findFirstLink',
      value: function _findFirstLink(bookNode) {
        var context = { that: this };

        var node = nodeUtil.parentNode(bookNode);
        context.bookid = $.getAttribute(bookNode, 'data-itemid');
        $.traverseNode(node, this._findLinkFn, null, null, context);
        return context.linkNode;
      }
    }, {
      key: '_isParentTocItem',
      value: function _isParentTocItem(node) {
        return this.bookNode !== node && this.that.isTOCItem(node);
      }
    }, {
      key: '_findLinkFn',
      value: function _findLinkFn(node) {
        var id = $.getAttribute(node, 'data-itemid');
        if (id === this.bookid) {
          this.bookFound = true;
        }
        if (this.bookFound && this.that.hasTOCItemLink(node) && this.linkNode === undefined) {
          this.linkNode = node;
          return false;
        }
        return true;
      }
    }, {
      key: 'nextLevel',
      value: function nextLevel(node) {
        var level = void 0;
        level = _.parseInt($.dataset(node, 'itemlevel'), 0);
        if ($.hasClass(node, EXPANDED_CLASS)) {
          return level;
        } else {
          return level + 1;
        }
      }
    }, {
      key: 'onClick',
      value: function onClick(event) {
        var clickNode = void 0,
            hasLink = void 0,
            node = void 0,
            topNode = void 0;
        topNode = event.currentTarget;
        clickNode = event.target;
        hasLink = this.hasLink(clickNode);
        node = this.getItemNode(clickNode, topNode);
        if (this.isBookNode(node)) {
          if (!(hasLink && this.selectedNode !== node && this.isOpenBook(node))) {
            this.toggleBook(node, false);
            this.updateBreadcrumbInfo(node);
          }
        }

        if (!(!hasLink || this.isUrlNode(node) && this.hasExternalLink(clickNode))) {
          return this.selectLink(node, false);
        }
      }
    }, {
      key: 'selectLink',
      value: function selectLink(node, scrollIntoView, wait) {
        if (wait == null) {
          wait = ANIM_TIME;
        }
        if (this.selectedNode) {
          $.removeClass(this.selectedNode, SELECTED_CLASS);
        }
        if (scrollIntoView && this.selectedNode !== node) {
          _.delay(function () {
            return node.scrollIntoView(true);
          }, wait);
        }
        this.selectedNode = node;
        if (node) {
          this.updateBreadcrumbInfo(node);
          model.publish(consts('EVT_TOC_SELECTED_ITEM_CHANGED'));
          return $.addClass(node, SELECTED_CLASS);
        }
      }
    }, {
      key: 'selectTocItem',
      value: function selectTocItem(tocObj) {
        var id = tocObj.id + '_0';
        if (id) {
          var childData = {},
              level = -1;
          while (id) {
            level++;
            childData[id] = true;
            id = id.substr(0, id.lastIndexOf('_'));
          }
          this.widget.publish("show_child", childData);
          this.widget.publish("curlevel", level);
          if (tocObj.url) rh.model.publish('EVT_TOC_LOADED' + 'gototab', { 'tab': 0, 'item': { 'url': tocObj.url } });
        }
      }
    }, {
      key: 'getItemNode',
      value: function getItemNode(node, topNode) {
        return _.findParentNode(node, topNode, this.isTOCItem);
      }
    }, {
      key: 'getChildItemNode',
      value: function getChildItemNode(node, index) {
        return $.find(node, function (node) {
          return $.nodeName(node) === 'LI' || $.getAttribute(node, TOC_ITEM_ATTR);
        });
      }
    }, {
      key: 'hasTOCItemLink',
      value: function hasTOCItemLink(node) {
        var href = $.getAttribute(node, 'data-haslink');
        return href === 'true';
      }
    }, {
      key: 'hasLink',
      value: function hasLink(node) {
        var href = void 0;
        href = $.getAttribute(node, 'href');
        return href && href !== '#';
      }
    }, {
      key: 'isBookNode',
      value: function isBookNode(node) {
        return $.hasClass(node, 'book');
      }
    }, {
      key: 'isTopicNode',
      value: function isTopicNode(node) {
        return $.hasClass(node, 'item');
      }
    }, {
      key: 'isUrlNode',
      value: function isUrlNode(node) {
        return $.hasClass(node, 'url');
      }
    }, {
      key: 'isPageNode',
      value: function isPageNode(node) {
        return this.isTopicNode(node) || this.isUrlNode(node);
      }
    }, {
      key: 'isOpenBook',
      value: function isOpenBook(node) {
        if (this.widget.get(KEY_TOC_DRILL_DOWN)) {
          return $.hasClass(node, ACTIVE_CLASS);
        } else {
          return $.hasClass(node, EXPANDED_CLASS);
        }
      }
    }, {
      key: 'hasExternalLink',
      value: function hasExternalLink(node) {
        var href = void 0;
        href = $.getAttribute(node, 'href');
        if (!(href && !_.isRelativeUrl(href))) {
          return false;
        }
        return !_.isUrlAllowdInIframe(href);
      }
    }, {
      key: 'getBookNode',
      value: function getBookNode(node, topNode) {
        var itemNode = void 0;
        itemNode = this.getItemNode(node, topNode);
        if (this.isBookNode(itemNode)) {
          return itemNode;
        } else {
          return null;
        }
      }
    }, {
      key: 'animateCollapse',
      value: function animateCollapse(bookNode) {
        return _.each([bookNode, bookNode.nextElementSibling], function (node) {
          $.addClass(node, COLLAPSING_CLASS);
          return _.delay(function () {
            return $.removeClass(node, COLLAPSING_CLASS);
          }, ANIM_TIME);
        });
      }
    }, {
      key: 'animateExpand',
      value: function animateExpand(bookNode) {
        return _.each([bookNode, bookNode.nextElementSibling], function (node) {
          $.addClass(node, EXPANDING_CLASS);
          return _.delay(function () {
            return $.removeClass(node, EXPANDING_CLASS);
          }, ANIM_TIME);
        });
      }
    }, {
      key: 'toggleBook',
      value: function toggleBook(bookNode, scrollIntoView) {
        if (scrollIntoView == null) {
          scrollIntoView = true;
        }
        if (this.isOpenBook(bookNode)) {
          return this.closeBook(bookNode);
        } else {
          return this.openBook(bookNode, scrollIntoView);
        }
      }
    }, {
      key: 'onBackButtonClicked',
      value: function onBackButtonClicked() {
        var _this3 = this;

        var node = document.getElementsByClassName('expanded active') && document.getElementsByClassName('expanded active')[0];
        if (node) {
          this.closeBook(node);
          _.defer(function () {
            _this3.widget.subscribe(KEY_ACTIVE_BOOKID, function (id) {
              var sendData = void 0;
              if (id === '_') {
                sendData = false;
              } else {
                sendData = true;
              }
              model.publish(rh.consts('KEY_SHOW_TOC_BACK_BUTTON'), sendData);
            });
          });
        }
      }
    }, {
      key: 'closeBook',
      value: function closeBook(node) {
        var id = void 0,
            keyShow = void 0;
        id = $.dataset(node, 'itemid');
        keyShow = '' + KEY_SHOW_CHILD + id;
        if (false !== this.widget.get(keyShow)) {
          this.widget.publish(keyShow, false);
        }
        this.updateActiveBookInfo(this.nextLevel(node), this.pid(id));
        this.updateBookInfo();
        if ($.hasClass(node, EXPANDED_CLASS)) {
          $.removeClass(node, EXPANDED_CLASS);
          return this.animateCollapse(node);
        }
      }
    }, {
      key: 'openBook',
      value: function openBook(node, scrollIntoView, success) {
        model.publish(rh.consts('KEY_SHOW_TOC_BACK_BUTTON'), true);
        var childOrder = void 0,
            id = void 0,
            key = void 0,
            keyShow = void 0;
        if (success == null) {
          success = this.updateBookInfo;
        }
        key = $.dataset(node, 'itemkey');
        id = $.dataset(node, 'itemid');
        childOrder = $.dataset(node, 'childorder');
        keyShow = '' + KEY_SHOW_CHILD + id;
        if (true !== this.widget.get(keyShow)) {
          this.widget.publish(keyShow, true);
        }
        this.updateActiveBookInfo(this.nextLevel(node), id);
        if (this.widget.get(key)) {
          if (!$.hasClass(node, EXPANDED_CLASS)) {
            $.addClass(node, EXPANDED_CLASS);
            this.animateExpand(node);
          }
          return success();
        } else {
          $.addClass(node, LOADING_BOOK);
          if (scrollIntoView) {
            node.scrollIntoView(false);
          }
          return this.loadToc(key, childOrder, function (_this) {
            return function () {
              $.removeClass(node, LOADING_BOOK);
              $.addClass(node, EXPANDED_CLASS);
              _this.animateExpand(node);
              return success();
            };
          }(this));
        }
      }
    }, {
      key: 'extractTempData',
      value: function extractTempData(event) {
        var tempItems = void 0;
        if (event && event.type === 'error') {
          tempItems = [];
          return tempItems;
        }
        tempItems = this.widget.get(rh.consts('KEY_TEMP_DATA'));
        this.widget.publish(rh.consts('KEY_TEMP_DATA'));
        return tempItems;
      }
    }, {
      key: 'loadToc',
      value: function loadToc(fullKey, parentOrder, success) {
        var absRef = void 0,
            key = void 0,
            parentPath = void 0,
            ref1 = void 0;
        ref1 = this.parseKey(fullKey), absRef = ref1.absRef, key = ref1.key;
        parentPath = absRef ? absRef + '/' : '';
        return _.loadScript(parentPath + 'whxdata/' + key + '.new.js', true, function (_this) {
          return function (event) {
            var tempItems = void 0;
            tempItems = _this.extractTempData(event) || [];
            _.each(tempItems, function (item) {
              item.absRef = absRef;
              if (item.type === 'remoteitem') {
                item.url = item.url && decodeURI(item.url);
              }
              if (parentOrder) {
                return item.childOrder = parentOrder;
              }
            });
            return _this.loadRefToc(tempItems, function (items) {
              _this.widget.publish(fullKey, items);
              if (success) {
                return success();
              }
            });
          };
        }(this));
      }
    }, {
      key: 'loadRefToc',
      value: function loadRefToc(items, success) {
        var _this4 = this;

        var absRef = void 0,
            index = void 0,
            item = void 0;
        if (items == null) {
          items = [];
        }
        index = _.findIndex(items, function (item) {
          if (item.ref) {
            return true;
          }
        });
        if (index !== -1) {
          item = items[index];
          absRef = item.absRef || '';
          if (absRef) {
            absRef += '/';
          }
          absRef += item.ref;
          var prjOrder = model.get(consts('KEY_TOC_ORDER'));
          var childOrder = '';
          if (prjOrder[absRef]) {
            childOrder = prjOrder[absRef].order;
          }
          return _.loadScript(absRef + '/whxdata/toc.new.js', true, function (event) {
            var tempItems = void 0;
            tempItems = _this4.extractTempData(event) || [];
            _.each(tempItems, function (item) {
              item.absRef = absRef;
              if (childOrder) {
                return item.childOrder = childOrder;
              }
            });
            Array.prototype.splice.apply(items, [index, 1].concat(tempItems));
            return _this4.loadRefToc(items, success);
          });
        } else if (success) {
          return success(items);
        }
      }
    }, {
      key: 'getTOCData',
      value: function getTOCData() {
        return model.subscribeOnce(consts('KEY_PUBLISH_BASE_URL'), function (_this) {
          return function () {
            var err;
            try {
              return model.subscribe(consts('KEY_PROJECT_LIST'), function (allProjects) {
                return model.subscribe(consts('KEY_MASTER_PROJECT_LIST'), function (list) {
                  var items, len;
                  len = list.length;
                  items = [];
                  return _.each(list, function (prj) {
                    prj = _.makeRelativeUrl(prj, allProjects[0]);
                    if (prj) {
                      prj = prj + "/";
                    }
                    return _.loadScript(prj + "whxdata/toc.new.js", true, function (_this) {
                      return function (event) {
                        var tempItems;
                        tempItems = _this.extractTempData(event) || [];
                        _.each(tempItems, function (item) {
                          item.absRef = prj;
                        });
                        return _this.loadRefToc(tempItems, function (resolvedItems) {
                          len--;
                          items = items.concat(resolvedItems);
                          if (len === 0) {
                            _this.widget.publish(KEY_TOC, items);
                            _this.widget.publish(consts('EVT_TOC_LOADED'), true);
                            return _this.widget.subscribe(rh.consts('KEY_TOPIC_ID'), _this.subscribeTopicID);
                          }
                        });
                      };
                    }(this));
                  }, _this);
                });
              });
            } catch (error) {
              err = error;
              if (rh._debug) {
                return rh._d('warn', err.message);
              }
            }
          };
        }(this));
      }
    }, {
      key: 'nextChildOrder',
      value: function nextChildOrder(childOrder) {
        var orders = void 0;
        orders = childOrder.split('@');
        orders[orders.length - 1] = 1 + _.parseInt(orders[orders.length - 1], 0);
        return orders.join('@');
      }
    }, {
      key: 'childOrder',
      value: function childOrder(parentOrder) {
        if (parentOrder) {
          return parentOrder + '@1';
        } else {
          return '@1';
        }
      }
    }, {
      key: 'pid',
      value: function pid(id) {
        var path = void 0;
        path = id.split('_');
        path.pop();
        return path.join('_') || '_';
      }
    }, {
      key: 'key',
      value: function key(absRef, _key) {
        var idx = void 0;
        if (absRef == null) {
          absRef = '';
        }
        idx = _.findIndex(this.projectAbsRef, function (ref) {
          return ref === absRef;
        });
        if (idx === -1) {
          idx = this.projectAbsRef.length;
          this.projectAbsRef.push(absRef);
        }
        return '.p.child_toc.' + idx + '.' + _key;
      }
    }, {
      key: 'parseKey',
      value: function parseKey(key) {
        var absRef = void 0,
            keys = void 0,
            lastKey = void 0;
        key = key.substring(3);
        keys = key.split('.');
        lastKey = keys.pop();
        absRef = this.projectAbsRef[keys.pop()] || '';
        return {
          key: lastKey,
          absRef: absRef
        };
      }
    }, {
      key: 'url',
      value: function url(item, id) {
        var bookMark = void 0,
            filePath = void 0,
            params = void 0,
            parentPath = void 0,
            url = void 0;
        if (!item.url) {
          return '#';
        }
        if (item.type === 'remoteitem') {
          return encodeURI(item.url);
        }
        parentPath = item.absRef ? _.ensureSlash(item.absRef) : '';
        url = '' + parentPath + item.url;
        bookMark = _.extractHashString(url);
        if (this.urls.indexOf(url) !== -1 || bookMark.length > 0) {
          bookMark = bookMark && '#' + bookMark;
          filePath = _.filePath(url);
          params = _.extractParamString(url);
          if (params.length > 0) {
            params = params + '&';
          }
          params = '?' + params + 'rhtocid=' + id;
          url = '' + filePath + params + (bookMark || '');
        }
        this.urls.push(url);
        return encodeURI(url);
      }
    }, {
      key: 'tags',
      value: function tags(item) {
        var parentPath = void 0;
        parentPath = item.absRef ? '+' + item.absRef : '';
        if (item['data-rhtags']) {
          return item['data-rhtags'] + parentPath;
        } else {
          return '';
        }
      }
    }, {
      key: 'subscribeTopicID',
      value: function subscribeTopicID(tocInfo) {
        var _this5 = this;

        var path = void 0,
            tocid = void 0;
        if (tocInfo == null) {
          tocInfo = {};
        }
        tocid = _.hashParams()['rhtocid'];
        if (tocid) {
          path = this.getPathfromId(tocid);
          this.selectTocById(path, this.widget.node);
        } else {
          rh.model.subscribe(rh.consts('KEY_MASTER_PROJECT_LIST'), function (list) {
            if (list && list.length < 2) return _this5.syncToc.sync(_this5, tocInfo);
          });
        }
      }
    }, {
      key: 'subscribeBookId',
      value: function subscribeBookId(bookId) {
        // sukumar: TODO remove this line
        var books = void 0;
        var path = void 0;
        if (bookId) {
          path = this.getPathfromId(bookId);
          return this.selectTocById(path, this.widget.node, null, books);
        }
      }
    }, {
      key: 'getPathfromId',
      value: function getPathfromId(id) {
        var path = void 0;
        path = id.split('_');
        path.shift();
        path = _.map(path, function (item) {
          return _.parseInt(item, 0);
        });
        return path;
      }
    }, {
      key: 'selectTocById',
      value: function selectTocById(path, node, wait, books) {
        var child = void 0,
            index = void 0;
        if (wait == null) {
          wait = 1;
        }
        if (!(node && node.children)) {
          return;
        }
        index = path.shift();
        child = _.find(node.children, function (child) {
          if (this.isBookNode(child) || this.isPageNode(child)) {
            if (index === 0) {
              return true;
            }
            index--;
          }
          return false;
        }, this);
        if (!child) {
          return;
        }

        if (path.length === 0) {
          this.selectLink(child, true, wait);
        }
        if (this.isBookNode(child)) {
          return this.openBook(child, true, function (_this) {
            return function () {
              return _.defer(function () {
                var childNode = void 0,
                    parentNode = void 0;
                if (path.length === 0) {
                  return _this.updateBookInfo();
                } else {
                  childNode = child.nextElementSibling;
                  parentNode = childNode.children && childNode.children[0];
                  return _this.selectTocById(path, parentNode, ANIM_TIME);
                }
              });
            };
          }(this));
        } else {
          return this.updateBookInfo();
        }
      }
    }]);

    return TocController;
  }();

  TocController.prototype["class"] = function (item) {
    if (item.type === 'remoteitem') {
      return 'url';
    } else {
      return item.type;
    }
  };

  return TocController;
}();

rh.controller('TocController', TocController);

},{"../../src/lib/rh":25,"../../src/responsive_help/utils/node_utils":68}],6:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var rh = require("../../src/lib/rh");
var _ = rh._;
var $ = rh.$;
var model = rh.model;
var consts = rh.consts;

var TOCLevel = function () {
  function TOCLevel() {
    var _this = this;

    _classCallCheck(this, TOCLevel);

    this.data = { '': { order: '', nextChild: 0 } };
    model.subscribeOnce(consts('KEY_PROJECT_LIST'), function (allProjects) {
      _.each(allProjects, function (prj) {
        prj = _.makeRelativeUrl(_this.trimFirst(prj, '.'), allProjects[0]);
        _this.childOrder(prj);
      });
      model.publish(consts('KEY_TOC_ORDER'), _this.data);
    });
  }

  _createClass(TOCLevel, [{
    key: 'trimFirst',
    value: function trimFirst(path, char) {
      return path = path.length && path[0] === char && path[1] !== char ? path.substring(1) : path;
    }
  }, {
    key: 'childOrder',
    value: function childOrder(absRef) {
      absRef = this.trimFirst(absRef, '/');
      if (!this.data[absRef]) {
        var path = absRef;
        path = path.substring(0, path.lastIndexOf('/'));
        path = path.substring(0, path.lastIndexOf('/'));
        var parent = this.data[path];
        parent.nextChild++;
        this.data[absRef] = { order: parent.order + '@' + parent.nextChild, nextChild: 0 };
      }
      return this.data[absRef].order;
    }
  }]);

  return TOCLevel;
}();

new TOCLevel();

},{"../../src/lib/rh":25}],7:[function(require,module,exports){
'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _window = window,
    rh = _window.rh;
var _ = rh._;
var $ = rh.$;

var BrowseSequenceBuilder = function BrowseSequenceBuilder() {
  _classCallCheck(this, BrowseSequenceBuilder);

  var handleTopicChange = function handleTopicChange(doNotUse) {
    var brsMap = rh.model.get('t.brsmap');
    if (brsMap != null) {
      var next = brsMap['n'] && brsMap['n'][0] || '';
      var prev = brsMap['p'] && brsMap['p'][0] || '';
      var decodedURI = window.decodeURI(document.location.href);

      if (!_.isEmptyString(next)) {
        next = window._getRelativeFileName(decodedURI, next);
      }
      if (!_.isEmptyString) {
        prev = window._getRelativeFileName(decodedURI, prev);
      }

      rh.model.publish('l.brsBack', prev);
      return rh.model.publish('l.brsNext', next);
    }
  };

  var updateShowBrs = function updateShowBrs() {
    var uiMode = rh.model.get(rh.consts('KEY_UI_MODE'));
    var prev = rh.model.get('l.brsBack');
    var next = rh.model.get('l.brsNext');
    var showBrs = !uiMode && (prev || next) ? true : false;
    return rh.model.publish('l.show_brs', showBrs);
  };

  rh.model.subscribe('t.topicurl', _.debounce(handleTopicChange, 200));
  rh.model.subscribe('t.brsmap', _.debounce(handleTopicChange, 200));

  rh.model.subscribe('l.brsBack', updateShowBrs);
  rh.model.subscribe('l.brsNext', updateShowBrs);
  rh.model.subscribe(rh.consts('KEY_UI_MODE'), updateShowBrs);
};

//TODO: move it to controller


rh.widgets.BrowseSequenceBuilder = BrowseSequenceBuilder;

},{}],8:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _window = window,
    rh = _window.rh;
var _ = rh._;
var $ = rh.$;
var consts = rh.consts;
var storage = rh.storage;

var urlFilter = rh._params.filter;

var ExpressionBuilder = function () {
  var GRP_SEPARATOR = undefined;
  var TAG_SEPARATOR = undefined;
  var ELEMENT_SEPARATOR = undefined;
  ExpressionBuilder = function () {
    _createClass(ExpressionBuilder, null, [{
      key: 'initClass',
      value: function initClass() {

        GRP_SEPARATOR = ':';
        TAG_SEPARATOR = ';';
        ELEMENT_SEPARATOR = ',';
      }
    }]);

    function ExpressionBuilder(config) {
      _classCallCheck(this, ExpressionBuilder);

      this.getUnchecked = this.getUnchecked.bind(this);
      this.handleTagStates = this.handleTagStates.bind(this);
      storage.init(consts('HELP_ID'));

      this.allTagNames = this.computeNames(rh.model.get(consts('KEY_MERGED_FILTER_KEY')));

      this.prepareTagStates();

      this.handleTagStates(rh.model.get(consts('KEY_PROJECT_TAG_STATES')));

      rh.model.subscribe(consts('KEY_PROJECT_TAG_STATES'), _.debounce(this.handleTagStates, 300), { initDone: true });
    }

    _createClass(ExpressionBuilder, [{
      key: 'computeNames',
      value: function computeNames(tags) {
        return _.reduce(tags, function (result, tag) {
          result.push(tag.children ? this.computeNames(tag.children) : tag.name);
          return result;
        }, [], this);
      }
    }, {
      key: 'getUnchecked',
      value: function getUnchecked(index, checked) {
        return _.filter(this.allTagNames[index], function (item) {
          return -1 === checked.indexOf(item);
        });
      }
    }, {
      key: 'computeExpression',
      value: function computeExpression(states) {
        if (!states || !this.allTagNames) {
          return rh.model.publish(consts('KEY_TAG_EXPRESSION'), []);
        }

        var groupExprs = _.reduce(states, function (result, value, key) {
          if (_.isString(value)) {
            result.push({ c: [value], u: [] });
          } else if (value != null) {
            var validValues = void 0;
            if ((validValues = _.compact(value)) && validValues.length > 0) {
              result.push({
                c: validValues,
                u: this.getUnchecked(key, validValues)
              });
            }
          }
          return result;
        }, [], this);

        return rh.model.publish(consts('KEY_TAG_EXPRESSION'), groupExprs);
      }
    }, {
      key: 'handleTagStates',
      value: function handleTagStates(states) {
        if (states == null) {
          states = {};
        }
        this.computeExpression(states);

        // Persist new tag state in localDB or cookies
        return storage.persist('tag_states', states);
      }
    }, {
      key: 'prepareTagStates',
      value: function prepareTagStates() {
        var _this = this;

        return rh.model.subscribe(consts('KEY_PROJECT_FILTER_TYPE'), function () {
          var tagStates = void 0;
          if (urlFilter) {
            var filter = rh.model.get(consts('KEY_MERGED_FILTER_KEY'));
            tagStates = _this.parseUrlFilter(filter, urlFilter.split(ELEMENT_SEPARATOR));
          }

          if (!tagStates) {
            tagStates = storage.fetch('tag_states');
          }

          if (!tagStates) {
            tagStates = _.clone(rh.model.get(consts('KEY_DEFAULT_FILTER')));
          }

          if (tagStates) {
            return rh.model.publish(consts('KEY_PROJECT_TAG_STATES'), tagStates);
          }
        });
      }
    }, {
      key: 'parseFilterElemnt',
      value: function parseFilterElemnt(filter, element) {
        var temp = element.split(GRP_SEPARATOR);
        var name = temp[0];
        var elements = temp[1] && temp[1].split(TAG_SEPARATOR);
        var index = _.findIndex(filter, function (item) {
          return elements != null === (item.children != null) && item.display === name;
        });
        return { index: index, elements: elements };
      }
    }, {
      key: 'parseUrlFilter',
      value: function parseUrlFilter(filter, array) {
        if (!array && !array.length) {
          return;
        }
        var radioMode = rh.model.get(consts('KEY_PROJECT_FILTER_TYPE')) === 'radio';
        var firstString = true;
        return _.reduce(array, function (result, element, index) {
          var elements = void 0;

          var _parseFilterElemnt = this.parseFilterElemnt(filter, element);

          index = _parseFilterElemnt.index;
          elements = _parseFilterElemnt.elements;

          if (index !== -1) {
            var node = filter[index];
            if (node.children) {
              result[index] = this.parseUrlFilter(node.children, elements);
            } else if (!radioMode || firstString) {
              firstString = false;
              result[index] = node.name;
            }
          }
          return result;
        }, {}, this);
      }
    }]);

    return ExpressionBuilder;
  }();
  ExpressionBuilder.initClass();
  return ExpressionBuilder;
}();

rh.widgets.ExpressionBuilder = ExpressionBuilder;

},{}],9:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _window = window,
    rh = _window.rh;
var _ = rh._;
var $ = rh.$;
var consts = rh.consts;


var FilterController = function () {
  var GROUP_CLASS = undefined;
  var ITEM_CLASS = undefined;
  var KEY_PROJECT_FILTER_TYPE = undefined;
  FilterController = function () {
    _createClass(FilterController, null, [{
      key: 'initClass',
      value: function initClass() {

        GROUP_CLASS = 'group';
        ITEM_CLASS = 'item';
        KEY_PROJECT_FILTER_TYPE = consts('KEY_PROJECT_FILTER_TYPE');
      }
    }]);

    function FilterController(widget) {
      _classCallCheck(this, FilterController);

      this.click = this.click.bind(this);
      this.widget = widget;
    }

    _createClass(FilterController, [{
      key: 'click',
      value: function click(e) {
        var topNode = e.currentTarget;
        var clickNode = e.target;
        var node = this.getItemNode(clickNode, topNode);
        var selTagExprsPath = '' + consts('KEY_PROJECT_TAG_STATES') + this.getItemKey(node);
        var selTagExprs = this.widget.get(selTagExprsPath);
        if (this.filterType() !== 'radio') {
          this.handleCheckboxClick(node, selTagExprsPath, selTagExprs);
        } else {
          this.handleRadioClick(node, selTagExprsPath, selTagExprs);
        }
        return _.preventDefault(e);
      }
    }, {
      key: 'handleRadioClick',
      value: function handleRadioClick(node, selTagExprsPath, selTagExprs) {
        if (!this.isGroupNode(node) && !selTagExprs) {
          var _$splitKey = _.splitKey(selTagExprsPath),
              parentKey = _$splitKey.parentKey,
              key = _$splitKey.key;

          var newValue = {};
          newValue[key] = this.getItemValue(node);
          return this.widget.publish(parentKey, newValue);
        }
      }
    }, {
      key: 'handleCheckboxClick',
      value: function handleCheckboxClick(node, selTagExprsPath, selTagExprs) {
        var newValue = void 0;
        if (this.isGroupNode(node)) {
          var checked = _.any(selTagExprs, function (tagExpr) {
            return tagExpr;
          });
          newValue = checked ? undefined : this.getGroupItemExprs(node);
          return this.widget.publish(selTagExprsPath, newValue);
        } else {
          newValue = selTagExprs ? undefined : this.getItemValue(node);
          return this.widget.publish(selTagExprsPath, newValue);
        }
      }
    }, {
      key: 'getItemNode',
      value: function getItemNode(node, topNode) {
        return _.findParentNode(node, topNode, function (node) {
          return $.nodeName(node) === 'LI';
        });
      }
    }, {
      key: 'getItemValue',
      value: function getItemValue(node) {
        return $.dataset(node, 'itemvalue');
      }
    }, {
      key: 'getGroupItemExprs',
      value: function getGroupItemExprs(node) {
        var key = $.dataset(node, 'itemkey');
        var groupTag = this.widget.get('' + this.widget.key + key);
        return _.map(groupTag.children, function (tag) {
          return tag.name;
        });
      }
    }, {
      key: 'getItemKey',
      value: function getItemKey(node) {
        return $.dataset(node, 'itemkey');
      }
    }, {
      key: 'isGroupNode',
      value: function isGroupNode(node) {
        return $.hasClass(node, GROUP_CLASS);
      }
    }, {
      key: 'isItemNode',
      value: function isItemNode(node) {
        return $.hasClass(node, ITEM_CLASS);
      }
    }, {
      key: 'class',
      value: function _class(item) {
        if (item.children) {
          return GROUP_CLASS;
        } else {
          return ITEM_CLASS;
        }
      }
    }, {
      key: 'value',
      value: function value(item) {
        if (item.children) {
          return null;
        } else {
          return item.name;
        }
      }
    }, {
      key: 'filterType',
      value: function filterType() {
        return this.widget.get(KEY_PROJECT_FILTER_TYPE) || 'checkbox';
      }
    }, {
      key: 'inputType',
      value: function inputType(item) {
        var type = this.filterType();
        if (item.children && type === 'radio') {
          type = undefined;
        }
        return type;
      }
    }]);

    return FilterController;
  }();
  FilterController.initClass();
  return FilterController;
}();

rh.controller('FilterController', FilterController);

},{}],10:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _window = window,
    rh = _window.rh;
var model = rh.model;
var _ = rh._;
var consts = rh.consts;
var apiClient = rh.apiClient;
var rhs = rh.rhs;


var FilterReport = function () {
  var getPostUrl = undefined;
  FilterReport = function () {
    _createClass(FilterReport, null, [{
      key: 'initClass',
      value: function initClass() {

        getPostUrl = function getPostUrl() {
          var host = document.location.origin;
          var baseContext = model.get(consts('KEY_PUBLISH_BASE_URL')).substr(host.length);
          if (baseContext && !_.isEmptyString(baseContext)) {
            var hashString = _.mapToEncodedString(_.extend(_.addPathNameKey({ area: rhs.area(),
              prj: rhs.project(), type: rhs.type(), agt: 'fltRpt', mgr: 'agm'
            })));
            return baseContext + '?' + hashString;
          }
        };
      }
    }]);

    function FilterReport() {
      _classCallCheck(this, FilterReport);

      var timer = 3000;
      model.subscribeOnce(consts('EVT_PROJECT_LOADED'), function () {
        return model.subscribeOnce(consts('KEY_PUBLISH_MODE'), function (val) {
          if (!val) {
            return;
          }
          var url = url || getPostUrl();
          var ckTags = [];
          var postToServer = _.debounce(function () {
            return apiClient.post(url, JSON.stringify(ckTags)).error(function (data, status) {
              if (rh._debug) {
                return rh._d('error', 'Filter report status ', status);
              }
            });
          }, timer, false);

          return model.subscribe(consts('KEY_TAG_EXPRESSION'), function (expr) {
            ckTags = [];
            var filterData = rh.model.get(consts('KEY_MERGED_FILTER_KEY'));
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
              for (var _iterator = Array.from(expr)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var tags = _step.value;
                var _iteratorNormalCompletion2 = true;
                var _didIteratorError2 = false;
                var _iteratorError2 = undefined;

                try {
                  for (var _iterator2 = Array.from(tags.c)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                    var tag = _step2.value;

                    var tagData;
                    if (tagData = rh.filterObject.lookup(filterData, tag, false)) {
                      ckTags.push(tagData.display);
                    }
                  }
                } catch (err) {
                  _didIteratorError2 = true;
                  _iteratorError2 = err;
                } finally {
                  try {
                    if (!_iteratorNormalCompletion2 && _iterator2.return) {
                      _iterator2.return();
                    }
                  } finally {
                    if (_didIteratorError2) {
                      throw _iteratorError2;
                    }
                  }
                }
              }
            } catch (err) {
              _didIteratorError = true;
              _iteratorError = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion && _iterator.return) {
                  _iterator.return();
                }
              } finally {
                if (_didIteratorError) {
                  throw _iteratorError;
                }
              }
            }

            if (ckTags.length > 0) {
              return postToServer();
            }
          });
        });
      });
    }

    return FilterReport;
  }();
  FilterReport.initClass();
  return FilterReport;
}();

new FilterReport();

},{}],11:[function(require,module,exports){
'use strict';

var _window = window,
    rh = _window.rh;
var _ = rh._;
var $ = rh.$;
var consts = rh.consts;
var model = rh.model;


model.publish(consts('KEY_SHOW_TAGS'), rh._params.showtags === 'true');
model.publish(consts('KEY_IFRAME_EVENTS'), { click: true });

var oldHashMap = {};
var hashChanged = function hashChanged() {
  var newHashMap = _.hashParams();
  model.publish(consts('EVT_HASH_CHANGE'), { oldMap: oldHashMap, newMap: newHashMap }, { sync: true });
  return oldHashMap = newHashMap;
};

var redirectToDefaultTopic = function redirectToDefaultTopic() {
  var paramsStr = _.extractParamString(document.location.href);
  var paramsMap = _.urlParams(paramsStr);
  var hashStr = _.extractHashString(document.location.href);
  var hashMap = _.hashParams(hashStr);
  var mapnoattr = consts('RHMAPNO');
  var topicKey = consts('HASH_KEY_TOPIC');
  if (!(mapnoattr in paramsMap) && !(topicKey in hashMap)) {
    return document.location = consts('DEFAULT_TOPIC');
  }
};

_.addEventListener(window, 'hashchange', hashChanged);

_.addEventListener(window, 'orientationchange', function (e) {
  model.publish(consts('EVT_ORIENTATION_CHANGE'), null);
  if (model.get(consts('KEY_SCREEN_IPAD'))) {
    var topicFrame = void 0;
    if (topicFrame = _.getTopicFrame()) {
      var display = topicFrame.style.display;

      topicFrame.style.display = 'none';
      topicFrame.offsetHeight;
      return _.defer(function () {
        topicFrame.style.display = display;
        return _.delay(function () {
          topicFrame.offsetHeight;
          return _.delay(function () {
            return (// Let try once more
              topicFrame.offsetHeight
            );
          }, 500);
        }, 200);
      });
    }
  }
});

// TODO
//model.subscribe consts('EVT_ORIENTATION_CHANGE'), _.debounce ->
//  meta = $('meta[name=viewport]', 0)
//  meta.content = "width=#{window.innerWidth}, initial-scale=1,
//  maximum-scale=3, user-scalable=yes"
//  if model.get consts 'KEY_SCREEN_IOS'
//    model.publish consts('EVT_RELOAD_TOPIC'), null
//, 250

model.subscribe(consts('EVT_WIDGET_LOADED'), function () {
  // Create ExpressionBuilder widget on every page
  var topicFrame = void 0;
  model.subscribe(consts('KEY_MERGED_FILTER_KEY'), function () {
    return new rh.widgets.ExpressionBuilder();
  });

  // Create BrowseSequenceBuilder widget on every page
  new rh.widgets.BrowseSequenceBuilder();

  hashChanged();

  // replace default print method to support iFrame
  rh.layoutPrint = window.print;
  window.print = function () {
    return (
      // publish it with null value, to stop the autmatic subscribe calls
      model.publish(consts('EVT_PRINT_TOPIC'), null)
    );
  };

  var topicFileName = _.getFileName(document.location.href);
  if (topicFileName === consts('TOPIC_FILE')) {
    var redirectUrl = redirectToDefaultTopic();
    if (redirectUrl) {
      return redirectUrl;
    }
  }

  if (topicFrame = _.getTopicFrame()) {
    return topicFrame.onload = function () {
      return model.publish(consts('EVT_TOPIC_LOADED'), null);
    };
  } else {
    var paramsStr = _.extractParamString(document.location.href);
    var paramsMap = _.urlParams(paramsStr);
    var mapnoattr = consts('RHMAPNO');
    if (mapnoattr in paramsMap) {
      return document.location = consts('TOPIC_FILE') + "?" + paramsStr;
    }
  }
});
model.subscribe(consts('EVT_BOOKMARK') + '#content_top_placeholder', function () {
  return (
    // Hack #content_top_link clicks and send them to content iframe
    model.publish(consts('EVT_SCROLL_TO_TOP'), null)
  );
});

model.subscribe(consts('KEY_PROJECT_LIST'), function () {
  return rh.filterObject = new rh.MergeProj();
});

model.subscribe(consts('EVT_PROJECT_LOADED'), function () {
  var deviceReady = "deviceready";
  return document.addEventListener(deviceReady, function () {
    if (window.cordova != null) {
      return model.publish(consts('KEY_MOBILE_APP_MODE'), true);
    }
  });
});

model.subscribe(consts('GO_TO_DEFAULT_TOPIC'), function () {
  _.goToDefaultTopic();
});

},{}],12:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var JsLoadingController = function () {
  var rh = undefined;
  var $ = undefined;
  var _ = undefined;
  JsLoadingController = function () {
    _createClass(JsLoadingController, null, [{
      key: 'initClass',
      value: function initClass() {
        var _window = window;
        rh = _window.rh;
        var _rh = rh;
        $ = _rh.$;
        var _rh2 = rh;
        _ = _rh2._;
      }
    }]);

    function JsLoadingController(widget, opts) {
      _classCallCheck(this, JsLoadingController);

      var removeClasses = (opts != null ? opts.removeClasses : undefined) || ['hide-children', 'loading'];
      _.each(removeClasses, function (className) {
        return $.removeClass(widget.node, className);
      });
      _.each(opts != null ? opts.addClasses : undefined, function (className) {
        return $.addClass(widget.node, className);
      });
    }

    return JsLoadingController;
  }();
  JsLoadingController.initClass();
  return JsLoadingController;
}();

window.rh.controller('JsLoadingController', JsLoadingController);

},{}],13:[function(require,module,exports){
'use strict';

var _window = window,
    rh = _window.rh;
var _ = rh._;
var $ = rh.$;
var consts = rh.consts;


rh.model.subscribe(consts('EVT_WIDGET_BEFORELOAD'), function () {
  if ($('a.wShow', 0) !== null) {
    var contentDiv = $('.contenttopic', 0);
    $.setAttribute(contentDiv, 'data-rhwidget', 'Basic');
    return $.setAttribute(contentDiv, 'data-class', 'govt_csh:@.l.csh_mode;govt_nocsh:!@.l.csh_mode');
  }
});

},{}],14:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _window = window,
    rh = _window.rh;
var _ = rh._;
var model = rh.model;
var consts = rh.consts;


var Projects = function () {
  var projectList = undefined;
  var projectsToBeLoaded = undefined;
  var projectQueue = undefined;
  var projDataFile = undefined;
  var REMOTENODE = undefined;
  var PROJNODE = undefined;
  var URL = undefined;
  var loaded = undefined;
  var loadProjectFile = undefined;
  var getProjectList = undefined;
  Projects = function () {
    _createClass(Projects, null, [{
      key: 'initClass',
      value: function initClass() {
        projectList = [];
        projectsToBeLoaded = [];
        projectQueue = [];
        projDataFile = 'projectdata.js';
        REMOTENODE = 'remote';
        PROJNODE = 'project';
        URL = 'url';
        loaded = 0;

        loadProjectFile = function loadProjectFile(curProjPath) {
          var curProjDataFile = curProjPath + '/' + projDataFile;
          return window.xmlJsReader.loadFile(curProjDataFile, function (xmlDoc, curProjPath) {
            var remoteNodes = void 0;
            var len = 0;
            loaded++;
            if (xmlDoc != null) {
              var projXmlNode = xmlDoc.getElementsByTagName(PROJNODE)[0];
              remoteNodes = projXmlNode.getElementsByTagName(REMOTENODE);
              len = remoteNodes.length;
            } else if (curProjPath.length > 0) {
              var index = projectsToBeLoaded.indexOf(curProjPath[0]);
              if (index > -1) {
                projectsToBeLoaded.splice(index, 1);
              }
            }
            _.each(remoteNodes, function (remoteNode) {
              var path = curProjPath + '/' + remoteNode.getAttribute(URL);
              projectList.push(path);
              projectsToBeLoaded.push(path);
              return projectQueue.push(path);
            });
            getProjectList();
            if (projectQueue.length === 0 && loaded === projectList.length) {
              model.publish(consts('KEY_PROJECT_LIST'), projectsToBeLoaded);
              return model.publish(consts('KEY_MASTER_PROJECT_LIST'), ["."]);
            }
          }, curProjPath);
        };

        getProjectList = function getProjectList() {
          return function () {
            var result = [];
            while (projectQueue.length > 0) {
              var project = projectQueue.splice(0, 1);
              result.push(loadProjectFile(project));
            }
            return result;
          }();
        };
      }
    }]);

    function Projects() {
      _classCallCheck(this, Projects);

      projectList.push('.');
      projectsToBeLoaded.push('.');
      projectQueue.push('.');
      getProjectList();
    }

    return Projects;
  }();
  Projects.initClass();
  return Projects;
}();

model.subscribe(consts('EVT_PROJECT_LOADED'), function () {
  return _.defer(function () {
    if (!model.get(consts('KEY_PUBLISH_MODE')) && !window.gbPreviewMode) {
      return new Projects();
    }
  });
});

},{}],15:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ModernLayoutController = function () {
  var rh = undefined;
  var _ = undefined;
  var $ = undefined;
  var consts = undefined;
  var KEY_FEATURE = undefined;
  var KEY_FILTER_LOCATION = undefined;
  var KEY_SEARCH_LOCATION = undefined;
  var KEY_ACTIVE_TAB = undefined;
  var KEY_UI_MODE = undefined;
  var KEY_MOBILE_TOC_DRILL_DOWN = undefined;
  var KEY_TOC_DRILL_DOWN = undefined;
  var DESKTOP = undefined;
  var TABLET = undefined;
  var PHONE = undefined;
  var SHOW_FILTER_UI = undefined;
  var tabs = undefined;
  var sideBarTabs = undefined;
  var delayLoadTabs = undefined;
  ModernLayoutController = function () {
    _createClass(ModernLayoutController, null, [{
      key: 'initClass',
      value: function initClass() {
        var _window = window;
        rh = _window.rh;
        var _rh = rh;
        _ = _rh._;
        var _rh2 = rh;
        $ = _rh2.$;
        var _rh3 = rh;
        consts = _rh3.consts;

        KEY_FEATURE = consts('KEY_FEATURE');
        KEY_FILTER_LOCATION = consts('KEY_FILTER_LOCATION');
        KEY_SEARCH_LOCATION = consts('KEY_SEARCH_LOCATION');
        KEY_ACTIVE_TAB = consts('KEY_ACTIVE_TAB');
        KEY_UI_MODE = consts('KEY_UI_MODE');
        KEY_MOBILE_TOC_DRILL_DOWN = consts('KEY_MOBILE_TOC_DRILL_DOWN');
        KEY_TOC_DRILL_DOWN = consts('KEY_TOC_DRILL_DOWN');
        DESKTOP = 'desktop';
        TABLET = 'tablet';
        PHONE = 'phone';
        SHOW_FILTER_UI = rh._params.hideUI !== 'filter';
        tabs = {
          desktop: ['toc', 'idx', 'glo', 'filter', 'fts'],
          tablet: ['toc', 'idx', 'glo', 'filter', 'fts'],
          phone: ['toc', 'idx', 'glo', 'filter', 'fts']
        };

        sideBarTabs = {
          desktop: ['toc', 'idx', 'glo', 'filter', 'fts'],
          tablet: ['toc', 'idx', 'glo', 'filter', 'fts'],
          phone: ['toc', 'idx', 'glo']
        };
        delayLoadTabs = {
          'idx': { evt: 'EVT_LOAD_IDX', f_key: 'delay_load_idx' },
          'glo': { evt: 'EVT_LOAD_GLO', f_key: 'delay_load_glo' }
        };
      }
    }]);

    function ModernLayoutController(widget) {
      var _this = this;

      _classCallCheck(this, ModernLayoutController);

      this.triggerDelayLoadWidgets = this.triggerDelayLoadWidgets.bind(this);
      this.widget = widget;
      this.init();
      this.subscribeActiveTab();
      this.subscribeToLocations();
      this.subscribeScreens();

      this.widget.subscribe(consts('EVT_PROJECT_LOADED'), function () {
        _this.subscribeUIMode();
        _this.subscribeMergedFilter();
        _this.subscribeTopicClick();
        _this.subscribeTopicScroll();
        _this.subscribForSearchResult();
        _this.subscribeTopicNavigate();
        _this.subscribeToDelayLoadEvents();
        return _this.widget.publish(consts('KEY_IFRAME_EVENTS'), { click: true, scroll: false });
      });
    }

    _createClass(ModernLayoutController, [{
      key: 'init',
      value: function init() {
        this.screens = this.widget.get(consts('KEY_SCREEN_NAMES'));
        rh.storage.init(consts('HELP_ID'));
        this.activeScreen = _.find(this.screens, function (screen) {
          return this.widget.get(consts('KEY_SCREEN') + '.' + screen + '.attached');
        }, this);
        if (this.activeScreen == null) {
          this.activeScreen = this.widget.get(consts('KEY_DEFAULT_SCREEN'));
        }

        this.assureLocations(this.activeScreen);

        this.initDefauls();

        return this.initActiveTab();
      }
    }, {
      key: 'initDefauls',
      value: function initDefauls() {
        var defaultTab = this.widget.get(consts('KEY_DEFAULT_TAB'));
        if (!this.hasFeature(defaultTab)) {
          defaultTab = null;
        }

        this.defaultTabs = {};

        return _.each(this.screens, function (screen) {
          tabs[screen] = _.filter(tabs[screen], function (tab) {
            return this.hasFeature(tab);
          }, this);

          sideBarTabs[screen] = _.filter(sideBarTabs[screen], function (tab) {
            return this.hasFeature(tab);
          }, this);

          return this.defaultTabs[screen] = defaultTab && -1 !== tabs[screen].indexOf(defaultTab) ? defaultTab : tabs[screen][0];
        }, this);
      }
    }, {
      key: 'initActiveTab',
      value: function initActiveTab() {
        var activeTab = rh.storage.fetch('activetab');
        if (activeTab !== undefined && activeTab && this.hasFeature(activeTab)) {
          return this.widget.publish(KEY_ACTIVE_TAB, activeTab);
        }
      }
    }, {
      key: 'isValidTab',
      value: function isValidTab(tab, screen) {
        if (screen == null) {
          screen = this.activeScreen;
        }
        if (!tab || !this.hasFeature(tab)) {
          return false;
        }

        if (screen === DESKTOP) {
          if (tab === 'filter' && 'content' === this.widget.get(KEY_FILTER_LOCATION) || tab === 'fts' && 'content' === this.widget.get(KEY_SEARCH_LOCATION)) {
            return false;
          }
        }

        return -1 !== tabs[screen].indexOf(tab);
      }
    }, {
      key: 'defaultTab',
      value: function defaultTab(screen) {
        if (screen == null) {
          screen = this.activeScreen;
        }
        var defaultTab = this.defaultTabs[screen];
        if (!this.isValidTab(defaultTab)) {
          defaultTab = _.find(tabs[screen], function (tab) {
            return this.isValidTab(tab);
          }, this);
        }
        return defaultTab;
      }
    }, {
      key: 'assureValidActiveTab',
      value: function assureValidActiveTab(screen) {
        if (screen == null) {
          screen = this.activeScreen;
        }
        var activetab = this.widget.get(KEY_ACTIVE_TAB);
        if (screen === DESKTOP || activetab) {
          if (!this.isValidTab(activetab)) {
            activetab = this.defaultTab();
          }
          return this.widget.publish(KEY_ACTIVE_TAB, activetab);
        }
      }
    }, {
      key: 'toggleSideBar',
      value: function toggleSideBar() {
        if (this.widget.get(KEY_ACTIVE_TAB)) {
          return this.widget.publish(KEY_ACTIVE_TAB, null);
        } else {
          return this.widget.publish(KEY_ACTIVE_TAB, this.lastMobileTab || this.defaultTab());
        }
      }
    }, {
      key: 'toggleActiveTab',
      value: function toggleActiveTab(tab) {
        return this.widget.publish(KEY_ACTIVE_TAB, !this.isDesktopScreen() && tab === this.widget.get(KEY_ACTIVE_TAB) ? null : tab);
      }
    }, {
      key: 'triggerDelayLoadWidgets',
      value: function triggerDelayLoadWidgets(tab) {
        var tabObj = delayLoadTabs[tab];
        if (tabObj && this.hasFeature(tabObj.f_key)) {
          return this.widget.publish(consts(tabObj.evt), true);
        }
      }
    }, {
      key: 'subscribeToDelayLoadEvents',
      value: function subscribeToDelayLoadEvents() {
        return this.widget.subscribe(KEY_ACTIVE_TAB, this.triggerDelayLoadWidgets);
      }
    }, {
      key: 'filterDone',
      value: function filterDone() {
        return this.widget.publish(KEY_ACTIVE_TAB, this.searchMode ? 'fts' : null);
      }
    }, {
      key: 'hasFeature',
      value: function hasFeature(feature) {
        return feature === undefined || false !== this.widget.get(KEY_FEATURE + '.' + feature);
      }
    }, {
      key: 'subscribeUIMode',
      value: function subscribeUIMode() {
        var _this2 = this;

        var setSearchTab = function setSearchTab() {
          if (!_this2.isValidTab('fts')) {
            return;
          }
          if (!_this2.isDesktopScreen() || 'tabbar' === _this2.widget.get(KEY_SEARCH_LOCATION)) {
            return _this2.widget.publish(KEY_ACTIVE_TAB, 'fts');
          }
        };

        this.widget.subscribe(KEY_UI_MODE, function (mode) {
          return _this2.widget.publish('active_content', mode);
        });

        this.widget.subscribe('active_content', function (mode) {
          if (_this2.isMobileScreen() && !mode) {
            return _this2.widget.publish(KEY_ACTIVE_TAB, null);
          } else if ('search' === mode) {
            return setSearchTab();
          }
        }, { initDone: true });
        if ('search' === this.widget.get('active_content')) {
          return setSearchTab();
        }
      }
    }, {
      key: 'subscribeMergedFilter',
      value: function subscribeMergedFilter() {
        var _this3 = this;

        var featureFilterKey = void 0;
        if (this.widget.get(featureFilterKey = KEY_FEATURE + '.filter')) {
          return this.widget.subscribe(consts('KEY_MERGED_FILTER_KEY'), function (tags) {
            _this3.widget.publish(featureFilterKey, tags && tags.length && SHOW_FILTER_UI ? true : false);
            return _this3.assureValidActiveTab();
          });
        }
      }
    }, {
      key: 'subscribeTopicClick',
      value: function subscribeTopicClick() {
        var _this4 = this;

        return this.widget.subscribe(consts('EVT_CLICK_INSIDE_IFRAME'), function () {
          if (_this4.activeScreen === PHONE && _this4.widget.get(KEY_ACTIVE_TAB)) {
            return _this4.toggleSideBar();
          }
        });
      }
    }, {
      key: 'subscribeTopicNavigate',
      value: function subscribeTopicNavigate() {
        var _this5 = this;

        return this.widget.subscribe(consts('EVT_NAVIGATE_TO_URL'), function (obj) {
          if (obj.absUrl && _.isUrlAllowdInIframe(obj.absUrl)) {
            return _this5.widget.publish('active_content', null);
          }
        });
      }
    }, {
      key: 'subscribeTopicScroll',
      value: function subscribeTopicScroll() {
        var _this6 = this;

        return this.widget.subscribe(consts('EVT_SCROLL_INSIDE_IFRAME'), function (info) {
          var hide_header = info.dir === 'down' || info.scrollTop > 10;
          _this6.widget.publish('hide_header', hide_header);

          var hide_mobile_functions = info.dir === 'down' && info.scrollTop > 10;
          return _this6.widget.publish('hide_mobile_functions', hide_mobile_functions);
        });
      }
    }, {
      key: 'subscribeActiveTab',
      value: function subscribeActiveTab() {
        var _this7 = this;

        return this.widget.subscribe(KEY_ACTIVE_TAB, function (activeTab) {
          rh.storage.persist('activetab', activeTab);
          _this7.setFocusInTab(activeTab);
          if (_this7.isMobileScreen()) {
            if (_this7.isSidebarTab(activeTab)) {
              _this7.lastMobileTab = activeTab;
            }
            return _this7.searchMode = activeTab === 'fts' || _this7.searchMode && activeTab === 'filter';
          } else {
            return _this7.searchMode = false;
          }
        });
      }
    }, {
      key: 'setFocusInTab',
      value: function setFocusInTab(tab) {
        var className;
        switch (tab) {
          case 'fts':
            className = 'wSearchField';
            break;
          case 'idx':
            className = 'IdxFilter';
            break;
          case 'glo':
            className = 'GloFilter';
            break;

          default:
            return;
        }
        var inputElement = document.getElementsByClassName(className);
        if (inputElement && inputElement.length) {
          _.defer(function () {
            inputElement[0].focus();
          });
        }
      }
    }, {
      key: 'subscribeScreens',
      value: function subscribeScreens() {
        return _.each(this.screens, function (screen) {
          var _this8 = this;

          var key = consts('KEY_SCREEN') + '.' + screen + '.attached';
          if (this.widget.get(key)) {
            this.handleScreen(true, screen);
          }
          return this.widget.subscribe(key, function (attached) {
            return _this8.handleScreen(attached, screen);
          }, { initDone: true });
        }, this);
      }
    }, {
      key: 'subscribeToLocations',
      value: function subscribeToLocations() {
        var _this9 = this;

        this.widget.subscribe(KEY_SEARCH_LOCATION, function () {
          return _this9.assureValidActiveTab(_this9.activeScreen);
        });

        return this.widget.subscribe(KEY_FILTER_LOCATION, function () {
          return _this9.assureValidActiveTab(_this9.activeScreen);
        });
      }
    }, {
      key: 'subscribForSearchResult',
      value: function subscribForSearchResult() {
        var _this10 = this;

        var updateSearchResults = function updateSearchResults() {
          var tagExpr = _this10.widget.get(consts('KEY_TAG_EXPRESSION'));
          var searchTagExpr = _this10.widget.get(consts('KEY_ONSEARCH_TAG_EXPR'));
          if (searchTagExpr && searchTagExpr !== JSON.stringify(tagExpr)) {
            return _this10.widget.publish(consts('EVT_SEARCH_TERM'), true);
          }
        };

        this.widget.subscribe(consts('KEY_TAG_EXPRESSION'), _.debounce(function () {
          if (_this10.isValidTab('fts') && 'fts' !== _this10.widget.get(KEY_ACTIVE_TAB)) {
            return;
          }
          if (!_this10.isSearchMode(_this10.widget.get(KEY_ACTIVE_TAB))) {
            return;
          }

          return updateSearchResults();
        }, 300));

        return this.widget.subscribe(KEY_ACTIVE_TAB, function (tab) {
          if (tab === 'fts') {
            return updateSearchResults();
          }
        });
      }
    }, {
      key: 'isMobileScreen',
      value: function isMobileScreen() {
        return this.activeScreen === PHONE;
      }
    }, {
      key: 'isDesktopScreen',
      value: function isDesktopScreen() {
        return this.activeScreen === DESKTOP;
      }
    }, {
      key: 'isTabletScreen',
      value: function isTabletScreen() {
        return this.activeScreen === TABLET;
      }
    }, {
      key: 'isSidebarTab',
      value: function isSidebarTab(tab) {
        return tab && -1 !== sideBarTabs[this.activeScreen].indexOf(tab);
      }
    }, {
      key: 'isSearchMode',
      value: function isSearchMode(tab) {
        var topicTab = this.widget.get('active_content');
        return tab === 'fts' || topicTab === 'search' && this.isDesktopScreen() && 'content' === this.widget.get(KEY_SEARCH_LOCATION);
      }
    }, {
      key: 'handleScreen',
      value: function handleScreen(attached, screen) {
        if (attached) {
          this.activeScreen = screen;
          return this.handleAttached(screen);
        } else {
          return this.handleDetached(screen);
        }
      }
    }, {
      key: 'handleDetached',
      value: function handleDetached(screen) {
        var _this11 = this;

        return _.defer(function () {
          if (screen === DESKTOP) {
            return _this11.widget.publish(KEY_ACTIVE_TAB, 'search' === _this11.widget.get('active_content') && _this11.isValidTab('fts') ? 'fts' : null);
          }
        });
      }
    }, {
      key: 'handleAttached',
      value: function handleAttached(screen) {
        this.assureLocations(screen);
        this.assureValidActiveTab(screen);
        return this.assureTOCMode(screen);
      }
    }, {
      key: 'assureLocations',
      value: function assureLocations(screen) {
        if (screen == null) {
          screen = this.activeScreen;
        }
        this.widget.publish(KEY_SEARCH_LOCATION, screen === DESKTOP ? this.widget.get(consts('KEY_DEFAULT_SEARCH_LOCATION')) : screen === TABLET ? 'tabbar' : 'content');
        return this.widget.publish(KEY_FILTER_LOCATION, screen === DESKTOP || screen === TABLET ? 'tabbar' : 'content');
      }
    }, {
      key: 'assureTOCMode',
      value: function assureTOCMode(screen) {
        if (screen == null) {
          screen = this.activeScreen;
        }
        return this.widget.publish(KEY_TOC_DRILL_DOWN, screen !== DESKTOP && this.widget.get(KEY_MOBILE_TOC_DRILL_DOWN));
      }
    }, {
      key: 'newSearch',
      value: function newSearch(text, keyCode, event) {
        return;
        if (keyCode === 13) {
          var oldText = this.widget.get(consts('KEY_SEARCH_TERM'));
          if (oldText !== text) {
            this.widget.publish(consts('KEY_SEARCH_TERM'), text);
          }
          this.widget.publish(consts('EVT_SEARCH_TERM'), true);
          if (event != null ? event.target : undefined) {
            return event.target.blur();
          }
        }
      }
    }, {
      key: 'isTagStatesChanged',
      value: function isTagStatesChanged() {
        var currentState = _.compactObject(this.widget.get(consts('KEY_PROJECT_TAG_STATES')));
        var defaultState = _.compactObject(this.widget.get(consts('KEY_DEFAULT_FILTER')));
        return !_.isEqual(currentState, defaultState);
      }
    }, {
      key: 'setDefaultTagStates',
      value: function setDefaultTagStates() {
        var defaultState = this.widget.get(consts('KEY_DEFAULT_FILTER'));
        return this.widget.publish(consts('KEY_PROJECT_TAG_STATES'), _.clone(defaultState));
      }
    }]);

    return ModernLayoutController;
  }();
  ModernLayoutController.initClass();
  return ModernLayoutController;
}();

window.rh.controller('ModernLayoutController', ModernLayoutController);

},{}],16:[function(require,module,exports){
'use strict';

// Generated by CoffeeScript 1.9.1
(function () {
  var MergeProj, _, consts, model, rh;

  rh = window.rh;

  model = rh.model;

  _ = rh._;

  consts = rh.consts;

  MergeProj = function () {
    var group;

    function MergeProj() {
      this.tagCombs = [];
      this.idmap = {};
      this.filter = [];
      this.grpType = 'group';
      this.dataLoaded = false;
      this.loadTagData(model.get(consts('KEY_PROJECT_LIST')));
      this.caption = this.type = this.defFilter = void 0;
    }

    MergeProj.prototype.updateTagCombs = function (project) {
      var base, combs;
      combs = model.get(consts('KEY_PROJECT_TAG_COMBINATIONS'));
      if (combs != null) {
        project = _.parseProjectName(project);
        return (base = this.idmap)[project] != null ? base[project] : base[project] = combs;
      }
    };

    MergeProj.prototype.lookup = function (children, key, isGrpType) {
      var child, compKey, element, i, len;
      if (isGrpType == null) {
        isGrpType = true;
      }
      if (children != null && key != null) {
        for (i = 0, len = children.length; i < len; i++) {
          child = children[i];
          if (!(child != null)) {
            continue;
          }
          compKey = child.name || child.display;
          if (isGrpType === (child.children != null) && compKey === key) {
            element = child;
          } else if (child.children != null && !isGrpType) {
            element = this.lookup(child.children, key, isGrpType);
          }
          if (element != null) {
            break;
          }
        }
      }
      return element;
    };

    group = function group(disp) {
      var object;
      return object = {
        type: 'group',
        display: disp,
        children: []
      };
    };

    MergeProj.prototype.addTag = function (childArr, tagElement) {
      var tag;
      if (this.lookup(this.filter, tagElement.name, false) == null) {
        tag = {
          display: tagElement.display,
          name: tagElement.name
        };
        return childArr.push(tag);
      }
    };

    MergeProj.prototype.addGroup = function (grpElement) {
      var element, grp, i, len, ref;
      grp = this.lookup(this.filter, grpElement.display);
      if (grp == null) {
        grp = group(grpElement.display);
        this.filter.push(grp);
      }
      ref = grpElement.children;
      for (i = 0, len = ref.length; i < len; i++) {
        element = ref[i];
        if (element != null) {
          if (element.children == null) {
            this.addTag(grp.children, element);
          }
        }
      }
      if (grp.children.length === 0 && this.filter.indexOf(grp) > -1) {
        return this.filter.splice(this.filter.indexOf(grp), 1);
      }
    };

    MergeProj.prototype.updateFilter = function (event) {
      var curfilter, element, i, len, results;
      curfilter = _.extractTempData(event, model, {});
      if (!this.caption) {
        this.caption = curfilter['caption'];
      }
      if (!this.type) {
        this.type = curfilter['type'];
      }
      if (typeof this.defFilter === 'undefined') {
        this.defFilter = curfilter['default'];
      }
      curfilter = curfilter['tags'] || [];
      results = [];
      for (i = 0, len = curfilter.length; i < len; i++) {
        element = curfilter[i];
        if (element != null) {
          if (element.children != null) {
            results.push(this.addGroup(element));
          } else {
            results.push(this.addTag(this.filter, element));
          }
        }
      }
      return results;
    };

    MergeProj.prototype.onLoadScript = function (event, project, count) {
      this.updateTagCombs(project);
      this.updateFilter(event);
      if (!count) {
        model.publish(consts('KEY_MERGED_FILTER_KEY'), this.filter);
        model.publish(consts('KEY_MERGED_PROJECT_MAP'), this.idmap);
        model.publish(consts('KEY_PROJECT_FILTER_CAPTION'), this.caption);
        model.publish(consts('KEY_PROJECT_FILTER_TYPE'), this.type);
        model.publish(consts('KEY_DEFAULT_FILTER'), this.defFilter);
        return this.dataLoaded = true;
      }
    };

    MergeProj.prototype.loadTagData = function (projList) {
      var count, i, len, project, results;
      if (!this.dataLoaded) {
        count = projList.length;
        results = [];
        var data = { project: project, count: count };
        for (i = 0, len = projList.length; i < len; i++) {
          project = projList[i];
          if (project != null) {
            if (project) {
              project = project + "/";
            }
            data.project = project;
            results.push(_.loadScript("" + project + consts('PATH_PROJECT_TAGDATA_FILE'), false, this.getLoadCallback(data)));
          } else {
            results.push(void 0);
          }
        }
        return results;
      }
    };

    MergeProj.prototype.getLoadCallback = function (data) {
      var _this = this;

      var proj = data.project;
      return function (event) {
        return _this.onLoadScript(event, proj, --data.count);
      };
    };

    return MergeProj;
  }();

  rh.MergeProj = MergeProj;
}).call(undefined);

},{}],17:[function(require,module,exports){
'use strict';

var _window = window,
    rh = _window.rh;
var _ = rh._;
var consts = rh.consts;
var model = rh.model;

var unsub = null;

unsub = model.subscribe(consts('KEY_TAG_EXPRESSION'), function () {
  var done = false;
  return function () {
    if (unsub) {
      unsub();
    }
    if (done) {
      return;
    }
    done = true;
    return model.subscribe(consts('KEY_SEARCHED_TERM'), function () {
      return model.publish(consts('KEY_ONSEARCH_TAG_EXPR'), JSON.stringify(model.get(consts('KEY_TAG_EXPRESSION'))));
    });
  };
}());

model.subscribe(consts('EVT_SEARCH_TERM'), function () {
  var canHandleSearch = model.get(consts('KEY_CAN_HANDLE_SEARCH'));
  var searchTerm = model.get(consts('KEY_SEARCH_TERM')) || null;
  var newMap = {};
  newMap[consts('HASH_KEY_RH_SEARCH')] = searchTerm;
  newMap[consts('HASH_KEY_UIMODE')] = 'search';
  model.publish(consts('DESKTOP_SIDEBAR_VISIBLE'), true);
  var searchResultInTabbar = model.get(consts('KEY_DEFAULT_SEARCH_LOCATION')) === 'tabbar';
  if (searchResultInTabbar) {
    model.publish(consts('KEY_ACTIVE_TAB'), 'fts');
  }

  var hlTerm = _.urlParam(consts('HASH_KEY_RH_HIGHLIGHT'), document.location.href);
  if (searchTerm !== hlTerm) {
    newMap[consts('HASH_KEY_RH_HIGHLIGHT')] = '';
  }
  if (canHandleSearch !== true) {
    return document.location = window.gRootRelPath + '/' + ('' + (window.gSearchPageFilePath || consts('START_FILEPATH'))) + ('?#' + _.mapToEncodedString(newMap));
  } else {
    model.publish(consts('EVT_QUERY_SEARCH_RESULTS'), true);
    return _.defer(function () {
      return _.updateHashMap(newMap, true);
    });
  }
});

model.subscribe(consts('EVT_PROJECT_LOADED'), function () {
  if (rh.model.get(rh.consts('KEY_CLASSIC_OUTPUT'))) {
    window.readSetting(RHANDSEARCH, function (state) {
      return model.publish(consts('KEY_AND_SEARCH'), state);
    });
  }
  return model.subscribe(consts('KEY_AND_SEARCH'), function (state) {
    if (rh.model.get(rh.consts('KEY_CLASSIC_OUTPUT'))) {
      return saveSetting(RHANDSEARCH, state === '1' ? '1' : '0', true);
    }
  });
});
model.subscribe(consts('EVT_QUERY_SEARCH_RESULTS'), function () {
  if (rh.model.get(rh.consts('KEY_CLASSIC_OUTPUT'))) {
    return window.doSearch();
  }
});

},{}],18:[function(require,module,exports){
'use strict';

var _window = window,
    rh = _window.rh;
var _ = rh._;
var $ = rh.$;
var consts = rh.consts;
var model = rh.model;


_.getRootUrl = function () {
  var rootUrl = null;
  return function () {
    return rootUrl != null ? rootUrl : rootUrl = '' + _.getHostFolder() + consts('START_FILEPATH');
  };
}();

_.getDefaultTopic = function (callback) {
  var gDefaultTopic = window.gDefaultTopic && window.gDefaultTopic.substring(1);
  if (gDefaultTopic && gDefaultTopic.endsWith("rhpj")) {
    var projPath = './mergedProjects/' + gDefaultTopic.substring(0, gDefaultTopic.length - 5);
    var filePath = projPath + '/whxdata/projectsettings.js';
    _.loadScript(filePath, true, function () {
      gDefaultTopic = _.exports();
      gDefaultTopic = projPath + '/' + gDefaultTopic;
      window.gDefaultTopic = '#' + gDefaultTopic;
      callback(gDefaultTopic);
    });
  } else {
    callback(gDefaultTopic);
  }
};

_.runTopicLoadingAnimation = function () {
  var runAnimation = null;
  var topicLoading = false;
  return function (flag) {
    topicLoading = flag;
    if (flag) {
      if (runAnimation == null) {
        runAnimation = _.debounce(function () {
          return model.publish(consts('EVT_TOPIC_LOADING'), topicLoading);
        }, 700);
      }
      return runAnimation();
    } else {
      runAnimation = null;
      return model.publish(consts('EVT_TOPIC_LOADING'), false);
    }
  };
}();

_.getTopicFrame = function () {
  var topicFrameName = window.gTopicFrameName || 'rh_default_topic_frame_name';
  return $('[name=' + topicFrameName + ']', 0);
};

_.goToDefaultTopic = function () {
  var newMap = {};
  _.getDefaultTopic(function (defaultTopic) {
    newMap[consts('HASH_KEY_TOPIC')] = defaultTopic;
    _.updateHashMap(newMap, true);
  });
  return false;
};

},{}],19:[function(require,module,exports){
//----------------------------------------------------------------------
//
// ECMAScript 5 Polyfills
//
//----------------------------------------------------------------------

//----------------------------------------------------------------------
// ES5 15.2 Object Objects
//----------------------------------------------------------------------

//
// ES5 15.2.3 Properties of the Object Constructor
//

// ES5 15.2.3.2 Object.getPrototypeOf ( O )
// From http://ejohn.org/blog/objectgetprototypeof/
// NOTE: won't work for typical function T() {}; T.prototype = {}; new T; case
// since the constructor property is destroyed.
if (!Object.getPrototypeOf) {
  Object.getPrototypeOf = function (o) {
    if (o !== Object(o)) { throw TypeError("Object.getPrototypeOf called on non-object"); }
    return o.__proto__ || o.constructor.prototype || Object.prototype;
  };
}

//    // ES5 15.2.3.3 Object.getOwnPropertyDescriptor ( O, P )
//    if (typeof Object.getOwnPropertyDescriptor !== "function") {
//        Object.getOwnPropertyDescriptor = function (o, name) {
//            if (o !== Object(o)) { throw TypeError(); }
//            if (o.hasOwnProperty(name)) {
//                return {
//                    value: o[name],
//                    enumerable: true,
//                    writable: true,
//                    configurable: true
//                };
//            }
//        };
//    }

// ES5 15.2.3.4 Object.getOwnPropertyNames ( O )
if (typeof Object.getOwnPropertyNames !== "function") {
  Object.getOwnPropertyNames = function (o) {
    if (o !== Object(o)) { throw TypeError("Object.getOwnPropertyNames called on non-object"); }
    var props = [], p;
    for (p in o) {
      if (Object.prototype.hasOwnProperty.call(o, p)) {
        props.push(p);
      }
    }
    return props;
  };
}

// ES5 15.2.3.5 Object.create ( O [, Properties] )
if (typeof Object.create !== "function") {
  Object.create = function (prototype, properties) {
    if (typeof prototype !== "object") { throw TypeError(); }
    function Ctor() {}
    Ctor.prototype = prototype;
    var o = new Ctor();
    if (prototype) { o.constructor = Ctor; }
    if (properties !== undefined) {
      if (properties !== Object(properties)) { throw TypeError(); }
      Object.defineProperties(o, properties);
    }
    return o;
  };
}

// ES 15.2.3.6 Object.defineProperty ( O, P, Attributes )
// Partial support for most common case - getters, setters, and values
(function() {
  if (!Object.defineProperty ||
      !(function () { try { Object.defineProperty({}, 'x', {}); return true; } catch (e) { return false; } } ())) {
    var orig = Object.defineProperty;
    Object.defineProperty = function (o, prop, desc) {
      // In IE8 try built-in implementation for defining properties on DOM prototypes.
      if (orig) { try { return orig(o, prop, desc); } catch (e) {} }

      if (o !== Object(o)) { throw TypeError("Object.defineProperty called on non-object"); }
      if (Object.prototype.__defineGetter__ && ('get' in desc)) {
        Object.prototype.__defineGetter__.call(o, prop, desc.get);
      }
      if (Object.prototype.__defineSetter__ && ('set' in desc)) {
        Object.prototype.__defineSetter__.call(o, prop, desc.set);
      }
      if ('value' in desc) {
        o[prop] = desc.value;
      }
      return o;
    };
  }
}());

// ES 15.2.3.7 Object.defineProperties ( O, Properties )
if (typeof Object.defineProperties !== "function") {
  Object.defineProperties = function (o, properties) {
    if (o !== Object(o)) { throw TypeError("Object.defineProperties called on non-object"); }
    var name;
    for (name in properties) {
      if (Object.prototype.hasOwnProperty.call(properties, name)) {
        Object.defineProperty(o, name, properties[name]);
      }
    }
    return o;
  };
}


// ES5 15.2.3.14 Object.keys ( O )
// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object/keys
if (!Object.keys) {
  Object.keys = function (o) {
    if (o !== Object(o)) { throw TypeError('Object.keys called on non-object'); }
    var ret = [], p;
    for (p in o) {
      if (Object.prototype.hasOwnProperty.call(o, p)) {
        ret.push(p);
      }
    }
    return ret;
  };
}

//----------------------------------------------------------------------
// ES5 15.3 Function Objects
//----------------------------------------------------------------------

//
// ES5 15.3.4 Properties of the Function Prototype Object
//

// ES5 15.3.4.5 Function.prototype.bind ( thisArg [, arg1 [, arg2, ... ]] )
// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function/bind
if (!Function.prototype.bind) {
  Function.prototype.bind = function (o) {
    if (typeof this !== 'function') { throw TypeError("Bind must be called on a function"); }

    var args = Array.prototype.slice.call(arguments, 1),
        self = this,
        nop = function() {},
        bound = function () {
          return self.apply(this instanceof nop ? this : o,
                            args.concat(Array.prototype.slice.call(arguments)));
        };

    if (this.prototype)
      nop.prototype = this.prototype;
    bound.prototype = new nop();
    return bound;
  };
}


//----------------------------------------------------------------------
// ES5 15.4 Array Objects
//----------------------------------------------------------------------

//
// ES5 15.4.3 Properties of the Array Constructor
//


// ES5 15.4.3.2 Array.isArray ( arg )
// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/isArray
Array.isArray = Array.isArray || function (o) { return Boolean(o && Object.prototype.toString.call(Object(o)) === '[object Array]'); };


//
// ES5 15.4.4 Properties of the Array Prototype Object
//

// ES5 15.4.4.14 Array.prototype.indexOf ( searchElement [ , fromIndex ] )
// From https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/indexOf
if (!Array.prototype.indexOf) {
  Array.prototype.indexOf = function (searchElement /*, fromIndex */) {
    if (this === void 0 || this === null) { throw TypeError(); }

    var t = Object(this);
    var len = t.length >>> 0;
    if (len === 0) { return -1; }

    var n = 0;
    if (arguments.length > 0) {
      n = Number(arguments[1]);
      if (isNaN(n)) {
        n = 0;
      } else if (n !== 0 && n !== (1 / 0) && n !== -(1 / 0)) {
        n = (n > 0 || -1) * Math.floor(Math.abs(n));
      }
    }

    if (n >= len) { return -1; }

    var k = n >= 0 ? n : Math.max(len - Math.abs(n), 0);

    for (; k < len; k++) {
      if (k in t && t[k] === searchElement) {
        return k;
      }
    }
    return -1;
  };
}

// ES5 15.4.4.15 Array.prototype.lastIndexOf ( searchElement [ , fromIndex ] )
// From https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/lastIndexOf
if (!Array.prototype.lastIndexOf) {
  Array.prototype.lastIndexOf = function (searchElement /*, fromIndex*/) {
    if (this === void 0 || this === null) { throw TypeError(); }

    var t = Object(this);
    var len = t.length >>> 0;
    if (len === 0) { return -1; }

    var n = len;
    if (arguments.length > 1) {
      n = Number(arguments[1]);
      if (n !== n) {
        n = 0;
      } else if (n !== 0 && n !== (1 / 0) && n !== -(1 / 0)) {
        n = (n > 0 || -1) * Math.floor(Math.abs(n));
      }
    }

    var k = n >= 0 ? Math.min(n, len - 1) : len - Math.abs(n);

    for (; k >= 0; k--) {
      if (k in t && t[k] === searchElement) {
        return k;
      }
    }
    return -1;
  };
}

// ES5 15.4.4.16 Array.prototype.every ( callbackfn [ , thisArg ] )
// From https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/every
if (!Array.prototype.every) {
  Array.prototype.every = function (fun /*, thisp */) {
    if (this === void 0 || this === null) { throw TypeError(); }

    var t = Object(this);
    var len = t.length >>> 0;
    if (typeof fun !== "function") { throw TypeError(); }

    var thisp = arguments[1], i;
    for (i = 0; i < len; i++) {
      if (i in t && !fun.call(thisp, t[i], i, t)) {
        return false;
      }
    }

    return true;
  };
}

// ES5 15.4.4.17 Array.prototype.some ( callbackfn [ , thisArg ] )
// From https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/some
if (!Array.prototype.some) {
  Array.prototype.some = function (fun /*, thisp */) {
    if (this === void 0 || this === null) { throw TypeError(); }

    var t = Object(this);
    var len = t.length >>> 0;
    if (typeof fun !== "function") { throw TypeError(); }

    var thisp = arguments[1], i;
    for (i = 0; i < len; i++) {
      if (i in t && fun.call(thisp, t[i], i, t)) {
        return true;
      }
    }

    return false;
  };
}

// ES5 15.4.4.18 Array.prototype.forEach ( callbackfn [ , thisArg ] )
// From https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/forEach
if (!Array.prototype.forEach) {
  Array.prototype.forEach = function (fun /*, thisp */) {
    if (this === void 0 || this === null) { throw TypeError(); }

    var t = Object(this);
    var len = t.length >>> 0;
    if (typeof fun !== "function") { throw TypeError(); }

    var thisp = arguments[1], i;
    for (i = 0; i < len; i++) {
      if (i in t) {
        fun.call(thisp, t[i], i, t);
      }
    }
  };
}


// ES5 15.4.4.19 Array.prototype.map ( callbackfn [ , thisArg ] )
// From https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/Map
if (!Array.prototype.map) {
  Array.prototype.map = function (fun /*, thisp */) {
    if (this === void 0 || this === null) { throw TypeError(); }

    var t = Object(this);
    var len = t.length >>> 0;
    if (typeof fun !== "function") { throw TypeError(); }

    var res = []; res.length = len;
    var thisp = arguments[1], i;
    for (i = 0; i < len; i++) {
      if (i in t) {
        res[i] = fun.call(thisp, t[i], i, t);
      }
    }

    return res;
  };
}

// ES5 15.4.4.20 Array.prototype.filter ( callbackfn [ , thisArg ] )
// From https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/Filter
if (!Array.prototype.filter) {
  Array.prototype.filter = function (fun /*, thisp */) {
    if (this === void 0 || this === null) { throw TypeError(); }

    var t = Object(this);
    var len = t.length >>> 0;
    if (typeof fun !== "function") { throw TypeError(); }

    var res = [];
    var thisp = arguments[1], i;
    for (i = 0; i < len; i++) {
      if (i in t) {
        var val = t[i]; // in case fun mutates this
        if (fun.call(thisp, val, i, t)) {
          res.push(val);
        }
      }
    }

    return res;
  };
}


// ES5 15.4.4.21 Array.prototype.reduce ( callbackfn [ , initialValue ] )
// From https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/Reduce
if (!Array.prototype.reduce) {
  Array.prototype.reduce = function (fun /*, initialValue */) {
    if (this === void 0 || this === null) { throw TypeError(); }

    var t = Object(this);
    var len = t.length >>> 0;
    if (typeof fun !== "function") { throw TypeError(); }

    // no value to return if no initial value and an empty array
    if (len === 0 && arguments.length === 1) { throw TypeError(); }

    var k = 0;
    var accumulator;
    if (arguments.length >= 2) {
      accumulator = arguments[1];
    } else {
      do {
        if (k in t) {
          accumulator = t[k++];
          break;
        }

        // if array contains no values, no initial value to return
        if (++k >= len) { throw TypeError(); }
      }
      while (true);
    }

    while (k < len) {
      if (k in t) {
        accumulator = fun.call(undefined, accumulator, t[k], k, t);
      }
      k++;
    }

    return accumulator;
  };
}


// ES5 15.4.4.22 Array.prototype.reduceRight ( callbackfn [, initialValue ] )
// From https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/ReduceRight
if (!Array.prototype.reduceRight) {
  Array.prototype.reduceRight = function (callbackfn /*, initialValue */) {
    if (this === void 0 || this === null) { throw TypeError(); }

    var t = Object(this);
    var len = t.length >>> 0;
    if (typeof callbackfn !== "function") { throw TypeError(); }

    // no value to return if no initial value, empty array
    if (len === 0 && arguments.length === 1) { throw TypeError(); }

    var k = len - 1;
    var accumulator;
    if (arguments.length >= 2) {
      accumulator = arguments[1];
    } else {
      do {
        if (k in this) {
          accumulator = this[k--];
          break;
        }

        // if array contains no values, no initial value to return
        if (--k < 0) { throw TypeError(); }
      }
      while (true);
    }

    while (k >= 0) {
      if (k in t) {
        accumulator = callbackfn.call(undefined, accumulator, t[k], k, t);
      }
      k--;
    }

    return accumulator;
  };
}


//----------------------------------------------------------------------
// ES5 15.5 String Objects
//----------------------------------------------------------------------

//
// ES5 15.5.4 Properties of the String Prototype Object
//


// ES5 15.5.4.20 String.prototype.trim()
if (!String.prototype.trim) {
  String.prototype.trim = function () {
    return String(this).replace(/^\s+/, '').replace(/\s+$/, '');
  };
}



//----------------------------------------------------------------------
// ES5 15.9 Date Objects
//----------------------------------------------------------------------


//
// ES 15.9.4 Properties of the Date Constructor
//

// ES5 15.9.4.4 Date.now ( )
// From https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Global_Objects/Date/now
if (!Date.now) {
  Date.now = function now() {
    return Number(new Date());
  };
}


//
// ES5 15.9.5 Properties of the Date Prototype Object
//

// ES5 15.9.4.43 Date.prototype.toISOString ( )
// Inspired by http://www.json.org/json2.js
if (!Date.prototype.toISOString) {
  Date.prototype.toISOString = function () {
    function pad2(n) { return ('00' + n).slice(-2); }
    function pad3(n) { return ('000' + n).slice(-3); }

    return this.getUTCFullYear() + '-' +
      pad2(this.getUTCMonth() + 1) + '-' +
      pad2(this.getUTCDate()) + 'T' +
      pad2(this.getUTCHours()) + ':' +
      pad2(this.getUTCMinutes()) + ':' +
      pad2(this.getUTCSeconds()) + '.' +
      pad3(this.getUTCMilliseconds()) + 'Z';
  };
}

},{}],20:[function(require,module,exports){
//----------------------------------------------------------------------
//
// ECMAScript 2015 Polyfills
//
//----------------------------------------------------------------------

(function (global) {
  "use strict";

  // Set this to always override native implementations, for testing
  // the polyfill in browsers with partial/full ES2015 support.
  var OVERRIDE_NATIVE_FOR_TESTING = false;

  var undefined = (void 0); // Paranoia

  // Helpers

  function strict(o) {
    return o === global ? undefined : o;
  }

  function isSymbol(s) {
    return (typeof s === 'symbol') || ('Symbol' in global && s instanceof global.Symbol);
  }

  function getPropertyDescriptor(target, name) {
    var desc = Object.getOwnPropertyDescriptor(target, name);
    var proto = Object.getPrototypeOf(target);
    while (!desc && proto) {
      desc = Object.getOwnPropertyDescriptor(proto, name);
      proto = Object.getPrototypeOf(proto);
    }
    return desc;
  }

  var enqueue = (function(nativePromise, nativeSetImmediate) {
    if (nativePromise)
      return function(job) { nativePromise.resolve().then(function() { job(); }); };
    if (nativeSetImmediate)
      return function(job) { nativeSetImmediate(job); };
    return function(job) { setTimeout(job, 0); };
  }(global['Promise'], global['setImmediate']));

  function define(o, p, v, override) {
    if (p in o && !override && !OVERRIDE_NATIVE_FOR_TESTING)
      return;

    if (typeof v === 'function') {
      // Sanity check that functions are appropriately named (where possible)
      //console.assert(isSymbol(p) || !('name' in v) || v.name === p || v.name === p + '_', 'Expected function name "' + p.toString() + '", was "' + v.name + '"');
      Object.defineProperty(o, p, {
        value: v,
        configurable: true,
        enumerable: false,
        writable: true
      });
    } else {
      Object.defineProperty(o, p, {
        value: v,
        configurable: false,
        enumerable: false,
        writable: false
      });
    }
  }

  function set_internal(o, p, v) {
    Object.defineProperty(o, p, {
      value: v,
      configurable: false,
      enumerable: false,
      writable: true
    });
  }

  // Snapshot intrinsic functions
  var $isNaN = global.isNaN,
      $parseInt = global.parseInt,
      $parseFloat = global.parseFloat;

  var E = Math.E,
      LOG10E = Math.LOG10E,
      LOG2E = Math.LOG2E,
      abs = Math.abs,
      ceil = Math.ceil,
      exp = Math.exp,
      floor = Math.floor,
      log = Math.log,
      max = Math.max,
      min = Math.min,
      pow = Math.pow,
      random = Math.random,
      sqrt = Math.sqrt;

  var orig_match = String.prototype.match,
      orig_replace = String.prototype.replace,
      orig_search = String.prototype.search,
      orig_split = String.prototype.split;

  // These are used for implementing the polyfills, but not exported.

  // Inspired by https://gist.github.com/1638059
  /** @constructor */
  function EphemeronTable() {
    var secretKey = ObjectCreate(null);

    function conceal(o) {
      var oValueOf = o.valueOf, secrets = ObjectCreate(null);
      Object.defineProperty(o, 'valueOf', {
          value: (function(secretKey) {
            return function (k) {
              return (k === secretKey) ? secrets : oValueOf.apply(o, arguments);
            };
          }(secretKey)),
        configurable: true,
        writeable: true,
        enumerable: false
        });
      return secrets;
    }

    function reveal(o) {
      var v = typeof o.valueOf === 'function' && o.valueOf(secretKey);
      return v === o ? null : v;
    }

    return {
      clear: function() {
        secretKey = ObjectCreate(null);
      },
      remove: function(key) {
        var secrets = reveal(key);
        if (secrets && HasOwnProperty(secrets, 'value')) {
          delete secrets.value;
          return true;
        }
        return false;
      },
      get: function(key, defaultValue) {
        var secrets = reveal(key);
        return (secrets && HasOwnProperty(secrets, 'value')) ? secrets.value : defaultValue;
      },
      has: function(key) {
        var secrets = reveal(key);
        return Boolean(secrets && HasOwnProperty(secrets, 'value'));
      },
      set: function(key, value) {
        var secrets = reveal(key) || conceal(key);
        secrets.value = value;
      }
    };
  }

  var empty = Object.create(null);

  //----------------------------------------------------------------------
  //
  // ECMAScript 2015
  // http://www.ecma-international.org/ecma-262/6.0/
  //
  //----------------------------------------------------------------------

  // ---------------------------------------
  // 19.4 Symbol Objects
  // ---------------------------------------

  // NOTE: Symbols are defined here - out of spec order - since we need the
  // properties and prototype to be populated for other polyfills.

  // NOTE: Not secure, nor is obj[$$symbol] hidden from Object.keys()

  var symbolForKey;
  (function() {
    var secret = Object.create(null);
    var symbolMap = {};
    symbolForKey = function(k) {
      return symbolMap[k];
    };

    var GlobalSymbolRegistry = [];

    function unique(bits) {
      return Array(bits + 1).join('x').replace(/x/g, function() {
        return random() < 0.5 ? '\u200C' : '\u200D'; // JWNJ / ZWJ
      });
    }

    // 19.4.1 The Symbol Constructor
    // 19.4.1.1 Symbol ( description=undefined )
    function Symbol(description) {
      if (!(this instanceof Symbol)) return new Symbol(description, secret);
      if (this instanceof Symbol && arguments[1] !== secret) throw TypeError();

      var descString = description === undefined ? undefined : String(description);

      set_internal(this, '[[SymbolData]]', unique(128));
      set_internal(this, '[[Description]]', descString);

      symbolMap[this] = this;
      return this;
    }

    if (!('Symbol' in global) || OVERRIDE_NATIVE_FOR_TESTING)
      global.Symbol = Symbol;

    // 19.4.2 Properties of the Symbol Constructor

    // 19.4.2.1 Symbol.for (key)
    define(Symbol, 'for', function for_(key) {
      var stringKey = String(key);
      for (var i = 0; i < GlobalSymbolRegistry.length; ++i) {
        var e = GlobalSymbolRegistry[i];
        if (SameValue(e['[[key]]'], stringKey)) return e['[[symbol]]'];
      }
      var newSymbol = Symbol(key);
      GlobalSymbolRegistry.push({'[[key]]': stringKey, '[[symbol]]': newSymbol});
      return newSymbol;
    });

    // 19.4.2.2 Symbol.hasInstance
    // 19.4.2.3 Symbol.isConcatSpreadable

    // 19.4.2.4 Symbol.iterator
    define(global.Symbol, 'iterator', global.Symbol('Symbol.iterator'));

    // 19.4.2.5 Symbol.keyFor (sym)
    define(Symbol, 'keyFor', function keyFor(sym) {
      if (!(sym instanceof Symbol)) throw TypeError();
      for (var i = 0; i < GlobalSymbolRegistry.length; ++i) {
        var e = GlobalSymbolRegistry[i];
        if (SameValue(e['[[symbol]]'], sym)) return e['[[key]]'];
      }
      return undefined;
    });

    // 19.4.2.6 Symbol.match
    define(global.Symbol, 'match', global.Symbol('Symbol.match'));

    // 19.4.2.7 Symbol.prototype

    // 19.4.2.8 Symbol.replace
    define(global.Symbol, 'replace', global.Symbol('Symbol.replace'));

    // 19.4.2.9 Symbol.search
    define(global.Symbol, 'search', global.Symbol('Symbol.search'));

    // 19.4.2.10 Symbol.species

    // 19.4.2.11 Symbol.search
    define(global.Symbol, 'split', global.Symbol('Symbol.split'));

    // 19.4.2.12 Symbol.toPrimitive

    // 19.4.2.13 Symbol.toStringTag
    define(global.Symbol, 'toStringTag', global.Symbol('Symbol.toStringTag'));

    // 19.4.2.14 Symbol.unscopables

    // 19.4.3 Properties of the Symbol Prototype Object
    // 19.4.3.1 Symbol.prototype.constructor

    // 19.4.3.2 Symbol.prototype.toString ( )
    Object.defineProperty(Symbol.prototype, 'toString', {
      value: function toString() {
        var s = strict(this);
        var desc = s['[[Description]]'];
        return 'Symbol(' + (desc === undefined ? '' : desc) + s['[[SymbolData]]'] + ')';
      },
      configurable: true, writeable: true, enumerable: false });

    // 19.4.3.3 Symbol.prototype.valueOf ( )
    Object.defineProperty(Symbol.prototype, 'valueOf', {
      value: function valueOf() {
        // To prevent automatic string conversion:
        throw TypeError();

        // Spec has approximately the following:
        //var s = strict(this);
        //if (Type(s) === 'symbol') return s;
        //if (Type(s) !== 'object') throw TypeError();
        //if (!('[[SymbolData]]' in s)) throw TypeError();
        //return s['[[SymbolData]]'];
      },
      configurable: true, writeable: true, enumerable: false });

    // 19.4.3.4 Symbol.prototype [ @@toStringTag ]
    // (Done later to polyfill partial implementations)

    // 19.4.4 Properties of Symbol Instances
  }());

  console.assert(typeof global.Symbol() === 'symbol' || symbolForKey(String(global.Symbol('x'))) !== undefined);

  // Defined here so that other prototypes can reference it
  // 25.1.2 The %IteratorPrototype% Object
  var $IteratorPrototype$ = {};

  //----------------------------------------
  // 6 ECMAScript Data Types and Values
  //----------------------------------------

  // 6.1 ECMAScript Language Types

  // "Type(x)" is used as shorthand for "the type of x"...
  function Type(v) {
    switch (typeof v) {
    case 'undefined': return 'undefined';
    case 'boolean': return 'boolean';
    case 'number': return 'number';
    case 'string': return 'string';
    case 'symbol': return 'symbol';
    default:
      if (v === null) return 'null';
      if (v instanceof global.Symbol) return 'symbol';
      return 'object';
    }
  }

  // 6.1.5.1 Well-Known Symbols
  var $$iterator = global.Symbol.iterator,
      $$match = global.Symbol.match,
      $$replace = global.Symbol.replace,
      $$search = global.Symbol.search,
      $$split = global.Symbol.split,
      $$toStringTag = global.Symbol.toStringTag;

  //----------------------------------------
  // 7 Abstract Operations
  //----------------------------------------

  //----------------------------------------
  // 7.1 Type Conversion
  //----------------------------------------

  // 7.1.1 ToPrimitive ( input [, PreferredType] )
  // just use valueOf()

  // 7.1.2 ToBoolean ( argument )
  // just use Boolean()

  // 7.1.3 ToNumber ( argument )
  // just use Number()

  // 7.1.4 ToInteger ( argument )
  function ToInteger(n) {
    n = Number(n);
    if ($isNaN(n)) return 0;
    if (n === 0 || n === Infinity || n === -Infinity) return n;
    return ((n < 0) ? -1 : 1) * floor(abs(n));
  }

  // 7.1.5 ToInt32 ( argument )
  function ToInt32(v) { return v >> 0; }

  // 7.1.6 ToUint32 ( argument )
  function ToUint32(v) { return v >>> 0; }

  // 7.1.7 ToInt16 ( argument )
  function ToInt16(v) { return (v << 16) >> 16; }

  // 7.1.8 ToUint16 ( argument )
  function ToUint16(v) { return v & 0xFFFF; }

  // 7.1.9 ToInt8 ( argument )
  function ToInt8(v) { return (v << 24) >> 24; }

  // 7.1.10 ToUint8 ( argument )
  function ToUint8(v) { return v & 0xFF; }

  // 7.1.11 ToUint8Clamp ( argument )
  function ToUint8Clamp(argument) {
    var number = Number(argument);
    if ($isNaN(number)) return 0;
    if (number <= 0) return 0;
    if (number >= 255) return 255;
    var f = floor(number);
    if ((f + 0.5) < number) return f + 1;
    if (number < (f + 0.5)) return f;
    if (f % 2) return f + 1;
    return f;
  }

  // 7.1.12 ToString ( argument )
  // just use String()

  // 7.1.13 ToObject ( argument )
  function ToObject(v) {
    if (v === null || v === undefined) throw TypeError();
    return Object(v);
  }

  // 7.1.14 ToPropertyKey ( argument )
  function ToPropertyKey(v) {
    return String(v);
  }

  // 7.1.15 ToLength ( argument )
  function ToLength(v) {
    var len = ToInteger(v);
    if (len <= 0) return 0;
    if (len === Infinity) return 0x20000000000000 - 1; // 2^53-1
    return min(len, 0x20000000000000 - 1); // 2^53-1
  }

  // 7.1.16 CanonicalNumericIndexString ( argument )

  //----------------------------------------
  // 7.2 Testing and Comparison Operations
  //----------------------------------------

  // 7.2.1 RequireObjectCoercible ( argument )
  // 7.2.2 IsArray ( argument )

  // 7.2.3 IsCallable ( argument )
  function IsCallable(o) { return typeof o === 'function'; }

  // 7.2.4 IsConstructor ( argument )
  function IsConstructor(o) {
    // Hacks for Safari 7 TypedArray XXXConstructor objects
    if (/Constructor/.test(Object.prototype.toString.call(o))) return true;
    if (/Function/.test(Object.prototype.toString.call(o))) return true;
    // TODO: Can this be improved on?
    return typeof o === 'function';
  }

  // 7.2.5 IsExtensible (O)
  // 7.2.6 IsInteger ( argument )

  // 7.2.7 IsPropertyKey ( argument )
  function IsPropertyKey(argument) {
    if (Type(argument) === 'string') return true;
    if (Type(argument) === 'symbol') return true;
    return false;
  }

  // 7.2.8 IsRegExp ( argument )

  // 7.2.9 SameValue(x, y)
  function SameValue(x, y) {
    if (typeof x !== typeof y) return false;
    switch (typeof x) {
    case 'undefined':
      return true;
    case 'number':
      if (x !== x && y !== y) return true;
      if (x === 0 && y === 0) return 1/x === 1/y;
      return x === y;
    case 'boolean':
    case 'string':
    case 'object':
    default:
      return x === y;
    }
  }

  // 7.2.10 SameValueZero(x, y)
  function SameValueZero(x, y) {
    if (typeof x !== typeof y) return false;
    switch (typeof x) {
    case 'undefined':
      return true;
    case 'number':
      if (x !== x && y !== y) return true;
      return x === y;
    case 'boolean':
    case 'string':
    case 'object':
    default:
      return x === y;
    }
  }

  //----------------------------------------
  // 7.3 Operations on Objects
  //----------------------------------------

  // 7.3.1 Get (O, P)
  // - just use o.p or o[p]

  // 7.3.2 GetV (V, P)
  function GetV(v, p) {
    var o = ToObject(v);
    return o[p];
  }

  // 7.3.3 Set (O, P, V, Throw)
  // - just use o.p = v or o[p] = v




  // 7.3.9 GetMethod (O, P)
  function GetMethod(o, p) {
    var func = GetV(o, p);
    if (func === undefined || func === null) return undefined;
    if (!IsCallable(func)) throw TypeError();
    return func;
  }

  // 7.3.10 HasProperty (O, P)
  function HasProperty(o, p) {
    while (o) {
      if (Object.prototype.hasOwnProperty.call(o, p)) return true;
      if (Type(o) !== 'object') return false;
      var op = Object.getPrototypeOf(o);
      if (op === o) return false; // IE8 has self-referential prototypes
      o = op;
    }
    return false;
  }

  // 7.3.11 HasOwnProperty (O, P)
  function HasOwnProperty(o, p) {
    return Object.prototype.hasOwnProperty.call(o, p);
  }

  //----------------------------------------
  // 7.4 Operations on Iterator Objects
  //----------------------------------------

  // 7.4.1 GetIterator ( obj, method )
  function GetIterator(obj, method) {
    if (arguments.length < 2)
      method = GetMethod(obj, $$iterator);
    var iterator = method.call(obj);
    if (Type(iterator) !== 'object') throw TypeError();
    return iterator;
  }

  // 7.4.2 IteratorNext ( iterator, value )
  function IteratorNext(iterator, value) {
    if (arguments.length < 2)
      var result = iterator.next();
    else
      result = iterator.next(value);
    if (Type(result) !== 'object') throw TypeError();
    return result;
  }

  // 7.4.3 IteratorComplete ( iterResult )
  function IteratorComplete(iterResult) {
    console.assert(Type(iterResult) === 'object');
    return Boolean(iterResult.done);
  }

  // 7.4.4 IteratorValue ( iterResult )
  function IteratorValue(iterResult) {
    console.assert(Type(iterResult) === 'object');
    return iterResult.value;
  }

  // 7.4.5 IteratorStep ( iterator )
  function IteratorStep( iterator, value ) {
    var result = IteratorNext(iterator, value);
    var done = result['done'];
    if (Boolean(done) === true) return false;
    return result;
  }

  // 7.4.6 IteratorClose( iterator, completion )
  function IteratorClose( iterator, completion ) {
    console.assert(Type(iterator) === 'object');
    var _return = GetMethod(iterator, 'return');
    if (_return === undefined) return completion;
    try {
      var innerResult = _return[iterator]();
    } catch (result) {
      // TODO: If completion.[[type]] is throw, return completion
      return result;
    }
    if (Type(innerResult) !== 'object') throw TypeError();
    return completion;
  }

  // 7.4.7 CreateIterResultObject (value, done)
  function CreateIterResultObject(value, done) {
    console.assert(Type(done) === 'boolean');
    var obj = {};
    obj["value"] = value;
    obj["done"] = done;
    return obj;
  }

  // 7.4.8 CreateListIterator (list)
  // 7.4.8.1 ListIterator next( )

  //----------------------------------------
  // 8 Executable Code and Execution Contexts
  //----------------------------------------

  //----------------------------------------
  // 8.4 Jobs and Job Queues
  //----------------------------------------

  // 8.4.1 EnqueueJob ( queueName, job, arguments)
  function EnqueueJob(queueName, job, args) {
    var fn = function() { job.apply(undefined, args); };
    enqueue(fn);
  }

  // 8.4.2 NextJob result
  function NextJob(result) {
    // no-op
  }

  //----------------------------------------
  // 9 Ordinary and Exotic Objects Behaviors
  //----------------------------------------

  // 9.1.11 [[Enumerate]] ()
  function Enumerate(obj) {
    var e = [];
    if (Object(obj) !== obj) return e;
    var visited = new Set;
    while (obj !== null) {
      Object.getOwnPropertyNames(obj).forEach(function(name) {
        if (!visited.has(name)) {
          var desc = Object.getOwnPropertyDescriptor(obj, name);
          if (desc) {
            visited.add(name);
            if (desc.enumerable) e.push(name);
          }
        }
      });
      obj = Object.getPrototypeOf(obj);
    }
    return e[$$iterator]();
  }

  // 9.1.12 [[OwnPropertyKeys]] ( )
  function OwnPropertyKeys(o) {
    return Object.getOwnPropertyNames(o);
  }

  // 9.1.13 ObjectCreate(proto, internalSlotsList)
  function ObjectCreate(proto, internalSlotsList) {
    return Object.create(proto, internalSlotsList);
  }

  // ---------------------------------------
  // 19 Fundamental Objects
  // ---------------------------------------

  // ---------------------------------------
  // 19.1 Object Objects
  // ---------------------------------------

  // 19.1.1 The Object Constructor
  // 19.1.1.1 Object ( [ value ] )
  // 19.1.2 Properties of the Object Constructor
  // 19.1.2.1 Object.assign ( target, ...sources )
  define(
    Object, 'assign',
    function assign(target, /*...*/sources) {
      var to = ToObject(target);
      if (arguments.length < 2) return to;

      var sourcesIndex = 1;
      while (sourcesIndex < arguments.length) {
        var nextSource = arguments[sourcesIndex++];
        if (nextSource === undefined || nextSource === null) {
          var keys = [];
        } else {
          var from = ToObject(nextSource);
          keys = OwnPropertyKeys(from);
        }
        for (var keysIndex = 0; keysIndex < keys.length; ++keysIndex) {
          var nextKey = keys[keysIndex];
          var desc = Object.getOwnPropertyDescriptor(from, nextKey);
          if (desc !== undefined && desc.enumerable) {
            var propValue = from[nextKey];
            to[nextKey] = propValue;
          }
        }
      }
      return to;
    });

  // 19.1.2.2 Object.create ( O [ , Properties ] )
  // 19.1.2.3 Object.defineProperties ( O, Properties )
  // 19.1.2.4 Object.defineProperty ( O, P, Attributes )
  // 19.1.2.5 Object.freeze ( O )
  // 19.1.2.6 Object.getOwnPropertyDescriptor ( O, P )

  (function() {
    var nativeSymbols = (typeof global.Symbol() === 'symbol'),
        $getOwnPropertyNames = Object.getOwnPropertyNames,
        $keys = Object.keys,
        $window_names = (typeof window === 'object' ? $getOwnPropertyNames(window) : []);

    function isStringKey(k) { return !symbolForKey(k); }

    // 19.1.2.7 Object.getOwnPropertyNames ( O )
    define(
      Object, 'getOwnPropertyNames',
      function getOwnPropertyNames(o) {
        if (Object.prototype.toString.call(o) === '[object Window]') {
          // Workaround for cross-realm calling by IE itself.
          // https://github.com/inexorabletash/polyfill/issues/96
          try {
            return $getOwnPropertyNames(o).filter(isStringKey);
          } catch (_) {
            return $window_names.slice();
          }
        }
        return $getOwnPropertyNames(o).filter(isStringKey);
      }, !nativeSymbols);

    // 19.1.2.8 Object.getOwnPropertySymbols ( O )
    define(
      Object, 'getOwnPropertySymbols',
      function getOwnPropertySymbols(o) {
        return $getOwnPropertyNames(o).filter(symbolForKey).map(symbolForKey);
      }, !nativeSymbols);

    // 19.1.2.14 Object.keys ( O )
    define(
      Object, 'keys',
      function keys(o) {
        return $keys(o).filter(isStringKey);
      }, !nativeSymbols);
  }());

  // 19.1.2.9 Object.getPrototypeOf ( O )
  // 19.1.2.10 Object.is ( value1, value2 )
  define(
    Object, 'is',
    function is(value1, value2) {
      return SameValue(value1, value2);
    });

  // 19.1.2.11 Object.isExtensible ( O )
  // 19.1.2.12 Object.isFrozen ( O )
  // 19.1.2.13 Object.isSealed ( O )

  // 19.1.2.14 Object.keys ( O )
  // see above

  // 19.1.2.15 Object.preventExtensions ( O )
  // 19.1.2.16 Object.prototype
  // 19.1.2.17 Object.seal ( O )

  // 19.1.2.18 Object.setPrototypeOf ( O, proto )
  define(
    Object, 'setPrototypeOf',
    function setPrototypeOf(o, proto) {
      if (Type(o) !== 'object') throw TypeError();
      if (Type(proto) !== 'object' && Type(proto) !== 'null') throw TypeError();
      o.__proto__ = proto;
      return o;
    }
  );

  // 19.1.3 Properties of the Object Prototype Object
  // 19.1.3.1 Object.prototype.constructor
  // 19.1.3.2 Object.prototype.hasOwnProperty ( V )
  // 19.1.3.3 Object.prototype.isPrototypeOf ( V )
  // 19.1.3.4 Object.prototype.propertyIsEnumerable ( V )
  // 19.1.3.5 Object.prototype.toLocaleString ( [ reserved1 [ , reserved2 ] ] )
  // 19.1.3.6 Object.prototype.toString ( )
  var o_p_ts = Object.prototype.toString;
  define(Object.prototype, 'toString',
       function() {
         var o = strict(this);
         if (o === Object(o) && $$toStringTag in o) {
           return '[object ' + o[$$toStringTag] + ']';
         }
         return o_p_ts.apply(o, arguments);
       });

  // 19.1.3.7 Object.prototype.valueOf ( )
  // 19.1.4 Properties of Object Instances

  // ---------------------------------------
  // 19.2 Function Objects
  // ---------------------------------------

  // 19.2.1 The Function Constructor
  // 19.2.1.1 Function ( p1, p2, … , pn, body )
  // 19.2.2 Properties of the Function Constructor
  // 19.2.2.1 Function.length
  // 19.2.2.2 Function.prototype
  // 19.2.3 Properties of the Function Prototype Object
  // 19.2.3.1 Function.prototype.apply ( thisArg, argArray )
  // 19.2.3.2 Function.prototype.bind ( thisArg , ...args)
  // 19.2.3.3 Function.prototype.call (thisArg , ...args)
  // 19.2.3.4 Function.prototype.constructor
  // 19.2.3.5 Function.prototype.toString ( )
  // 19.2.3.6 Function.prototype[@@hasInstance] ( V )
  // 19.2.4 Function Instances
  // 19.2.4.1 length
  // 19.2.4.2 name
  // 19.2.4.3 prototype

  // (No polyfillable changes from ES5)

  // ---------------------------------------
  // 19.3 Boolean Objects
  // ---------------------------------------

  // 19.3.1 The Boolean Constructor
  // 19.3.1.1 Boolean ( value )
  // 19.3.2 Properties of the Boolean Constructor
  // 19.3.2.1 Boolean.prototype
  // 19.3.3 Properties of the Boolean Prototype Object
  // 19.3.3.1 Boolean.prototype.constructor
  // 19.3.3.2 Boolean.prototype.toString ( )
  // 19.3.3.3 Boolean.prototype.valueOf ( )
  // 19.3.4 Properties of Boolean Instances

  // (No polyfillable changes from ES5)

  // ---------------------------------------
  // 19.4 Symbol Objects
  // ---------------------------------------

  // Moved earlier in this script, so that other polyfills can depend on them.

  // 19.4.3.4 Symbol.prototype [ @@toStringTag ]
  define(global.Symbol.prototype, global.Symbol.toStringTag, 'Symbol');

  // ---------------------------------------
  // 19.5 Error Objects
  // ---------------------------------------

  // 19.5.1 The Error Constructor
  // 19.5.1.1 Error ( message )
  // 19.5.1.2 new Error( ...argumentsList )
  // 19.5.2 Properties of the Error Constructor
  // 19.5.2.1 Error.prototype
  // 19.5.3 Properties of the Error Prototype Object
  // 19.5.3.1 Error.prototype.constructor
  // 19.5.3.2 Error.prototype.message
  // 19.5.3.3 Error.prototype.name
  // 19.5.3.4 Error.prototype.toString ( )
  // 19.5.4 Properties of Error Instances
  // 19.5.5 Native Error Types Used in This Standard
  // 19.5.5.1 EvalError
  // 19.5.5.2 RangeError
  // 19.5.5.3 ReferenceError
  // 19.5.5.4 SyntaxError
  // 19.5.5.5 TypeError
  // 19.5.5.6 URIError
  // 19.5.6 NativeError Object Structure
  // 19.5.6.1 NativeError Constructors
  // 19.5.6.1.1 NativeError ( message )
  // 19.5.6.1.2 new NativeError ( ...argumentsList )
  // 19.5.6.2 Properties of the NativeError Constructors
  // 19.5.6.2.1 NativeError.prototype
  // 19.5.6.3 Properties of the NativeError Prototype Objects
  // 19.5.6.4 Properties of NativeError Instances

  // (No polyfillable changes from ES5)

  // ---------------------------------------
  // 20 Numbers and Dates
  // ---------------------------------------

  // ---------------------------------------
  // 20.1 Number Objects
  // ---------------------------------------

  // 20.1.1 The Number Constructor
  // 20.1.1.1 Number ( [ value ] )
  // 20.1.1.2 new Number ( ...argumentsList )
  // 20.1.2 Properties of the Number Constructor

  // 20.1.2.1 Number.EPSILON
  define(
    Number, 'EPSILON',
    (function () {
      var next, result;
      for (next = 1; 1 + next !== 1; next = next / 2)
        result = next;
      return result;
    }()));

  // 20.1.2.2 Number.isFinite ( number )
  define(
    Number, 'isFinite',
    function isFinite(number) {
      if (Type(number) !== 'number') return false;
      if (number !== number || number === +Infinity || number === -Infinity) return false;
      return true;
    });

  // 20.1.2.3 Number.isInteger ( number )
  define(
    Number, 'isInteger',
    function isInteger(number) {
      if (Type(number) !== 'number') return false;
      if (number !== number || number === +Infinity || number === -Infinity) return false;
      var integer = ToInteger(number);
      if (integer !== number) return false;
      return true;
    });

  // 20.1.2.4 Number.isNaN ( number )
  define(
    Number, 'isNaN',
    function isNaN(number) {
      if (Type(number) !== 'number') return false;
      if (number !== number) return true;
      return false;
    });

  // 20.1.2.5 Number.isSafeInteger ( number )
  define(
    Number, 'isSafeInteger',
    function isSafeInteger(number) {
      if (Type(number) !== 'number') return false;
      if (number !== number || number === +Infinity || number === -Infinity) return false;
      var integer = ToInteger(number);
      if (integer !== number) return false;
      if (abs(integer) <= (0x20000000000000 - 1)) // 2^53-1
        return true;
      return false;
    });

  // 20.1.2.6 Number.MAX_SAFE_INTEGER
  define(
    Number, 'MAX_SAFE_INTEGER',
    9007199254740991); // 2^53-1

  // 20.1.2.7 Number.MAX_VALUE

  // 20.1.2.8 Number.MIN_SAFE_INTEGER
  define(
    Number, 'MIN_SAFE_INTEGER',
    -9007199254740991); // -2^53+1

  // 20.1.2.9 Number.MIN_VALUE
  // 20.1.2.10 Number.NaN
  // 20.1.2.11 Number.NEGATIVE_INFINITY

  // 20.1.2.12 Number.parseFloat ( string )
  define(Number, 'parseFloat', $parseFloat);

  // 20.1.2.13 Number.parseInt ( string, radix )
  define(Number, 'parseInt', $parseInt);

  // 20.1.2.14 Number.POSITIVE_INFINITY
  // 20.1.2.15 Number.prototype

  // 20.1.3 Properties of the Number Prototype Object
  // 20.1.3.1 Number.prototype.constructor
  // 20.1.3.2 Number.prototype.toExponential ( fractionDigits )
  // 20.1.3.3 Number.prototype.toFixed ( fractionDigits )
  // 20.1.3.4 Number.prototype.toLocaleString( [ reserved1 [ , reserved2 ] ])
  // 20.1.3.5 Number.prototype.toPrecision ( precision )
  // 20.1.3.6 Number.prototype.toString ( [ radix ] )
  // 20.1.3.7 Number.prototype.valueOf ( )
  // 20.1.4 Properties of Number Instances

  // ---------------------------------------
  // 20.2 The Math Object
  // ---------------------------------------

  // 20.2.1 Value Properties of the Math Object
  // 20.2.1.1 Math.E
  // 20.2.1.2 Math.LN10
  // 20.2.1.3 Math.LN2
  // 20.2.1.4 Math.LOG10E
  // 20.2.1.5 Math.LOG2E
  // 20.2.1.6 Math.PI
  // 20.2.1.7 Math.SQRT1_2
  // 20.2.1.8 Math.SQRT2

  // 20.2.1.9 Math [ @@toStringTag ]
  define(Math, $$toStringTag, 'Math');

  // 20.2.2 Function Properties of the Math Object
  // 20.2.2.1 Math.abs ( x )
  // 20.2.2.2 Math.acos ( x )

  // 20.2.2.3 Math.acosh(x)
  define(
    Math, 'acosh',
    function acosh(x) {
      x = Number(x);
      return log(x + sqrt(x * x - 1));
    });

  // 20.2.2.4 Math.asin ( x )

  // 20.2.2.5 Math.asinh( x )
  define(
    Math, 'asinh',
    function asinh(x) {
      x = Number(x);
      if (SameValue(x, -0)) {
        return x;
      }
      var s = sqrt(x * x + 1);
      return (s === -x) ? log(0) : log(x + s);
    });

  // 20.2.2.6 Math.atan ( x )

  // 20.2.2.7 Math.atanh( x )
  define(
    Math, 'atanh',
    function atanh(x) {
      x = Number(x);
      return (x === 0) ? x : log((1 + x) / (1 - x)) / 2;
    });

  // 20.2.2.8 Math.atan2 ( y, x )

  // 20.2.2.9 Math.cbrt ( x )
  define(
    Math, 'cbrt',
    function cbrt(x) {
      x = Number(x);
      if ($isNaN(x/x)) {
        return x;
      }
      var r = pow(abs(x), 1/3);
      var t = x/r/r;
      return r + (r * (t-r) / (2*r + t));
    });

  // 20.2.2.10 Math.ceil ( x )

  // 20.2.2.11 Math.clz32 ( x )
  define(
    Math, 'clz32',
    function clz32(x) {
      function clz8(x) {
        return (x & 0xf0) ? (x & 0x80 ? 0 : x & 0x40 ? 1 : x & 0x20 ? 2 : 3) :
        (x & 0x08 ? 4 : x & 0x04 ? 5 : x & 0x02 ? 6 : x & 0x01 ? 7 : 8);
      }
      x = ToUint32(x);
      return x & 0xff000000 ? clz8(x >> 24) :
        x & 0xff0000 ? clz8(x >> 16) + 8 :
        x & 0xff00 ? clz8(x >> 8) + 16 : clz8(x) + 24;
    });



  // 20.2.2.12 Math.cos ( x )

  // 20.2.2.13 Math.cosh ( x )
  define(
    Math, 'cosh',
    function cosh(x) {
      x = Number(x);
      return (pow(E, x) + pow(E, -x)) / 2;
    });

  // 20.2.2.14 Math.exp ( x )

  // 20.2.2.15 Math.expm1 ( x )
  define(
    Math, 'expm1',
    function expm1(x) {
      x = Number(x);
      // from: http://www.johndcook.com/cpp_log1p.html
      if (SameValue(x, -0)) {
        return -0;
      } else if (abs(x) < 1e-5) {
        return x + 0.5 * x * x; // two terms of Taylor expansion
      } else {
        return exp(x) - 1;
      }
    });

  // 20.2.2.16 Math.floor ( x )

  // 20.2.2.17 Math.fround ( x )
  define(
    Math, 'fround',
    function fround(x) {
      if ($isNaN(x)) {
        return NaN;
      }
      if (1/x === +Infinity || 1/x === -Infinity || x === +Infinity || x === -Infinity) {
        return x;
      }
      return (new Float32Array([x]))[0];
    });

  // 20.2.2.18 Math.hypot ( value1 [, value2 [ ... ] ] )
  define(
    Math, 'hypot',
    function hypot() {
      var values = [];
      var m = 0, sawNaN = false;
      for (var i = 0; i < arguments.length; ++i) {
        var n = abs(Number(arguments[i]));
        if (n === Infinity) return n;
        if (n !== n) sawNaN = true;
        if (n > m) m = n;
        values[i] = n;
      }
      if (sawNaN) return NaN;
      if (m === 0) return +0;
      var sum = +0;
      for (i = 0; i < values.length; ++i) {
        var r = values[i] / m;
        sum = sum + r * r;
      }
      return m * sqrt(sum);
    });

  // 20.2.2.19 Math.imul ( x, y )
  define(
    Math, 'imul',
    function imul(x, y) {
      var a = ToUint32(x);
      var b = ToUint32(y);
      // (slow but accurate)
      var ah  = (a >>> 16) & 0xffff;
      var al = a & 0xffff;
      var bh  = (b >>> 16) & 0xffff;
      var bl = b & 0xffff;
      return ((al * bl) + (((ah * bl + al * bh) << 16) >>> 0)|0);
    }, ('imul' in Math && Math.imul(1, 0x80000000) === 0) // Safari 7 bug
  );

  // 20.2.2.20 Math.log ( x )

  // 20.2.2.21 Math.log1p ( x )
  define(
    Math, 'log1p',
    function log1p(x) {
      x = Number(x);
      // from: http://www.johndcook.com/cpp_expm1.html
      if (x < -1) {
        return NaN;
      } else if (SameValue(x, -0)) {
        return -0;
      } else if (abs(x) > 1e-4) {
        return log(1 + x);
      } else {
        return (-0.5 * x + 1) * x;
      }
    });

  // 20.2.2.22 Math.log10 ( x )
  define(
    Math, 'log10',
    function log10(x) {
      x = Number(x);
      return log(x) * LOG10E;
    });

  // 20.2.2.23 Math.log2 ( x )
  define(
    Math, 'log2',
    function log2(x) {
      x = Number(x);
      return log(x) * LOG2E;
    });

  // 20.2.2.24 Math.max ( value1, value2 , ...values )
  // 20.2.2.25 Math.min ( value1, value2 , ...values )
  // 20.2.2.26 Math.pow ( x, y )
  // 20.2.2.27 Math.random ( )
  // 20.2.2.28 Math.round ( x )

  // 20.2.2.29 Math.sign(x)
  define(
    Math, 'sign',
    function sign(x) {
      x = Number(x);
      return x < 0 ? -1 : x > 0 ? 1 : x;
    });

  // 20.2.2.30 Math.sin ( x )

  // 20.2.2.31 Math.sinh( x )
  define(
    Math, 'sinh',
    function sinh(x) {
      x = Number(x);
      return SameValue(x, -0) ? x : (pow(E, x) - pow(E, -x)) / 2;
    });

  // 20.2.2.32 Math.sqrt ( x )
  // 20.2.2.33 Math.tan ( x )

  // 20.2.2.34 Math.tanh ( x )
  define(
    Math, 'tanh',
    function tanh(x) {
      x = Number(x);
      var n = pow(E, 2 * x) - 1,
          d = pow(E, 2 * x) + 1;
      if (SameValue(x, -0))
        return x;
      return (n === d) ? 1 : n / d; // Handle Infinity/Infinity
    });

  // 20.2.2.35 Math.trunc ( x )
  define(
    Math, 'trunc',
    function trunc(x) {
      x = Number(x);
      return $isNaN(x) ? NaN :
        x < 0 ? ceil(x) : floor(x);
    });

  // ---------------------------------------
  // 20.3 Date Objects
  // ---------------------------------------

  // 20.3.1 Overview of Date Objects and Definitions of Abstract Operations
  // 20.3.1.1 Time Values and Time Range
  // 20.3.1.2 Day Number and Time within Day
  // 20.3.1.3 Year Number
  // 20.3.1.4 Month Number
  // 20.3.1.5 Date Number
  // 20.3.1.6 Week Day
  // 20.3.1.7 Local Time Zone Adjustment
  // 20.3.1.8 Daylight Saving Time Adjustment
  // 20.3.1.9 Local Time
  // 20.3.1.10 Hours, Minutes, Second, and Milliseconds
  // 20.3.1.11 MakeTime (hour, min, sec, ms)
  // 20.3.1.12 MakeDay (year, month, date)
  // 20.3.1.13 MakeDate (day, time)
  // 20.3.1.14 TimeClip (time)
  // 20.3.1.15 Date Time String Format
  // 20.3.1.15.1 Extended years
  // 20.3.2 The Date Constructor
  // 20.3.2.1 Date ( year, month [, date [ , hours [ , minutes [ , seconds [ , ms ] ] ] ] ] )
  // 20.3.2.2 Date ( value )
  // 20.3.2.3 Date ( )
  // 20.3.3 Properties of the Date Constructor
  // 20.3.3.1 Date.now ( )
  // 20.3.3.2 Date.parse (string)
  // 20.3.3.3 Date.prototype
  // 20.3.3.4 Date.UTC ( year, month [ , date [ , hours [ , minutes [ , seconds [ , ms ] ] ] ] ] )
  // 20.3.4 Properties of the Date Prototype Object
  // 20.3.4.1 Date.prototype.constructor
  // 20.3.4.2 Date.prototype.getDate ( )
  // 20.3.4.3 Date.prototype.getDay ( )
  // 20.3.4.4 Date.prototype.getFullYear ( )
  // 20.3.4.5 Date.prototype.getHours ( )
  // 20.3.4.6 Date.prototype.getMilliseconds ( )
  // 20.3.4.7 Date.prototype.getMinutes ( )
  // 20.3.4.8 Date.prototype.getMonth ( )
  // 20.3.4.9 Date.prototype.getSeconds ( )
  // 20.3.4.10 Date.prototype.getTime ( )
  // 20.3.4.11 Date.prototype.getTimezoneOffset ( )
  // 20.3.4.12 Date.prototype.getUTCDate ( )
  // 20.3.4.13 Date.prototype.getUTCDay ( )
  // 20.3.4.14 Date.prototype.getUTCFullYear ( )
  // 20.3.4.15 Date.prototype.getUTCHours ( )
  // 20.3.4.16 Date.prototype.getUTCMilliseconds ( )
  // 20.3.4.17 Date.prototype.getUTCMinutes ( )
  // 20.3.4.18 Date.prototype.getUTCMonth ( )
  // 20.3.4.19 Date.prototype.getUTCSeconds ( )
  // 20.3.4.20 Date.prototype.setDate ( date )
  // 20.3.4.21 Date.prototype.setFullYear ( year [ , month [ , date ] ] )
  // 20.3.4.22 Date.prototype.setHours ( hour [ , min [ , sec [ , ms ] ] ] )
  // 20.3.4.23 Date.prototype.setMilliseconds ( ms )
  // 20.3.4.24 Date.prototype.setMinutes ( min [ , sec [ , ms ] ] )
  // 20.3.4.25 Date.prototype.setMonth ( month [ , date ] )
  // 20.3.4.26 Date.prototype.setSeconds ( sec [ , ms ] )
  // 20.3.4.27 Date.prototype.setTime ( time )
  // 20.3.4.28 Date.prototype.setUTCDate ( date )
  // 20.3.4.29 Date.prototype.setUTCFullYear ( year [ , month [ , date ] ] )
  // 20.3.4.30 Date.prototype.setUTCHours ( hour [ , min [ , sec [ , ms ] ] ] )
  // 20.3.4.31 Date.prototype.setUTCMilliseconds ( ms )
  // 20.3.4.32 Date.prototype.setUTCMinutes ( min [ , sec [, ms ] ] )
  // 20.3.4.33 Date.prototype.setUTCMonth ( month [ , date ] )
  // 20.3.4.34 Date.prototype.setUTCSeconds ( sec [ , ms ] )
  // 20.3.4.35 Date.prototype.toDateString ( )
  // 20.3.4.36 Date.prototype.toISOString ( )
  // 20.3.4.37 Date.prototype.toJSON ( key )
  // 20.3.4.38 Date.prototype.toLocaleDateString ( [ reserved1 [ , reserved2 ] ] )
  // 20.3.4.39 Date.prototype.toLocaleString ( [ reserved1 [ , reserved2 ] ] )
  // 20.3.4.40 Date.prototype.toLocaleTimeString ( [ reserved1 [ , reserved2 ] ] )
  // 20.3.4.41 Date.prototype.toString ( )
  // 20.3.4.42 Date.prototype.toTimeString ( )
  // 20.3.4.43 Date.prototype.toUTCString ( )
  // 20.3.4.44 Date.prototype.valueOf ( )
  // 20.3.4.45 Date.prototype [ @@toPrimitive ] ( hint )
  // 20.3.5 Properties of Date Instances

  // (No polyfillable changes from ES5)

  // ---------------------------------------
  // 21 Text Processing
  // ---------------------------------------

  var string_regexp_dispatch = (function() {
    var faux = {}, secret = Symbol();
    faux[Symbol.match] = function() { return secret; };
    return ("").match(faux) === secret;
  }());

  // 21.1 String Objects
  // 21.1.1 The String Constructor
  // 21.1.1.1 String ( value )
  // 21.1.2 Properties of the String Constructor
  // 21.1.2.1 String.fromCharCode ( ...codeUnits )

  // 21.1.2.2 String.fromCodePoint ( ...codePoints )
  define(
    String, 'fromCodePoint',
    function fromCodePoint(/*...codePoints*/) {
      var codePoints = arguments,
          length = codePoints.length,
          elements = [],
          nextIndex = 0;
      while (nextIndex < length) {
        var next = codePoints[nextIndex];
        var nextCP = Number(next);
        if (!SameValue(nextCP, ToInteger(nextCP)) ||
            nextCP < 0 || nextCP > 0x10FFFF) {
          throw RangeError('Invalid code point ' + nextCP);
        }
        if (nextCP < 0x10000) {
          elements.push(String.fromCharCode(nextCP));
        } else {
          nextCP -= 0x10000;
          elements.push(String.fromCharCode((nextCP >> 10) + 0xD800));
          elements.push(String.fromCharCode((nextCP % 0x400) + 0xDC00));
        }
        nextIndex += 1;
      }
      return elements.join('');
    });

  // 21.1.2.3 String.prototype

  // 21.1.2.4 String.raw ( template , ...substitutions )
  define(
    String, 'raw',
    function raw(template /*, ...substitutions*/) {
      var substitutions = [].slice.call(arguments, 1);

      var cooked = Object(template);
      var rawValue = cooked['raw'];
      var raw = Object(rawValue);
      var len = raw['length'];
      var literalSegments = ToLength(len);
      if (literalSegments <= 0) return '';
      var stringElements = [];
      var nextIndex = 0;
      while (true) {
        var next = raw[nextIndex];
        var nextSeg = String(next);
        stringElements.push(nextSeg);
        if (nextIndex + 1 === literalSegments)
          return stringElements.join('');
        next = substitutions[nextIndex];
        var nextSub = String(next);
        stringElements.push(nextSub);
        nextIndex = nextIndex + 1;
      }
    });

  // See https://githib.com/inexorabletash/uate for a more useful version.

  // 21.1.3 Properties of the String Prototype Object
  // 21.1.3.1 String.prototype.charAt ( pos )
  // 21.1.3.2 String.prototype.charCodeAt ( pos )

  // 21.1.3.3 String.prototype.codePointAt ( pos )
  define(
    String.prototype, 'codePointAt',
    function codePointAt(pos) {
      var o = strict(this);
      var s = String(o);
      var position = ToInteger(pos);
      var size = s.length;
      if (position < 0 || position >= size) return undefined;
      var first = s.charCodeAt(position);
      if (first < 0xD800 || first > 0xDBFF || position + 1 === size) return first;
      var second = s.charCodeAt(position + 1);
      if (second < 0xDC00 || second > 0xDFFF) return first;
      return ((first - 0xD800) * 1024) + (second - 0xDC00) + 0x10000;
    });

  // 21.1.3.4 String.prototype.concat ( ...args )
  // 21.1.3.5 String.prototype.constructor

  // 21.1.3.6 String.prototype.endsWith ( searchString [ , endPosition] )
  define(
    String.prototype, 'endsWith',
    function endsWith(searchString) {
      var endPosition = arguments[1];

      var o = strict(this);
      var s = String(o);
      var searchStr = String(searchString);
      var len = s.length;
      var pos = (endPosition === undefined) ? len : ToInteger(endPosition);
      var end = min(max(pos, 0), len);
      var searchLength = searchStr.length;
      var start = end - searchLength;
      if (start < 0) return false;
      if (s.substring(start, start + searchLength) === searchStr) return true;
      return false;
    });

  // 21.1.3.7 String.prototype.includes ( searchString [ , position ] )
  define(
    String.prototype, 'includes',
    function includes(searchString) {
      var position = arguments[1];

      var o = strict(this);
      var s = String(o);
      var searchStr = String(searchString);
      var pos = ToInteger(position);
      var len = s.length;
      var start = min(max(pos, 0), len);
      return s.indexOf(searchStr, start) !== -1;
    });

  // 21.1.3.8 String.prototype.indexOf ( searchString [ , position ] )
  // 21.1.3.9 String.prototype.lastIndexOf ( searchString [ , position ] )
  // 21.1.3.10 String.prototype.localeCompare ( that [, reserved1 [ , reserved2 ] ] )
  // 21.1.3.11 String.prototype.match ( regexp )
  define(
    String.prototype, 'match',
    function match(regexp) {
      var o = strict(this);
      var s = String(o);
      if (HasProperty(regexp, $$match)) var rx = regexp;
      else rx = new RegExp(regexp);
      return rx[$$match](s);
    }, !string_regexp_dispatch);

  // 21.1.3.12 String.prototype.normalize ( [ form ] )

  // Not practical due to table sizes; if needed, pull in:
  // https://github.com/walling/unorm/

  // 21.1.3.13 String.prototype.repeat ( count )
  define(
    String.prototype, 'repeat',
    function repeat(count) {
      var o = strict(this);
      var s = String(o);
      var n = ToInteger(count);
      if (n < 0) throw RangeError();
      if (n === Infinity) throw RangeError();
      var t = new Array(n + 1).join(s);
      return t;
    });

  // 21.1.3.14 String.prototype.replace (searchValue, replaceValue )
  define(
    String.prototype, 'replace',
    function replace(searchValue, replaceValue) {
      var o = strict(this);
      if (HasProperty(searchValue, $$replace))
        return searchValue[$$replace](o, replaceValue);
      return orig_replace.call(o, searchValue, replaceValue);
    }, !string_regexp_dispatch);

  // 21.1.3.15 String.prototype.search ( regexp )
  define(
    String.prototype, 'search',
    function search(regexp) {
      var o = strict(this);
      var string = String(o);
      if (HasProperty(regexp, $$search)) var rx = regexp;
      else rx = new RegExp(regexp);
      return rx[$$search](string);
    }, !string_regexp_dispatch);

  // 21.1.3.16 String.prototype.slice ( start, end )
  // 21.1.3.17 String.prototype.split ( separator, limit )
  define(
    String.prototype, 'split',
    function split(separator, limit) {
      var o = strict(this);
      if (HasProperty(separator, $$split))
        return separator[$$split](o, limit);
      return orig_split.call(o, separator, limit);
    }, !string_regexp_dispatch);

  // 21.1.3.18 String.prototype.startsWith ( searchString [, position ] )
  define(
    String.prototype, 'startsWith',
    function startsWith(searchString) {
      var position = arguments[1];

      var o = strict(this);
      var s = String(o);
      var searchStr = String(searchString);
      var pos = ToInteger(position);
      var len = s.length;
      var start = min(max(pos, 0), len);
      var searchLength = searchStr.length;
      if (searchLength + start > len) return false;
      if (s.substring(start, start + searchLength) === searchStr) return true;
      return false;
    });

  // 21.1.3.19 String.prototype.substring ( start, end )
  // 21.1.3.20 String.prototype.toLocaleLowerCase ( [ reserved1 [ , reserved2 ] ] )
  // 21.1.3.21 String.prototype.toLocaleUpperCase ([ reserved1 [ , reserved2 ] ] )
  // 21.1.3.22 String.prototype.toLowerCase ( )
  // 21.1.3.23 String.prototype.toString ( )
  // 21.1.3.24 String.prototype.toUpperCase ( )
  // 21.1.3.25 String.prototype.trim ( )
  // 21.1.3.26 String.prototype.valueOf ( )

  // 21.1.3.27 String.prototype [ @@iterator ]( )
  define(
    String.prototype, $$iterator,
    function entries() {
      return CreateStringIterator(this, 'value');
    });

  // 21.1.4 Properties of String Instances
  // 21.1.4.1 length

  // 21.1.5 String Iterator Objects
  /** @constructor */
  function StringIterator() {}

  // 21.1.5.1 CreateStringIterator Abstract Operation
  function CreateStringIterator(string, kind) {
    var s = String(string);
    var iterator = new StringIterator;
    set_internal(iterator, '[[IteratedString]]', s);
    set_internal(iterator, '[[StringIteratorNextIndex]]', 0);
    set_internal(iterator, '[[StringIterationKind]]', kind);
    return iterator;
  }

  // 21.1.5.2 The %StringIteratorPrototype% Object
  var $StringIteratorPrototype$ = Object.create($IteratorPrototype$);
  StringIterator.prototype = $StringIteratorPrototype$;

  // 21.1.5.2.1 %StringIteratorPrototype%.next ( )
  define(
    $StringIteratorPrototype$, 'next',
    function next() {
      var o = ToObject(this);
      var s = String(o['[[IteratedString]]']),
          index = o['[[StringIteratorNextIndex]]'],
          len = s.length;
      if (index >= len) {
        set_internal(o, '[[StringIteratorNextIndex]]', Infinity);
        return CreateIterResultObject(undefined, true);
      }
      var cp = s.codePointAt(index);
      set_internal(o, '[[StringIteratorNextIndex]]', index + (cp > 0xFFFF ? 2 : 1));
      return CreateIterResultObject(String.fromCodePoint(cp), false);
    });

  // 21.1.5.2.2 %StringIteratorPrototype% [ @@toStringTag ]
  define($StringIteratorPrototype$, $$toStringTag, 'String Iterator');

  // 21.1.5.3 Properties of String Iterator Instances

  // ---------------------------------------
  // 21.2 RegExp (Regular Expression) Objects
  // ---------------------------------------

  // 21.2.1 Patterns
  // 21.2.2 Pattern Semantics
  // 21.2.2.1 Notation
  // 21.2.2.2 Pattern
  // 21.2.2.3 Disjunction
  // 21.2.2.4 Alternative
  // 21.2.2.5 Term
  // 21.2.2.6 Assertion
  // 21.2.2.7 Quantifier
  // 21.2.2.8 Atom
  // 21.2.2.9 AtomEscape
  // 21.2.2.10 CharacterEscape
  // 21.2.2.11 DecimalEscape
  // 21.2.2.12 CharacterClassEscape
  // 21.2.2.13 CharacterClass
  // 21.2.2.14 ClassRanges
  // 21.2.2.15 NonemptyClassRanges
  // 21.2.2.16 NonemptyClassRangesNoDash
  // 21.2.2.17 ClassAtom
  // 21.2.2.18 ClassAtomNoDash
  // 21.2.2.19 ClassEscape
  // 21.2.3 The RegExp Constructor
  // 21.2.3.1 RegExp ( pattern, flags )
  // 21.2.3.2 new RegExp( ...argumentsList )
  // 21.2.3.3 Abstract Operations for the RegExp Constructor
  // 21.2.4 Properties of the RegExp Constructor
  // 21.2.4.1 RegExp.prototype
  // 21.2.5 Properties of the RegExp Prototype Object
  // 21.2.5.1 RegExp.prototype.constructor
  // 21.2.5.2 RegExp.prototype.exec ( string )

  // 21.2.5.3 get RegExp.prototype.flags
  if (!('flags' in RegExp.prototype)) {
    Object.defineProperty(
      RegExp.prototype, 'flags', {
        get: function() {
          var s = String(this);
          return s.substring(s.lastIndexOf('/') + 1);
        }
      });
  }

  // 21.2.5.4 get RegExp.prototype.global
  // 21.2.5.5 get RegExp.prototype.ignoreCase

  // 21.2.5.6 RegExp.prototype [ @@match ] ( string )
  define(RegExp.prototype, $$match, function(string) {
    var o = strict(this);
    return orig_match.call(string, o);
  });

  // 21.2.5.7 get RegExp.prototype.multiline

  // 21.2.5.8 RegExp.prototype [ @@replace ] ( string, replaceValue )
  define(RegExp.prototype, $$replace, function(string, replaceValue) {
    var o = strict(this);
    return orig_replace.call(string, o, replaceValue);
  });

  // 21.2.5.9 RegExp.prototype [ @@search ] ( string )
  define(RegExp.prototype, $$search, function(string) {
    var o = strict(this);
    return orig_search.call(string, o);
  });

  // 21.2.5.10 get RegExp.prototype.source

  // 21.2.5.11 RegExp.prototype [ @@split ] ( string, limit )
  define(RegExp.prototype, $$split, function(string, limit) {
    var o = strict(this);
    return orig_split.call(string, o, limit);
  });

  // 21.2.5.12 get RegExp.prototype.sticky
  // 21.2.5.13 RegExp.prototype.test( S )
  // 21.2.5.14 RegExp.prototype.toString ( )
  // 21.2.5.15 get RegExp.prototype.unicode

  // 21.2.6 Properties of RegExp Instances
  // 21.2.6.1 lastIndex

  // (No polyfillable changes from ES5)

  // ---------------------------------------
  // 22 Indexed Collections
  // ---------------------------------------

  // ---------------------------------------
  // 22.1 Array Objects
  // ---------------------------------------

  // 22.1.1 The Array Constructor
  // 22.1.1.1 Array ( )
  // 22.1.1.2 Array (len)
  // 22.1.1.3 Array (...items )

  // 22.1.2 Properties of the Array Constructor

  // 22.1.2.1 Array.from ( items [ , mapfn [ , thisArg ] ] )
  define(
    Array, 'from',
    function from(items) {
      var mapfn = arguments[1];
      var thisArg = arguments[2];

      var c = strict(this);
      if (mapfn === undefined) {
        var mapping = false;
      } else {
        if (!IsCallable(mapfn)) throw TypeError();
        var t = thisArg;
        mapping = true;
      }
      var usingIterator = GetMethod(items, $$iterator);
      if (usingIterator !== undefined) {
         if (IsConstructor(c)) {
          var a = new c();
        } else {
          a = new Array(0);
        }
        var iterator = GetIterator(items, usingIterator);
        var k = 0;
        while (true) {
          var next = IteratorStep(iterator);
          if (next === false) {
            a.length = k;
            return a;
          }
          var nextValue = IteratorValue(next);
          if (mapping)
            var mappedValue = mapfn.call(t, nextValue);
          else
            mappedValue = nextValue;
          a[k] = mappedValue;
          k += 1;
        }
      }
      var arrayLike = ToObject(items);
      var lenValue = arrayLike.length;
      var len = ToLength(lenValue);
      if (IsConstructor(c)) {
        a = new c(len);
      } else {
        a = new Array(len);
      }
      k = 0;
      while (k < len) {
        var kValue = arrayLike[k];
        if (mapping)
          mappedValue = mapfn.call(t, kValue, k);
        else
          mappedValue = kValue;
        a[k] = mappedValue;
        k += 1;
      }
      a.length = len;
      return a;
    });

  // 22.1.2.2 Array.isArray ( arg )

  // 22.1.2.3 Array.of ( ...items )
  define(
    Array, 'of',
    function of() {
      var items = arguments;

      var lenValue = items.length;
      var len = ToUint32(lenValue);
      var c = strict(this), a;
      if (IsConstructor(c)) {
        a = new c(len);
        a = ToObject(a);
      } else {
        a = new Array(len);
      }
      var k = 0;
      while (k < len) {
        a[k] = items[k];
        k += 1;
      }
      a.length = len;
      return a;
    });

  // 22.1.2.4 Array.prototype
  // 22.1.2.5 get Array [ @@species ]
  // 22.1.3 Properties of the Array Prototype Object
  // 22.1.3.1 Array.prototype.concat ( ...arguments )
  // 22.1.3.1.1 Runtime Semantics: IsConcatSpreadable ( O )
  // 22.1.3.2 Array.prototype.constructor
  // 22.1.3.3 Array.prototype.copyWithin (target, start [ , end ] )
  define(
    Array.prototype, 'copyWithin',
    function copyWithin(target, start/*, end*/) {
      var end = arguments[2];

      var o = ToObject(this);
      var lenVal = o.length;
      var len = ToLength(lenVal);
      len = max(len, 0);
      var relativeTarget = ToInteger(target);
      var to;
      if (relativeTarget < 0)
        to = max(len + relativeTarget, 0);
      else
        to = min(relativeTarget, len);
      var relativeStart = ToInteger(start);
      var from;
      if (relativeStart < 0)
        from = max(len + relativeStart, 0);
      else
        from = min(relativeStart, len);
      var relativeEnd;
      if (end === undefined)
        relativeEnd = len;
      else
        relativeEnd = ToInteger(end);
      var final;
      if (relativeEnd < 0)
        final = max(len + relativeEnd, 0);
      else
        final = min(relativeEnd, len);
      var count = min(final - from, len - to);
      var direction;
      if (from < to && to < from + count) {
        direction = -1;
        from = from + count - 1;
        to = to + count - 1;
      } else {
        direction = 1;
      }
      while (count > 0) {
        var fromKey = String(from);
        var toKey = String(to);
        var fromPresent = HasProperty(o, fromKey);
        if (fromPresent) {
          var fromVal = o[fromKey];
          o[toKey] = fromVal;
        } else {
          delete o[toKey];
        }
        from = from + direction;
        to = to + direction;
        count = count - 1;
      }
      return o;
    });

  // 22.1.3.4 Array.prototype.entries ( )
  var nativeArrayIteratorMethods =
        ('entries' in Array.prototype && 'next' in [].entries());

  define(
    Array.prototype, 'entries',
    function entries() {
      return CreateArrayIterator(this, 'key+value');
    }, !nativeArrayIteratorMethods);

  // 22.1.3.5 Array.prototype.every ( callbackfn [ , thisArg] )

  // 22.1.3.6 Array.prototype.fill (value [ , start [ , end ] ] )
  define(
    Array.prototype, 'fill',
    function fill(value/*, start, end*/) {
      var start = arguments[1],
          end = arguments[2];

      var o = ToObject(this);
      var lenVal = o.length;
      var len = ToLength(lenVal);
      len = max(len, 0);
      var relativeStart = ToInteger(start);
      var k;
      if (relativeStart < 0)
        k = max((len + relativeStart), 0);
      else
        k = min(relativeStart, len);
      var relativeEnd;
      if (end === undefined)
        relativeEnd = len;
      else
        relativeEnd = ToInteger(end);
      var final;
      if (relativeEnd < 0)
        final = max((len + relativeEnd), 0);
      else
        final = min(relativeEnd, len);
      while (k < final) {
        var pk = String(k);
        o[pk] = value;
        k += 1;
      }
      return o;
    });

  // 22.1.3.7 Array.prototype.filter ( callbackfn [ , thisArg ] )

  // 22.1.3.8 Array.prototype.find ( predicate [ , thisArg ] )
  define(
    Array.prototype, 'find',
    function find(predicate) {
      var o = ToObject(this);
      var lenValue = o.length;
      var len = ToInteger(lenValue);
      if (!IsCallable(predicate)) throw TypeError();
      var t = arguments.length > 1 ? arguments[1] : undefined;
      var k = 0;
      while (k < len) {
        var pk = String(k);
        var kPresent = HasProperty(o, pk);
        if (kPresent) {
          var kValue = o[pk];
          var testResult = predicate.call(t, kValue, k, o);
          if (Boolean(testResult)) {
            return kValue;
          }
        }
        ++k;
      }
      return undefined;
    });

  // 22.1.3.9 Array.prototype.findIndex ( predicate [ , thisArg ] )
  define(
    Array.prototype, 'findIndex',
    function findIndex(predicate) {
      var o = ToObject(this);
      var lenValue = o.length;
      var len = ToLength(lenValue);
      if (!IsCallable(predicate)) throw TypeError();
      var t = arguments.length > 1 ? arguments[1] : undefined;
      var k = 0;
      while (k < len) {
        var pk = String(k);
        var kPresent = HasProperty(o, pk);
        if (kPresent) {
          var kValue = o[pk];
          var testResult = predicate.call(t, kValue, k, o);
          if (Boolean(testResult)) {
            return k;
          }
        }
        ++k;
      }
      return -1;
    });

  // 22.1.3.10 Array.prototype.forEach ( callbackfn [ , thisArg ] )
  // 22.1.3.11 Array.prototype.indexOf ( searchElement [ , fromIndex ] )
  // 22.1.3.12 Array.prototype.join (separator)

  // 22.1.3.13 Array.prototype.keys ( )
  define(
    Array.prototype, 'keys',
    function keys() {
      return CreateArrayIterator(this, 'key');
    }, !nativeArrayIteratorMethods);

  // 22.1.3.14 Array.prototype.lastIndexOf ( searchElement [ , fromIndex ] )
  // 22.1.3.15 Array.prototype.map ( callbackfn [ , thisArg ] )
  // 22.1.3.16 Array.prototype.pop ( )
  // 22.1.3.17 Array.prototype.push ( ...items )
  // 22.1.3.18 Array.prototype.reduce ( callbackfn [ , initialValue ] )
  // 22.1.3.19 Array.prototype.reduceRight ( callbackfn [ , initialValue ] )
  // 22.1.3.20 Array.prototype.reverse ( )
  // 22.1.3.21 Array.prototype.shift ( )
  // 22.1.3.22 Array.prototype.slice (start, end)
  // 22.1.3.23 Array.prototype.some ( callbackfn [ , thisArg ] )
  // 22.1.3.24 Array.prototype.sort (comparefn)
  // 22.1.3.25 Array.prototype.splice (start, deleteCount , ...items )
  // 22.1.3.26 Array.prototype.toLocaleString ( [ reserved1 [ , reserved2 ] ] )
  // 22.1.3.27 Array.prototype.toString ( )
  // 22.1.3.28 Array.prototype.unshift ( ...items )

  // 22.1.3.29 Array.prototype.values ( )
  define(
    Array.prototype, 'values',
    function values() {
      return CreateArrayIterator(this, 'value');
    }, !nativeArrayIteratorMethods);

  // 22.1.3.30 Array.prototype [ @@iterator ] ( )
  define(
    Array.prototype, $$iterator,
    Array.prototype.values
    );

  // 22.1.3.31 Array.prototype [ @@unscopables ]
  // 22.1.4 Properties of Array Instances
  // 22.1.4.1 length

  // 22.1.5 Array Iterator Objects
  function ArrayIterator() {}

  // 22.1.5.1 CreateArrayIterator Abstract Operation
  function CreateArrayIterator(array, kind) {
    var o = ToObject(array);
    var iterator = new ArrayIterator;
    set_internal(iterator, '[[IteratedObject]]', o);
    set_internal(iterator, '[[ArrayIteratorNextIndex]]', 0);
    set_internal(iterator, '[[ArrayIterationKind]]', kind);
    return iterator;
  }

  // 22.1.5.2 The %ArrayIteratorPrototype% Object
  var $ArrayIteratorPrototype$ = Object.create($IteratorPrototype$);
  ArrayIterator.prototype = $ArrayIteratorPrototype$;

  // 22.1.5.2.1 %ArrayIteratorPrototype%. next( )
  define(
    $ArrayIteratorPrototype$, 'next',
    function next() {
      var o = strict(this);
      if (Type(o) !== 'object') throw TypeError();
      var a = o['[[IteratedObject]]'],
          index = o['[[ArrayIteratorNextIndex]]'],
          itemKind = o['[[ArrayIterationKind]]'],
          lenValue = a.length,
          len = ToUint32(lenValue),
          elementKey,
          elementValue;
      if (itemKind.indexOf('sparse') !== -1) {
        var found = false;
        while (!found && index < len) {
          elementKey = String(index);
          found = HasProperty(a, elementKey);
          if (!found) {
            index += 1;
          }
        }
      }
      if (index >= len) {
        set_internal(o, '[[ArrayIteratorNextIndex]]', Infinity);
        return CreateIterResultObject(undefined, true);
      }
      elementKey = index;
      set_internal(o, '[[ArrayIteratorNextIndex]]', index + 1);
      if (itemKind.indexOf('value') !== -1)
        elementValue = a[elementKey];
      if (itemKind.indexOf('key+value') !== -1)
        return CreateIterResultObject([elementKey, elementValue], false);
      if (itemKind.indexOf('key') !== -1)
        return CreateIterResultObject(elementKey, false);
      if (itemKind === 'value')
        return CreateIterResultObject(elementValue, false);
      throw Error('Internal error');
    });

  // 22.1.5.2.2 %ArrayIteratorPrototype% [ @@toStringTag ]
  define($ArrayIteratorPrototype$, $$toStringTag, 'Array Iterator');

  // 22.1.5.3 Properties of Array Iterator Instances


  // ---------------------------------------
  // 22.2 TypedArray Objects
  // ---------------------------------------

  // See typedarray.js for TypedArray polyfill

  ['Int8Array', 'Uint8Array', 'Uint8ClampedArray',
   'Int16Array', 'Uint16Array',
   'Int32Array', 'Uint32Array',
   'Float32Array', 'Float64Array'].forEach(function ($TypedArrayName$) {
     if (!($TypedArrayName$ in global))
       return;
     var $TypedArray$ = global[$TypedArrayName$];

     // 22.2.1 The %TypedArray% Intrinsic Object
     // 22.2.1.1 %TypedArray% ( length )
     // 22.2.1.2 %TypedArray% ( typedArray )
     // 22.2.1.3 %TypedArray% ( object )
     // 22.2.1.4 %TypedArray% ( buffer [ , byteOffset [ , length ] ] )
     // 22.2.1.5 %TypedArray% ( all other argument combinations )
     // 22.2.2 Properties of the %TypedArray% Intrinsic Object

     // 22.2.2.1 %TypedArray%.from ( source [ , mapfn [ , thisArg ] ] )
     define(
       $TypedArray$, 'from',
       function from(source) {
         var mapfn = arguments[1];
         var thisArg = arguments[2];

         var c = strict(this);
         if (!IsConstructor(c)) throw TypeError();
         if (mapfn === undefined) {
           var mapping = false;
         } else {
           if (IsCallable(mapfn)) throw TypeError();
           var t = thisArg;
           mapping = true;
         }
         var usingIterator = GetMethod(source, $$iterator);
         if (usingIterator !== undefined) {
           var iterator = GetIterator(source, usingIterator);
           var values = [];
           var next = true;
           while (next !== false) {
             next = IteratorStep(iterator);
             if (next !== false) {
               var nextValue = IteratorValue(next);
               values.push(nextValue);
             }
           }
           var len = values.length;
           var newObj = new c(len);
           var k = 0;
           while (k < len) {
             var kValue = values.shift();
             if (mapping) {
               var mappedValue = mapfn.call(t, kValue);
             } else {
               mappedValue = kValue;
             }
             newObj[k] = mappedValue;
             ++k;
           }
           console.assert(values.length === 0);
           return newObj;
         }
         var arrayLike = ToObject(source);
         var lenValue = arrayLike.length;
         len = ToLength(lenValue);
         newObj = new c(len);
         k = 0;
         while (k < len) {
           kValue = arrayLike[k];
           if (mapping) {
             mappedValue = mapfn.call(t, kValue, k);
           } else {
             mappedValue = kValue;
           }
           newObj[k] = mappedValue;
           ++k;
         }
         return newObj;
       });

     // 22.2.2.2 %TypedArray%.of ( ...items )
     define(
       $TypedArray$, 'of',
       function of() {
         var items = arguments;

         var len = items.length;
         var c = strict(this);
         var newObj = new c(len);
         var k = 0;
         while (k < len) {
           newObj[k] = items[k];
           ++k;
         }
         return newObj;
       });

     // 22.2.2.3 %TypedArray%.prototype
     // 22.2.2.4 get %TypedArray% [ @@species ]
     // 22.2.3 Properties of the %TypedArrayPrototype% Object
     // 22.2.3.1 get %TypedArray%.prototype.buffer
     // 22.2.3.2 get %TypedArray%.prototype.byteLength
     // 22.2.3.3 get %TypedArray%.prototype.byteOffset
     // 22.2.3.4 %TypedArray%.prototype.constructor

     // 22.2.3.5 %TypedArray%.prototype.copyWithin (target, start [, end ] )
     define($TypedArray$.prototype, 'copyWithin', Array.prototype.copyWithin);

     // 22.2.3.6 %TypedArray%.prototype.entries ( )
     define($TypedArray$.prototype, 'entries', Array.prototype.entries);

     // 22.2.3.7 %TypedArray%.prototype.every ( callbackfn [ , thisArg ] )
     define($TypedArray$.prototype, 'every', Array.prototype.every);

     // 22.2.3.8 %TypedArray%.prototype.fill (value [ , start [ , end ] ] )
     define(
       $TypedArray$.prototype, 'fill',
       //Array.prototype.fill // Doesn't work in Safari 7
       function fill(value/*, start, end*/) {
         var start = arguments[1],
             end = arguments[2];

         var o = ToObject(this);
         var lenVal = o.length;
         var len = ToLength(lenVal);
         len = max(len, 0);
         var relativeStart = ToInteger(start);
         var k;
         if (relativeStart < 0) k = max((len + relativeStart), 0);
         else k = min(relativeStart, len);
         var relativeEnd;
         if (end === undefined) relativeEnd = len;
         else relativeEnd = ToInteger(end);
         var final;
         if (relativeEnd < 0) final = max((len + relativeEnd), 0);
         else final = min(relativeEnd, len);
         while (k < final) {
           var pk = String(k);
           o[pk] = value;
           k += 1;
         }
         return o;
       });

     // 22.2.3.9 %TypedArray%.prototype.filter ( callbackfn [ , thisArg ] )
     define(
       $TypedArray$.prototype, 'filter',
       function filter(callbackfn) {
         var thisArg = arguments[1];

         var o = ToObject(this);
         var lenVal = o.length;
         var len = ToLength(lenVal);
         if (!IsCallable(callbackfn)) throw TypeError();
         var t = thisArg;
         var c = o.constructor;
         var kept = [];
         var k = 0;
         var captured = 0;
         while (k < len) {
           var kValue = o[k];
           var selected = callbackfn.call(t, kValue, k, o);
           if (selected) {
             kept.push(kValue);
             ++captured;
           }
           ++k;
         }
         var a = new c(captured);
         var n = 0;
         for (var i = 0; i < kept.length; ++i) {
           var e = kept[i];
           a[n] = e;
           ++n;
         }
         return a;
       });

     // 22.2.3.10 %TypedArray%.prototype.find (predicate [ , thisArg ] )
     define($TypedArray$.prototype, 'find', Array.prototype.find);

     // 22.2.3.11 %TypedArray%.prototype.findIndex ( predicate [ , thisArg ] )
     define($TypedArray$.prototype, 'findIndex', Array.prototype.findIndex);

     // 22.2.3.12 %TypedArray%.prototype.forEach ( callbackfn [ , thisArg ] )
     define($TypedArray$.prototype, 'forEach', Array.prototype.forEach);

     // 22.2.3.13 %TypedArray%.prototype.indexOf (searchElement [ , fromIndex ] )
     define($TypedArray$.prototype, 'indexOf', Array.prototype.indexOf);

     // 22.2.3.14 %TypedArray%.prototype.join ( separator )
     define($TypedArray$.prototype, 'join', Array.prototype.join);

     // 22.2.3.15 %TypedArray%.prototype.keys ( )
     define($TypedArray$.prototype, 'keys', Array.prototype.keys);

     // 22.2.3.16 %TypedArray%.prototype.lastIndexOf ( searchElement [ , fromIndex ] )
     define($TypedArray$.prototype, 'lastIndexOf', Array.prototype.lastIndexOf);

     // 22.2.3.17 get %TypedArray%.prototype.length

     // 22.2.3.18 %TypedArray%.prototype.map ( callbackfn [ , thisArg ] )
     define(
       $TypedArray$.prototype, 'map',
       function map(callbackfn) {
         var thisArg = arguments[1];

         var o = ToObject(this);
         var lenValue = o.length;
         var len = ToLength(lenValue);
         if (!IsCallable(callbackfn)) throw TypeError();
         var t = thisArg;
         var a = undefined;
         var c = o.constructor;
         if (IsConstructor(c))
           a = new c(len);
         if (a === undefined)
           a = new Array(len);
         var k = 0;
         while (k < len) {
           var kPresent = HasProperty(o, k);
           if (kPresent) {
             var kValue = o[k];
             var mappedValue = callbackfn.call(t, kValue, k, o);
             a[k] = mappedValue;
           }
           ++k;
         }
         return a;
       });

     // 22.2.3.19 %TypedArray%.prototype.reduce ( callbackfn [, initialValue] )
     define($TypedArray$.prototype, 'reduce', Array.prototype.reduce);

     // 22.2.3.20 %TypedArray%.prototype.reduceRight ( callbackfn [, initialValue] )
     define($TypedArray$.prototype, 'reduceRight', Array.prototype.reduceRight);

     // 22.2.3.21 %TypedArray%.prototype.reverse ( )
     define($TypedArray$.prototype, 'reverse', Array.prototype.reverse);

     // 22.2.3.22 %TypedArray%.prototype.set ( overloaded [ , offset ])
     // 22.2.3.22.1 %TypedArray%.prototype.set (array [ , offset ] )
     // 22.2.3.22.2 %TypedArray%.prototype.set(typedArray [, offset ] )

     // 22.2.3.23 %TypedArray%.prototype.slice ( start, end )
     define(
       $TypedArray$.prototype, 'slice',
       function slice(start, end) {
         var o = ToObject(this);
         var lenVal = o.length;
         var len = ToLength(lenVal);
         var relativeStart = ToInteger(start);
         var k = (relativeStart < 0) ? max(len + relativeStart, 0) : min(relativeStart, len);
         var relativeEnd = (end === undefined) ? len : ToInteger(end);
         var final = (relativeEnd < 0) ? max(len + relativeEnd, 0) : min(relativeEnd, len);
         var count = final - k;
         var c = o.constructor;
         if (IsConstructor(c)) {
           var a = new c(count);
         } else {
           throw TypeError();
         }
         var n = 0;
         while (k < final) {
           var kValue = o[k];
           a[n] = kValue;
           ++k;
           ++n;
         }
         return a;
       });

     // 22.2.3.24 %TypedArray%.prototype.some ( callbackfn [ , thisArg ] )
     define($TypedArray$.prototype, 'some', Array.prototype.some);

     // 22.2.3.25 %TypedArray%.prototype.sort ( comparefn )
     define(
       $TypedArray$.prototype, 'sort',
       function sort() {
         var comparefn = arguments[0];

         function sortCompare(x, y) {
           console.assert(Type(x) === 'number' && Type(y) === 'number');
           if (x !== x && y !== y) return +0;
           if (x !== x) return 1;
           if (y !== y) return -1;
           if (comparefn !== undefined) {
             return comparefn(x, y);
           }
           if (x < y) return -1;
           if (x > y) return 1;
           return +0;
         }
         return Array.prototype.sort.call(this, sortCompare);
       });

     // 22.2.3.26 %TypedArray%.prototype.subarray( [ begin [ , end ] ] )
     // 22.2.3.27 %TypedArray%.prototype.toLocaleString ([ reserved1 [ , reserved2 ] ])
     // 22.2.3.28 %TypedArray%.prototype.toString ( )

     // 22.2.3.29 %TypedArray%.prototype.values ( )
     define($TypedArray$.prototype, 'values', Array.prototype.values);

     // 22.2.3.30 %TypedArray%.prototype [ @@iterator ] ( )
     define(
       $TypedArray$.prototype, $$iterator,
       $TypedArray$.prototype.values
     );

     // 22.2.3.31 get %TypedArray%.prototype [ @@toStringTag ]
     define($TypedArray$.prototype, $$toStringTag, $TypedArrayName$);

     // 22.2.4 The TypedArray Constructors
     // 22.2.4.1TypedArray( ... argumentsList)
     // 22.2.5 Properties of the TypedArray Constructors
     // 22.2.5.1 TypedArray.BYTES_PER_ELEMENT
     // 22.2.5.2 TypedArray.prototype
     // 22.2.6 Properties of TypedArray Prototype Objects
     // 22.2.6.1 TypedArray.prototype.BYTES_PER_ELEMENT
     // 22.2.6.2 TypedArray.prototype.constructor
     // 22.2.7 Properties of TypedArray Instances
   });

  // ---------------------------------------
  // 23 Keyed Collection
  // ---------------------------------------

  // ---------------------------------------
  // 23.1 Map Objects
  // ---------------------------------------

  (function() {
    // 23.1.1 The Map Constructor

    // 23.1.1.1 Map ( [ iterable ] )
    /** @constructor */
    function Map(/*iterable*/) {
      var map = strict(this);
      var iterable = arguments[0];

      if (Type(map) !== 'object') throw TypeError();
      if ('[[MapData]]' in map) throw TypeError();

      if (iterable !== undefined) {
        var adder = map['set'];
        if (!IsCallable(adder)) throw TypeError();
        var iter = GetIterator(ToObject(iterable));
      }
      set_internal(map, '[[MapData]]', { keys: [], values: [] });
      if (iter === undefined) return map;
      while (true) {
        var next = IteratorStep(iter);
        if (next === false)
          return map;
        var nextItem = IteratorValue(next);
        if (Type(nextItem) !== 'object') throw TypeError();
        var k = nextItem[0];
        var v = nextItem[1];
        adder.call(map, k, v);
      }

      return map;
    }

    if (!('Map' in global) || OVERRIDE_NATIVE_FOR_TESTING ||
        (function() { try { new global.Map([]); return false; } catch (_) { return true; } }()) ||
        (function() { try { return !new global.Map().entries().next; } catch (_) { return true; } }()) ||
        (new global.Map([['a', 1]]).size !== 1))
      global.Map = Map;


    function MapDataIndexOf(mapData, key) {
      var i;
      if (key === key) return mapData.keys.indexOf(key);
      // Slow case for NaN
      for (i = 0; i < mapData.keys.length; i += 1)
        if (SameValueZero(mapData.keys[i], key)) return i;
      return -1;
    }

    // 23.1.1.2 new Map ( ... argumentsList )
    // 23.1.2 Properties of the Map Constructor
    // 23.1.2.1 Map.prototype
    var $MapPrototype$ = {};
    Map.prototype = $MapPrototype$;

    // 23.1.2.2 get Map [ @@species ]

    // 23.1.3 Properties of the Map Prototype Object
    // 23.1.3.1 Map.prototype.clear ()
    define(
      Map.prototype, 'clear',
      function clear() {
        var m = strict(this);
        if (Type(m) !== 'object') throw TypeError();
        if (!('[[MapData]]' in m)) throw TypeError();
        if (m['[[MapData]]'] === undefined) throw TypeError();
        var entries = m['[[MapData]]'];
        entries.keys.length = 0;
        entries.values.length = 0;
        return undefined;
      });

    // 23.1.3.2 Map.prototype.constructor

    // 23.1.3.3 Map.prototype.delete ( key )
    define(
      Map.prototype, 'delete',
      function delete_(key) {
        var m = strict(this);
        if (Type(m) !== 'object') throw TypeError();
        if (!('[[MapData]]' in m)) throw TypeError();
        if (m['[[MapData]]'] === undefined) throw TypeError();
        var entries = m['[[MapData]]'];
        var i = MapDataIndexOf(entries, key);
        if (i < 0) return false;
        entries.keys[i] = empty;
        entries.values[i] = empty;
        return true;
      });

    // 23.1.3.4 Map.prototype.entries ( )
    define(
      Map.prototype, 'entries',
      function entries() {
        var m = strict(this);
        if (Type(m) !== 'object') throw TypeError();
        return CreateMapIterator(m, 'key+value');
      });

    // 23.1.3.5 Map.prototype.forEach ( callbackfn [ , thisArg ] )
    define(
      Map.prototype, 'forEach',
      function forEach(callbackfn /*, thisArg*/) {
        var thisArg = arguments[1];

        var m = strict(this);
        if (Type(m) !== 'object') throw TypeError();
        if (!('[[MapData]]' in m)) throw TypeError();
        if (m['[[MapData]]'] === undefined) throw TypeError();
        var entries = m['[[MapData]]'];

        if (!IsCallable(callbackfn)) {
          throw TypeError('First argument to forEach is not callable.');
        }
        for (var i = 0; i < entries.keys.length; ++i) {
          if (entries.keys[i] !== empty) {
            callbackfn.call(thisArg, entries.values[i], entries.keys[i], m);
          }
        }
        return undefined;
      });

    // 23.1.3.6 Map.prototype.get ( key )
    define(
      Map.prototype, 'get',
      function get(key) {
        var m = strict(this);
        if (Type(m) !== 'object') throw TypeError();
        if (!('[[MapData]]' in m)) throw TypeError();
        if (m['[[MapData]]'] === undefined) throw TypeError();
        var entries = m['[[MapData]]'];
        var i = MapDataIndexOf(entries, key);
        if (i >= 0) return entries.values[i];
        return undefined;
      });

    // 23.1.3.7 Map.prototype.has ( key )
    define(
      Map.prototype, 'has',
      function has(key) {
        var m = strict(this);
        if (Type(m) !== 'object') throw TypeError();
        if (!('[[MapData]]' in m)) throw TypeError();
        if (m['[[MapData]]'] === undefined) throw TypeError();
        var entries = m['[[MapData]]'];
        if (MapDataIndexOf(entries, key) >= 0) return true;
        return false;
      });

    // 23.1.3.8 Map.prototype.keys ( )
    define(
      Map.prototype, 'keys',
      function keys() {
        var m = strict(this);
        if (Type(m) !== 'object') throw TypeError();
        return CreateMapIterator(m, 'key');
      });

    // 23.1.3.9 Map.prototype.set ( key , value )
    define(
      Map.prototype, 'set',
      function set(key, value) {
        var m = strict(this);
        if (Type(m) !== 'object') throw TypeError();
        if (!('[[MapData]]' in m)) throw TypeError();
        if (m['[[MapData]]'] === undefined) throw TypeError();
        var entries = m['[[MapData]]'];
        var i = MapDataIndexOf(entries, key);
        if (i < 0) i = entries.keys.length;
        if (SameValue(key, -0)) key = 0;
        entries.keys[i] = key;
        entries.values[i] = value;
        return m;
      });

    // 23.1.3.10 get Map.prototype.size
    Object.defineProperty(
      Map.prototype, 'size', {
        get: function() {
          var m = strict(this);
          if (Type(m) !== 'object') throw TypeError();
          if (!('[[MapData]]' in m)) throw TypeError();
          if (m['[[MapData]]'] === undefined) throw TypeError();
          var entries = m['[[MapData]]'];
          var count = 0;
          for (var i = 0; i < entries.keys.length; ++i) {
            if (entries.keys[i] !== empty)
              count = count + 1;
          }
          return count;
        }
      });

    // 23.1.3.11 Map.prototype.values ( )
    define(
      Map.prototype, 'values',
      function values() {
        var m = strict(this);
        if (Type(m) !== 'object') throw TypeError();
        return CreateMapIterator(m, 'value');
      });

    // 23.1.3.12 Map.prototype [ @@iterator ]( )
    define(
      Map.prototype, $$iterator,
      function() {
        var m = strict(this);
        if (Type(m) !== 'object') throw TypeError();
        return CreateMapIterator(m, 'key+value');
      });

    // 23.1.3.13 Map.prototype [ @@toStringTag ]
    define(global.Map.prototype, $$toStringTag, 'Map');

    // 23.1.4 Properties of Map Instances
    // 23.1.5 Map Iterator Objects

    /** @constructor */
    function MapIterator() {}

    // 23.1.5.1 CreateMapIterator Abstract Operation
    function CreateMapIterator(map, kind) {
      if (Type(map) !== 'object') throw TypeError();
      if (!('[[MapData]]' in map)) throw TypeError();
      if (map['[[MapData]]'] === undefined) throw TypeError();
      var iterator = new MapIterator;
      set_internal(iterator, '[[Map]]', map);
      set_internal(iterator, '[[MapNextIndex]]', 0);
      set_internal(iterator, '[[MapIterationKind]]', kind);
      return iterator;
    }

    // 23.1.5.2 The %MapIteratorPrototype% Object
    var $MapIteratorPrototype$ = Object.create($IteratorPrototype$);
    MapIterator.prototype = $MapIteratorPrototype$;

    // 23.1.5.2.1 %MapIteratorPrototype%.next ( )
    define(
      $MapIteratorPrototype$, 'next',
      function next() {
        var o = strict(this);
        if (Type(o) !== 'object') throw TypeError();
        var m = o['[[Map]]'],
            index = o['[[MapNextIndex]]'],
            itemKind = o['[[MapIterationKind]]'],
            entries = m['[[MapData]]'];
        while (index < entries.keys.length) {
          var e = {key: entries.keys[index], value: entries.values[index]};
          index = index += 1;
          set_internal(o, '[[MapNextIndex]]', index);
          if (e.key !== empty) {
            if (itemKind === 'key') {
              return CreateIterResultObject(e.key, false);
            } else if (itemKind === 'value') {
              return CreateIterResultObject(e.value, false);
            } else {
              return CreateIterResultObject([e.key, e.value], false);
            }
          }
        }
        return CreateIterResultObject(undefined, true);
      });

    // 23.1.5.2.2 %MapIteratorPrototype% [ @@toStringTag ]
    define($MapIteratorPrototype$, $$toStringTag, 'Map Iterator');

    // 23.1.5.3 Properties of Map Iterator Instances
  }());

  // ---------------------------------------
  // 23.2 Set Objects
  // ---------------------------------------

  (function() {
    // 23.2.1 The Set Constructor
    // 23.2.1.1 Set ( [ iterable ] )

    /** @constructor */
    function Set(/*iterable*/) {
      var set = strict(this);
      var iterable = arguments[0];

      if (Type(set) !== 'object') throw TypeError();
      if ('[[SetData]]' in set) throw TypeError();

      if (iterable !== undefined) {
        var adder = set['add'];
        if (!IsCallable(adder)) throw TypeError();
        var iter = GetIterator(ToObject(iterable));
      }
      set_internal(set, '[[SetData]]', []);
      if (iter === undefined) return set;
      while (true) {
        var next = IteratorStep(iter);
        if (next === false)
          return set;
        var nextValue = IteratorValue(next);
        adder.call(set, nextValue);
      }

      return set;
    }

    if (!('Set' in global) || OVERRIDE_NATIVE_FOR_TESTING ||
        (function() { try { return !new global.Set().entries().next; } catch (_) { return true; } }()) ||
        (new global.Set([1]).size !== 1))
      global.Set = Set;

    function SetDataIndexOf(setData, key) {
      var i;
      if (key === key)
        return setData.indexOf(key);
      // Slow case for NaN
      for (i = 0; i < setData.length; i += 1)
        if (SameValueZero(setData[i], key)) return i;
      return -1;
    }

    // 23.2.1.2 new Set ( ...argumentsList )
    // 23.2.2 Properties of the Set Constructor

    // 23.2.2.1 Set.prototype
    var $SetPrototype$ =  {};
    Set.prototype = $SetPrototype$;

    // 23.2.2.2 get Set [ @@species ]
    // 23.2.3 Properties of the Set Prototype Object

    // 23.2.3.1 Set.prototype.add (value )
    define(
      Set.prototype, 'add',
      function add(value) {
        var s = strict(this);
        if (Type(s) !== 'object') throw TypeError();
        if (!('[[SetData]]' in s)) throw TypeError();
        if (s['[[SetData]]'] === undefined) throw TypeError();
        if (SameValue(value, -0)) value = 0;
        var entries = s['[[SetData]]'];
        var i = SetDataIndexOf(entries, value);
        if (i < 0) i = s['[[SetData]]'].length;
        s['[[SetData]]'][i] = value;

        return s;
      });

    // 23.2.3.2 Set.prototype.clear ()
    define(
      Set.prototype, 'clear',
      function clear() {
        var s = strict(this);
        if (Type(s) !== 'object') throw TypeError();
        if (!('[[SetData]]' in s)) throw TypeError();
        if (s['[[SetData]]'] === undefined) throw TypeError();
        var entries = s['[[SetData]]'];
        entries.length = 0;
        return undefined;
      });

    // 23.2.3.3 Set.prototype.constructor
    // 23.2.3.4 Set.prototype.delete ( value )
    define(
      Set.prototype, 'delete',
      function delete_(value) {
        var s = strict(this);
        if (Type(s) !== 'object') throw TypeError();
        if (!('[[SetData]]' in s)) throw TypeError();
        if (s['[[SetData]]'] === undefined) throw TypeError();
        var entries = s['[[SetData]]'];
        var i = SetDataIndexOf(entries, value);
        if (i < 0) return false;
        entries[i] = empty;
        return true;
      });

    // 23.2.3.5 Set.prototype.entries ( )
    define(
      Set.prototype, 'entries',
      function entries() {
        var s = strict(this);
        if (Type(s) !== 'object') throw TypeError();
        return CreateSetIterator(s, 'key+value');
      });

    // 23.2.3.6 Set.prototype.forEach ( callbackfn [ , thisArg ] )
    define(
      Set.prototype, 'forEach',
      function forEach(callbackfn/*, thisArg*/) {
        var thisArg = arguments[1];

        var s = strict(this);
        if (Type(s) !== 'object') throw TypeError();
        if (!('[[SetData]]' in s)) throw TypeError();
        if (s['[[SetData]]'] === undefined) throw TypeError();
        var entries = s['[[SetData]]'];

        if (!IsCallable(callbackfn)) {
          throw TypeError('First argument to forEach is not callable.');
        }
        for (var i = 0; i < entries.length; ++i) {
          if (entries[i] !== empty) {
            callbackfn.call(thisArg, entries[i], entries[i], s);
          }
        }
      });

    // 23.2.3.7 Set.prototype.has ( value )
    define(
      Set.prototype, 'has',
      function has(key) {
        var s = strict(this);
        if (Type(s) !== 'object') throw TypeError();
        if (!('[[SetData]]' in s)) throw TypeError();
        if (s['[[SetData]]'] === undefined) throw TypeError();
        var entries = s['[[SetData]]'];
        return SetDataIndexOf(entries, key) !== -1;
      });

    // 23.2.3.8 Set.prototype.keys ( )
    // See Set.prototype.values

    // 23.2.3.9 get Set.prototype.size
    Object.defineProperty(
      Set.prototype, 'size', {
        get: function() {
          var s = strict(this);
          if (Type(s) !== 'object') throw TypeError();
          if (!('[[SetData]]' in s)) throw TypeError();
          if (s['[[SetData]]'] === undefined) throw TypeError();
          var entries = s['[[SetData]]'];
          var count = 0;
          for (var i = 0; i < entries.length; ++i) {
            if (entries[i] !== empty)
              count = count + 1;
          }
          return count;
        }
      });

    // 23.2.3.10 Set.prototype.values ( )
    define(
      Set.prototype, 'values',
      function values() {
        var s = strict(this);
        if (Type(s) !== 'object') throw TypeError();
        return CreateSetIterator(s, 'value');
      });
    // NOTE: function name is still 'values':
    Set.prototype.keys = Set.prototype.values;

    // 23.2.3.11 Set.prototype [@@iterator ] ( )
    define(
      Set.prototype, $$iterator,
      function() {
        var s = strict(this);
        if (Type(s) !== 'object') throw TypeError();
        return CreateSetIterator(s);
      });

    // 23.2.3.12 Set.prototype [ @@toStringTag ]
    define(global.Set.prototype, $$toStringTag, 'Set');

    // 23.2.4 Properties of Set Instances
    // 23.2.5 Set Iterator Objects
    /** @constructor */
    function SetIterator() {}

    // 23.2.5.1 CreateSetIterator Abstract Operation
    function CreateSetIterator(set, kind) {
      if (Type(set) !== 'object') throw TypeError();
      if (!('[[SetData]]' in set)) throw TypeError();
      if (set['[[SetData]]'] === undefined) throw TypeError();
      var iterator = new SetIterator;
      set_internal(iterator, '[[IteratedSet]]', set);
      set_internal(iterator, '[[SetNextIndex]]', 0);
      set_internal(iterator, '[[SetIterationKind]]', kind);
      return iterator;
    }

    // 23.2.5.2 The %SetIteratorPrototype% Object
    var $SetIteratorPrototype$ = Object.create($IteratorPrototype$);
    SetIterator.prototype = $SetIteratorPrototype$;

    // 23.2.5.2.1 %SetIteratorPrototype%.next( )
    define(
      $SetIteratorPrototype$, 'next',
      function next() {
        var o = strict(this);
        if (Type(o) !== 'object') throw TypeError();
        var s = o['[[IteratedSet]]'],
            index = o['[[SetNextIndex]]'],
            itemKind = o['[[SetIterationKind]]'],
            entries = s['[[SetData]]'];
        while (index < entries.length) {
          var e = entries[index];
          index = index += 1;
          set_internal(o, '[[SetNextIndex]]', index);
          if (e !== empty) {
            if (itemKind === 'key+value')
              return CreateIterResultObject([e, e], false);
            return CreateIterResultObject(e, false);
          }
        }
        return CreateIterResultObject(undefined, true);
      });

    // 23.2.5.2.2 %SetIteratorPrototype% [ @@toStringTag ]
    define($SetIteratorPrototype$, $$toStringTag, 'Set Iterator');

    // 23.2.5.3 Properties of Set Iterator Instances

  }());

  // ---------------------------------------
  // 23.3 WeakMap Objects
  // ---------------------------------------

  (function() {
    // 23.3.1 The WeakMap Constructor
    // 23.3.1.1 WeakMap ( [ iterable ] )
    /** @constructor */
    function WeakMap(/*iterable*/) {
      var map = strict(this);
      var iterable = arguments[0];

      if (Type(map) !== 'object') throw TypeError();
      if ('[[WeakMapData]]' in map) throw TypeError();

      if (iterable !== undefined) {
        var adder = map['set'];
        if (!IsCallable(adder)) throw TypeError();
        var iter = GetIterator(ToObject(iterable));
      }
      set_internal(map, '[[WeakMapData]]', new EphemeronTable);
      if (iter === undefined) return map;
      while (true) {
        var next = IteratorStep(iter);
        if (next === false)
          return map;
        var nextValue = IteratorValue(next);
        if (Type(nextValue) !== 'object') throw TypeError();
        var k = nextValue[0];
        var v = nextValue[1];
        adder.call(map, k, v);
      }

      return map;
    }

    if (!('WeakMap' in global) || OVERRIDE_NATIVE_FOR_TESTING)
      global.WeakMap = WeakMap;

    // 23.3.2 Properties of the WeakMap Constructor
    // 23.3.2.1 WeakMap.prototype
    var $WeakMapPrototype$ = {};
    WeakMap.prototype = $WeakMapPrototype$;



   // 23.3.2.2 WeakMap[ @@create ] ( )
    // 23.3.3 Properties of the WeakMap Prototype Object

    // 23.3.3.1 WeakMap.prototype.constructor

    // 23.3.3.2 WeakMap.prototype.delete ( key )
    define(
      WeakMap.prototype, 'delete',
      function delete_(key) {
        var M = strict(this);
        if (Type(M) !== 'object') throw TypeError();
        if (M['[[WeakMapData]]'] === undefined) throw TypeError();
        if (Type(key) !== 'object') throw TypeError('Expected object');
        return M['[[WeakMapData]]'].remove(key);
      });

    // 23.3.3.3 WeakMap.prototype.get ( key )
    define(
      WeakMap.prototype, 'get',
      function get(key, defaultValue) {
        var M = strict(this);
        if (Type(M) !== 'object') throw TypeError();
        if (M['[[WeakMapData]]'] === undefined) throw TypeError();
        if (Type(key) !== 'object') throw TypeError('Expected object');
        return M['[[WeakMapData]]'].get(key, defaultValue);
      });

    // 23.3.3.4 WeakMap.prototype.has ( key )
    define(
      WeakMap.prototype, 'has',
      function has(key) {
        var M = strict(this);
        if (Type(M) !== 'object') throw TypeError();
        if (M['[[WeakMapData]]'] === undefined) throw TypeError();
        if (Type(key) !== 'object') throw TypeError('Expected object');
        return M['[[WeakMapData]]'].has(key);
      });

    // 23.3.3.5 WeakMap.prototype.set ( key , value )
    define(
      WeakMap.prototype, 'set',
      function set(key, value) {
        var M = strict(this);
        if (Type(M) !== 'object') throw TypeError();
        if (M['[[WeakMapData]]'] === undefined) throw TypeError();
        if (Type(key) !== 'object') throw TypeError('Expected object');
        M['[[WeakMapData]]'].set(key, value);
        return M;
      });

    // 23.3.3.6 WeakMap.prototype [ @@toStringTag ]
    define(global.WeakMap.prototype, $$toStringTag, 'WeakMap');

    // 23.3.4 Properties of WeakMap Instances

    // Polyfills for incomplete native implementations:
    (function() {
      var wm = new global.WeakMap();
      var orig = global.WeakMap.prototype.set;
      define(global.WeakMap.prototype, 'set', function set() {
        orig.apply(this, arguments);
        return this;
      }, wm.set({}, 0) !== wm);
    }());
  }());

  // ---------------------------------------
  // 23.4 WeakSet Objects
  // ---------------------------------------

  (function() {
    // 23.4.1 The WeakSet Constructor
    // 23.4.1.1 WeakSet ( [ iterable ] )
    /** @constructor */
    function WeakSet(/*iterable*/) {
      var set = strict(this);
      var iterable = arguments[0];

      if (Type(set) !== 'object') throw TypeError();
      if ('[[WeakSetData]]' in set) throw TypeError();

      if (iterable !== undefined) {
        var adder = set['add'];
        if (!IsCallable(adder)) throw TypeError();
        var iter = GetIterator(ToObject(iterable));
      }
      set_internal(set, '[[WeakSetData]]', new EphemeronTable);
      if (iter === undefined) return set;
      while (true) {
        var next = IteratorStep(iter);
        if (next === false)
          return set;
        var nextValue = IteratorValue(next);
        adder.call(set, nextValue);
      }

      return set;
    }

    if (!('WeakSet' in global) || OVERRIDE_NATIVE_FOR_TESTING)
      global.WeakSet = WeakSet;

    // 23.4.2 Properties of the WeakSet Constructor
    // 23.4.2.1 WeakSet.prototype
    var $WeakSetPrototype$ = {};
    WeakSet.prototype = $WeakSetPrototype$;

    // 23.4.3 Properties of the WeakSet Prototype Object
    // 23.4.3.1 WeakSet.prototype.add (value )
    define(
      WeakSet.prototype, 'add',
      function add(value) {
        var S = strict(this);
        if (Type(S) !== 'object') throw TypeError();
        if (S['[[WeakSetData]]'] === undefined) throw TypeError();
        if (Type(value) !== 'object') throw TypeError('Expected object');
        S['[[WeakSetData]]'].set(value, true);
        return S;
      });

    // 23.4.3.2 WeakSet.prototype.constructor
    // 23.4.3.3 WeakSet.prototype.delete ( value )
    define(
      WeakSet.prototype, 'delete',
      function delete_(value) {
        var S = strict(this);
        if (Type(S) !== 'object') throw TypeError();
        if (S['[[WeakSetData]]'] === undefined) throw TypeError();
        if (Type(value) !== 'object') throw TypeError('Expected object');
        return S['[[WeakSetData]]'].remove(value);
      });

    // 23.4.3.4 WeakSet.prototype.has ( value )
    define(
      WeakSet.prototype, 'has',
      function has(key) {
        var S = strict(this);
        if (Type(S) !== 'object') throw TypeError();
        if (S['[[WeakSetData]]'] === undefined) throw TypeError();
        if (Type(key) !== 'object') throw TypeError('Expected object');
        return S['[[WeakSetData]]'].has(key);
      });

    // 23.4.3.5 WeakSet.prototype [ @@toStringTag ]
    define(global.WeakSet.prototype, $$toStringTag, 'WeakSet');

    // 23.4.4 Properties of WeakSet Instances

    // Polyfills for incomplete native implementations:
    (function() {
      var ws = new global.WeakSet();
      var orig = global.WeakSet.prototype.add;
      define(global.WeakSet.prototype, 'add', function add() {
        orig.apply(this, arguments);
        return this;
      }, ws.add({}) !== ws);
    }());
  }());

  // ---------------------------------------
  // 24 Structured Data
  // ---------------------------------------

  // ---------------------------------------
  // 24.1 ArrayBuffer Objects
  // ---------------------------------------

  // See typedarray.js for TypedArray polyfill

  (function() {
    if (!('ArrayBuffer' in global))
      return;

    // 24.1.1 Abstract Operations For ArrayBuffer Objects
    // 24.1.1.1 AllocateArrayBuffer( constructor, byteLength )
    // 24.1.1.2 IsDetachedBuffer( arrayBuffer )
    // 24.1.1.3 DetachArrayBuffer( arrayBuffer )
    // 24.1.1.4 CloneArrayBuffer( srcBuffer, srcByteOffset [, cloneConstructor] )
    // 24.1.1.5 GetValueFromBuffer ( arrayBuffer, byteIndex, type, isLittleEndian )
    // 24.1.1.6 SetValueInBuffer ( arrayBuffer, byteIndex, type, value, isLittleEndian )
    // 24.1.2 The ArrayBuffer Constructor
    // 24.1.2.1 ArrayBuffer( length )
    // 24.1.3 Properties of the ArrayBuffer Constructor

    // 24.1.3.1 ArrayBuffer.isView ( arg )
    define(
      ArrayBuffer, 'isView',
      function isView(arg) {
        if (Type(arg) !== 'object') return false;
        if ('buffer' in arg && arg.buffer instanceof ArrayBuffer) return true;
        return false;
      });

    // 24.1.3.2 ArrayBuffer.prototype
    // 24.1.3.3 get ArrayBuffer [ @@species ]
    // 24.1.4 Properties of the ArrayBuffer Prototype Object
    // 24.1.4.1 get ArrayBuffer.prototype.byteLength
    // 24.1.4.2 ArrayBuffer.prototype.constructor
    // 24.1.4.3 ArrayBuffer.prototype.slice ( start , end)

    // 24.1.4.4 ArrayBuffer.prototype [ @@toStringTag ]
    define(ArrayBuffer.prototype, $$toStringTag, 'ArrayBuffer');

    // 24.1.5 Properties of the ArrayBuffer Instances
  }());

  // ---------------------------------------
  // 24.2 DataView Objects
  // ---------------------------------------

  // See typedarray.js for TypedArray polyfill

  (function() {
    if (!('DataView' in global))
      return;

    // 24.2.1 Abstract Operations For DataView Objects
    // 24.2.1.1 GetViewValue(view, requestIndex, isLittleEndian, type)
    // 24.2.1.2 SetViewValue(view, requestIndex, isLittleEndian, type, value)
    // 24.2.2 The DataView Constructor
    // 24.2.2.1 DataView (buffer [ , byteOffset [ , byteLength ] ] )
    // 24.2.3 Properties of the DataView Constructor
    // 24.2.3.1 DataView.prototype
    // 24.2.4 Properties of the DataView Prototype Object
    // 24.2.4.1 get DataView.prototype.buffer
    // 24.2.4.2 get DataView.prototype.byteLength
    // 24.2.4.3 get DataView.prototype.byteOffset
    // 24.2.4.4 DataView.prototype.constructor
    // 24.2.4.5 DataView.prototype.getFloat32 ( byteOffset [ , littleEndian ] )
    // 24.2.4.6 DataView.prototype.getFloat64 ( byteOffset [ , littleEndian ] )
    // 24.2.4.7 DataView.prototype.getInt8 ( byteOffset )
    // 24.2.4.8 DataView.prototype.getInt16 ( byteOffset [ , littleEndian ] )
    // 24.2.4.9 DataView.prototype.getInt32 ( byteOffset [ , littleEndian ] )
    // 24.2.4.10 DataView.prototype.getUint8 ( byteOffset )
    // 24.2.4.11 DataView.prototype.getUint16 ( byteOffset [ , littleEndian ] )
    // 24.2.4.12 DataView.prototype.getUint32 ( byteOffset [ , littleEndian ] )
    // 24.2.4.13 DataView.prototype.setFloat32 ( byteOffset, value [ , littleEndian ] )
    // 24.2.4.14 DataView.prototype.setFloat64 ( byteOffset, value [ , littleEndian ] )
    // 24.2.4.15 DataView.prototype.setInt8 ( byteOffset, value )
    // 24.2.4.16 DataView.prototype.setInt16 ( byteOffset, value [ , littleEndian ] )
    // 24.2.4.17 DataView.prototype.setInt32 ( byteOffset, value [ , littleEndian ] )
    // 24.2.4.18 DataView.prototype.setUint8 ( byteOffset, value )
    // 24.2.4.19 DataView.prototype.setUint16 ( byteOffset, value [ , littleEndian ] )
    // 24.2.4.20 DataView.prototype.setUint32 ( byteOffset, value [ , littleEndian ] )

    // 24.2.4.21 DataView.prototype[ @@toStringTag ]
    define(DataView.prototype, $$toStringTag, 'DataView');

    // 24.2.5 Properties of DataView Instances
  }());

  // ---------------------------------------
  // 24.3 The JSON Object
  // ---------------------------------------

  // 24.3.1 JSON.parse ( text [ , reviver ] )
  // 24.3.2 JSON.stringify ( value [ , replacer [ , space ] ] )
  // 24.3.3 JSON [ @@toStringTag ]
  define(JSON, $$toStringTag, 'JSON');

  // ---------------------------------------
  // 25.1 Iteration
  // ---------------------------------------

  // 25.1.1 Common Iteration Interfaces
  // 25.1.1.1 The Iterable Interface
  // 25.1.1.2 The Iterator Interface
  // 25.1.1.3 The IteratorResult Interface

  // 25.1.2 The %IteratorPrototype% Object
  // Defined earlier, so other prototypes can reference it.
  // 25.1.2.1 %IteratorPrototype% [ @@iterator ] ( )
  define($IteratorPrototype$, $$iterator, function() {
    return this;
  });


  // ---------------------------------------
  // 25.4 Promise Objects
  // ---------------------------------------

  (function() {
    // 25.4 Promise Objects

    // 25.4.1 Promise Abstract Operations

    // 25.4.1.1 PromiseCapability Records
    // 25.4.1.1.1 IfAbruptRejectPromise ( value, capability )

    function IfAbruptRejectPromise(value, capability) {
      var rejectResult = capability['[[Reject]]'].call(undefined, value);
      return capability['[[Promise]]'];
    }

    // 25.4.1.2 PromiseReaction Records

    // 25.4.1.3 CreateResolvingFunctions ( promise )

    function CreateResolvingFunctions(promise) {
      var alreadyResolved = {'[[value]]': false};
      var resolve = PromiseResolveFunction();
      set_internal(resolve, '[[Promise]]',  promise);
      set_internal(resolve, '[[AlreadyResolved]]', alreadyResolved);
      var reject = PromiseRejectFunction();
      set_internal(reject, '[[Promise]]', promise);
      set_internal(reject, '[[AlreadyResolved]]', alreadyResolved);
      return { '[[Resolve]]': resolve, '[[Reject]]': reject};
    }

    // 25.4.1.3.1 Promise Reject Functions

    function PromiseRejectFunction() {
      var F = function(reason) {
        console.assert(Type(F['[[Promise]]']) === 'object');
        var promise = F['[[Promise]]'];
        var alreadyResolved = F['[[AlreadyResolved]]'];
        if (alreadyResolved['[[value]]']) return undefined;
        set_internal(alreadyResolved, '[[value]]', true);
        return RejectPromise(promise, reason);
      };
      return F;
    }

    // 25.4.1.3.2 Promise Resolve Functions

    function PromiseResolveFunction() {
      var F = function(resolution) {
        console.assert(Type(F['[[Promise]]']) === 'object');
        var promise = F['[[Promise]]'];
        var alreadyResolved = F['[[AlreadyResolved]]'];
        if (alreadyResolved['[[value]]']) return undefined;
        set_internal(alreadyResolved, '[[value]]', true);

        if (SameValue(resolution, promise))  {
          var selfResolutionError = TypeError();
          return RejectPromise(promise, selfResolutionError);
        }
        if (Type(resolution) !== 'object')
          return FulfillPromise(promise, resolution);
        try {
          var then = resolution['then'];
        } catch(then) {
          return RejectPromise(promise, then);
        }
        if (!IsCallable(then))
          return FulfillPromise(promise, resolution);
        EnqueueJob('PromiseJobs', PromiseResolveThenableJob, [promise, resolution, then]);
        return undefined;
      };
      return F;
    }

    // 25.4.1.4 FulfillPromise ( promise, value )

    function FulfillPromise(promise, value) {
      console.assert(promise['[[PromiseState]]'] === 'pending');
      var reactions = promise['[[PromiseFulfillReactions]]'];
      set_internal(promise, '[[PromiseResult]]', value);
      set_internal(promise, '[[PromiseFulfillReactions]]', undefined);
      set_internal(promise, '[[PromiseRejectReactions]]', undefined);
      set_internal(promise, '[[PromiseState]]', 'fulfilled');
      return TriggerPromiseReactions(reactions, value);
    }

    // 25.4.1.5 NewPromiseCapability ( C )

    function NewPromiseCapability(c) {
      // To keep Promise hermetic, this doesn't look much like the spec.
      return CreatePromiseCapabilityRecord(undefined, c);
    }

    // 25.4.1.5.1 CreatePromiseCapabilityRecord ( promise, constructor )

    function CreatePromiseCapabilityRecord(promise, constructor) {
      // To keep Promise hermetic, this doesn't look much like the spec.
      console.assert(IsConstructor(constructor));
      var promiseCapability = {};
      set_internal(promiseCapability, '[[Promise]]', promise);
      set_internal(promiseCapability, '[[Resolve]]', undefined);
      set_internal(promiseCapability, '[[Reject]]', undefined);
      var executor = GetCapabilitiesExecutor();
      set_internal(executor, '[[Capability]]', promiseCapability);

      // NOTE: Differs from spec; object is constructed here
      var constructorResult = promise = new constructor(executor);
      set_internal(promiseCapability, '[[Promise]]', promise);

      if (!IsCallable(promiseCapability['[[Resolve]]'])) throw TypeError();
      if (!IsCallable(promiseCapability['[[Reject]]'])) throw TypeError();
      if (Type(constructorResult) === 'object' && !SameValue(promise, constructorResult)) throw TypeError();
      return promiseCapability;
    }

    // 25.4.1.5.2 GetCapabilitiesExecutor Functions

    function GetCapabilitiesExecutor() {
      var F = function(resolve, reject) {
        console.assert(F['[[Capability]]']);
        var promiseCapability = F['[[Capability]]'];
        if (promiseCapability['[[Resolve]]'] !== undefined) throw TypeError();
        if (promiseCapability['[[Reject]]'] !== undefined) throw TypeError();
        set_internal(promiseCapability, '[[Resolve]]', resolve);
        set_internal(promiseCapability, '[[Reject]]', reject);
        return undefined;
      };
      return F;
    }

    // 25.4.1.6 IsPromise ( x )

    function IsPromise(x) {
      if (Type(x) !== 'object') return false;
      if (!('[[PromiseState]]' in x)) return false;
      if (x['[[PromiseState]]'] === undefined) return false;
      return true;
    }

    // 25.4.1.7 RejectPromise ( promise, reason )

    function RejectPromise(promise, reason) {
      console.assert(promise['[[PromiseState]]'] === 'pending');
      var reactions = promise['[[PromiseRejectReactions]]'];
      set_internal(promise, '[[PromiseResult]]', reason);
      set_internal(promise, '[[PromiseFulfillReactions]]', undefined);
      set_internal(promise, '[[PromiseRejectReactions]]', undefined);
      set_internal(promise, '[[PromiseState]]', 'rejected');
      return TriggerPromiseReactions(reactions, reason);
    }

    // 25.4.1.8 TriggerPromiseReactions ( reactions, argument )

    function TriggerPromiseReactions(reactions, argument) {
      for (var i = 0, len = reactions.length; i < len; ++i)
        EnqueueJob('PromiseJobs', PromiseReactionJob, [reactions[i], argument]);
      return undefined;
    }

    // 25.4.2 Promise Jobs

    // 25.4.2.1 PromiseReactionJob ( reaction, argument )

    function PromiseReactionJob(reaction, argument) {
      var promiseCapability = reaction['[[Capabilities]]'];
      var handler = reaction['[[Handler]]'];
      var handlerResult, status;
      try {
        if (handler === 'Identity') handlerResult = argument;
        else if (handler === 'Thrower') throw argument;
        else handlerResult = handler.call(undefined, argument);
      } catch (handlerResult) {
        status = promiseCapability['[[Reject]]'].call(undefined, handlerResult);
        NextJob(status); return;
      }
      status = promiseCapability['[[Resolve]]'].call(undefined, handlerResult);
      NextJob(status);
    }

    // 25.4.2.2 PromiseResolveThenableJob ( promiseToResolve, thenable, then)

    function PromiseResolveThenableJob(promiseToResolve, thenable, then) {
      // SPEC BUG: promise vs. promiseToResolve
      var resolvingFunctions = CreateResolvingFunctions(promiseToResolve);
      try {
        var thenCallResult = then.call(thenable, resolvingFunctions['[[Resolve]]'],
                                       resolvingFunctions['[[Reject]]']);
      } catch (thenCallResult) {
        var status = resolvingFunctions['[[Reject]]'].call(undefined, thenCallResult);
        NextJob(status); return;
      }
      NextJob(thenCallResult);
    }

    // 25.4.3 The Promise Constructor

    // 25.4.3.1 Promise ( executor )

    function Promise(executor) {
      var config = { configurable: false, enumerable: false, writable: true, value: undefined };
      Object.defineProperty(this, '[[PromiseState]]', config);
      Object.defineProperty(this, '[[PromiseConstructor]]', config);
      Object.defineProperty(this, '[[PromiseResult]]', config);
      Object.defineProperty(this, '[[PromiseFulfillReactions]]', config);
      Object.defineProperty(this, '[[PromiseRejectReactions]]', config);

      var promise = this;
      if (Type(promise) !== 'object') throw new TypeError();
      if (!('[[PromiseState]]' in promise)) throw TypeError();
      if (promise['[[PromiseState]]'] !== undefined) throw TypeError();
      if (!IsCallable(executor)) throw TypeError();

      set_internal(promise, '[[PromiseConstructor]]', Promise);

      return InitializePromise(promise, executor);
    }

    // 25.4.3.1.1 InitializePromise ( promise, executor )

    function InitializePromise(promise, executor) {
      console.assert('[[PromiseState]]' in promise);
      console.assert(IsCallable(executor));
      set_internal(promise, '[[PromiseState]]', 'pending');
      set_internal(promise, '[[PromiseFulfillReactions]]', []);
      set_internal(promise, '[[PromiseRejectReactions]]', []);
      var resolvingFunctions = CreateResolvingFunctions(promise);
      try {
        var completion = executor.call(undefined, resolvingFunctions['[[Resolve]]'],
                                       resolvingFunctions['[[Reject]]']);
      } catch (completion) {
        var status = resolvingFunctions['[[Reject]]'].call(undefined, completion);
      }
      return promise;
    }

    // 25.4.4 Properties of the Promise Constructor
    // 25.4.4.1 Promise.all ( iterable )

    define(Promise, 'all', function all(iterable) {
      var c = strict(this);
      var promiseCapability = NewPromiseCapability(c);
      try {
        var iterator = GetIterator(iterable);
      } catch (value) {
        promiseCapability['[[Reject]]'].call(undefined, value);
        return promiseCapability['[[Promise]]'];
      }
      var values = [];
      var remainingElementsCount = { value: 1 };
      var index = 0;
      while (true) {
        try {
          var next = IteratorStep(iterator);
        } catch (value) {
          promiseCapability['[[Reject]]'].call(undefined, value);
          return promiseCapability['[[Promise]]'];
        }
        if (!next) {
          remainingElementsCount.value -= 1;
          if (remainingElementsCount.value === 0) {
            var resolveResult = promiseCapability['[[Resolve]]'].apply(undefined, values);


          }
          return promiseCapability['[[Promise]]'];
        }
        try {
          var nextValue = IteratorValue(next);
        } catch (value) {
          promiseCapability['[[Reject]]'].call(undefined, value);
          return promiseCapability['[[Promise]]'];
        }
        try {
          var nextPromise = c.resolve(nextValue);
        } catch (value) {
          promiseCapability['[[Reject]]'].call(undefined, value);
          return promiseCapability['[[Promise]]'];
        }
        var resolveElement = PromiseAllResolveElementFunction();
        set_internal(resolveElement, '[[AlreadyCalled]]', { value: false });
        set_internal(resolveElement, '[[Index]]', index);
        set_internal(resolveElement, '[[Values]]', values);
        set_internal(resolveElement, '[[Capabilities]]', promiseCapability);
        set_internal(resolveElement, '[[RemainingElements]]', remainingElementsCount);
        remainingElementsCount.value += 1;
        try {
          var result = nextPromise.then(resolveElement, promiseCapability['[[Reject]]']);
        } catch (value) {
          promiseCapability['[[Reject]]'].call(undefined, value);
          return promiseCapability['[[Promise]]'];
        }
        index += 1;
      }
    });

    // 25.4.4.1.1 Promise.all Resolve Element Functions

    function PromiseAllResolveElementFunction() {
      var F = function(x) {
        var alreadyCalled = F['[[AlreadyCalled]]'];
        if (alreadyCalled.value) return undefined;
        alreadyCalled.value = true;
        var index = F['[[Index]]'];
        var values = F['[[Values]]'];
        var promiseCapability = F['[[Capabilities]]'];
        var remainingElementsCount = F['[[RemainingElements]]'];
        try {
          values[index] = x;
        } catch (result) {
          promiseCapability['[[Reject]]'].call(undefined, result);
          return promiseCapability['[[Promise]]'];
        }
        remainingElementsCount.value -= 1;
        if (remainingElementsCount.value === 0)
          return promiseCapability['[[Resolve]]'].call(undefined, values);
        return undefined;
      };
      return F;
    }

    // 25.4.4.2 Promise.prototype

    Promise.prototype = {};

    // 25.4.4.3 Promise.race ( iterable )

    define(Promise, 'race', function race(iterable) {
      var c = strict(this);
      var promiseCapability = NewPromiseCapability(c);
      try {
        var iterator = GetIterator(iterable);
      } catch (value) {
        promiseCapability['[[Reject]]'].call(undefined, value);
        return promiseCapability['[[Promise]]'];
      }
      while (true) {
        try {
          var next = IteratorStep(iterator);
        } catch (value) {
          promiseCapability['[[Reject]]'].call(undefined, value);
          return promiseCapability['[[Promise]]'];
        }
        if (!next) return promiseCapability['[[Promise]]'];
        try {
          var nextValue = IteratorValue(next);
        } catch (value) {
          promiseCapability['[[Reject]]'].call(undefined, value);
          return promiseCapability['[[Promise]]'];
        }
        try {
          var nextPromise = c.resolve(nextValue);
        } catch (value) {
          promiseCapability['[[Reject]]'].call(undefined, value);
          return promiseCapability['[[Promise]]'];
        }
        try {
          nextPromise.then(promiseCapability['[[Resolve]]'], promiseCapability['[[Reject]]']);
        } catch (value) {
          promiseCapability['[[Reject]]'].call(undefined, value);
          return promiseCapability['[[Promise]]'];
        }
      }
    });

    // 25.4.4.4 Promise.reject ( r )

    define(Promise, 'reject', function reject(r) {
      var c = strict(this);
      var promiseCapability = NewPromiseCapability(c);
      var rejectResult = promiseCapability['[[Reject]]'].call(undefined, r);
      return promiseCapability['[[Promise]]'];
    });

    // 25.4.4.5 Promise.resolve ( x )

    define(Promise, 'resolve', function resolve(x) {
      var c = strict(this);
      if (IsPromise(x)) {
        var constructor = x['[[PromiseConstructor]]'];
        if (SameValue(constructor, c)) return x;
      }
      var promiseCapability = NewPromiseCapability(c);
      var resolveResult = promiseCapability['[[Resolve]]'].call(undefined, x);
      return promiseCapability['[[Promise]]'];
    });

    // 25.4.4.6 Promise [ @@create ] ( )
    // 25.4.4.6.1 AllocatePromise ( constructor )
    // 25.4.5 Properties of the Promise Prototype Object
    // 25.4.5.1 Promise.prototype.catch ( onRejected )

    define(Promise.prototype, 'catch', function catch_(onRejected) {
      var promise = this;
      return promise.then(undefined, onRejected);
    });

    // 25.4.5.2 Promise.prototype.constructor

    Promise.prototype.constructor = Promise;

    // 25.4.5.3 Promise.prototype.then ( onFulfilled , onRejected )

    define(Promise.prototype, 'then', function then(onFulfilled, onRejected) {
      var promise = this;
      if (!IsPromise(promise)) throw TypeError();
      if (!IsCallable(onFulfilled)) onFulfilled = 'Identity';
      if (!IsCallable(onRejected)) onRejected = 'Thrower';
      var c = promise.constructor;
      var promiseCapability = NewPromiseCapability(c);
      var fulfillReaction = { '[[Capabilities]]': promiseCapability,
                              '[[Handler]]': onFulfilled };
      var rejectReaction = { '[[Capabilities]]': promiseCapability,
                             '[[Handler]]': onRejected };
      if (promise['[[PromiseState]]'] === 'pending') {
        promise['[[PromiseFulfillReactions]]'].push(fulfillReaction);
        promise['[[PromiseRejectReactions]]'].push(rejectReaction);
      } else if (promise['[[PromiseState]]'] === 'fulfilled') {
        var value = promise['[[PromiseResult]]'];
        EnqueueJob('PromiseJobs', PromiseReactionJob, [fulfillReaction, value]);
      } else if (promise['[[PromiseState]]'] === 'rejected') {
        var reason = promise['[[PromiseResult]]'];
        EnqueueJob('PromiseJobs', PromiseReactionJob, [rejectReaction, reason]);
      }
      return promiseCapability['[[Promise]]'];
    });

    // 25.4.6 Properties of Promise Instances

    if (!('Promise' in global) || OVERRIDE_NATIVE_FOR_TESTING)
      global.Promise = Promise;

    // Patch early Promise.cast vs. Promise.resolve implementations
    if ('cast' in global.Promise) global.Promise.resolve = global.Promise.cast;
  }());

  // 25.4.5.1 Promise.prototype [ @@toStringTag ]
  define(Promise.prototype, $$toStringTag, 'Promise');

  // ---------------------------------------
  // 26 Reflection
  // ---------------------------------------

  (function() {
    // 26.1 The Reflect Object
    if (!('Reflect' in global) || OVERRIDE_NATIVE_FOR_TESTING)
      global.Reflect = {};

    // 26.1.1 Reflect.apply ( target, thisArgument, argumentsList )
    define(
      Reflect, 'apply',
      function apply(target, thisArgument, argumentsList) {
        if (!IsCallable(target)) throw TypeError();
        return Function.prototype.apply.call(target, thisArgument, argumentsList);
      });

    // 26.1.2 Reflect.construct ( target, argumentsList [, newTarget] )
    define(
      Reflect, 'construct',
      function construct(target, argumentsList) {
        return __cons(target, argumentsList);
      });

    // 26.1.3 Reflect.defineProperty ( target, propertyKey, attributes )
    define(
      Reflect, 'defineProperty',
      function defineProperty(target, propertyKey, attributes) {
        try {
          Object.defineProperty(target, propertyKey, attributes);
          return true;
        } catch (_) {
          return false;
        }
      });

    // 26.1.4 Reflect.deleteProperty ( target, propertyKey )
    define(
      Reflect, 'deleteProperty',
      function deleteProperty(target,name) {
        try {
          delete target[name];
          return !HasOwnProperty(target, name);
        } catch (_) {
          return false;
        }
      });

    // 26.1.5 Reflect.enumerate ( target )
    define(
      Reflect, 'enumerate',
      function enumerate(target) {
        target = ToObject(target);
        var iterator = Enumerate(target);
        return iterator;
      });

    // 26.1.6 Reflect.get ( target, propertyKey [ , receiver ])
    define(
      Reflect, 'get',
      function get(target, name, receiver) {
        target = ToObject(target);
        name = String(name);
        receiver = (receiver === undefined) ? target : ToObject(receiver);
        var desc = getPropertyDescriptor(target, name);
        if (desc && 'get' in desc)
          return Function.prototype.call.call(desc['get'], receiver);
        return target[name];
      });

    // 26.1.7 Reflect.getOwnPropertyDescriptor ( target, propertyKey )
    define(
      Reflect, 'getOwnPropertyDescriptor',
      Object.getOwnPropertyDescriptor);

    // 26.1.8 Reflect.getPrototypeOf ( target )
    define(
      Reflect, 'getPrototypeOf',
      Object.getPrototypeOf);

    // 26.1.9 Reflect.has ( target, propertyKey )
    define(
      Reflect, 'has',
      function has(target,name) {
        return String(name) in ToObject(target);
      });

    // 26.1.10 Reflect.isExtensible (target)
    define(
      Reflect, 'isExtensible',
      Object.isExtensible);

    // 26.1.11 Reflect.ownKeys ( target )
    define(
      Reflect, 'ownKeys',
      function ownKeys(target) {
        var obj = ToObject(target);
        return Object.getOwnPropertyNames(obj);
      });

    // 26.1.12 Reflect.preventExtensions ( target )
    define(
      Reflect, 'preventExtensions',
      function preventExtensions(target) {
        try { Object.preventExtensions(target); return true; } catch (_) { return false; }
      });

    // 26.1.13 Reflect.set ( target, propertyKey, V [ , receiver ] )
    define(
      Reflect, 'set',
      function set(target, name, value, receiver) {
        target = ToObject(target);
        name = String(name);
        receiver = (receiver === undefined) ? target : ToObject(receiver);
        var desc = getPropertyDescriptor(target, name);
        try {
          if (desc && 'set' in desc)
            Function.prototype.call.call(desc['set'], receiver, value);
          else
            target[name] = value;
          return true;
        } catch (_) {
          return false;
        }
      });

    // 26.1.14 Reflect.setPrototypeOf ( target, proto )
    define(
      Reflect, 'setPrototypeOf',
      function setPrototypeOf(target, proto) {
        try {
          target.__proto__ = proto;
          return Reflect.getPrototypeOf(target) === proto;
        } catch(_) {
          return false;
        }
      });

  }());

  // ---------------------------------------
  // 26.2 Proxy Objects
  // ---------------------------------------

  // Not polyfillable.

}(self));

// This helper is defined outside the main scope so that the use of
// 'eval' does not taint the scope for minifiers.
function __cons(t, a) {
  return eval('new t(' + a.map(function(_, i) { return 'a[' + i + ']'; }).join(',') + ')');
}

},{}],21:[function(require,module,exports){
/**
 * lunr - http://lunrjs.com - A bit like Solr, but much smaller and not as bright - 2.3.8
 * Copyright (C) 2019 Oliver Nightingale
 * @license MIT
 */

;(function(){

/**
 * A convenience function for configuring and constructing
 * a new lunr Index.
 *
 * A lunr.Builder instance is created and the pipeline setup
 * with a trimmer, stop word filter and stemmer.
 *
 * This builder object is yielded to the configuration function
 * that is passed as a parameter, allowing the list of fields
 * and other builder parameters to be customised.
 *
 * All documents _must_ be added within the passed config function.
 *
 * @example
 * var idx = lunr(function () {
 *   this.field('title')
 *   this.field('body')
 *   this.ref('id')
 *
 *   documents.forEach(function (doc) {
 *     this.add(doc)
 *   }, this)
 * })
 *
 * @see {@link lunr.Builder}
 * @see {@link lunr.Pipeline}
 * @see {@link lunr.trimmer}
 * @see {@link lunr.stopWordFilter}
 * @see {@link lunr.stemmer}
 * @namespace {function} lunr
 */
var lunr = function (config) {
  var builder = new lunr.Builder

  builder.pipeline.add(
    lunr.trimmer,
    lunr.stopWordFilter,
    lunr.stemmer
  )

  builder.searchPipeline.add(
    lunr.stemmer
  )

  config.call(builder, builder)
  return builder.build()
}

lunr.version = "2.3.8"
/*!
 * lunr.utils
 * Copyright (C) 2019 Oliver Nightingale
 */

/**
 * A namespace containing utils for the rest of the lunr library
 * @namespace lunr.utils
 */
lunr.utils = {}

/**
 * Print a warning message to the console.
 *
 * @param {String} message The message to be printed.
 * @memberOf lunr.utils
 * @function
 */
lunr.utils.warn = (function (global) {
  /* eslint-disable no-console */
  return function (message) {
    if (global.console && console.warn) {
      console.warn(message)
    }
  }
  /* eslint-enable no-console */
})(this)

/**
 * Convert an object to a string.
 *
 * In the case of `null` and `undefined` the function returns
 * the empty string, in all other cases the result of calling
 * `toString` on the passed object is returned.
 *
 * @param {Any} obj The object to convert to a string.
 * @return {String} string representation of the passed object.
 * @memberOf lunr.utils
 */
lunr.utils.asString = function (obj) {
  if (obj === void 0 || obj === null) {
    return ""
  } else {
    return obj.toString()
  }
}

/**
 * Clones an object.
 *
 * Will create a copy of an existing object such that any mutations
 * on the copy cannot affect the original.
 *
 * Only shallow objects are supported, passing a nested object to this
 * function will cause a TypeError.
 *
 * Objects with primitives, and arrays of primitives are supported.
 *
 * @param {Object} obj The object to clone.
 * @return {Object} a clone of the passed object.
 * @throws {TypeError} when a nested object is passed.
 * @memberOf Utils
 */
lunr.utils.clone = function (obj) {
  if (obj === null || obj === undefined) {
    return obj
  }

  var clone = Object.create(null),
      keys = Object.keys(obj)

  for (var i = 0; i < keys.length; i++) {
    var key = keys[i],
        val = obj[key]

    if (Array.isArray(val)) {
      clone[key] = val.slice()
      continue
    }

    if (typeof val === 'string' ||
        typeof val === 'number' ||
        typeof val === 'boolean') {
      clone[key] = val
      continue
    }

    throw new TypeError("clone is not deep and does not support nested objects")
  }

  return clone
}
lunr.FieldRef = function (docRef, fieldName, stringValue) {
  this.docRef = docRef
  this.fieldName = fieldName
  this._stringValue = stringValue
}

lunr.FieldRef.joiner = "/"

lunr.FieldRef.fromString = function (s) {
  var n = s.indexOf(lunr.FieldRef.joiner)

  if (n === -1) {
    throw "malformed field ref string"
  }

  var fieldRef = s.slice(0, n),
      docRef = s.slice(n + 1)

  return new lunr.FieldRef (docRef, fieldRef, s)
}

lunr.FieldRef.prototype.toString = function () {
  if (this._stringValue == undefined) {
    this._stringValue = this.fieldName + lunr.FieldRef.joiner + this.docRef
  }

  return this._stringValue
}
/*!
 * lunr.Set
 * Copyright (C) 2019 Oliver Nightingale
 */

/**
 * A lunr set.
 *
 * @constructor
 */
lunr.Set = function (elements) {
  this.elements = Object.create(null)

  if (elements) {
    this.length = elements.length

    for (var i = 0; i < this.length; i++) {
      this.elements[elements[i]] = true
    }
  } else {
    this.length = 0
  }
}

/**
 * A complete set that contains all elements.
 *
 * @static
 * @readonly
 * @type {lunr.Set}
 */
lunr.Set.complete = {
  intersect: function (other) {
    return other
  },

  union: function (other) {
    return other
  },

  contains: function () {
    return true
  }
}

/**
 * An empty set that contains no elements.
 *
 * @static
 * @readonly
 * @type {lunr.Set}
 */
lunr.Set.empty = {
  intersect: function () {
    return this
  },

  union: function (other) {
    return other
  },

  contains: function () {
    return false
  }
}

/**
 * Returns true if this set contains the specified object.
 *
 * @param {object} object - Object whose presence in this set is to be tested.
 * @returns {boolean} - True if this set contains the specified object.
 */
lunr.Set.prototype.contains = function (object) {
  return !!this.elements[object]
}

/**
 * Returns a new set containing only the elements that are present in both
 * this set and the specified set.
 *
 * @param {lunr.Set} other - set to intersect with this set.
 * @returns {lunr.Set} a new set that is the intersection of this and the specified set.
 */

lunr.Set.prototype.intersect = function (other) {
  var a, b, elements, intersection = []

  if (other === lunr.Set.complete) {
    return this
  }

  if (other === lunr.Set.empty) {
    return other
  }

  if (this.length < other.length) {
    a = this
    b = other
  } else {
    a = other
    b = this
  }

  elements = Object.keys(a.elements)

  for (var i = 0; i < elements.length; i++) {
    var element = elements[i]
    if (element in b.elements) {
      intersection.push(element)
    }
  }

  return new lunr.Set (intersection)
}

/**
 * Returns a new set combining the elements of this and the specified set.
 *
 * @param {lunr.Set} other - set to union with this set.
 * @return {lunr.Set} a new set that is the union of this and the specified set.
 */

lunr.Set.prototype.union = function (other) {
  if (other === lunr.Set.complete) {
    return lunr.Set.complete
  }

  if (other === lunr.Set.empty) {
    return this
  }

  return new lunr.Set(Object.keys(this.elements).concat(Object.keys(other.elements)))
}
/**
 * A function to calculate the inverse document frequency for
 * a posting. This is shared between the builder and the index
 *
 * @private
 * @param {object} posting - The posting for a given term
 * @param {number} documentCount - The total number of documents.
 */
lunr.idf = function (posting, documentCount) {
  var documentsWithTerm = 0

  for (var fieldName in posting) {
    if (fieldName == '_index') continue // Ignore the term index, its not a field
    documentsWithTerm += Object.keys(posting[fieldName]).length
  }

  var x = (documentCount - documentsWithTerm + 0.5) / (documentsWithTerm + 0.5)

  return Math.log(1 + Math.abs(x))
}

/**
 * A token wraps a string representation of a token
 * as it is passed through the text processing pipeline.
 *
 * @constructor
 * @param {string} [str=''] - The string token being wrapped.
 * @param {object} [metadata={}] - Metadata associated with this token.
 */
lunr.Token = function (str, metadata) {
  this.str = str || ""
  this.metadata = metadata || {}
}

/**
 * Returns the token string that is being wrapped by this object.
 *
 * @returns {string}
 */
lunr.Token.prototype.toString = function () {
  return this.str
}

/**
 * A token update function is used when updating or optionally
 * when cloning a token.
 *
 * @callback lunr.Token~updateFunction
 * @param {string} str - The string representation of the token.
 * @param {Object} metadata - All metadata associated with this token.
 */

/**
 * Applies the given function to the wrapped string token.
 *
 * @example
 * token.update(function (str, metadata) {
 *   return str.toUpperCase()
 * })
 *
 * @param {lunr.Token~updateFunction} fn - A function to apply to the token string.
 * @returns {lunr.Token}
 */
lunr.Token.prototype.update = function (fn) {
  this.str = fn(this.str, this.metadata)
  return this
}

/**
 * Creates a clone of this token. Optionally a function can be
 * applied to the cloned token.
 *
 * @param {lunr.Token~updateFunction} [fn] - An optional function to apply to the cloned token.
 * @returns {lunr.Token}
 */
lunr.Token.prototype.clone = function (fn) {
  fn = fn || function (s) { return s }
  return new lunr.Token (fn(this.str, this.metadata), this.metadata)
}
/*!
 * lunr.tokenizer
 * Copyright (C) 2019 Oliver Nightingale
 */

/**
 * A function for splitting a string into tokens ready to be inserted into
 * the search index. Uses `lunr.tokenizer.separator` to split strings, change
 * the value of this property to change how strings are split into tokens.
 *
 * This tokenizer will convert its parameter to a string by calling `toString` and
 * then will split this string on the character in `lunr.tokenizer.separator`.
 * Arrays will have their elements converted to strings and wrapped in a lunr.Token.
 *
 * Optional metadata can be passed to the tokenizer, this metadata will be cloned and
 * added as metadata to every token that is created from the object to be tokenized.
 *
 * @static
 * @param {?(string|object|object[])} obj - The object to convert into tokens
 * @param {?object} metadata - Optional metadata to associate with every token
 * @returns {lunr.Token[]}
 * @see {@link lunr.Pipeline}
 */
lunr.tokenizer = function (obj, metadata) {
  if (obj == null || obj == undefined) {
    return []
  }

  if (Array.isArray(obj)) {
    return obj.map(function (t) {
      return new lunr.Token(
        lunr.utils.asString(t).toLowerCase(),
        lunr.utils.clone(metadata)
      )
    })
  }

  var str = obj.toString().toLowerCase(),
      len = str.length,
      tokens = []

  for (var sliceEnd = 0, sliceStart = 0; sliceEnd <= len; sliceEnd++) {
    var char = str.charAt(sliceEnd),
        sliceLength = sliceEnd - sliceStart

    if ((char.match(lunr.tokenizer.separator) || sliceEnd == len)) {

      if (sliceLength > 0) {
        var tokenMetadata = lunr.utils.clone(metadata) || {}
        tokenMetadata["position"] = [sliceStart, sliceLength]
        tokenMetadata["index"] = tokens.length

        tokens.push(
          new lunr.Token (
            str.slice(sliceStart, sliceEnd),
            tokenMetadata
          )
        )
      }

      sliceStart = sliceEnd + 1
    }

  }

  return tokens
}

/**
 * The separator used to split a string into tokens. Override this property to change the behaviour of
 * `lunr.tokenizer` behaviour when tokenizing strings. By default this splits on whitespace and hyphens.
 *
 * @static
 * @see lunr.tokenizer
 */
lunr.tokenizer.separator = /[\s\-]+/
/*!
 * lunr.Pipeline
 * Copyright (C) 2019 Oliver Nightingale
 */

/**
 * lunr.Pipelines maintain an ordered list of functions to be applied to all
 * tokens in documents entering the search index and queries being ran against
 * the index.
 *
 * An instance of lunr.Index created with the lunr shortcut will contain a
 * pipeline with a stop word filter and an English language stemmer. Extra
 * functions can be added before or after either of these functions or these
 * default functions can be removed.
 *
 * When run the pipeline will call each function in turn, passing a token, the
 * index of that token in the original list of all tokens and finally a list of
 * all the original tokens.
 *
 * The output of functions in the pipeline will be passed to the next function
 * in the pipeline. To exclude a token from entering the index the function
 * should return undefined, the rest of the pipeline will not be called with
 * this token.
 *
 * For serialisation of pipelines to work, all functions used in an instance of
 * a pipeline should be registered with lunr.Pipeline. Registered functions can
 * then be loaded. If trying to load a serialised pipeline that uses functions
 * that are not registered an error will be thrown.
 *
 * If not planning on serialising the pipeline then registering pipeline functions
 * is not necessary.
 *
 * @constructor
 */
lunr.Pipeline = function () {
  this._stack = []
}

lunr.Pipeline.registeredFunctions = Object.create(null)

/**
 * A pipeline function maps lunr.Token to lunr.Token. A lunr.Token contains the token
 * string as well as all known metadata. A pipeline function can mutate the token string
 * or mutate (or add) metadata for a given token.
 *
 * A pipeline function can indicate that the passed token should be discarded by returning
 * null, undefined or an empty string. This token will not be passed to any downstream pipeline
 * functions and will not be added to the index.
 *
 * Multiple tokens can be returned by returning an array of tokens. Each token will be passed
 * to any downstream pipeline functions and all will returned tokens will be added to the index.
 *
 * Any number of pipeline functions may be chained together using a lunr.Pipeline.
 *
 * @interface lunr.PipelineFunction
 * @param {lunr.Token} token - A token from the document being processed.
 * @param {number} i - The index of this token in the complete list of tokens for this document/field.
 * @param {lunr.Token[]} tokens - All tokens for this document/field.
 * @returns {(?lunr.Token|lunr.Token[])}
 */

/**
 * Register a function with the pipeline.
 *
 * Functions that are used in the pipeline should be registered if the pipeline
 * needs to be serialised, or a serialised pipeline needs to be loaded.
 *
 * Registering a function does not add it to a pipeline, functions must still be
 * added to instances of the pipeline for them to be used when running a pipeline.
 *
 * @param {lunr.PipelineFunction} fn - The function to check for.
 * @param {String} label - The label to register this function with
 */
lunr.Pipeline.registerFunction = function (fn, label) {
  if (label in this.registeredFunctions) {
    lunr.utils.warn('Overwriting existing registered function: ' + label)
  }

  fn.label = label
  lunr.Pipeline.registeredFunctions[fn.label] = fn
}

/**
 * Warns if the function is not registered as a Pipeline function.
 *
 * @param {lunr.PipelineFunction} fn - The function to check for.
 * @private
 */
lunr.Pipeline.warnIfFunctionNotRegistered = function (fn) {
  var isRegistered = fn.label && (fn.label in this.registeredFunctions)

  if (!isRegistered) {
    lunr.utils.warn('Function is not registered with pipeline. This may cause problems when serialising the index.\n', fn)
  }
}

/**
 * Loads a previously serialised pipeline.
 *
 * All functions to be loaded must already be registered with lunr.Pipeline.
 * If any function from the serialised data has not been registered then an
 * error will be thrown.
 *
 * @param {Object} serialised - The serialised pipeline to load.
 * @returns {lunr.Pipeline}
 */
lunr.Pipeline.load = function (serialised) {
  var pipeline = new lunr.Pipeline

  serialised.forEach(function (fnName) {
    var fn = lunr.Pipeline.registeredFunctions[fnName]

    if (fn) {
      pipeline.add(fn)
    } else {
      throw new Error('Cannot load unregistered function: ' + fnName)
    }
  })

  return pipeline
}

/**
 * Adds new functions to the end of the pipeline.
 *
 * Logs a warning if the function has not been registered.
 *
 * @param {lunr.PipelineFunction[]} functions - Any number of functions to add to the pipeline.
 */
lunr.Pipeline.prototype.add = function () {
  var fns = Array.prototype.slice.call(arguments)

  fns.forEach(function (fn) {
    lunr.Pipeline.warnIfFunctionNotRegistered(fn)
    this._stack.push(fn)
  }, this)
}

/**
 * Adds a single function after a function that already exists in the
 * pipeline.
 *
 * Logs a warning if the function has not been registered.
 *
 * @param {lunr.PipelineFunction} existingFn - A function that already exists in the pipeline.
 * @param {lunr.PipelineFunction} newFn - The new function to add to the pipeline.
 */
lunr.Pipeline.prototype.after = function (existingFn, newFn) {
  lunr.Pipeline.warnIfFunctionNotRegistered(newFn)

  var pos = this._stack.indexOf(existingFn)
  if (pos == -1) {
    throw new Error('Cannot find existingFn')
  }

  pos = pos + 1
  this._stack.splice(pos, 0, newFn)
}

/**
 * Adds a single function before a function that already exists in the
 * pipeline.
 *
 * Logs a warning if the function has not been registered.
 *
 * @param {lunr.PipelineFunction} existingFn - A function that already exists in the pipeline.
 * @param {lunr.PipelineFunction} newFn - The new function to add to the pipeline.
 */
lunr.Pipeline.prototype.before = function (existingFn, newFn) {
  lunr.Pipeline.warnIfFunctionNotRegistered(newFn)

  var pos = this._stack.indexOf(existingFn)
  if (pos == -1) {
    throw new Error('Cannot find existingFn')
  }

  this._stack.splice(pos, 0, newFn)
}

/**
 * Removes a function from the pipeline.
 *
 * @param {lunr.PipelineFunction} fn The function to remove from the pipeline.
 */
lunr.Pipeline.prototype.remove = function (fn) {
  var pos = this._stack.indexOf(fn)
  if (pos == -1) {
    return
  }

  this._stack.splice(pos, 1)
}

/**
 * Runs the current list of functions that make up the pipeline against the
 * passed tokens.
 *
 * @param {Array} tokens The tokens to run through the pipeline.
 * @returns {Array}
 */
lunr.Pipeline.prototype.run = function (tokens) {
  var stackLength = this._stack.length

  for (var i = 0; i < stackLength; i++) {
    var fn = this._stack[i]
    var memo = []

    for (var j = 0; j < tokens.length; j++) {
      var result = fn(tokens[j], j, tokens)

      if (result === null || result === void 0 || result === '') continue

      if (Array.isArray(result)) {
        for (var k = 0; k < result.length; k++) {
          memo.push(result[k])
        }
      } else {
        memo.push(result)
      }
    }

    tokens = memo
  }

  return tokens
}

/**
 * Convenience method for passing a string through a pipeline and getting
 * strings out. This method takes care of wrapping the passed string in a
 * token and mapping the resulting tokens back to strings.
 *
 * @param {string} str - The string to pass through the pipeline.
 * @param {?object} metadata - Optional metadata to associate with the token
 * passed to the pipeline.
 * @returns {string[]}
 */
lunr.Pipeline.prototype.runString = function (str, metadata) {
  var token = new lunr.Token (str, metadata)

  return this.run([token]).map(function (t) {
    return t.toString()
  })
}

/**
 * Resets the pipeline by removing any existing processors.
 *
 */
lunr.Pipeline.prototype.reset = function () {
  this._stack = []
}

/**
 * Returns a representation of the pipeline ready for serialisation.
 *
 * Logs a warning if the function has not been registered.
 *
 * @returns {Array}
 */
lunr.Pipeline.prototype.toJSON = function () {
  return this._stack.map(function (fn) {
    lunr.Pipeline.warnIfFunctionNotRegistered(fn)

    return fn.label
  })
}
/*!
 * lunr.Vector
 * Copyright (C) 2019 Oliver Nightingale
 */

/**
 * A vector is used to construct the vector space of documents and queries. These
 * vectors support operations to determine the similarity between two documents or
 * a document and a query.
 *
 * Normally no parameters are required for initializing a vector, but in the case of
 * loading a previously dumped vector the raw elements can be provided to the constructor.
 *
 * For performance reasons vectors are implemented with a flat array, where an elements
 * index is immediately followed by its value. E.g. [index, value, index, value]. This
 * allows the underlying array to be as sparse as possible and still offer decent
 * performance when being used for vector calculations.
 *
 * @constructor
 * @param {Number[]} [elements] - The flat list of element index and element value pairs.
 */
lunr.Vector = function (elements) {
  this._magnitude = 0
  this.elements = elements || []
}


/**
 * Calculates the position within the vector to insert a given index.
 *
 * This is used internally by insert and upsert. If there are duplicate indexes then
 * the position is returned as if the value for that index were to be updated, but it
 * is the callers responsibility to check whether there is a duplicate at that index
 *
 * @param {Number} insertIdx - The index at which the element should be inserted.
 * @returns {Number}
 */
lunr.Vector.prototype.positionForIndex = function (index) {
  // For an empty vector the tuple can be inserted at the beginning
  if (this.elements.length == 0) {
    return 0
  }

  var start = 0,
      end = this.elements.length / 2,
      sliceLength = end - start,
      pivotPoint = Math.floor(sliceLength / 2),
      pivotIndex = this.elements[pivotPoint * 2]

  while (sliceLength > 1) {
    if (pivotIndex < index) {
      start = pivotPoint
    }

    if (pivotIndex > index) {
      end = pivotPoint
    }

    if (pivotIndex == index) {
      break
    }

    sliceLength = end - start
    pivotPoint = start + Math.floor(sliceLength / 2)
    pivotIndex = this.elements[pivotPoint * 2]
  }

  if (pivotIndex == index) {
    return pivotPoint * 2
  }

  if (pivotIndex > index) {
    return pivotPoint * 2
  }

  if (pivotIndex < index) {
    return (pivotPoint + 1) * 2
  }
}

/**
 * Inserts an element at an index within the vector.
 *
 * Does not allow duplicates, will throw an error if there is already an entry
 * for this index.
 *
 * @param {Number} insertIdx - The index at which the element should be inserted.
 * @param {Number} val - The value to be inserted into the vector.
 */
lunr.Vector.prototype.insert = function (insertIdx, val) {
  this.upsert(insertIdx, val, function () {
    throw "duplicate index"
  })
}

/**
 * Inserts or updates an existing index within the vector.
 *
 * @param {Number} insertIdx - The index at which the element should be inserted.
 * @param {Number} val - The value to be inserted into the vector.
 * @param {function} fn - A function that is called for updates, the existing value and the
 * requested value are passed as arguments
 */
lunr.Vector.prototype.upsert = function (insertIdx, val, fn) {
  this._magnitude = 0
  var position = this.positionForIndex(insertIdx)

  if (this.elements[position] == insertIdx) {
    this.elements[position + 1] = fn(this.elements[position + 1], val)
  } else {
    this.elements.splice(position, 0, insertIdx, val)
  }
}

/**
 * Calculates the magnitude of this vector.
 *
 * @returns {Number}
 */
lunr.Vector.prototype.magnitude = function () {
  if (this._magnitude) return this._magnitude

  var sumOfSquares = 0,
      elementsLength = this.elements.length

  for (var i = 1; i < elementsLength; i += 2) {
    var val = this.elements[i]
    sumOfSquares += val * val
  }

  return this._magnitude = Math.sqrt(sumOfSquares)
}

/**
 * Calculates the dot product of this vector and another vector.
 *
 * @param {lunr.Vector} otherVector - The vector to compute the dot product with.
 * @returns {Number}
 */
lunr.Vector.prototype.dot = function (otherVector) {
  var dotProduct = 0,
      a = this.elements, b = otherVector.elements,
      aLen = a.length, bLen = b.length,
      aVal = 0, bVal = 0,
      i = 0, j = 0

  while (i < aLen && j < bLen) {
    aVal = a[i], bVal = b[j]
    if (aVal < bVal) {
      i += 2
    } else if (aVal > bVal) {
      j += 2
    } else if (aVal == bVal) {
      dotProduct += a[i + 1] * b[j + 1]
      i += 2
      j += 2
    }
  }

  return dotProduct
}

/**
 * Calculates the similarity between this vector and another vector.
 *
 * @param {lunr.Vector} otherVector - The other vector to calculate the
 * similarity with.
 * @returns {Number}
 */
lunr.Vector.prototype.similarity = function (otherVector) {
  return this.dot(otherVector) / this.magnitude() || 0
}

/**
 * Converts the vector to an array of the elements within the vector.
 *
 * @returns {Number[]}
 */
lunr.Vector.prototype.toArray = function () {
  var output = new Array (this.elements.length / 2)

  for (var i = 1, j = 0; i < this.elements.length; i += 2, j++) {
    output[j] = this.elements[i]
  }

  return output
}

/**
 * A JSON serializable representation of the vector.
 *
 * @returns {Number[]}
 */
lunr.Vector.prototype.toJSON = function () {
  return this.elements
}
/* eslint-disable */
/*!
 * lunr.stemmer
 * Copyright (C) 2019 Oliver Nightingale
 * Includes code from - http://tartarus.org/~martin/PorterStemmer/js.txt
 */

/**
 * lunr.stemmer is an english language stemmer, this is a JavaScript
 * implementation of the PorterStemmer taken from http://tartarus.org/~martin
 *
 * @static
 * @implements {lunr.PipelineFunction}
 * @param {lunr.Token} token - The string to stem
 * @returns {lunr.Token}
 * @see {@link lunr.Pipeline}
 * @function
 */
lunr.stemmer = (function(){
  var step2list = {
      "ational" : "ate",
      "tional" : "tion",
      "enci" : "ence",
      "anci" : "ance",
      "izer" : "ize",
      "bli" : "ble",
      "alli" : "al",
      "entli" : "ent",
      "eli" : "e",
      "ousli" : "ous",
      "ization" : "ize",
      "ation" : "ate",
      "ator" : "ate",
      "alism" : "al",
      "iveness" : "ive",
      "fulness" : "ful",
      "ousness" : "ous",
      "aliti" : "al",
      "iviti" : "ive",
      "biliti" : "ble",
      "logi" : "log"
    },

    step3list = {
      "icate" : "ic",
      "ative" : "",
      "alize" : "al",
      "iciti" : "ic",
      "ical" : "ic",
      "ful" : "",
      "ness" : ""
    },

    c = "[^aeiou]",          // consonant
    v = "[aeiouy]",          // vowel
    C = c + "[^aeiouy]*",    // consonant sequence
    V = v + "[aeiou]*",      // vowel sequence

    mgr0 = "^(" + C + ")?" + V + C,               // [C]VC... is m>0
    meq1 = "^(" + C + ")?" + V + C + "(" + V + ")?$",  // [C]VC[V] is m=1
    mgr1 = "^(" + C + ")?" + V + C + V + C,       // [C]VCVC... is m>1
    s_v = "^(" + C + ")?" + v;                   // vowel in stem

  var re_mgr0 = new RegExp(mgr0);
  var re_mgr1 = new RegExp(mgr1);
  var re_meq1 = new RegExp(meq1);
  var re_s_v = new RegExp(s_v);

  var re_1a = /^(.+?)(ss|i)es$/;
  var re2_1a = /^(.+?)([^s])s$/;
  var re_1b = /^(.+?)eed$/;
  var re2_1b = /^(.+?)(ed|ing)$/;
  var re_1b_2 = /.$/;
  var re2_1b_2 = /(at|bl|iz)$/;
  var re3_1b_2 = new RegExp("([^aeiouylsz])\\1$");
  var re4_1b_2 = new RegExp("^" + C + v + "[^aeiouwxy]$");

  var re_1c = /^(.+?[^aeiou])y$/;
  var re_2 = /^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/;

  var re_3 = /^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/;

  var re_4 = /^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/;
  var re2_4 = /^(.+?)(s|t)(ion)$/;

  var re_5 = /^(.+?)e$/;
  var re_5_1 = /ll$/;
  var re3_5 = new RegExp("^" + C + v + "[^aeiouwxy]$");

  var porterStemmer = function porterStemmer(w) {
    var stem,
      suffix,
      firstch,
      re,
      re2,
      re3,
      re4;

    if (w.length < 3) { return w; }

    firstch = w.substr(0,1);
    if (firstch == "y") {
      w = firstch.toUpperCase() + w.substr(1);
    }

    // Step 1a
    re = re_1a
    re2 = re2_1a;

    if (re.test(w)) { w = w.replace(re,"$1$2"); }
    else if (re2.test(w)) { w = w.replace(re2,"$1$2"); }

    // Step 1b
    re = re_1b;
    re2 = re2_1b;
    if (re.test(w)) {
      var fp = re.exec(w);
      re = re_mgr0;
      if (re.test(fp[1])) {
        re = re_1b_2;
        w = w.replace(re,"");
      }
    } else if (re2.test(w)) {
      var fp = re2.exec(w);
      stem = fp[1];
      re2 = re_s_v;
      if (re2.test(stem)) {
        w = stem;
        re2 = re2_1b_2;
        re3 = re3_1b_2;
        re4 = re4_1b_2;
        if (re2.test(w)) { w = w + "e"; }
        else if (re3.test(w)) { re = re_1b_2; w = w.replace(re,""); }
        else if (re4.test(w)) { w = w + "e"; }
      }
    }

    // Step 1c - replace suffix y or Y by i if preceded by a non-vowel which is not the first letter of the word (so cry -> cri, by -> by, say -> say)
    re = re_1c;
    if (re.test(w)) {
      var fp = re.exec(w);
      stem = fp[1];
      w = stem + "i";
    }

    // Step 2
    re = re_2;
    if (re.test(w)) {
      var fp = re.exec(w);
      stem = fp[1];
      suffix = fp[2];
      re = re_mgr0;
      if (re.test(stem)) {
        w = stem + step2list[suffix];
      }
    }

    // Step 3
    re = re_3;
    if (re.test(w)) {
      var fp = re.exec(w);
      stem = fp[1];
      suffix = fp[2];
      re = re_mgr0;
      if (re.test(stem)) {
        w = stem + step3list[suffix];
      }
    }

    // Step 4
    re = re_4;
    re2 = re2_4;
    if (re.test(w)) {
      var fp = re.exec(w);
      stem = fp[1];
      re = re_mgr1;
      if (re.test(stem)) {
        w = stem;
      }
    } else if (re2.test(w)) {
      var fp = re2.exec(w);
      stem = fp[1] + fp[2];
      re2 = re_mgr1;
      if (re2.test(stem)) {
        w = stem;
      }
    }

    // Step 5
    re = re_5;
    if (re.test(w)) {
      var fp = re.exec(w);
      stem = fp[1];
      re = re_mgr1;
      re2 = re_meq1;
      re3 = re3_5;
      if (re.test(stem) || (re2.test(stem) && !(re3.test(stem)))) {
        w = stem;
      }
    }

    re = re_5_1;
    re2 = re_mgr1;
    if (re.test(w) && re2.test(w)) {
      re = re_1b_2;
      w = w.replace(re,"");
    }

    // and turn initial Y back to y

    if (firstch == "y") {
      w = firstch.toLowerCase() + w.substr(1);
    }

    return w;
  };

  return function (token) {
    return token.update(porterStemmer);
  }
})();

lunr.Pipeline.registerFunction(lunr.stemmer, 'stemmer')
/*!
 * lunr.stopWordFilter
 * Copyright (C) 2019 Oliver Nightingale
 */

/**
 * lunr.generateStopWordFilter builds a stopWordFilter function from the provided
 * list of stop words.
 *
 * The built in lunr.stopWordFilter is built using this generator and can be used
 * to generate custom stopWordFilters for applications or non English languages.
 *
 * @function
 * @param {Array} token The token to pass through the filter
 * @returns {lunr.PipelineFunction}
 * @see lunr.Pipeline
 * @see lunr.stopWordFilter
 */
lunr.generateStopWordFilter = function (stopWords) {
  var words = stopWords.reduce(function (memo, stopWord) {
    memo[stopWord] = stopWord
    return memo
  }, {})

  return function (token) {
    if (token && words[token.toString()] !== token.toString()) return token
  }
}

/**
 * lunr.stopWordFilter is an English language stop word list filter, any words
 * contained in the list will not be passed through the filter.
 *
 * This is intended to be used in the Pipeline. If the token does not pass the
 * filter then undefined will be returned.
 *
 * @function
 * @implements {lunr.PipelineFunction}
 * @params {lunr.Token} token - A token to check for being a stop word.
 * @returns {lunr.Token}
 * @see {@link lunr.Pipeline}
 */
lunr.stopWordFilter = lunr.generateStopWordFilter([
  'a',
  'able',
  'about',
  'across',
  'after',
  'all',
  'almost',
  'also',
  'am',
  'among',
  'an',
  'and',
  'any',
  'are',
  'as',
  'at',
  'be',
  'because',
  'been',
  'but',
  'by',
  'can',
  'cannot',
  'could',
  'dear',
  'did',
  'do',
  'does',
  'either',
  'else',
  'ever',
  'every',
  'for',
  'from',
  'get',
  'got',
  'had',
  'has',
  'have',
  'he',
  'her',
  'hers',
  'him',
  'his',
  'how',
  'however',
  'i',
  'if',
  'in',
  'into',
  'is',
  'it',
  'its',
  'just',
  'least',
  'let',
  'like',
  'likely',
  'may',
  'me',
  'might',
  'most',
  'must',
  'my',
  'neither',
  'no',
  'nor',
  'not',
  'of',
  'off',
  'often',
  'on',
  'only',
  'or',
  'other',
  'our',
  'own',
  'rather',
  'said',
  'say',
  'says',
  'she',
  'should',
  'since',
  'so',
  'some',
  'than',
  'that',
  'the',
  'their',
  'them',
  'then',
  'there',
  'these',
  'they',
  'this',
  'tis',
  'to',
  'too',
  'twas',
  'us',
  'wants',
  'was',
  'we',
  'were',
  'what',
  'when',
  'where',
  'which',
  'while',
  'who',
  'whom',
  'why',
  'will',
  'with',
  'would',
  'yet',
  'you',
  'your'
])

lunr.Pipeline.registerFunction(lunr.stopWordFilter, 'stopWordFilter')
/*!
 * lunr.trimmer
 * Copyright (C) 2019 Oliver Nightingale
 */

/**
 * lunr.trimmer is a pipeline function for trimming non word
 * characters from the beginning and end of tokens before they
 * enter the index.
 *
 * This implementation may not work correctly for non latin
 * characters and should either be removed or adapted for use
 * with languages with non-latin characters.
 *
 * @static
 * @implements {lunr.PipelineFunction}
 * @param {lunr.Token} token The token to pass through the filter
 * @returns {lunr.Token}
 * @see lunr.Pipeline
 */
lunr.trimmer = function (token) {
  return token.update(function (s) {
    return s.replace(/^\W+/, '').replace(/\W+$/, '')
  })
}

lunr.Pipeline.registerFunction(lunr.trimmer, 'trimmer')
/*!
 * lunr.TokenSet
 * Copyright (C) 2019 Oliver Nightingale
 */

/**
 * A token set is used to store the unique list of all tokens
 * within an index. Token sets are also used to represent an
 * incoming query to the index, this query token set and index
 * token set are then intersected to find which tokens to look
 * up in the inverted index.
 *
 * A token set can hold multiple tokens, as in the case of the
 * index token set, or it can hold a single token as in the
 * case of a simple query token set.
 *
 * Additionally token sets are used to perform wildcard matching.
 * Leading, contained and trailing wildcards are supported, and
 * from this edit distance matching can also be provided.
 *
 * Token sets are implemented as a minimal finite state automata,
 * where both common prefixes and suffixes are shared between tokens.
 * This helps to reduce the space used for storing the token set.
 *
 * @constructor
 */
lunr.TokenSet = function () {
  this.final = false
  this.edges = {}
  this.id = lunr.TokenSet._nextId
  lunr.TokenSet._nextId += 1
}

/**
 * Keeps track of the next, auto increment, identifier to assign
 * to a new tokenSet.
 *
 * TokenSets require a unique identifier to be correctly minimised.
 *
 * @private
 */
lunr.TokenSet._nextId = 1

/**
 * Creates a TokenSet instance from the given sorted array of words.
 *
 * @param {String[]} arr - A sorted array of strings to create the set from.
 * @returns {lunr.TokenSet}
 * @throws Will throw an error if the input array is not sorted.
 */
lunr.TokenSet.fromArray = function (arr) {
  var builder = new lunr.TokenSet.Builder

  for (var i = 0, len = arr.length; i < len; i++) {
    builder.insert(arr[i])
  }

  builder.finish()
  return builder.root
}

/**
 * Creates a token set from a query clause.
 *
 * @private
 * @param {Object} clause - A single clause from lunr.Query.
 * @param {string} clause.term - The query clause term.
 * @param {number} [clause.editDistance] - The optional edit distance for the term.
 * @returns {lunr.TokenSet}
 */
lunr.TokenSet.fromClause = function (clause) {
  if ('editDistance' in clause) {
    return lunr.TokenSet.fromFuzzyString(clause.term, clause.editDistance)
  } else {
    return lunr.TokenSet.fromString(clause.term)
  }
}

/**
 * Creates a token set representing a single string with a specified
 * edit distance.
 *
 * Insertions, deletions, substitutions and transpositions are each
 * treated as an edit distance of 1.
 *
 * Increasing the allowed edit distance will have a dramatic impact
 * on the performance of both creating and intersecting these TokenSets.
 * It is advised to keep the edit distance less than 3.
 *
 * @param {string} str - The string to create the token set from.
 * @param {number} editDistance - The allowed edit distance to match.
 * @returns {lunr.Vector}
 */
lunr.TokenSet.fromFuzzyString = function (str, editDistance) {
  var root = new lunr.TokenSet

  var stack = [{
    node: root,
    editsRemaining: editDistance,
    str: str
  }]

  while (stack.length) {
    var frame = stack.pop()

    // no edit
    if (frame.str.length > 0) {
      var char = frame.str.charAt(0),
          noEditNode

      if (char in frame.node.edges) {
        noEditNode = frame.node.edges[char]
      } else {
        noEditNode = new lunr.TokenSet
        frame.node.edges[char] = noEditNode
      }

      if (frame.str.length == 1) {
        noEditNode.final = true
      }

      stack.push({
        node: noEditNode,
        editsRemaining: frame.editsRemaining,
        str: frame.str.slice(1)
      })
    }

    if (frame.editsRemaining == 0) {
      continue
    }

    // insertion
    if ("*" in frame.node.edges) {
      var insertionNode = frame.node.edges["*"]
    } else {
      var insertionNode = new lunr.TokenSet
      frame.node.edges["*"] = insertionNode
    }

    if (frame.str.length == 0) {
      insertionNode.final = true
    }

    stack.push({
      node: insertionNode,
      editsRemaining: frame.editsRemaining - 1,
      str: frame.str
    })

    // deletion
    // can only do a deletion if we have enough edits remaining
    // and if there are characters left to delete in the string
    if (frame.str.length > 1) {
      stack.push({
        node: frame.node,
        editsRemaining: frame.editsRemaining - 1,
        str: frame.str.slice(1)
      })
    }

    // deletion
    // just removing the last character from the str
    if (frame.str.length == 1) {
      frame.node.final = true
    }

    // substitution
    // can only do a substitution if we have enough edits remaining
    // and if there are characters left to substitute
    if (frame.str.length >= 1) {
      if ("*" in frame.node.edges) {
        var substitutionNode = frame.node.edges["*"]
      } else {
        var substitutionNode = new lunr.TokenSet
        frame.node.edges["*"] = substitutionNode
      }

      if (frame.str.length == 1) {
        substitutionNode.final = true
      }

      stack.push({
        node: substitutionNode,
        editsRemaining: frame.editsRemaining - 1,
        str: frame.str.slice(1)
      })
    }

    // transposition
    // can only do a transposition if there are edits remaining
    // and there are enough characters to transpose
    if (frame.str.length > 1) {
      var charA = frame.str.charAt(0),
          charB = frame.str.charAt(1),
          transposeNode

      if (charB in frame.node.edges) {
        transposeNode = frame.node.edges[charB]
      } else {
        transposeNode = new lunr.TokenSet
        frame.node.edges[charB] = transposeNode
      }

      if (frame.str.length == 1) {
        transposeNode.final = true
      }

      stack.push({
        node: transposeNode,
        editsRemaining: frame.editsRemaining - 1,
        str: charA + frame.str.slice(2)
      })
    }
  }

  return root
}

/**
 * Creates a TokenSet from a string.
 *
 * The string may contain one or more wildcard characters (*)
 * that will allow wildcard matching when intersecting with
 * another TokenSet.
 *
 * @param {string} str - The string to create a TokenSet from.
 * @returns {lunr.TokenSet}
 */
lunr.TokenSet.fromString = function (str) {
  var node = new lunr.TokenSet,
      root = node

  /*
   * Iterates through all characters within the passed string
   * appending a node for each character.
   *
   * When a wildcard character is found then a self
   * referencing edge is introduced to continually match
   * any number of any characters.
   */
  for (var i = 0, len = str.length; i < len; i++) {
    var char = str[i],
        final = (i == len - 1)

    if (char == "*") {
      node.edges[char] = node
      node.final = final

    } else {
      var next = new lunr.TokenSet
      next.final = final

      node.edges[char] = next
      node = next
    }
  }

  return root
}

/**
 * Converts this TokenSet into an array of strings
 * contained within the TokenSet.
 *
 * This is not intended to be used on a TokenSet that
 * contains wildcards, in these cases the results are
 * undefined and are likely to cause an infinite loop.
 *
 * @returns {string[]}
 */
lunr.TokenSet.prototype.toArray = function () {
  var words = []

  var stack = [{
    prefix: "",
    node: this
  }]

  while (stack.length) {
    var frame = stack.pop(),
        edges = Object.keys(frame.node.edges),
        len = edges.length

    if (frame.node.final) {
      /* In Safari, at this point the prefix is sometimes corrupted, see:
       * https://github.com/olivernn/lunr.js/issues/279 Calling any
       * String.prototype method forces Safari to "cast" this string to what
       * it's supposed to be, fixing the bug. */
      frame.prefix.charAt(0)
      words.push(frame.prefix)
    }

    for (var i = 0; i < len; i++) {
      var edge = edges[i]

      stack.push({
        prefix: frame.prefix.concat(edge),
        node: frame.node.edges[edge]
      })
    }
  }

  return words
}

/**
 * Generates a string representation of a TokenSet.
 *
 * This is intended to allow TokenSets to be used as keys
 * in objects, largely to aid the construction and minimisation
 * of a TokenSet. As such it is not designed to be a human
 * friendly representation of the TokenSet.
 *
 * @returns {string}
 */
lunr.TokenSet.prototype.toString = function () {
  // NOTE: Using Object.keys here as this.edges is very likely
  // to enter 'hash-mode' with many keys being added
  //
  // avoiding a for-in loop here as it leads to the function
  // being de-optimised (at least in V8). From some simple
  // benchmarks the performance is comparable, but allowing
  // V8 to optimize may mean easy performance wins in the future.

  if (this._str) {
    return this._str
  }

  var str = this.final ? '1' : '0',
      labels = Object.keys(this.edges).sort(),
      len = labels.length

  for (var i = 0; i < len; i++) {
    var label = labels[i],
        node = this.edges[label]

    str = str + label + node.id
  }

  return str
}

/**
 * Returns a new TokenSet that is the intersection of
 * this TokenSet and the passed TokenSet.
 *
 * This intersection will take into account any wildcards
 * contained within the TokenSet.
 *
 * @param {lunr.TokenSet} b - An other TokenSet to intersect with.
 * @returns {lunr.TokenSet}
 */
lunr.TokenSet.prototype.intersect = function (b) {
  var output = new lunr.TokenSet,
      frame = undefined

  var stack = [{
    qNode: b,
    output: output,
    node: this
  }]

  while (stack.length) {
    frame = stack.pop()

    // NOTE: As with the #toString method, we are using
    // Object.keys and a for loop instead of a for-in loop
    // as both of these objects enter 'hash' mode, causing
    // the function to be de-optimised in V8
    var qEdges = Object.keys(frame.qNode.edges),
        qLen = qEdges.length,
        nEdges = Object.keys(frame.node.edges),
        nLen = nEdges.length

    for (var q = 0; q < qLen; q++) {
      var qEdge = qEdges[q]

      for (var n = 0; n < nLen; n++) {
        var nEdge = nEdges[n]

        if (nEdge == qEdge || qEdge == '*') {
          var node = frame.node.edges[nEdge],
              qNode = frame.qNode.edges[qEdge],
              final = node.final && qNode.final,
              next = undefined

          if (nEdge in frame.output.edges) {
            // an edge already exists for this character
            // no need to create a new node, just set the finality
            // bit unless this node is already final
            next = frame.output.edges[nEdge]
            next.final = next.final || final

          } else {
            // no edge exists yet, must create one
            // set the finality bit and insert it
            // into the output
            next = new lunr.TokenSet
            next.final = final
            frame.output.edges[nEdge] = next
          }

          stack.push({
            qNode: qNode,
            output: next,
            node: node
          })
        }
      }
    }
  }

  return output
}
lunr.TokenSet.Builder = function () {
  this.previousWord = ""
  this.root = new lunr.TokenSet
  this.uncheckedNodes = []
  this.minimizedNodes = {}
}

lunr.TokenSet.Builder.prototype.insert = function (word) {
  var node,
      commonPrefix = 0

  if (word < this.previousWord) {
    throw new Error ("Out of order word insertion")
  }

  for (var i = 0; i < word.length && i < this.previousWord.length; i++) {
    if (word[i] != this.previousWord[i]) break
    commonPrefix++
  }

  this.minimize(commonPrefix)

  if (this.uncheckedNodes.length == 0) {
    node = this.root
  } else {
    node = this.uncheckedNodes[this.uncheckedNodes.length - 1].child
  }

  for (var i = commonPrefix; i < word.length; i++) {
    var nextNode = new lunr.TokenSet,
        char = word[i]

    node.edges[char] = nextNode

    this.uncheckedNodes.push({
      parent: node,
      char: char,
      child: nextNode
    })

    node = nextNode
  }

  node.final = true
  this.previousWord = word
}

lunr.TokenSet.Builder.prototype.finish = function () {
  this.minimize(0)
}

lunr.TokenSet.Builder.prototype.minimize = function (downTo) {
  for (var i = this.uncheckedNodes.length - 1; i >= downTo; i--) {
    var node = this.uncheckedNodes[i],
        childKey = node.child.toString()

    if (childKey in this.minimizedNodes) {
      node.parent.edges[node.char] = this.minimizedNodes[childKey]
    } else {
      // Cache the key for this node since
      // we know it can't change anymore
      node.child._str = childKey

      this.minimizedNodes[childKey] = node.child
    }

    this.uncheckedNodes.pop()
  }
}
/*!
 * lunr.Index
 * Copyright (C) 2019 Oliver Nightingale
 */

/**
 * An index contains the built index of all documents and provides a query interface
 * to the index.
 *
 * Usually instances of lunr.Index will not be created using this constructor, instead
 * lunr.Builder should be used to construct new indexes, or lunr.Index.load should be
 * used to load previously built and serialized indexes.
 *
 * @constructor
 * @param {Object} attrs - The attributes of the built search index.
 * @param {Object} attrs.invertedIndex - An index of term/field to document reference.
 * @param {Object<string, lunr.Vector>} attrs.fieldVectors - Field vectors
 * @param {lunr.TokenSet} attrs.tokenSet - An set of all corpus tokens.
 * @param {string[]} attrs.fields - The names of indexed document fields.
 * @param {lunr.Pipeline} attrs.pipeline - The pipeline to use for search terms.
 */
lunr.Index = function (attrs) {
  this.invertedIndex = attrs.invertedIndex
  this.fieldVectors = attrs.fieldVectors
  this.tokenSet = attrs.tokenSet
  this.fields = attrs.fields
  this.pipeline = attrs.pipeline
}

/**
 * A result contains details of a document matching a search query.
 * @typedef {Object} lunr.Index~Result
 * @property {string} ref - The reference of the document this result represents.
 * @property {number} score - A number between 0 and 1 representing how similar this document is to the query.
 * @property {lunr.MatchData} matchData - Contains metadata about this match including which term(s) caused the match.
 */

/**
 * Although lunr provides the ability to create queries using lunr.Query, it also provides a simple
 * query language which itself is parsed into an instance of lunr.Query.
 *
 * For programmatically building queries it is advised to directly use lunr.Query, the query language
 * is best used for human entered text rather than program generated text.
 *
 * At its simplest queries can just be a single term, e.g. `hello`, multiple terms are also supported
 * and will be combined with OR, e.g `hello world` will match documents that contain either 'hello'
 * or 'world', though those that contain both will rank higher in the results.
 *
 * Wildcards can be included in terms to match one or more unspecified characters, these wildcards can
 * be inserted anywhere within the term, and more than one wildcard can exist in a single term. Adding
 * wildcards will increase the number of documents that will be found but can also have a negative
 * impact on query performance, especially with wildcards at the beginning of a term.
 *
 * Terms can be restricted to specific fields, e.g. `title:hello`, only documents with the term
 * hello in the title field will match this query. Using a field not present in the index will lead
 * to an error being thrown.
 *
 * Modifiers can also be added to terms, lunr supports edit distance and boost modifiers on terms. A term
 * boost will make documents matching that term score higher, e.g. `foo^5`. Edit distance is also supported
 * to provide fuzzy matching, e.g. 'hello~2' will match documents with hello with an edit distance of 2.
 * Avoid large values for edit distance to improve query performance.
 *
 * Each term also supports a presence modifier. By default a term's presence in document is optional, however
 * this can be changed to either required or prohibited. For a term's presence to be required in a document the
 * term should be prefixed with a '+', e.g. `+foo bar` is a search for documents that must contain 'foo' and
 * optionally contain 'bar'. Conversely a leading '-' sets the terms presence to prohibited, i.e. it must not
 * appear in a document, e.g. `-foo bar` is a search for documents that do not contain 'foo' but may contain 'bar'.
 *
 * To escape special characters the backslash character '\' can be used, this allows searches to include
 * characters that would normally be considered modifiers, e.g. `foo\~2` will search for a term "foo~2" instead
 * of attempting to apply a boost of 2 to the search term "foo".
 *
 * @typedef {string} lunr.Index~QueryString
 * @example <caption>Simple single term query</caption>
 * hello
 * @example <caption>Multiple term query</caption>
 * hello world
 * @example <caption>term scoped to a field</caption>
 * title:hello
 * @example <caption>term with a boost of 10</caption>
 * hello^10
 * @example <caption>term with an edit distance of 2</caption>
 * hello~2
 * @example <caption>terms with presence modifiers</caption>
 * -foo +bar baz
 */

/**
 * Performs a search against the index using lunr query syntax.
 *
 * Results will be returned sorted by their score, the most relevant results
 * will be returned first.  For details on how the score is calculated, please see
 * the {@link https://lunrjs.com/guides/searching.html#scoring|guide}.
 *
 * For more programmatic querying use lunr.Index#query.
 *
 * @param {lunr.Index~QueryString} queryString - A string containing a lunr query.
 * @throws {lunr.QueryParseError} If the passed query string cannot be parsed.
 * @returns {lunr.Index~Result[]}
 */
lunr.Index.prototype.search = function (queryString) {
  return this.query(function (query) {
    var parser = new lunr.QueryParser(queryString, query)
    parser.parse()
  })
}

/**
 * A query builder callback provides a query object to be used to express
 * the query to perform on the index.
 *
 * @callback lunr.Index~queryBuilder
 * @param {lunr.Query} query - The query object to build up.
 * @this lunr.Query
 */

/**
 * Performs a query against the index using the yielded lunr.Query object.
 *
 * If performing programmatic queries against the index, this method is preferred
 * over lunr.Index#search so as to avoid the additional query parsing overhead.
 *
 * A query object is yielded to the supplied function which should be used to
 * express the query to be run against the index.
 *
 * Note that although this function takes a callback parameter it is _not_ an
 * asynchronous operation, the callback is just yielded a query object to be
 * customized.
 *
 * @param {lunr.Index~queryBuilder} fn - A function that is used to build the query.
 * @returns {lunr.Index~Result[]}
 */
lunr.Index.prototype.query = function (fn) {
  // for each query clause
  // * process terms
  // * expand terms from token set
  // * find matching documents and metadata
  // * get document vectors
  // * score documents

  var query = new lunr.Query(this.fields),
      matchingFields = Object.create(null),
      queryVectors = Object.create(null),
      termFieldCache = Object.create(null),
      requiredMatches = Object.create(null),
      prohibitedMatches = Object.create(null)

  /*
   * To support field level boosts a query vector is created per
   * field. An empty vector is eagerly created to support negated
   * queries.
   */
  for (var i = 0; i < this.fields.length; i++) {
    queryVectors[this.fields[i]] = new lunr.Vector
  }

  fn.call(query, query)

  for (var i = 0; i < query.clauses.length; i++) {
    /*
     * Unless the pipeline has been disabled for this term, which is
     * the case for terms with wildcards, we need to pass the clause
     * term through the search pipeline. A pipeline returns an array
     * of processed terms. Pipeline functions may expand the passed
     * term, which means we may end up performing multiple index lookups
     * for a single query term.
     */
    var clause = query.clauses[i],
        terms = null,
        clauseMatches = lunr.Set.complete

    if (clause.usePipeline) {
      terms = this.pipeline.runString(clause.term, {
        fields: clause.fields
      })
    } else {
      terms = [clause.term]
    }

    for (var m = 0; m < terms.length; m++) {
      var term = terms[m]

      /*
       * Each term returned from the pipeline needs to use the same query
       * clause object, e.g. the same boost and or edit distance. The
       * simplest way to do this is to re-use the clause object but mutate
       * its term property.
       */
      clause.term = term

      /*
       * From the term in the clause we create a token set which will then
       * be used to intersect the indexes token set to get a list of terms
       * to lookup in the inverted index
       */
      var termTokenSet = lunr.TokenSet.fromClause(clause),
          expandedTerms = this.tokenSet.intersect(termTokenSet).toArray()

      /*
       * If a term marked as required does not exist in the tokenSet it is
       * impossible for the search to return any matches. We set all the field
       * scoped required matches set to empty and stop examining any further
       * clauses.
       */
      if (expandedTerms.length === 0 && clause.presence === lunr.Query.presence.REQUIRED) {
        for (var k = 0; k < clause.fields.length; k++) {
          var field = clause.fields[k]
          requiredMatches[field] = lunr.Set.empty
        }

        break
      }

      for (var j = 0; j < expandedTerms.length; j++) {
        /*
         * For each term get the posting and termIndex, this is required for
         * building the query vector.
         */
        var expandedTerm = expandedTerms[j],
            posting = this.invertedIndex[expandedTerm],
            termIndex = posting._index

        for (var k = 0; k < clause.fields.length; k++) {
          /*
           * For each field that this query term is scoped by (by default
           * all fields are in scope) we need to get all the document refs
           * that have this term in that field.
           *
           * The posting is the entry in the invertedIndex for the matching
           * term from above.
           */
          var field = clause.fields[k],
              fieldPosting = posting[field],
              matchingDocumentRefs = Object.keys(fieldPosting),
              termField = expandedTerm + "/" + field,
              matchingDocumentsSet = new lunr.Set(matchingDocumentRefs)

          /*
           * if the presence of this term is required ensure that the matching
           * documents are added to the set of required matches for this clause.
           *
           */
          if (clause.presence == lunr.Query.presence.REQUIRED) {
            clauseMatches = clauseMatches.union(matchingDocumentsSet)

            if (requiredMatches[field] === undefined) {
              requiredMatches[field] = lunr.Set.complete
            }
          }

          /*
           * if the presence of this term is prohibited ensure that the matching
           * documents are added to the set of prohibited matches for this field,
           * creating that set if it does not yet exist.
           */
          if (clause.presence == lunr.Query.presence.PROHIBITED) {
            if (prohibitedMatches[field] === undefined) {
              prohibitedMatches[field] = lunr.Set.empty
            }

            prohibitedMatches[field] = prohibitedMatches[field].union(matchingDocumentsSet)

            /*
             * Prohibited matches should not be part of the query vector used for
             * similarity scoring and no metadata should be extracted so we continue
             * to the next field
             */
            continue
          }

          /*
           * The query field vector is populated using the termIndex found for
           * the term and a unit value with the appropriate boost applied.
           * Using upsert because there could already be an entry in the vector
           * for the term we are working with. In that case we just add the scores
           * together.
           */
          queryVectors[field].upsert(termIndex, clause.boost, function (a, b) { return a + b })

          /**
           * If we've already seen this term, field combo then we've already collected
           * the matching documents and metadata, no need to go through all that again
           */
          if (termFieldCache[termField]) {
            continue
          }

          for (var l = 0; l < matchingDocumentRefs.length; l++) {
            /*
             * All metadata for this term/field/document triple
             * are then extracted and collected into an instance
             * of lunr.MatchData ready to be returned in the query
             * results
             */
            var matchingDocumentRef = matchingDocumentRefs[l],
                matchingFieldRef = new lunr.FieldRef (matchingDocumentRef, field),
                metadata = fieldPosting[matchingDocumentRef],
                fieldMatch

            if ((fieldMatch = matchingFields[matchingFieldRef]) === undefined) {
              matchingFields[matchingFieldRef] = new lunr.MatchData (expandedTerm, field, metadata)
            } else {
              fieldMatch.add(expandedTerm, field, metadata)
            }

          }

          termFieldCache[termField] = true
        }
      }
    }

    /**
     * If the presence was required we need to update the requiredMatches field sets.
     * We do this after all fields for the term have collected their matches because
     * the clause terms presence is required in _any_ of the fields not _all_ of the
     * fields.
     */
    if (clause.presence === lunr.Query.presence.REQUIRED) {
      for (var k = 0; k < clause.fields.length; k++) {
        var field = clause.fields[k]
        requiredMatches[field] = requiredMatches[field].intersect(clauseMatches)
      }
    }
  }

  /**
   * Need to combine the field scoped required and prohibited
   * matching documents into a global set of required and prohibited
   * matches
   */
  var allRequiredMatches = lunr.Set.complete,
      allProhibitedMatches = lunr.Set.empty

  for (var i = 0; i < this.fields.length; i++) {
    var field = this.fields[i]

    if (requiredMatches[field]) {
      allRequiredMatches = allRequiredMatches.intersect(requiredMatches[field])
    }

    if (prohibitedMatches[field]) {
      allProhibitedMatches = allProhibitedMatches.union(prohibitedMatches[field])
    }
  }

  var matchingFieldRefs = Object.keys(matchingFields),
      results = [],
      matches = Object.create(null)

  /*
   * If the query is negated (contains only prohibited terms)
   * we need to get _all_ fieldRefs currently existing in the
   * index. This is only done when we know that the query is
   * entirely prohibited terms to avoid any cost of getting all
   * fieldRefs unnecessarily.
   *
   * Additionally, blank MatchData must be created to correctly
   * populate the results.
   */
  if (query.isNegated()) {
    matchingFieldRefs = Object.keys(this.fieldVectors)

    for (var i = 0; i < matchingFieldRefs.length; i++) {
      var matchingFieldRef = matchingFieldRefs[i]
      var fieldRef = lunr.FieldRef.fromString(matchingFieldRef)
      matchingFields[matchingFieldRef] = new lunr.MatchData
    }
  }

  for (var i = 0; i < matchingFieldRefs.length; i++) {
    /*
     * Currently we have document fields that match the query, but we
     * need to return documents. The matchData and scores are combined
     * from multiple fields belonging to the same document.
     *
     * Scores are calculated by field, using the query vectors created
     * above, and combined into a final document score using addition.
     */
    var fieldRef = lunr.FieldRef.fromString(matchingFieldRefs[i]),
        docRef = fieldRef.docRef

    if (!allRequiredMatches.contains(docRef)) {
      continue
    }

    if (allProhibitedMatches.contains(docRef)) {
      continue
    }

    var fieldVector = this.fieldVectors[fieldRef],
        score = queryVectors[fieldRef.fieldName].similarity(fieldVector),
        docMatch

    if ((docMatch = matches[docRef]) !== undefined) {
      docMatch.score += score
      docMatch.matchData.combine(matchingFields[fieldRef])
    } else {
      var match = {
        ref: docRef,
        score: score,
        matchData: matchingFields[fieldRef]
      }
      matches[docRef] = match
      results.push(match)
    }
  }

  /*
   * Sort the results objects by score, highest first.
   */
  return results.sort(function (a, b) {
    return b.score - a.score
  })
}

/**
 * Prepares the index for JSON serialization.
 *
 * The schema for this JSON blob will be described in a
 * separate JSON schema file.
 *
 * @returns {Object}
 */
lunr.Index.prototype.toJSON = function () {
  var invertedIndex = Object.keys(this.invertedIndex)
    .sort()
    .map(function (term) {
      return [term, this.invertedIndex[term]]
    }, this)

  var fieldVectors = Object.keys(this.fieldVectors)
    .map(function (ref) {
      return [ref, this.fieldVectors[ref].toJSON()]
    }, this)

  return {
    version: lunr.version,
    fields: this.fields,
    fieldVectors: fieldVectors,
    invertedIndex: invertedIndex,
    pipeline: this.pipeline.toJSON()
  }
}

/**
 * Loads a previously serialized lunr.Index
 *
 * @param {Object} serializedIndex - A previously serialized lunr.Index
 * @returns {lunr.Index}
 */
lunr.Index.load = function (serializedIndex) {
  var attrs = {},
      fieldVectors = {},
      serializedVectors = serializedIndex.fieldVectors,
      invertedIndex = Object.create(null),
      serializedInvertedIndex = serializedIndex.invertedIndex,
      tokenSetBuilder = new lunr.TokenSet.Builder,
      pipeline = lunr.Pipeline.load(serializedIndex.pipeline)

  if (serializedIndex.version != lunr.version) {
    lunr.utils.warn("Version mismatch when loading serialised index. Current version of lunr '" + lunr.version + "' does not match serialized index '" + serializedIndex.version + "'")
  }

  for (var i = 0; i < serializedVectors.length; i++) {
    var tuple = serializedVectors[i],
        ref = tuple[0],
        elements = tuple[1]

    fieldVectors[ref] = new lunr.Vector(elements)
  }

  for (var i = 0; i < serializedInvertedIndex.length; i++) {
    var tuple = serializedInvertedIndex[i],
        term = tuple[0],
        posting = tuple[1]

    tokenSetBuilder.insert(term)
    invertedIndex[term] = posting
  }

  tokenSetBuilder.finish()

  attrs.fields = serializedIndex.fields

  attrs.fieldVectors = fieldVectors
  attrs.invertedIndex = invertedIndex
  attrs.tokenSet = tokenSetBuilder.root
  attrs.pipeline = pipeline

  return new lunr.Index(attrs)
}
/*!
 * lunr.Builder
 * Copyright (C) 2019 Oliver Nightingale
 */

/**
 * lunr.Builder performs indexing on a set of documents and
 * returns instances of lunr.Index ready for querying.
 *
 * All configuration of the index is done via the builder, the
 * fields to index, the document reference, the text processing
 * pipeline and document scoring parameters are all set on the
 * builder before indexing.
 *
 * @constructor
 * @property {string} _ref - Internal reference to the document reference field.
 * @property {string[]} _fields - Internal reference to the document fields to index.
 * @property {object} invertedIndex - The inverted index maps terms to document fields.
 * @property {object} documentTermFrequencies - Keeps track of document term frequencies.
 * @property {object} documentLengths - Keeps track of the length of documents added to the index.
 * @property {lunr.tokenizer} tokenizer - Function for splitting strings into tokens for indexing.
 * @property {lunr.Pipeline} pipeline - The pipeline performs text processing on tokens before indexing.
 * @property {lunr.Pipeline} searchPipeline - A pipeline for processing search terms before querying the index.
 * @property {number} documentCount - Keeps track of the total number of documents indexed.
 * @property {number} _b - A parameter to control field length normalization, setting this to 0 disabled normalization, 1 fully normalizes field lengths, the default value is 0.75.
 * @property {number} _k1 - A parameter to control how quickly an increase in term frequency results in term frequency saturation, the default value is 1.2.
 * @property {number} termIndex - A counter incremented for each unique term, used to identify a terms position in the vector space.
 * @property {array} metadataWhitelist - A list of metadata keys that have been whitelisted for entry in the index.
 */
lunr.Builder = function () {
  this._ref = "id"
  this._fields = Object.create(null)
  this._documents = Object.create(null)
  this.invertedIndex = Object.create(null)
  this.fieldTermFrequencies = {}
  this.fieldLengths = {}
  this.tokenizer = lunr.tokenizer
  this.pipeline = new lunr.Pipeline
  this.searchPipeline = new lunr.Pipeline
  this.documentCount = 0
  this._b = 0.75
  this._k1 = 1.2
  this.termIndex = 0
  this.metadataWhitelist = []
}

/**
 * Sets the document field used as the document reference. Every document must have this field.
 * The type of this field in the document should be a string, if it is not a string it will be
 * coerced into a string by calling toString.
 *
 * The default ref is 'id'.
 *
 * The ref should _not_ be changed during indexing, it should be set before any documents are
 * added to the index. Changing it during indexing can lead to inconsistent results.
 *
 * @param {string} ref - The name of the reference field in the document.
 */
lunr.Builder.prototype.ref = function (ref) {
  this._ref = ref
}

/**
 * A function that is used to extract a field from a document.
 *
 * Lunr expects a field to be at the top level of a document, if however the field
 * is deeply nested within a document an extractor function can be used to extract
 * the right field for indexing.
 *
 * @callback fieldExtractor
 * @param {object} doc - The document being added to the index.
 * @returns {?(string|object|object[])} obj - The object that will be indexed for this field.
 * @example <caption>Extracting a nested field</caption>
 * function (doc) { return doc.nested.field }
 */

/**
 * Adds a field to the list of document fields that will be indexed. Every document being
 * indexed should have this field. Null values for this field in indexed documents will
 * not cause errors but will limit the chance of that document being retrieved by searches.
 *
 * All fields should be added before adding documents to the index. Adding fields after
 * a document has been indexed will have no effect on already indexed documents.
 *
 * Fields can be boosted at build time. This allows terms within that field to have more
 * importance when ranking search results. Use a field boost to specify that matches within
 * one field are more important than other fields.
 *
 * @param {string} fieldName - The name of a field to index in all documents.
 * @param {object} attributes - Optional attributes associated with this field.
 * @param {number} [attributes.boost=1] - Boost applied to all terms within this field.
 * @param {fieldExtractor} [attributes.extractor] - Function to extract a field from a document.
 * @throws {RangeError} fieldName cannot contain unsupported characters '/'
 */
lunr.Builder.prototype.field = function (fieldName, attributes) {
  if (/\//.test(fieldName)) {
    throw new RangeError ("Field '" + fieldName + "' contains illegal character '/'")
  }

  this._fields[fieldName] = attributes || {}
}

/**
 * A parameter to tune the amount of field length normalisation that is applied when
 * calculating relevance scores. A value of 0 will completely disable any normalisation
 * and a value of 1 will fully normalise field lengths. The default is 0.75. Values of b
 * will be clamped to the range 0 - 1.
 *
 * @param {number} number - The value to set for this tuning parameter.
 */
lunr.Builder.prototype.b = function (number) {
  if (number < 0) {
    this._b = 0
  } else if (number > 1) {
    this._b = 1
  } else {
    this._b = number
  }
}

/**
 * A parameter that controls the speed at which a rise in term frequency results in term
 * frequency saturation. The default value is 1.2. Setting this to a higher value will give
 * slower saturation levels, a lower value will result in quicker saturation.
 *
 * @param {number} number - The value to set for this tuning parameter.
 */
lunr.Builder.prototype.k1 = function (number) {
  this._k1 = number
}

/**
 * Adds a document to the index.
 *
 * Before adding fields to the index the index should have been fully setup, with the document
 * ref and all fields to index already having been specified.
 *
 * The document must have a field name as specified by the ref (by default this is 'id') and
 * it should have all fields defined for indexing, though null or undefined values will not
 * cause errors.
 *
 * Entire documents can be boosted at build time. Applying a boost to a document indicates that
 * this document should rank higher in search results than other documents.
 *
 * @param {object} doc - The document to add to the index.
 * @param {object} attributes - Optional attributes associated with this document.
 * @param {number} [attributes.boost=1] - Boost applied to all terms within this document.
 */
lunr.Builder.prototype.add = function (doc, attributes) {
  var docRef = doc[this._ref],
      fields = Object.keys(this._fields)

  this._documents[docRef] = attributes || {}
  this.documentCount += 1

  for (var i = 0; i < fields.length; i++) {
    var fieldName = fields[i],
        extractor = this._fields[fieldName].extractor,
        field = extractor ? extractor(doc) : doc[fieldName],
        tokens = this.tokenizer(field, {
          fields: [fieldName]
        }),
        terms = this.pipeline.run(tokens),
        fieldRef = new lunr.FieldRef (docRef, fieldName),
        fieldTerms = Object.create(null)

    this.fieldTermFrequencies[fieldRef] = fieldTerms
    this.fieldLengths[fieldRef] = 0

    // store the length of this field for this document
    this.fieldLengths[fieldRef] += terms.length

    // calculate term frequencies for this field
    for (var j = 0; j < terms.length; j++) {
      var term = terms[j]

      if (fieldTerms[term] == undefined) {
        fieldTerms[term] = 0
      }

      fieldTerms[term] += 1

      // add to inverted index
      // create an initial posting if one doesn't exist
      if (this.invertedIndex[term] == undefined) {
        var posting = Object.create(null)
        posting["_index"] = this.termIndex
        this.termIndex += 1

        for (var k = 0; k < fields.length; k++) {
          posting[fields[k]] = Object.create(null)
        }

        this.invertedIndex[term] = posting
      }

      // add an entry for this term/fieldName/docRef to the invertedIndex
      if (this.invertedIndex[term][fieldName][docRef] == undefined) {
        this.invertedIndex[term][fieldName][docRef] = Object.create(null)
      }

      // store all whitelisted metadata about this token in the
      // inverted index
      for (var l = 0; l < this.metadataWhitelist.length; l++) {
        var metadataKey = this.metadataWhitelist[l],
            metadata = term.metadata[metadataKey]

        if (this.invertedIndex[term][fieldName][docRef][metadataKey] == undefined) {
          this.invertedIndex[term][fieldName][docRef][metadataKey] = []
        }

        this.invertedIndex[term][fieldName][docRef][metadataKey].push(metadata)
      }
    }

  }
}

/**
 * Calculates the average document length for this index
 *
 * @private
 */
lunr.Builder.prototype.calculateAverageFieldLengths = function () {

  var fieldRefs = Object.keys(this.fieldLengths),
      numberOfFields = fieldRefs.length,
      accumulator = {},
      documentsWithField = {}

  for (var i = 0; i < numberOfFields; i++) {
    var fieldRef = lunr.FieldRef.fromString(fieldRefs[i]),
        field = fieldRef.fieldName

    documentsWithField[field] || (documentsWithField[field] = 0)
    documentsWithField[field] += 1

    accumulator[field] || (accumulator[field] = 0)
    accumulator[field] += this.fieldLengths[fieldRef]
  }

  var fields = Object.keys(this._fields)

  for (var i = 0; i < fields.length; i++) {
    var fieldName = fields[i]
    accumulator[fieldName] = accumulator[fieldName] / documentsWithField[fieldName]
  }

  this.averageFieldLength = accumulator
}

/**
 * Builds a vector space model of every document using lunr.Vector
 *
 * @private
 */
lunr.Builder.prototype.createFieldVectors = function () {
  var fieldVectors = {},
      fieldRefs = Object.keys(this.fieldTermFrequencies),
      fieldRefsLength = fieldRefs.length,
      termIdfCache = Object.create(null)

  for (var i = 0; i < fieldRefsLength; i++) {
    var fieldRef = lunr.FieldRef.fromString(fieldRefs[i]),
        fieldName = fieldRef.fieldName,
        fieldLength = this.fieldLengths[fieldRef],
        fieldVector = new lunr.Vector,
        termFrequencies = this.fieldTermFrequencies[fieldRef],
        terms = Object.keys(termFrequencies),
        termsLength = terms.length


    var fieldBoost = this._fields[fieldName].boost || 1,
        docBoost = this._documents[fieldRef.docRef].boost || 1

    for (var j = 0; j < termsLength; j++) {
      var term = terms[j],
          tf = termFrequencies[term],
          termIndex = this.invertedIndex[term]._index,
          idf, score, scoreWithPrecision

      if (termIdfCache[term] === undefined) {
        idf = lunr.idf(this.invertedIndex[term], this.documentCount)
        termIdfCache[term] = idf
      } else {
        idf = termIdfCache[term]
      }

      score = idf * ((this._k1 + 1) * tf) / (this._k1 * (1 - this._b + this._b * (fieldLength / this.averageFieldLength[fieldName])) + tf)
      score *= fieldBoost
      score *= docBoost
      scoreWithPrecision = Math.round(score * 1000) / 1000
      // Converts 1.23456789 to 1.234.
      // Reducing the precision so that the vectors take up less
      // space when serialised. Doing it now so that they behave
      // the same before and after serialisation. Also, this is
      // the fastest approach to reducing a number's precision in
      // JavaScript.

      fieldVector.insert(termIndex, scoreWithPrecision)
    }

    fieldVectors[fieldRef] = fieldVector
  }

  this.fieldVectors = fieldVectors
}

/**
 * Creates a token set of all tokens in the index using lunr.TokenSet
 *
 * @private
 */
lunr.Builder.prototype.createTokenSet = function () {
  this.tokenSet = lunr.TokenSet.fromArray(
    Object.keys(this.invertedIndex).sort()
  )
}

/**
 * Builds the index, creating an instance of lunr.Index.
 *
 * This completes the indexing process and should only be called
 * once all documents have been added to the index.
 *
 * @returns {lunr.Index}
 */
lunr.Builder.prototype.build = function () {
  this.calculateAverageFieldLengths()
  this.createFieldVectors()
  this.createTokenSet()

  return new lunr.Index({
    invertedIndex: this.invertedIndex,
    fieldVectors: this.fieldVectors,
    tokenSet: this.tokenSet,
    fields: Object.keys(this._fields),
    pipeline: this.searchPipeline
  })
}

/**
 * Applies a plugin to the index builder.
 *
 * A plugin is a function that is called with the index builder as its context.
 * Plugins can be used to customise or extend the behaviour of the index
 * in some way. A plugin is just a function, that encapsulated the custom
 * behaviour that should be applied when building the index.
 *
 * The plugin function will be called with the index builder as its argument, additional
 * arguments can also be passed when calling use. The function will be called
 * with the index builder as its context.
 *
 * @param {Function} plugin The plugin to apply.
 */
lunr.Builder.prototype.use = function (fn) {
  var args = Array.prototype.slice.call(arguments, 1)
  args.unshift(this)
  fn.apply(this, args)
}
/**
 * Contains and collects metadata about a matching document.
 * A single instance of lunr.MatchData is returned as part of every
 * lunr.Index~Result.
 *
 * @constructor
 * @param {string} term - The term this match data is associated with
 * @param {string} field - The field in which the term was found
 * @param {object} metadata - The metadata recorded about this term in this field
 * @property {object} metadata - A cloned collection of metadata associated with this document.
 * @see {@link lunr.Index~Result}
 */
lunr.MatchData = function (term, field, metadata) {
  var clonedMetadata = Object.create(null),
      metadataKeys = Object.keys(metadata || {})

  // Cloning the metadata to prevent the original
  // being mutated during match data combination.
  // Metadata is kept in an array within the inverted
  // index so cloning the data can be done with
  // Array#slice
  for (var i = 0; i < metadataKeys.length; i++) {
    var key = metadataKeys[i]
    clonedMetadata[key] = metadata[key].slice()
  }

  this.metadata = Object.create(null)

  if (term !== undefined) {
    this.metadata[term] = Object.create(null)
    this.metadata[term][field] = clonedMetadata
  }
}

/**
 * An instance of lunr.MatchData will be created for every term that matches a
 * document. However only one instance is required in a lunr.Index~Result. This
 * method combines metadata from another instance of lunr.MatchData with this
 * objects metadata.
 *
 * @param {lunr.MatchData} otherMatchData - Another instance of match data to merge with this one.
 * @see {@link lunr.Index~Result}
 */
lunr.MatchData.prototype.combine = function (otherMatchData) {
  var terms = Object.keys(otherMatchData.metadata)

  for (var i = 0; i < terms.length; i++) {
    var term = terms[i],
        fields = Object.keys(otherMatchData.metadata[term])

    if (this.metadata[term] == undefined) {
      this.metadata[term] = Object.create(null)
    }

    for (var j = 0; j < fields.length; j++) {
      var field = fields[j],
          keys = Object.keys(otherMatchData.metadata[term][field])

      if (this.metadata[term][field] == undefined) {
        this.metadata[term][field] = Object.create(null)
      }

      for (var k = 0; k < keys.length; k++) {
        var key = keys[k]

        if (this.metadata[term][field][key] == undefined) {
          this.metadata[term][field][key] = otherMatchData.metadata[term][field][key]
        } else {
          this.metadata[term][field][key] = this.metadata[term][field][key].concat(otherMatchData.metadata[term][field][key])
        }

      }
    }
  }
}

/**
 * Add metadata for a term/field pair to this instance of match data.
 *
 * @param {string} term - The term this match data is associated with
 * @param {string} field - The field in which the term was found
 * @param {object} metadata - The metadata recorded about this term in this field
 */
lunr.MatchData.prototype.add = function (term, field, metadata) {
  if (!(term in this.metadata)) {
    this.metadata[term] = Object.create(null)
    this.metadata[term][field] = metadata
    return
  }

  if (!(field in this.metadata[term])) {
    this.metadata[term][field] = metadata
    return
  }

  var metadataKeys = Object.keys(metadata)

  for (var i = 0; i < metadataKeys.length; i++) {
    var key = metadataKeys[i]

    if (key in this.metadata[term][field]) {
      this.metadata[term][field][key] = this.metadata[term][field][key].concat(metadata[key])
    } else {
      this.metadata[term][field][key] = metadata[key]
    }
  }
}
/**
 * A lunr.Query provides a programmatic way of defining queries to be performed
 * against a {@link lunr.Index}.
 *
 * Prefer constructing a lunr.Query using the {@link lunr.Index#query} method
 * so the query object is pre-initialized with the right index fields.
 *
 * @constructor
 * @property {lunr.Query~Clause[]} clauses - An array of query clauses.
 * @property {string[]} allFields - An array of all available fields in a lunr.Index.
 */
lunr.Query = function (allFields) {
  this.clauses = []
  this.allFields = allFields
}

/**
 * Constants for indicating what kind of automatic wildcard insertion will be used when constructing a query clause.
 *
 * This allows wildcards to be added to the beginning and end of a term without having to manually do any string
 * concatenation.
 *
 * The wildcard constants can be bitwise combined to select both leading and trailing wildcards.
 *
 * @constant
 * @default
 * @property {number} wildcard.NONE - The term will have no wildcards inserted, this is the default behaviour
 * @property {number} wildcard.LEADING - Prepend the term with a wildcard, unless a leading wildcard already exists
 * @property {number} wildcard.TRAILING - Append a wildcard to the term, unless a trailing wildcard already exists
 * @see lunr.Query~Clause
 * @see lunr.Query#clause
 * @see lunr.Query#term
 * @example <caption>query term with trailing wildcard</caption>
 * query.term('foo', { wildcard: lunr.Query.wildcard.TRAILING })
 * @example <caption>query term with leading and trailing wildcard</caption>
 * query.term('foo', {
 *   wildcard: lunr.Query.wildcard.LEADING | lunr.Query.wildcard.TRAILING
 * })
 */

lunr.Query.wildcard = new String ("*")
lunr.Query.wildcard.NONE = 0
lunr.Query.wildcard.LEADING = 1
lunr.Query.wildcard.TRAILING = 2

/**
 * Constants for indicating what kind of presence a term must have in matching documents.
 *
 * @constant
 * @enum {number}
 * @see lunr.Query~Clause
 * @see lunr.Query#clause
 * @see lunr.Query#term
 * @example <caption>query term with required presence</caption>
 * query.term('foo', { presence: lunr.Query.presence.REQUIRED })
 */
lunr.Query.presence = {
  /**
   * Term's presence in a document is optional, this is the default value.
   */
  OPTIONAL: 1,

  /**
   * Term's presence in a document is required, documents that do not contain
   * this term will not be returned.
   */
  REQUIRED: 2,

  /**
   * Term's presence in a document is prohibited, documents that do contain
   * this term will not be returned.
   */
  PROHIBITED: 3
}

/**
 * A single clause in a {@link lunr.Query} contains a term and details on how to
 * match that term against a {@link lunr.Index}.
 *
 * @typedef {Object} lunr.Query~Clause
 * @property {string[]} fields - The fields in an index this clause should be matched against.
 * @property {number} [boost=1] - Any boost that should be applied when matching this clause.
 * @property {number} [editDistance] - Whether the term should have fuzzy matching applied, and how fuzzy the match should be.
 * @property {boolean} [usePipeline] - Whether the term should be passed through the search pipeline.
 * @property {number} [wildcard=lunr.Query.wildcard.NONE] - Whether the term should have wildcards appended or prepended.
 * @property {number} [presence=lunr.Query.presence.OPTIONAL] - The terms presence in any matching documents.
 */

/**
 * Adds a {@link lunr.Query~Clause} to this query.
 *
 * Unless the clause contains the fields to be matched all fields will be matched. In addition
 * a default boost of 1 is applied to the clause.
 *
 * @param {lunr.Query~Clause} clause - The clause to add to this query.
 * @see lunr.Query~Clause
 * @returns {lunr.Query}
 */
lunr.Query.prototype.clause = function (clause) {
  if (!('fields' in clause)) {
    clause.fields = this.allFields
  }

  if (!('boost' in clause)) {
    clause.boost = 1
  }

  if (!('usePipeline' in clause)) {
    clause.usePipeline = true
  }

  if (!('wildcard' in clause)) {
    clause.wildcard = lunr.Query.wildcard.NONE
  }

  if ((clause.wildcard & lunr.Query.wildcard.LEADING) && (clause.term.charAt(0) != lunr.Query.wildcard)) {
    clause.term = "*" + clause.term
  }

  if ((clause.wildcard & lunr.Query.wildcard.TRAILING) && (clause.term.slice(-1) != lunr.Query.wildcard)) {
    clause.term = "" + clause.term + "*"
  }

  if (!('presence' in clause)) {
    clause.presence = lunr.Query.presence.OPTIONAL
  }

  this.clauses.push(clause)

  return this
}

/**
 * A negated query is one in which every clause has a presence of
 * prohibited. These queries require some special processing to return
 * the expected results.
 *
 * @returns boolean
 */
lunr.Query.prototype.isNegated = function () {
  for (var i = 0; i < this.clauses.length; i++) {
    if (this.clauses[i].presence != lunr.Query.presence.PROHIBITED) {
      return false
    }
  }

  return true
}

/**
 * Adds a term to the current query, under the covers this will create a {@link lunr.Query~Clause}
 * to the list of clauses that make up this query.
 *
 * The term is used as is, i.e. no tokenization will be performed by this method. Instead conversion
 * to a token or token-like string should be done before calling this method.
 *
 * The term will be converted to a string by calling `toString`. Multiple terms can be passed as an
 * array, each term in the array will share the same options.
 *
 * @param {object|object[]} term - The term(s) to add to the query.
 * @param {object} [options] - Any additional properties to add to the query clause.
 * @returns {lunr.Query}
 * @see lunr.Query#clause
 * @see lunr.Query~Clause
 * @example <caption>adding a single term to a query</caption>
 * query.term("foo")
 * @example <caption>adding a single term to a query and specifying search fields, term boost and automatic trailing wildcard</caption>
 * query.term("foo", {
 *   fields: ["title"],
 *   boost: 10,
 *   wildcard: lunr.Query.wildcard.TRAILING
 * })
 * @example <caption>using lunr.tokenizer to convert a string to tokens before using them as terms</caption>
 * query.term(lunr.tokenizer("foo bar"))
 */
lunr.Query.prototype.term = function (term, options) {
  if (Array.isArray(term)) {
    term.forEach(function (t) { this.term(t, lunr.utils.clone(options)) }, this)
    return this
  }

  var clause = options || {}
  clause.term = term.toString()

  this.clause(clause)

  return this
}
lunr.QueryParseError = function (message, start, end) {
  this.name = "QueryParseError"
  this.message = message
  this.start = start
  this.end = end
}

lunr.QueryParseError.prototype = new Error
lunr.QueryLexer = function (str) {
  this.lexemes = []
  this.str = str
  this.length = str.length
  this.pos = 0
  this.start = 0
  this.escapeCharPositions = []
}

lunr.QueryLexer.prototype.run = function () {
  var state = lunr.QueryLexer.lexText

  while (state) {
    state = state(this)
  }
}

lunr.QueryLexer.prototype.sliceString = function () {
  var subSlices = [],
      sliceStart = this.start,
      sliceEnd = this.pos

  for (var i = 0; i < this.escapeCharPositions.length; i++) {
    sliceEnd = this.escapeCharPositions[i]
    subSlices.push(this.str.slice(sliceStart, sliceEnd))
    sliceStart = sliceEnd + 1
  }

  subSlices.push(this.str.slice(sliceStart, this.pos))
  this.escapeCharPositions.length = 0

  return subSlices.join('')
}

lunr.QueryLexer.prototype.emit = function (type) {
  this.lexemes.push({
    type: type,
    str: this.sliceString(),
    start: this.start,
    end: this.pos
  })

  this.start = this.pos
}

lunr.QueryLexer.prototype.escapeCharacter = function () {
  this.escapeCharPositions.push(this.pos - 1)
  this.pos += 1
}

lunr.QueryLexer.prototype.next = function () {
  if (this.pos >= this.length) {
    return lunr.QueryLexer.EOS
  }

  var char = this.str.charAt(this.pos)
  this.pos += 1
  return char
}

lunr.QueryLexer.prototype.width = function () {
  return this.pos - this.start
}

lunr.QueryLexer.prototype.ignore = function () {
  if (this.start == this.pos) {
    this.pos += 1
  }

  this.start = this.pos
}

lunr.QueryLexer.prototype.backup = function () {
  this.pos -= 1
}

lunr.QueryLexer.prototype.acceptDigitRun = function () {
  var char, charCode

  do {
    char = this.next()
    charCode = char.charCodeAt(0)
  } while (charCode > 47 && charCode < 58)

  if (char != lunr.QueryLexer.EOS) {
    this.backup()
  }
}

lunr.QueryLexer.prototype.more = function () {
  return this.pos < this.length
}

lunr.QueryLexer.EOS = 'EOS'
lunr.QueryLexer.FIELD = 'FIELD'
lunr.QueryLexer.TERM = 'TERM'
lunr.QueryLexer.EDIT_DISTANCE = 'EDIT_DISTANCE'
lunr.QueryLexer.BOOST = 'BOOST'
lunr.QueryLexer.PRESENCE = 'PRESENCE'

lunr.QueryLexer.lexField = function (lexer) {
  lexer.backup()
  lexer.emit(lunr.QueryLexer.FIELD)
  lexer.ignore()
  return lunr.QueryLexer.lexText
}

lunr.QueryLexer.lexTerm = function (lexer) {
  if (lexer.width() > 1) {
    lexer.backup()
    lexer.emit(lunr.QueryLexer.TERM)
  }

  lexer.ignore()

  if (lexer.more()) {
    return lunr.QueryLexer.lexText
  }
}

lunr.QueryLexer.lexEditDistance = function (lexer) {
  lexer.ignore()
  lexer.acceptDigitRun()
  lexer.emit(lunr.QueryLexer.EDIT_DISTANCE)
  return lunr.QueryLexer.lexText
}

lunr.QueryLexer.lexBoost = function (lexer) {
  lexer.ignore()
  lexer.acceptDigitRun()
  lexer.emit(lunr.QueryLexer.BOOST)
  return lunr.QueryLexer.lexText
}

lunr.QueryLexer.lexEOS = function (lexer) {
  if (lexer.width() > 0) {
    lexer.emit(lunr.QueryLexer.TERM)
  }
}

// This matches the separator used when tokenising fields
// within a document. These should match otherwise it is
// not possible to search for some tokens within a document.
//
// It is possible for the user to change the separator on the
// tokenizer so it _might_ clash with any other of the special
// characters already used within the search string, e.g. :.
//
// This means that it is possible to change the separator in
// such a way that makes some words unsearchable using a search
// string.
lunr.QueryLexer.termSeparator = lunr.tokenizer.separator

lunr.QueryLexer.lexText = function (lexer) {
  while (true) {
    var char = lexer.next()

    if (char == lunr.QueryLexer.EOS) {
      return lunr.QueryLexer.lexEOS
    }

    // Escape character is '\'
    if (char.charCodeAt(0) == 92) {
      lexer.escapeCharacter()
      continue
    }

    if (char == ":") {
      return lunr.QueryLexer.lexField
    }

    if (char == "~") {
      lexer.backup()
      if (lexer.width() > 0) {
        lexer.emit(lunr.QueryLexer.TERM)
      }
      return lunr.QueryLexer.lexEditDistance
    }

    if (char == "^") {
      lexer.backup()
      if (lexer.width() > 0) {
        lexer.emit(lunr.QueryLexer.TERM)
      }
      return lunr.QueryLexer.lexBoost
    }

    // "+" indicates term presence is required
    // checking for length to ensure that only
    // leading "+" are considered
    if (char == "+" && lexer.width() === 1) {
      lexer.emit(lunr.QueryLexer.PRESENCE)
      return lunr.QueryLexer.lexText
    }

    // "-" indicates term presence is prohibited
    // checking for length to ensure that only
    // leading "-" are considered
    if (char == "-" && lexer.width() === 1) {
      lexer.emit(lunr.QueryLexer.PRESENCE)
      return lunr.QueryLexer.lexText
    }

    if (char.match(lunr.QueryLexer.termSeparator)) {
      return lunr.QueryLexer.lexTerm
    }
  }
}

lunr.QueryParser = function (str, query) {
  this.lexer = new lunr.QueryLexer (str)
  this.query = query
  this.currentClause = {}
  this.lexemeIdx = 0
}

lunr.QueryParser.prototype.parse = function () {
  this.lexer.run()
  this.lexemes = this.lexer.lexemes

  var state = lunr.QueryParser.parseClause

  while (state) {
    state = state(this)
  }

  return this.query
}

lunr.QueryParser.prototype.peekLexeme = function () {
  return this.lexemes[this.lexemeIdx]
}

lunr.QueryParser.prototype.consumeLexeme = function () {
  var lexeme = this.peekLexeme()
  this.lexemeIdx += 1
  return lexeme
}

lunr.QueryParser.prototype.nextClause = function () {
  var completedClause = this.currentClause
  this.query.clause(completedClause)
  this.currentClause = {}
}

lunr.QueryParser.parseClause = function (parser) {
  var lexeme = parser.peekLexeme()

  if (lexeme == undefined) {
    return
  }

  switch (lexeme.type) {
    case lunr.QueryLexer.PRESENCE:
      return lunr.QueryParser.parsePresence
    case lunr.QueryLexer.FIELD:
      return lunr.QueryParser.parseField
    case lunr.QueryLexer.TERM:
      return lunr.QueryParser.parseTerm
    default:
      var errorMessage = "expected either a field or a term, found " + lexeme.type

      if (lexeme.str.length >= 1) {
        errorMessage += " with value '" + lexeme.str + "'"
      }

      throw new lunr.QueryParseError (errorMessage, lexeme.start, lexeme.end)
  }
}

lunr.QueryParser.parsePresence = function (parser) {
  var lexeme = parser.consumeLexeme()

  if (lexeme == undefined) {
    return
  }

  switch (lexeme.str) {
    case "-":
      parser.currentClause.presence = lunr.Query.presence.PROHIBITED
      break
    case "+":
      parser.currentClause.presence = lunr.Query.presence.REQUIRED
      break
    default:
      var errorMessage = "unrecognised presence operator'" + lexeme.str + "'"
      throw new lunr.QueryParseError (errorMessage, lexeme.start, lexeme.end)
  }

  var nextLexeme = parser.peekLexeme()

  if (nextLexeme == undefined) {
    var errorMessage = "expecting term or field, found nothing"
    throw new lunr.QueryParseError (errorMessage, lexeme.start, lexeme.end)
  }

  switch (nextLexeme.type) {
    case lunr.QueryLexer.FIELD:
      return lunr.QueryParser.parseField
    case lunr.QueryLexer.TERM:
      return lunr.QueryParser.parseTerm
    default:
      var errorMessage = "expecting term or field, found '" + nextLexeme.type + "'"
      throw new lunr.QueryParseError (errorMessage, nextLexeme.start, nextLexeme.end)
  }
}

lunr.QueryParser.parseField = function (parser) {
  var lexeme = parser.consumeLexeme()

  if (lexeme == undefined) {
    return
  }

  if (parser.query.allFields.indexOf(lexeme.str) == -1) {
    var possibleFields = parser.query.allFields.map(function (f) { return "'" + f + "'" }).join(', '),
        errorMessage = "unrecognised field '" + lexeme.str + "', possible fields: " + possibleFields

    throw new lunr.QueryParseError (errorMessage, lexeme.start, lexeme.end)
  }

  parser.currentClause.fields = [lexeme.str]

  var nextLexeme = parser.peekLexeme()

  if (nextLexeme == undefined) {
    var errorMessage = "expecting term, found nothing"
    throw new lunr.QueryParseError (errorMessage, lexeme.start, lexeme.end)
  }

  switch (nextLexeme.type) {
    case lunr.QueryLexer.TERM:
      return lunr.QueryParser.parseTerm
    default:
      var errorMessage = "expecting term, found '" + nextLexeme.type + "'"
      throw new lunr.QueryParseError (errorMessage, nextLexeme.start, nextLexeme.end)
  }
}

lunr.QueryParser.parseTerm = function (parser) {
  var lexeme = parser.consumeLexeme()

  if (lexeme == undefined) {
    return
  }

  parser.currentClause.term = lexeme.str.toLowerCase()

  if (lexeme.str.indexOf("*") != -1) {
    parser.currentClause.usePipeline = false
  }

  var nextLexeme = parser.peekLexeme()

  if (nextLexeme == undefined) {
    parser.nextClause()
    return
  }

  switch (nextLexeme.type) {
    case lunr.QueryLexer.TERM:
      parser.nextClause()
      return lunr.QueryParser.parseTerm
    case lunr.QueryLexer.FIELD:
      parser.nextClause()
      return lunr.QueryParser.parseField
    case lunr.QueryLexer.EDIT_DISTANCE:
      return lunr.QueryParser.parseEditDistance
    case lunr.QueryLexer.BOOST:
      return lunr.QueryParser.parseBoost
    case lunr.QueryLexer.PRESENCE:
      parser.nextClause()
      return lunr.QueryParser.parsePresence
    default:
      var errorMessage = "Unexpected lexeme type '" + nextLexeme.type + "'"
      throw new lunr.QueryParseError (errorMessage, nextLexeme.start, nextLexeme.end)
  }
}

lunr.QueryParser.parseEditDistance = function (parser) {
  var lexeme = parser.consumeLexeme()

  if (lexeme == undefined) {
    return
  }

  var editDistance = parseInt(lexeme.str, 10)

  if (isNaN(editDistance)) {
    var errorMessage = "edit distance must be numeric"
    throw new lunr.QueryParseError (errorMessage, lexeme.start, lexeme.end)
  }

  parser.currentClause.editDistance = editDistance

  var nextLexeme = parser.peekLexeme()

  if (nextLexeme == undefined) {
    parser.nextClause()
    return
  }

  switch (nextLexeme.type) {
    case lunr.QueryLexer.TERM:
      parser.nextClause()
      return lunr.QueryParser.parseTerm
    case lunr.QueryLexer.FIELD:
      parser.nextClause()
      return lunr.QueryParser.parseField
    case lunr.QueryLexer.EDIT_DISTANCE:
      return lunr.QueryParser.parseEditDistance
    case lunr.QueryLexer.BOOST:
      return lunr.QueryParser.parseBoost
    case lunr.QueryLexer.PRESENCE:
      parser.nextClause()
      return lunr.QueryParser.parsePresence
    default:
      var errorMessage = "Unexpected lexeme type '" + nextLexeme.type + "'"
      throw new lunr.QueryParseError (errorMessage, nextLexeme.start, nextLexeme.end)
  }
}

lunr.QueryParser.parseBoost = function (parser) {
  var lexeme = parser.consumeLexeme()

  if (lexeme == undefined) {
    return
  }

  var boost = parseInt(lexeme.str, 10)

  if (isNaN(boost)) {
    var errorMessage = "boost must be numeric"
    throw new lunr.QueryParseError (errorMessage, lexeme.start, lexeme.end)
  }

  parser.currentClause.boost = boost

  var nextLexeme = parser.peekLexeme()

  if (nextLexeme == undefined) {
    parser.nextClause()
    return
  }

  switch (nextLexeme.type) {
    case lunr.QueryLexer.TERM:
      parser.nextClause()
      return lunr.QueryParser.parseTerm
    case lunr.QueryLexer.FIELD:
      parser.nextClause()
      return lunr.QueryParser.parseField
    case lunr.QueryLexer.EDIT_DISTANCE:
      return lunr.QueryParser.parseEditDistance
    case lunr.QueryLexer.BOOST:
      return lunr.QueryParser.parseBoost
    case lunr.QueryLexer.PRESENCE:
      parser.nextClause()
      return lunr.QueryParser.parsePresence
    default:
      var errorMessage = "Unexpected lexeme type '" + nextLexeme.type + "'"
      throw new lunr.QueryParseError (errorMessage, nextLexeme.start, nextLexeme.end)
  }
}

  /**
   * export the module via AMD, CommonJS or as a browser global
   * Export code from https://github.com/umdjs/umd/blob/master/returnExports.js
   */
  ;(function (root, factory) {
    if (typeof define === 'function' && define.amd) {
      // AMD. Register as an anonymous module.
      define(factory)
    } else if (typeof exports === 'object') {
      /**
       * Node. Does not work with strict CommonJS, but
       * only CommonJS-like enviroments that support module.exports,
       * like Node.
       */
      module.exports = factory()
    } else {
      // Browser globals (root is window)
      root.lunr = factory()
    }
  }(this, function () {
    /**
     * Just return a value to define the module export.
     * This example returns an object, but the module
     * can return a function as the exported value.
     */
    return lunr
  }))
})();

},{}],22:[function(require,module,exports){
"use strict";

require("./shim/array");
require("./shim/object");

},{"./shim/array":23,"./shim/object":24}],23:[function(require,module,exports){
'use strict';

// https://tc39.github.io/ecma262/#sec-array.prototype.includes
if (!Array.prototype.includes) {
  Object.defineProperty(Array.prototype, 'includes', {
    value: function value(searchElement, fromIndex) {
      return this.indexOf(searchElement, fromIndex) !== -1;
    }
  });
}

},{}],24:[function(require,module,exports){
"use strict";

//https://tc39.es/proposal-object-values-entries/
//https://github.com/tc39/proposal-object-values-entries
if (!Object.entries) {
  Object.entries = function (obj) {
    var ownProps = Object.keys(obj),
        i = ownProps.length,
        resArray = new Array(i); // preallocate the Array
    while (i--) {
      resArray[i] = [ownProps[i], obj[ownProps[i]]];
    }

    return resArray;
  };
}

},{}],25:[function(require,module,exports){
(function (global){
'use strict';

require('../frameworks/shim');
require('js-polyfills/es5');
require('js-polyfills/es6');

if (global.rh === undefined) {
  global.rh = {};
}

module.exports = global.rh;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../frameworks/shim":22,"js-polyfills/es5":19,"js-polyfills/es6":20}],26:[function(require,module,exports){
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var CountingSeamaphore = function () {
  function CountingSeamaphore(callback) {
    _classCallCheck(this, CountingSeamaphore);

    this._callback = callback;
    this._count = 0;
  }

  _createClass(CountingSeamaphore, [{
    key: "signal",
    value: function signal() {
      this._count++;
      if (this._count >= 0 && this._callback) {
        this._callback();
      }
    }
  }, {
    key: "wait",
    value: function wait(count) {
      var dec_count = count || 1;
      this._count -= dec_count;
    }
  }]);

  return CountingSeamaphore;
}();

module.exports = CountingSeamaphore;

},{}],27:[function(require,module,exports){
"use strict";

require("../lib/rh");
require("../../lenient_src/robohelp/layout/url_utils");
require("../../lenient_src/robohelp/layout/init");
require("../../lenient_src/robohelp/layout/mp");
require("../../lenient_src/robohelp/layout/expression_builder");
require("../../lenient_src/robohelp/layout/browsesequence_builder");
require("../../lenient_src/robohelp/layout/search_filed");
require("../../lenient_src/robohelp/layout/layoutfix");
require("../../lenient_src/robohelp/layout/filter_controller");
require("../../lenient_src/robohelp/layout/modern_layout_controller");
require("../../lenient_src/robohelp/layout/js_loading_controller");
require("../../lenient_src/robohelp/layout/load_projects");
require("./layout/ui/carousel");
require("./layout/home_controller");
require("../../lenient_src/layout/search_util");
require("./layout/search/suggestion/search_controller");
require("./layout/favorites_controller");
require("./layout/toc_breadcrumbs_controller.js");
require("../../lenient_src/layout/toc_order");
require("../../lenient_src/layout/toc_controller");
require("../../lenient_src/layout/index_controller");
require("../../lenient_src/layout/glossary_controller");
require("../../lenient_src/layout/event_handlers");
require("./layout/rh2017layoutcontroller");
require("./layout/modal_dialog");
require("./layout/search_result_controller.js");
require("../../lenient_src/robohelp/layout/filter_handler");
require("./layout/custom_buttons");
require("./layout/expand_all");

},{"../../lenient_src/layout/event_handlers":1,"../../lenient_src/layout/glossary_controller":2,"../../lenient_src/layout/index_controller":3,"../../lenient_src/layout/search_util":4,"../../lenient_src/layout/toc_controller":5,"../../lenient_src/layout/toc_order":6,"../../lenient_src/robohelp/layout/browsesequence_builder":7,"../../lenient_src/robohelp/layout/expression_builder":8,"../../lenient_src/robohelp/layout/filter_controller":9,"../../lenient_src/robohelp/layout/filter_handler":10,"../../lenient_src/robohelp/layout/init":11,"../../lenient_src/robohelp/layout/js_loading_controller":12,"../../lenient_src/robohelp/layout/layoutfix":13,"../../lenient_src/robohelp/layout/load_projects":14,"../../lenient_src/robohelp/layout/modern_layout_controller":15,"../../lenient_src/robohelp/layout/mp":16,"../../lenient_src/robohelp/layout/search_filed":17,"../../lenient_src/robohelp/layout/url_utils":18,"../lib/rh":25,"./layout/custom_buttons":28,"./layout/expand_all":29,"./layout/favorites_controller":30,"./layout/home_controller":31,"./layout/modal_dialog":32,"./layout/rh2017layoutcontroller":33,"./layout/search/suggestion/search_controller":50,"./layout/search_result_controller.js":65,"./layout/toc_breadcrumbs_controller.js":66,"./layout/ui/carousel":67}],28:[function(require,module,exports){
'use strict';

var rh = require("../../lib/rh"),
    consts = rh.consts,
    model = rh.model,
    _ = rh._;

model.subscribe(consts('KEY_CUSTOM_BUTTONS_CONFIG'), function (config) {
  var buttons = _.map(config, function (item, index) {
    return _.extend({ class: 'custom-button-' + index }, item);
  });
  model.publish(consts('KEY_CUSTOM_BUTTONS'), buttons);
});

},{"../../lib/rh":25}],29:[function(require,module,exports){
'use strict';

var rh = require("../../lib/rh");

rh.model.csubscribe('EVT_EXPAND_COLLAPSE_ALL', function () {
  var currentState = rh.model.cget('ALL_ARE_EXPANDED');
  if (currentState) {
    rh.model.cpublish('EVT_COLLAPSE_ALL');
  } else {
    rh.model.cpublish('EVT_EXPAND_ALL');
  }
});

rh.model.csubscribe('EVT_COLLAPSE_ALL', function () {
  rh.model.cpublish('ALL_ARE_EXPANDED', false);
});

rh.model.csubscribe('EVT_EXPAND_ALL', function () {
  rh.model.cpublish('ALL_ARE_EXPANDED', true);
});

},{"../../lib/rh":25}],30:[function(require,module,exports){
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var rh = require("../../lib/rh");
var consts = rh.consts;

var FavoritesController = function () {
  function FavoritesController(widget) {
    var _this = this;

    _classCallCheck(this, FavoritesController);

    this.widget = widget;
    this.favStorage = new rh.Storage();
    /* Internal functions and variables */
    this._loadFromStorage = false; /* Favorites already loaded from storage? */

    this._favMemoryStore = undefined; /* Variable to hold favorites object */
    rh.model.subscribeOnce(consts('EVT_PROJECT_LOADED'), function () {
      _this.init();
    });
  }

  _createClass(FavoritesController, [{
    key: "_getUniqueId",
    value: function _getUniqueId() {
      function _p8(s) {
        var p = (Math.random().toString(16) + "000000000").substr(2, 8);
        return s ? "-" + p.substr(0, 4) + "-" + p.substr(4, 4) : p;
      }
      return _p8() + _p8(true) + _p8(true) + _p8();
    }
  }, {
    key: "numberOfItems",
    value: function numberOfItems(JSON) {
      /* Count the number of items in an object */
      return Object.keys(JSON).length;
    }
  }, {
    key: "_getFavHTMLElements",
    value: function _getFavHTMLElements(type) {
      /* Find all elements in the HTML that can hold a favorite widget */

      var allElements = document.getElementsByTagName("div"); /* Only divs can be favorite holders */
      var elements = [];

      for (var i = 0; i < allElements.length; i++) {
        if (allElements[i].getAttribute(rh.consts('FAVATTRIBUTE')) === type) {
          elements.push(allElements[i]);
        }
      }

      return elements;
    }
  }, {
    key: "getLinkTitle",
    value: function getLinkTitle(isFavorite) {
      var lng = rh.model.get(consts('KEY_LNG'));
      if (isFavorite) {
        return lng && lng.unsetAsFavorite || '';
      } else {
        return lng && lng.setAsFavorite || '';
      }
    }
  }, {
    key: "_loadFavoritesFromStorage",
    value: function _loadFavoritesFromStorage() {
      /* Load setting from storage */
      var storageObject = void 0;
      var loadString = this.favStorage.fetch(consts('FAVSTORAGE'));

      if (typeof loadString === "undefined" || loadString === null) {
        /* No settings yet, create new object. */
        storageObject = {};
      } else {
        storageObject = JSON.parse(loadString); /* Parse string to object */
      }
      return storageObject;
    }
  }, {
    key: "_loadFavorites",
    value: function _loadFavorites() {
      if (this._loadFromStorage === false) {
        /* Only load once, then use object in memory. Saves a few parsings. */
        this._favMemoryStore = this._loadFavoritesFromStorage();
      }
      return this._favMemoryStore;
    }
  }, {
    key: "_saveFavorites",
    value: function _saveFavorites() {
      var favoritesString = void 0;
      favoritesString = JSON.stringify(this._favMemoryStore);
      this.favStorage.persist(rh.consts('FAVSTORAGE'), favoritesString);
    }
  }, {
    key: "_unFavoriteTopic",
    value: function _unFavoriteTopic(topic) {
      for (var i in this._favMemoryStore) {
        var current = this._favMemoryStore[i];
        if (current.topic === topic) {
          delete this._favMemoryStore[i];
          break;
        }
      }
      this._saveFavorites();
      rh.model.publish(rh.consts('EVENTFAVCHANGE'), null); /* Publish so favorites subscribers are notified of changes */
    }
  }, {
    key: "_favoriteTopic",
    value: function _favoriteTopic(url, title) {
      //let id;
      this._favMemoryStore[this._getUniqueId()] = { "topic": url, "title": title };
      this._saveFavorites();
      rh.model.publish(rh.consts('EVENTFAVCHANGE'), null); /* Publish so favorites subscribers are notified of changes */
    }

    /* Public functions: for use in other scripts */

  }, {
    key: "getStorageId",
    value: function getStorageId() {
      return "fav-" + rh._.getHostFolder();
    }
  }, {
    key: "getTopicURL",
    value: function getTopicURL() {
      /* Get the URL of the current topic */
      return rh.model.get(rh.consts('KEY_TOPIC_URL'));
    }
  }, {
    key: "getTopicTitle",
    value: function getTopicTitle() {
      /* Get title of currently opened topic */
      return rh.model.get(rh.consts('KEY_TOPIC_TITLE'));
    }
  }, {
    key: "isTopicFavorite",
    value: function isTopicFavorite(topic) {
      /* Is the current topic a favorite topic? */
      var favorites = void 0;
      var isFavorite = void 0;
      if (!topic) {
        topic = this.getTopicURL();
      }
      favorites = this._loadFavorites();

      isFavorite = false;
      for (var i in favorites) {
        var current = favorites[i];
        if (current.topic === topic) {
          isFavorite = true;
          break;
        }
      }

      return isFavorite;
    }
  }, {
    key: "setfavoritesTitle",
    value: function setfavoritesTitle(isFavorite) {
      var title = this.getLinkTitle(isFavorite);
      rh.model.publish(consts('FAVORITES_BUTTON_TITLE'), title);
    }
  }, {
    key: "setTopicFavoriteState",
    value: function setTopicFavoriteState() {
      rh.model.publish(consts('TOPIC_FAVORITE'), this.isTopicFavorite());
    }
  }, {
    key: "setFavoritesList",
    value: function setFavoritesList() {
      /* Write the favorites list */
      //let favholders;
      var favorites = [];
      var id = void 0;
      var favorites_map = this._loadFavorites();
      for (id in favorites_map) {
        favorites.push(favorites_map[id]);
      }
      rh.model.publish(consts('KEY_FAVORITES'), favorites);
    }
  }, {
    key: "toggleFavorite",
    value: function toggleFavorite(topicURL) {
      /* Toggle whether the page is a favorite */
      if (!topicURL) {
        topicURL = this.getTopicURL();
      }
      if (this.isTopicFavorite(topicURL)) {
        this._unFavoriteTopic(topicURL); /* Because the favorites list can remove topics, removing a topic can be a different URL than the current topic. */
      } else {
        this._favoriteTopic(topicURL, this.getTopicTitle()); /* This can only be the current topic */
      }
      this.setTopicFavoriteState();
    }
  }, {
    key: "init",
    value: function init() {
      /* Initialise the favorites */

      this.favStorage.init(rh._.getRootUrl());

      /* Subscribe to topic events */
      rh.model.subscribe(rh.consts('KEY_TOPIC_URL'), this.setTopicFavoriteState.bind(this));
      rh.model.subscribe(rh.consts('EVENTFAVCHANGE'), this.setFavoritesList.bind(this));
      rh.model.subscribe(rh.consts('TOPIC_FAVORITE'), this.setfavoritesTitle.bind(this));

      this.setFavoritesList();
      rh.model.publish(consts('TOPIC_FAVORITE'), this.isTopicFavorite());
    }
  }]);

  return FavoritesController;
}();

rh.controller('FavoritesController', FavoritesController);

},{"../../lib/rh":25}],31:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var rh = require("../../lib/rh");
var _ = rh._;

var HomeController = function () {
  function HomeController(widget) {
    _classCallCheck(this, HomeController);

    this.widget = widget;
  }

  _createClass(HomeController, [{
    key: 'goToHome',
    value: function goToHome(tocId) {
      if (rh.consts('HOME_FILEPATH') === rh._.getFileName()) {
        return this.changeToDefaultTopic(tocId);
      }
      var hashMap = void 0;
      if (tocId !== undefined && tocId !== '') {
        hashMap = { rhtocid: tocId };
      }
      _.goToHome(hashMap);
      return true;
    }
  }, {
    key: 'changeToDefaultTopic',
    value: function changeToDefaultTopic(tocId) {
      var hashMap = { t: window.gDefaultTopic.substring(1) };
      if (tocId !== undefined && tocId !== '') {
        hashMap.rhtocid = tocId;
      }
      _.queueUpdateHashMap(hashMap, true);
      return true;
    }
  }]);

  return HomeController;
}();

rh.controller('HomeController', HomeController);

},{"../../lib/rh":25}],32:[function(require,module,exports){
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var rh = require("../../lib/rh");
var nodeUtils = require("../utils/node_utils");
var $ = rh.$;
var _ = rh._;

var ModalDialog = function () {
  function ModalDialog() {
    _classCallCheck(this, ModalDialog);
  }

  _createClass(ModalDialog, [{
    key: "createChildWidget",
    value: function createChildWidget() {
      this.node = $.createElement('div', this.template);
      nodeUtils.appendChild(document.body, this.node);
      this.widget = new rh.Widget({ node: this.node });
      this.widget.init();
    }
  }, {
    key: "setOnImageLoad",
    value: function setOnImageLoad() {
      var modalContent = $.find(this.node, '.rh-modal-content')[0];
      if (!modalContent) {
        return;
      }
      this.modalContent = modalContent;
      var img = $.find(modalContent, 'img')[0];
      if (img) {
        this.img = img;
        img.addEventListener('load', this.setModalSize.bind(this));
        img.addEventListener('error', this.setModalSize.bind(this));
      }
    }
  }, {
    key: "setModalSize",
    value: function setModalSize() {
      this.imageWidth = this.img.naturalWidth;
      this.imageHeight = this.img.naturalHeight;
      var position = this.calculatePosition(this.imageWidth, this.imageHeight);
      var modalContainer = $.find(this.node, '.rh-modal-container')[0];
      if (modalContainer) {
        this.setContainerStyle(modalContainer, position);
      }
    }
  }, {
    key: "setContainerStyle",
    value: function setContainerStyle(modalContainer, position) {
      var top = Math.round(position.top);
      var left = Math.round(position.left);

      $.css(modalContainer, 'left', left.toString() + 'px');
      $.css(modalContainer, 'top', top.toString() + 'px');

      if (this.modalContent) {
        this.setImageSize(position.width, position.height);
      }
      $.css(modalContainer, 'display', "block");
    }
  }, {
    key: "calculateImageSize",
    value: function calculateImageSize(size) {
      var aspect = size.imageWidth / size.imageHeight;
      if (size.imageWidth < size.pageWidth && size.imageHeight < size.pageHeight) {
        return { width: size.imageWidth, height: size.imageHeight };
      }

      if (size.imageWidth >= size.pageWidth && size.imageHeight <= size.pageHeight) {
        return { height: size.pageWidth / aspect, width: size.pageWidth };
      }
      if (size.imageWidth <= size.pageWidth && size.imageHeight >= size.pageHeight) {
        return { height: size.pageHeight, width: size.pageHeight * aspect
        };
      }
      if (size.imageWidth >= size.pageWidth && size.imageHeight >= size.pageHeight) {
        return this._calculateFullyExceedSize(size, aspect);
      }
    }
  }, {
    key: "_calculateFullyExceedSize",
    value: function _calculateFullyExceedSize(size, aspect) {
      var pageAspect = size.pageWidth / size.pageHeight;
      if (aspect < pageAspect) {
        return { height: size.pageHeight, width: size.pageHeight * aspect };
      } else {
        return { height: size.pageWidth / aspect, width: size.pageWidth };
      }
    }
  }, {
    key: "calculatePosition",
    value: function calculatePosition(imageWidth, imageHeight) {
      var pageWidth = window.innerWidth || document.body.clientWidth;
      var pageHeight = window.innerHeight || document.body.clientHeight;
      pageWidth -= 70;
      pageHeight -= 70;
      pageWidth = pageWidth >= 0 ? pageWidth : 0;
      pageHeight = pageHeight >= 0 ? pageHeight : 0;

      var size = { imageWidth: imageWidth, imageHeight: imageHeight, pageWidth: pageWidth, pageHeight: pageHeight };
      var image_size = this.calculateImageSize(size);
      imageWidth = image_size.width;
      imageHeight = image_size.height;
      var left = Math.max(5, (pageWidth - imageWidth) / 2);
      var top = Math.max(5, (pageHeight - imageHeight) / 2);

      return {
        left: left,
        top: top,
        width: imageWidth,
        height: imageHeight,
        pageWidth: pageWidth,
        pageHeight: pageHeight
      };
    }
  }, {
    key: "initialStyle",
    value: function initialStyle() {
      return this.isImage ? "style=\"display:none\"" : '';
    }
  }, {
    key: "ShowModal",
    value: function ShowModal(config) {
      this.isImage = config.isImage;
      this.createChildWidget();
      this.widget.subscribe('close', this._close.bind(this));
      this.widget.publish('content', config.content);
      _.defer(this.setOnImageLoad.bind(this));
    }
  }, {
    key: "setImageSize",
    value: function setImageSize(maxWidth, maxHeight) {
      if (this.imageWidth > maxWidth) {
        $.css(this.img, 'width', Math.round(maxWidth) + "px");
      }
      if (this.imageHeight > maxHeight) {
        $.css(this.img, 'height', Math.round(maxHeight) + "px");
      }
    }
  }, {
    key: "_close",
    value: function _close() {
      this.widget.destruct();
      this.widget = undefined;
      nodeUtils.removeChild(this.node);
      this.node = undefined;
    }
  }, {
    key: "template",
    get: function get() {
      var initialStyle = this.initialStyle();

      return "\n    <div class=\"rh-modal\">\n        <div class=\"rh-modal-container\" " + initialStyle + ">\n          <div class=\"rh-modal-content\" data-html=\"content\"></div>\n          <div class=\"rh-modal-close\" data-click=\"@close(true)\"> </div>\n        </div>\n    </div>";
    }
  }]);

  return ModalDialog;
}();

if (!_.isIframe()) {
  rh.model.csubscribe('SHOW_MODAL', function (config) {
    var model = new ModalDialog();
    model.ShowModal(config);
  });
}

rh.model.csubscribe('SHOW_MODAL_IN_TOPIC', function (config) {
  var model = new ModalDialog();
  model.ShowModal(config);
});

},{"../../lib/rh":25,"../utils/node_utils":68}],33:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var rh = require("../../lib/rh");
var $ = rh.$;
var _ = rh._;
var consts = rh.consts;

var RH2017LayoutController = function () {
  function RH2017LayoutController(widget) {
    _classCallCheck(this, RH2017LayoutController);

    this.widget = widget;
    this.topicFrame = '.topic-container iframe';
    this.initLayout();
    this.initModal();
  }

  _createClass(RH2017LayoutController, [{
    key: 'isLayoutMode',
    value: function isLayoutMode(hashMap) {
      var hash = hashMap || _.hashParams();
      var topicMode = hash[rh.consts('HASH_KEY_TOPIC')];
      return hash[rh.consts('HASH_KEY_UIMODE')] !== consts('HELP_SEARCH_MODE') && (!topicMode || hash[rh.consts('HASH_HOMEPAGE_MODE')] === 'true' || hash[rh.consts('HASH_KEY_RH_TOCID')]);
    }
  }, {
    key: 'initLayout',
    value: function initLayout() {
      var _this = this;

      rh.model.subscribe(consts('EVT_HASH_CHANGE'), function (obj) {
        var hashMap = obj.newMap,
            oldHashMap = obj.oldMap;
        if (_this.isLayoutMode()) {
          _this.widget.publish(rh.consts('KEY_VIEW_MODE'), rh.consts('HELP_LAYOUT_MODE'));
        } else if (hashMap[rh.consts('HASH_KEY_UIMODE')] === 'search') {
          _this.widget.publish(rh.consts('KEY_VIEW_MODE'), rh.consts('HELP_SEARCH_MODE'));
          _.queueUpdateHashMap(_defineProperty({}, consts('HASH_HOMEPAGE_MODE'), false), false);
        } else {
          _this.widget.publish(rh.consts('KEY_VIEW_MODE'), rh.consts('HELP_TOPIC_MODE'));
        }

        var feature = rh.model.get(rh.consts('KEY_FEATURE'));
        if (feature && feature.showDefTopic === false && !hashMap[rh.consts('HASH_KEY_RH_TOCID')] && !oldHashMap[rh.consts('HASH_KEY_TOPIC')] && hashMap[rh.consts('HASH_KEY_TOPIC')]) {
          _.queueUpdateHashMap(_defineProperty({}, consts('HASH_HOMEPAGE_MODE'), 'false'), false);
        } else if (oldHashMap[rh.consts('HASH_KEY_TOPIC')] && !hashMap[rh.consts('HASH_KEY_RH_TOCID')] && oldHashMap[rh.consts('HASH_KEY_TOPIC')] !== hashMap[rh.consts('HASH_KEY_TOPIC')] && hashMap[rh.consts('HASH_HOMEPAGE_MODE')] === 'true' && oldHashMap[rh.consts('HASH_HOMEPAGE_MODE')] === hashMap[rh.consts('HASH_HOMEPAGE_MODE')]) {
          _.queueUpdateHashMap(_defineProperty({}, consts('HASH_HOMEPAGE_MODE'), 'false'), false);
        }
      });

      var hashMap = _.hashParams();
      if (this.isLayoutMode() && hashMap[rh.consts('HASH_HOMEPAGE_MODE')] !== 'true') {
        _.queueUpdateHashMap(_defineProperty({}, consts('HASH_HOMEPAGE_MODE'), true), false);
      }
      rh.model.subscribe('EVT_TOC_LOADEDgototab', function (bookData) {
        if (bookData.key) {
          rh.model.subscribe(bookData.key, function (bookTOC, key, unsub) {
            unsub();
            if (bookData.item && bookData.item.url && !bookTOC[0].added) {
              bookTOC.unshift({ 'type': 'item', 'url': bookData.item.url,
                'name': bookData.item.name, 'added': true });
              rh.model.publish(bookData.key, bookTOC);
            }
          });
        }
        if (bookData.item.url) {
          _this.viewTopicInLayoutMode(bookData.item.url);
        }
      });
    }
  }, {
    key: 'viewTopicInLayoutMode',
    value: function viewTopicInLayoutMode(topicUrl) {
      var paramMap = _defineProperty({ 'homepage': 'true'
      }, rh.consts('HASH_KEY_RH_TOCID'), true);
      if (topicUrl && topicUrl !== '#') {
        paramMap.t = topicUrl;
      }
      _.queueUpdateHashMap(paramMap, false);
    }
  }, {
    key: 'initModal',
    value: function initModal() {
      var bHandled = false;
      document.addEventListener("keydown", function (e) {
        if (e.keyCode === 27) {
          // ESC
          rh._.each($.find('.modal'), function (item) {
            $.addClass(item, 'rh-hide');
          });
        }
      }, false);
      document.addEventListener('click', function () {
        if (!bHandled) {
          rh._.each($.find('.modal'), function (item) {
            $.addClass(item, 'rh-hide');
          });
        }
        bHandled = false;
      });
      rh._.each($.find('.modal-content'), function (item) {
        _.addEventListener(item, 'click', function () {
          bHandled = true;
        });
      });
    }
  }]);

  return RH2017LayoutController;
}();

rh.controller('RH2017LayoutController', RH2017LayoutController);

},{"../../lib/rh":25}],34:[function(require,module,exports){
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var rh = require("../../../../lib/rh");
var _ = rh._;

var Merger = function () {
  function Merger(items, max_items) {
    _classCallCheck(this, Merger);

    this._items = items;
    this._max_items = max_items || rh.model.get(rh.consts('MAX_SEARCH_RESULTS')) || 20;
  }

  _createClass(Merger, [{
    key: "merge",
    value: function merge(newItems) {
      var _this = this;

      _.each(newItems, function (item) {
        _this.mergeItem(item);
      });
      this._sort();
      this._purge();
    }
  }, {
    key: "clear",
    value: function clear() {
      this._items = [];
    }
  }, {
    key: "_purge",
    value: function _purge() {
      if (this._items.length > this._max_items) {
        this._items.splice(this._max_items);
      }
    }
  }, {
    key: "mergeItem",
    value: function mergeItem(item) {
      var existing_item = this.find_item(item);
      if (existing_item) {
        existing_item.merge(item);
      } else {
        this._items.push(item);
      }
    }
  }, {
    key: "find_item",
    value: function find_item(match_item) {
      return _.find(this._items, function (item) {
        return item.match(match_item);
      });
    }
  }, {
    key: "merge_item",
    value: function merge_item(existing_item, new_item) {
      existing_item.probability += new_item.probability;
      existing_item.count = Math.max(existing_item.count, new_item.count);
    }
  }, {
    key: "_sort",
    value: function _sort() {
      this.items.sort(this.compare_items);
    }
  }, {
    key: "compare_items",
    value: function compare_items(p1, p2) {
      return p1.compare(p2);
    }
  }, {
    key: "items",
    get: function get() {
      return this._items;
    }
  }]);

  return Merger;
}();

module.exports = Merger;

},{"../../../../lib/rh":25}],35:[function(require,module,exports){
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var rh = require("../../../../lib/rh");
var consts = rh.consts;

var Paths = function () {
  function Paths(path) {
    _classCallCheck(this, Paths);

    this._path = path || "";
    this.initPath();
  }

  _createClass(Paths, [{
    key: "getPath",
    value: function getPath() {
      return this._path;
    }
  }, {
    key: "initPath",
    value: function initPath() {
      if (this._path === ".") {
        this._path = "";
      }
      if (this._path[0] === '.' && this._path[1] === '/') {
        this._path = this._path.slice(2);
      }
    }
  }, {
    key: "_getModelFileName",
    value: function _getModelFileName(fileNo) {
      var prefix = consts("SEARCH_MODEL_ADDR");
      if (rh.model.get(rh.consts('KEY_CLASSIC_OUTPUT'))) {
        prefix = consts("SEARCH_MODEL_ADDR_OLD");
      }
      return prefix + fileNo.toString() + ".js";
    }
  }, {
    key: "getModelFilePath",
    value: function getModelFilePath(fileno) {
      var fileName = this._getModelFileName(fileno);
      return this._getRelativePath(fileName);
    }
  }, {
    key: "_getRelativePath",
    value: function _getRelativePath(filepath) {
      var path = this._path === "" ? filepath : this._path + '/' + filepath;

      return path;
    }
  }, {
    key: "_getPathKey",
    value: function _getPathKey() {
      return this._path === "" ? "" : '_' + this._path + '_';
    }
  }, {
    key: "getModelKey",
    value: function getModelKey(fileNo) {
      return consts('SEARCH_MODEL_KEY') + this._getPathKey() + fileNo.toString();
    }
  }, {
    key: "_getMapFileName",
    value: function _getMapFileName() {
      if (rh.model.get(rh.consts('KEY_CLASSIC_OUTPUT'))) {
        return consts("SEARCH_MAP_ADDR_OLD");
      }
      return consts("SEARCH_MAP_ADDR");
    }
  }, {
    key: "getMapFilePath",
    value: function getMapFilePath() {
      var fileName = this._getMapFileName();
      return this._getRelativePath(fileName);
    }
  }, {
    key: "getIndexFilePath",
    value: function getIndexFilePath() {
      var fileName = consts("SEARCH_INDEX_FILE");
      if (rh.model.get(rh.consts('KEY_CLASSIC_OUTPUT'))) {
        fileName = consts("SEARCH_INDEX_FILE_OLD");
      }
      return this._getRelativePath(fileName);
    }
  }, {
    key: "getTopicUrl",
    value: function getTopicUrl(url) {
      return this._getRelativePath(url);
    }
  }, {
    key: "getSearchDbFilePath",
    value: function getSearchDbFilePath() {
      var fileName = consts("SEARCH_DB_FILE");
      return this._getRelativePath(fileName);
    }
  }, {
    key: "getMetadataFilePath",
    value: function getMetadataFilePath() {
      var fileName = consts("SEARCH_METADATA_FILE");
      return this._getRelativePath(fileName);
    }
  }, {
    key: "getTextFilePath",
    value: function getTextFilePath(id) {
      var folderPath = consts("SEARCH_TEXT_FILE");
      var relFolderPath = this._getRelativePath(folderPath);
      return relFolderPath + "/" + id + ".js";
    }
  }]);

  return Paths;
}();

module.exports = Paths;

},{"../../../../lib/rh":25}],36:[function(require,module,exports){
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var rh = require("../../../../lib/rh");
var _ = rh._;
module.exports = function () {
  function Synonymns(synonymns) {
    _classCallCheck(this, Synonymns);

    this.synonymns = synonymns || [];
    this.rootWords = {};
    this.merge();
  }

  _createClass(Synonymns, [{
    key: "merge",
    value: function merge() {
      var _this = this;

      this.rootWords = {};
      _.each(this.synonymns, function (item) {
        var synonymns = item.words;
        var word = item.name;
        _.each(synonymns, function (syn) {
          _this._add(word, syn);
        });
      });
    }
  }, {
    key: "_add",
    value: function _add(word, syn) {
      syn = syn.toLowerCase();
      word = word.toLowerCase();
      this.rootWords[syn] = this.rootWords[word] || word;
    }
  }, {
    key: "getRoot",
    value: function getRoot(word) {
      return this.rootWords[word] || word;
    }
  }]);

  return Synonymns;
}();

},{"../../../../lib/rh":25}],37:[function(require,module,exports){
"use strict";

var _exports = {
  minPreviousThreshold: 0.2,
  previousnGram: 1,
  max_predictions: 5,
  PREDICTOR_SOURCE_ID: {
    HISTORY_PREDICTOR: 0,
    NGRAM_PREDICTOR: 1,
    GENERAL_PREDICTOR: 2,
    CORRECTOR: 3
  }
};

module.exports = _exports;

},{}],38:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var INDEX = require('./indices');
var rh = require("../../../../lib/rh");
var _ = rh._;
var Prediction = require('./prediction');
var search_consts = require('./consts');
var search_utils = require('./utils');
var PredictionList = require('./prediction_list');

var Corrector = function () {
  function Corrector(loader, callback) {
    var max_predictions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 20;

    _classCallCheck(this, Corrector);

    this._loader = loader;
    this.predictions = [];
    this.max_predictions = max_predictions;
    this._callback = callback;
  }

  _createClass(Corrector, [{
    key: 'getCorrections',
    value: function getCorrections(parsed_input) {
      this._parsed_input = parsed_input;
      this.predictions = [];
      this._computePredictions();
      var hashes = this._loader.getHashes(this._parsed_input._partial);
      if (hashes) {
        var hash_count = hashes.length;
        for (var i = 0; i < hash_count && this.predictions.length < this.max_predictions; i++) {
          var hash = hashes[i];
          this._addCorrection(hash);
        }
      }
      this.onResultCalculated();
    }
  }, {
    key: 'clear',
    value: function clear() {
      this.predictions = [];
    }
  }, {
    key: '_computePredictions',
    value: function _computePredictions() {

      var word_hashes = this._loader.getHashes(this._parsed_input._partial);
      if (word_hashes) {
        this._addCorrection(word_hashes);
      }
    }
  }, {
    key: 'onResultCalculated',
    value: function onResultCalculated() {
      if (this._callback) {
        this._callback(new PredictionList(this.predictions, this._parsed_input), this._loader);
      }
    }
  }, {
    key: '_matchCorrection',
    value: function _matchCorrection(word) {
      this._hamming_dist = this._getDistance(word);
      if (this._hamming_dist <= 2 && !this._loader.isStopWord(word)) {
        return true;
      }
      return false;
    }
  }, {
    key: '_addCorrection',
    value: function _addCorrection(word_hash) {
      if (!word_hash) {
        return;
      }
      var word = search_utils.getSafeElement(word_hash, INDEX.MAP.WORD);
      if (!word) {
        return;
      }

      if (this._matchCorrection(word)) {
        var complete_word = this._parsed_input.replaceLastWord(word);
        var term = this._parsed_input.completeSuggestion(complete_word);
        var prediction = new Prediction(term, 1 / this._hamming_dist, 2, search_consts.PREDICTOR_SOURCE_ID.CORRECTOR);
        this.predictions.push(prediction);
      }
    }
  }, {
    key: '_getDistance',
    value: function _getDistance(word) {
      return _.findEditDist(this._parsed_input._partial, word);
    }
  }]);

  return Corrector;
}();

module.exports = Corrector;

},{"../../../../lib/rh":25,"./consts":37,"./indices":42,"./prediction":46,"./prediction_list":48,"./utils":53}],39:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var PredictionList = require('./prediction_list');
var PredictonCreator = require('./prediction_creator');
var search_consts = require('./consts');
var INDEX = require('./indices');
var rh = require("../../../../lib/rh");
var _ = rh._;
var PredictonMerger = require('../common/merger');

var GeneralPredictor = function () {
  function GeneralPredictor(callback, loader) {
    var max_predictions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 20;

    _classCallCheck(this, GeneralPredictor);

    this._max_predictions = max_predictions;
    this._loader = loader;
    this.total_count = this._loader.getTotalCount();
    this._callback = callback;
    this._source = search_consts.PREDICTOR_SOURCE_ID.GENERAL_PREDICTOR;
    this.prediction_merger = new PredictonMerger([], this.total_count * 5);
  }

  _createClass(GeneralPredictor, [{
    key: 'clear',
    value: function clear() {
      this.prediction_merger.clear();
      this.parsed_input = undefined;
    }
  }, {
    key: 'getPredictions',
    value: function getPredictions(parsed_input) {

      this._init(parsed_input);
      this._computePredictions();

      this._onResultComputed();
    }
  }, {
    key: '_computePredictions',
    value: function _computePredictions() {

      var word_hashes = this._getWordHashes();
      if (word_hashes) {
        this._addPredictions(word_hashes);
      }
    }
  }, {
    key: '_isWholeWordInput',
    value: function _isWholeWordInput() {
      return this.parsed_input.isWholeWord;
    }
  }, {
    key: '_getWordHashes',
    value: function _getWordHashes() {
      return this.parsed_input.isWholeWord ? this._loader.top_words : this._loader.getHashes(this.parsed_input._partial);
    }
  }, {
    key: '_init',
    value: function _init(parsed_input) {
      this.prediction_merger = new PredictonMerger([], this.total_count * 5);
      this.parsed_input = parsed_input;
    }
  }, {
    key: '_onResultComputed',
    value: function _onResultComputed() {
      if (this._callback) {
        this._callback(new PredictionList(this.predictions, this.parsed_input), this._loader);
      }
    }
  }, {
    key: '_addPredictions',
    value: function _addPredictions(hashes) {
      if (!hashes) {
        return;
      }

      var hash_count = hashes.length;
      for (var i = 0; i < hash_count && this.predictions.length < this.max_predictions; i++) {
        var hash = hashes[i];
        this._addWordPrediction(hash);
      }
    }
  }, {
    key: '_addWordPrediction',
    value: function _addWordPrediction(word_hash, matchFn) {
      matchFn = matchFn || this._matches_partially.bind(this);
      var model_data = this._loader.getModelData(word_hash);
      var total_count = this._loader.total_count;
      if (matchFn(word_hash)) {
        var word = word_hash[INDEX.MAP.WORD];
        if (this._should_add_prediction(word)) {
          this._create_predictions(word_hash, total_count, model_data);
        }
      }
    }
  }, {
    key: '_continueFn',
    value: function _continueFn() {
      return true;
    }
  }, {
    key: '_should_add_prediction',
    value: function _should_add_prediction(word) {
      return !this._loader.isStopWord(word) && !this.parsed_input.equalLastWord(word);
    }
  }, {
    key: '_matches_partially',
    value: function _matches_partially(word_hash) {
      if (this.parsed_input.isWholeWord) {
        return true;
      }

      var word = word_hash[INDEX.MAP.WORD];
      return this.parsed_input.comparePartial(word);
    }
  }, {
    key: '_create_predictions',
    value: function _create_predictions(word_hash, model_count, model_item) {
      var _this = this;

      var creator = new PredictonCreator({ loader: this._loader, model_item: model_item, total_count: model_count, parsed_input: this.parsed_input, continueFn: this._continueFn });
      var predictions = creator.getMultiPredictions(word_hash, true, undefined, this._source);
      _.each(predictions, function (prediction) {
        if (prediction !== undefined) {
          _this.prediction_merger.mergeItem(prediction);
        }
      });
    }
  }, {
    key: '_calculate_probability',
    value: function _calculate_probability(count) {
      return count / this.total_count;
    }
  }, {
    key: 'predictions',
    get: function get() {
      return this.prediction_merger.items;
    }
  }, {
    key: 'max_predictions',
    set: function set(newValue) {
      this._max_predictions = newValue;
    },
    get: function get() {
      return this._max_predictions;
    }
  }]);

  return GeneralPredictor;
}();

module.exports = GeneralPredictor;

},{"../../../../lib/rh":25,"../common/merger":34,"./consts":37,"./indices":42,"./prediction_creator":47,"./prediction_list":48}],40:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var rh = require("../../../../lib/rh");
var _ = rh._;
var Prediction = require('./prediction');
var Parser = require('./input_parser');
var PredictionList = require('./prediction_list');
var search_consts = require('./consts');

var HistoryPredictor = function () {
  function HistoryPredictor(reader, callback) {
    _classCallCheck(this, HistoryPredictor);

    this._reader = reader;
    this._predictions = [];
    this._callback = callback;
    this._source = search_consts.PREDICTOR_SOURCE_ID.HISTORY_PREDICTOR;
    this._max_predictions = search_consts._max_history_predictions === undefined ? 2 : search_consts._max_history_predictions;
  }

  _createClass(HistoryPredictor, [{
    key: 'getPredictions',
    value: function getPredictions(parsed_input) {
      this._predictions = [];
      this._parsed_input = parsed_input;
      this._computePredictions();
      if (this._callback) {
        this._callback(new PredictionList(this._predictions, this._parsed_input));
      }
      return this._predictions;
    }
  }, {
    key: 'init',
    value: function init() {}
  }, {
    key: 'clear',
    value: function clear() {
      this._predictions = [];
    }
  }, {
    key: '_computePredictions',
    value: function _computePredictions() {
      var _this = this;

      if (this._parsed_input.trimmedText !== "") {
        _.each(this._reader._list, function (item) {
          if (_this._match(item.text)) {
            _this._predictions.push(_this._createPrediction(item));
          }
        });
        this._purge();
      }
    }
  }, {
    key: '_purge',
    value: function _purge() {
      this._predictions.splice(this._max_predictions);
    }
  }, {
    key: '_createPrediction',
    value: function _createPrediction(item) {
      var newPrediction = new Prediction(item.text, 1, item.count, this._source);
      return newPrediction;
    }
  }, {
    key: '_match',
    value: function _match(text) {
      if (this._parsed_input.original_text.length > text.length) {
        return false;
      }
      var parsed_text = new Parser(text, true);
      return this._parsed_input.compare(parsed_text);
    }
  }]);

  return HistoryPredictor;
}();

module.exports = HistoryPredictor;

},{"../../../../lib/rh":25,"./consts":37,"./input_parser":43,"./prediction":46,"./prediction_list":48}],41:[function(require,module,exports){
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var rh = require("../../../../lib/rh");
var _ = rh._;
var search_utils = require('./utils');

var HistoryReader = function () {
  function HistoryReader() {
    _classCallCheck(this, HistoryReader);
  }

  _createClass(HistoryReader, [{
    key: "initHistory",
    value: function initHistory(list) {
      if (this._list === undefined) {
        this._list = list || [];
      }
    }
  }, {
    key: "getHistory",
    value: function getHistory() {
      return this._list || [];
    }
  }, {
    key: "_updateText",
    value: function _updateText(text, index) {
      this.getHistory().splice(index, 1);
      this.getHistory().unshift(text);
    }
  }, {
    key: "_addNewText",
    value: function _addNewText(newText) {
      this.getHistory().push(newText);
    }
  }, {
    key: "add",
    value: function add(newText) {
      var nIndex = _.findIndex(this.getHistory(), function (item) {
        return search_utils.compareNoCase(newText.text, item.text) === 0;
      });
      if (nIndex >= 0) {
        this._updateText(newText, nIndex);
      } else {
        this._addNewText(newText);
      }
    }
  }, {
    key: "delete",
    value: function _delete(searchText) {
      var nIndex = _.findIndex(this.getHistory(), function (item) {
        return search_utils.compareNoCase(searchText, item.text) === 0;
      });
      if (nIndex >= 0) {
        this.getHistory().splice(nIndex);
      }
    }
  }]);

  return HistoryReader;
}();

module.exports = new HistoryReader();

},{"../../../../lib/rh":25,"./utils":53}],42:[function(require,module,exports){
"use strict";

var _exports = {
  MAP: {
    WORD: 0,
    HASH: 1,
    COUNT: 2,
    MODEL_FILE_NO: 3,
    MODEL_INDEX: 4,
    TOPICS: 5
  },

  MODEL: {
    WORD_HASH: 0,
    COUNT: 1,
    NEXT_MODEL: 2
  },

  FIRST_PREDICTION: {
    NEXT: 0,
    PREVIOUS: 1
  }
};

module.exports = _exports;

},{}],43:[function(require,module,exports){
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var search_utils = require('./utils');
var rh = require("../../../../../src/lib/rh");
var _ = rh._;

var InputParser = function () {
  function InputParser(text, isWholeWord, selection, isPrevious) {
    _classCallCheck(this, InputParser);

    this.isPrevious = isPrevious;
    this.selection = selection === undefined ? text.length : selection;
    var separator = this._calculateSeparator(text);
    if (!this.isPrevious) {
      this.isWholeWord = isWholeWord || this._isWholeWord(text, separator);
    }
    this.initText(text, separator);
  }

  _createClass(InputParser, [{
    key: "initText",
    value: function initText(text, separator) {
      this._computeText(text, separator);
      this.trimmedText = this.original_text.trim();
      this.words = _.compact(this.trimmedText.split(" ") || []);
      this._reverseIfPrevious();
      if (!this.isWholeWord && this.words.length > 0) {
        this._partial = this.words.splice(-1)[0];
      }
    }
  }, {
    key: "_computeText",
    value: function _computeText(text, separator) {
      this._right_text = "";
      this._left_text = "";

      if (separator === undefined) {
        separator = text.length;
      }
      this.isSplitText = !(separator === 0 || separator === text.length);
      var left_text = text.substring(0, separator);
      var right_text = text.substring(separator);

      if (this.isPrevious) {
        this.original_text = right_text;
        this._left_text = left_text.trim();
      } else {
        this.original_text = left_text;
        this._right_text = right_text.trim();
      }
    }
  }, {
    key: "equalRemaingWord",
    value: function equalRemaingWord(word) {
      if (this._left_text !== "" || this._right_text !== "") {
        var remainingWord = this._getRemainigWord();
        if (remainingWord) {
          return search_utils.compareNoCase(remainingWord, word) === 0;
        }
      }
      return false;
    }
  }, {
    key: "_getRemainigWord",
    value: function _getRemainigWord() {
      var words = this.isPrevious ? this._left_text.split(" ") : this._right_text.split(" ");

      words = words || [];
      words = _.compact(words);
      if (words.length > 0) {
        return this.isPrevious ? words[words.length - 1] : words[0];
      }
    }
  }, {
    key: "completeSuggestion",
    value: function completeSuggestion(text) {
      if (this.isPrevious) {
        return this._left_text.length === 0 ? text : this._left_text + " " + text;
      } else {
        return this._right_text.length === 0 ? text : text + " " + this._right_text;
      }
    }
  }, {
    key: "_calculateSeparator",
    value: function _calculateSeparator(text) {

      if (this.isPrevious) {
        if (this.selection === 0) {
          this.isWholeWord = true;
          return 0;
        }
        if (text.length > this.selection && text[this.selection - 1] !== " ") {
          var previousSpaceIndex = text.lastIndexOf(" ", this.selection - 1);
          this.isWholeWord = false;
          return previousSpaceIndex >= 0 ? previousSpaceIndex + 1 : 0;
        }
        this.isWholeWord = true;
      }
      return this.selection;
    }
  }, {
    key: "_reverseIfPrevious",
    value: function _reverseIfPrevious() {
      if (this.isPrevious) {
        this.words.reverse();
      }
    }
  }, {
    key: "_isWholeWord",
    value: function _isWholeWord(text, separator) {
      if (this.isPrevious) {
        if (separator === 0) {
          return true;
        }
        return text.length > separator && text[separator - 1] === " ";
      }

      return separator > 0 && text[separator - 1] === " ";
    }
  }, {
    key: "compare",
    value: function compare(other_input) {
      var start = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var end = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;

      end = end === undefined ? this.words.length - 1 : end;
      if (this.words.length > other_input.words.length) {
        return false;
      }
      var i = start;
      for (; i <= end; i++) {
        var word1 = this.words[i];
        var word2 = other_input.words[i];
        if (search_utils.compareNoCase(word1, word2) !== 0) {
          return false;
        }
      }
      return this.matchPartial(other_input, i);
    }
  }, {
    key: "matchPartial",
    value: function matchPartial(other_input, index) {
      if (this._partial === undefined) {
        return true;
      }
      if (other_input.words.length <= index) {
        return false;
      }
      var other_word = other_input.words[index];
      return this.comparePartial(other_word);
    }
  }, {
    key: "comparePartial",
    value: function comparePartial(word) {
      this._matchExp = new RegExp('^' + this._partial, 'i');
      return this._matchExp.test(word);
    }
  }, {
    key: "completeWord",
    value: function completeWord(next_word) {
      if (this.isWholeWord || this._partial === undefined || this._partial.length === 0) {
        return this.getTermForCompleteWord(next_word, this.trimmedText);
      } else {
        return this.getTermForPartialText(next_word);
      }
    }
  }, {
    key: "getTermForPartialText",
    value: function getTermForPartialText(next_word) {
      var partial_next_word = next_word.substring(this._partial.length, next_word.length);
      if (this.isPrevious) {
        var trimmedText = "";
        var firstSpaceIndex = this.trimmedText.indexOf(' ');
        if (firstSpaceIndex >= 0) {
          trimmedText = this.trimmedText.substring(firstSpaceIndex);
        }
        return this._partial + partial_next_word + trimmedText;
      } else {
        return this.trimmedText + partial_next_word;
      }
    }
  }, {
    key: "getTermForCompleteWord",
    value: function getTermForCompleteWord(next_word) {
      if (this.isPrevious) {
        return next_word + " " + this.trimmedText;
      } else {
        return this.trimmedText + " " + next_word;
      }
    }
  }, {
    key: "replaceLastWord",
    value: function replaceLastWord(next_word) {
      var text = this.trimmedText;
      if (this._partial !== undefined && !this.isWholeWord) {
        var index = this.trimmedText.length - this._partial.length;
        text = this.trimmedText.substring(0, index);
        text = text.trim();
      }
      return text + " " + next_word;
    }
  }, {
    key: "equalLastWord",
    value: function equalLastWord(word) {
      if (this.words.length === 0) {
        return false;
      }
      var last_word = this.words[this.words.length - 1];
      return search_utils.compareNoCase(last_word, word) === 0;
    }
  }]);

  return InputParser;
}();

module.exports = InputParser;

},{"../../../../../src/lib/rh":25,"./utils":53}],44:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var rh = require("../../../../lib/rh");
var _ = rh._;
var model = rh.model;
var search_utils = require('./utils');
var INDEX = require('./indices');
var SEARCH_CONSTS = require('./consts');
var Paths = require('../common/paths');

var Loader = function () {
  function Loader() {
    var path = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";

    _classCallCheck(this, Loader);

    this._paths = new Paths(path);
  }

  _createClass(Loader, [{
    key: 'init',
    value: function init(callbackFn) {
      this.loadIndex(callbackFn);
      this.loadMap(callbackFn);
    }
  }, {
    key: '_isIndexLoaded',
    value: function _isIndexLoaded() {
      return this.index_data !== undefined;
    }
  }, {
    key: 'getModelCount',
    value: function getModelCount() {
      return this.index_data.Model.length;
    }
  }, {
    key: 'getMapHash',
    value: function getMapHash(hash_key) {
      return this._hash_to_word[hash_key];
    }
  }, {
    key: 'getHashes',
    value: function getHashes(input) {
      if (input !== undefined && input.length > 0) {
        return this.getAplhabetHashes(input[0]);
      }
    }
  }, {
    key: 'getAplhabetHashes',
    value: function getAplhabetHashes(alphabet) {
      if (this.map_data && alphabet.length === 1) {
        var lalphabet = alphabet.toLowerCase();
        return this.map_data[lalphabet];
      }
    }
  }, {
    key: 'getWordModel',
    value: function getWordModel(word, model_data) {
      var word_model = void 0;
      var word_hash = this._getHashForWord(word);
      if (word_hash && model_data) {
        word_model = model_data[word_hash[INDEX.MAP.MODEL_INDEX]];
      }
      return word_model;
    }
  }, {
    key: 'getCount',
    value: function getCount(word) {
      var word_hash = this._getHashForWord(word);
      if (word_hash) {
        return word_hash[INDEX.MAP.COUNT];
      }
    }
  }, {
    key: 'getModelData',
    value: function getModelData(word_hash) {
      // async call if not loaded return empty array
      var fileno = word_hash[INDEX.MAP.MODEL_FILE_NO];
      var model_index = word_hash[INDEX.MAP.MODEL_INDEX];
      var data = model.get(this._paths.getModelKey(fileno));
      if (!data) {
        this.loadModel(fileno);
      }
      return data && data[model_index];
    }
  }, {
    key: '_compareWordCount',
    value: function _compareWordCount(hash_item1, hash_item2) {
      var count1 = search_utils.getSafeElement(hash_item1, INDEX.MAP.COUNT);
      var count2 = search_utils.getSafeElement(hash_item2, INDEX.MAP.COUNT);
      if (count1 && count2) {
        return count2 - count1;
      }
      return 0;
    }
  }, {
    key: '_buildTopWords',
    value: function _buildTopWords(words) {
      words.sort(this._compareWordCount);
      words.splice(SEARCH_CONSTS.max_predictions * 100);
      this._top_words = words;
    }
  }, {
    key: 'getModelFileNo',
    value: function getModelFileNo(word) {
      var word_hash = this._getHashForWord(word);
      if (word_hash) {
        return word_hash[INDEX.MAP.MODEL_FILE_NO];
      }
    }
  }, {
    key: '_getHashForWord',
    value: function _getHashForWord(word) {
      var hash = void 0;
      var word_key = this.getHashKey(word);
      if (word_key) {
        hash = this._hash_to_word[word_key];
      }
      return hash;
    }
  }, {
    key: 'getHashKey',
    value: function getHashKey(word) {
      if (word && word.length > 0) {
        var lWord = word.toLowerCase();
        return this._word_hash[lWord];
      }
    }
  }, {
    key: 'loadIndex',
    value: function loadIndex(callbackFn) {
      var _this = this;

      if (this._isIndexLoaded() === false) {
        _.loadScript(this._paths.getIndexFilePath(), true, function () {
          _this.index_data = _.exports();
          _this.onIndexLoaded(callbackFn);
        }, true);
      } else {
        this.onIndexLoaded(callbackFn);
      }
    }
  }, {
    key: 'loadModel',
    value: function loadModel(fileNo, callbackFn) {
      var data = [];
      if (fileNo !== undefined) {
        var key = this._paths.getModelKey(fileNo);
        var _data = model.get(key);
        if (_data === undefined) {
          model.publish(key, null);

          var filepath = this._paths.getModelFilePath(fileNo);
          _.loadScript(filepath, true, this.getOnModelLoadFn(fileNo, callbackFn), true);
        } else if (_data === null && callbackFn !== undefined) {

          model.subscribe(key, callbackFn);
        } else {
          this.doCallback(callbackFn, _data, fileNo);
        }
      } else {
        this.doCallback(callbackFn, data, fileNo);
      }
    }
  }, {
    key: 'doCallback',
    value: function doCallback(callbackFn, data, fileno) {
      if (callbackFn) {
        callbackFn(data, fileno);
      }
    }
  }, {
    key: 'getOnModelLoadFn',
    value: function getOnModelLoadFn(fileNo, callbackFn) {
      var _this2 = this;

      return function () {
        var data = _.exports();
        model.publish(_this2._paths.getModelKey(fileNo), data);
        if (callbackFn) {
          callbackFn(data, fileNo);
        }
      };
    }
  }, {
    key: 'onMapLoaded',
    value: function onMapLoaded(callbackFn) {
      this.parseMap();
      if (this.index_data && callbackFn) {
        callbackFn(this);
      }
    }
  }, {
    key: 'onIndexLoaded',
    value: function onIndexLoaded(callbackFn) {
      if (this.map_data && callbackFn) {
        callbackFn(this);
      }
    }
  }, {
    key: 'parseMap',
    value: function parseMap() {
      var data = this.map_data;
      this._word_hash = {};
      this._hash_to_word = {};
      var words = [];
      for (var letter in data) {
        var words_data = data[letter];
        this._parseWordsData(words_data);
        words = words.concat(words_data);
      }
      this._buildTopWords(words);
    }
  }, {
    key: '_parseWordsData',
    value: function _parseWordsData(words_data) {
      var _this3 = this;

      _.each(words_data, function (word_data) {
        var hash_key = parseInt(word_data[INDEX.MAP.HASH]);
        if (word_data[INDEX.MAP.WORD]) {
          var word = word_data[INDEX.MAP.WORD].toString();
          _this3._word_hash[word] = hash_key;
        }
        _this3._hash_to_word[hash_key] = word_data;
      });
    }
  }, {
    key: 'isStopWord',
    value: function isStopWord(word) {
      var index = _.find(this.index_data.stopWords, function (stop_word) {
        return search_utils.compareNoCase(word, stop_word) === 0;
      });
      return index !== undefined;
    }
  }, {
    key: 'getTotalCount',
    value: function getTotalCount() {
      return this.index_data.totalCount;
    }
  }, {
    key: 'wordHashfromIndexKey',
    value: function wordHashfromIndexKey(index_key, fileno) {
      return _.find(this._hash_to_word, function (map_item) {
        return map_item[INDEX.MAP.MODEL_INDEX] === index_key && map_item[INDEX.MAP.MODEL_FILE_NO] === fileno;
      });
    }
  }, {
    key: 'loadMap',
    value: function loadMap(callbackFn) {
      var _this4 = this;

      if (this.map_data === undefined) {
        _.loadScript(this._paths.getMapFilePath(), true, function () {
          _this4.map_data = _.exports();
          _this4.onMapLoaded(callbackFn);
        }, true);
      } else {
        this.onMapLoaded(callbackFn);
      }
    }
  }, {
    key: 'top_words',
    get: function get() {
      return this._top_words;
    }
  }, {
    key: 'nGram',
    get: function get() {
      return this.index_data.nGram;
    }
  }, {
    key: 'search_model',
    get: function get() {
      return this.index_data.Model;
    }
  }, {
    key: 'search_map',
    get: function get() {
      return this.index_data.Map;
    }
  }, {
    key: 'total_count',
    get: function get() {
      return this.index_data.totalCount;
    }
  }, {
    key: 'stop_words',
    get: function get() {
      return this.index_data.stopWords;
    }
  }]);

  return Loader;
}();

module.exports = Loader;

},{"../../../../lib/rh":25,"../common/paths":35,"./consts":37,"./indices":42,"./utils":53}],45:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var rh = require("../../../../lib/rh");
var _ = rh._;
var PredictonCreator = require('./prediction_creator');
//let search_utils = require('./utils');
//let Prediction = require('./prediction');
var PredictionList = require('./prediction_list');
var search_consts = require('./consts');
var INDEX = require('./indices');

var NGramPredictor = function () {
  function NGramPredictor(_ref) {
    var loader = _ref.loader,
        level = _ref.level,
        callback = _ref.callback,
        previous = _ref.previous,
        _ref$max_predictions = _ref.max_predictions,
        max_predictions = _ref$max_predictions === undefined ? 20 : _ref$max_predictions;

    _classCallCheck(this, NGramPredictor);

    this.level = level;
    this.previous = previous;
    this._max_predictions = max_predictions;
    this.predictions = [];
    this._callback = callback;
    this._loader = loader;
    this._source = search_consts.PREDICTOR_SOURCE_ID.NGRAM_PREDICTOR;
  }

  _createClass(NGramPredictor, [{
    key: 'init',
    value: function init() {}
  }, {
    key: 'clear',
    value: function clear() {
      this._word_model = undefined;
      this._prediction_array = undefined;
      this.parsed_input = undefined;
      this.predictions = [];
    }
  }, {
    key: 'getPredictions',
    value: function getPredictions(parsed_input) {
      this.parsed_input = parsed_input;
      this.predictions = [];
      if (parsed_input !== undefined && parsed_input.words.length >= this.level) {
        this.word_index = parsed_input.words.length - this.level;
        this._word = parsed_input.words[this.word_index];
        this._loadInputModel(this._word, this._compute_word_predictions.bind(this));
      } else {
        this._onResultsComputed();
      }
    }
  }, {
    key: '_compute_word_predictions',
    value: function _compute_word_predictions(model_data) {
      this.predictions = [];
      var level = this.level;
      var word = this._word;
      var total_count = this._loader.getCount(word);
      this._word_model = this._loader.getWordModel(word, model_data);
      if (this._word_model) {
        this._prediction_array = this._get_prediction_array();
        this._compute_prediction_from_model(word, level, total_count);
      }
      this._onResultsComputed();
    }
  }, {
    key: '_onResultsComputed',
    value: function _onResultsComputed() {
      if (this._callback) {
        this._callback(new PredictionList(this.predictions, this.parsed_input), this._loader);
      }
    }
  }, {
    key: '_compute_prediction_from_model',
    value: function _compute_prediction_from_model(word, level, total_count) {
      if (this._prediction_array === undefined) {
        return;
      }

      if (this._is_my_level(level)) {
        this._compute_next_words(total_count);
      } else {
        level--;
        var next_index = this._get_word_index(level);
        var next_word = this.parsed_input.words[next_index];
        var next_word_key = this._loader.getHashKey(next_word);
        var next_word_model = this._get_next_model(this._prediction_array, next_word_key);
        if (next_word_model) {
          total_count = next_word_model[INDEX.MODEL.COUNT];
          this._prediction_array = next_word_model[INDEX.MODEL.NEXT_MODEL];
          this._compute_prediction_from_model(next_word, level, total_count);
        }
      }
    }
  }, {
    key: '_get_next_model',
    value: function _get_next_model(model_data, word_hash_key) {
      if (!word_hash_key) {
        return undefined;
      }
      var next_word_prediction = _.find(model_data, function (item) {
        return item.length > 1 && item[INDEX.MODEL.WORD_HASH] === word_hash_key;
      });
      if (next_word_prediction && next_word_prediction.length > INDEX.MODEL.NEXT_MODEL && Array.isArray(next_word_prediction)) {
        return next_word_prediction; // TODO may be needs a fix
      }
    }
  }, {
    key: '_get_word_index',
    value: function _get_word_index(level) {
      return this.parsed_input.words.length - level;
    }
  }, {
    key: '_is_my_level',
    value: function _is_my_level(level) {
      return level === 1;
    }
  }, {
    key: '_continueFn',
    value: function _continueFn() {
      return true;
    }
  }, {
    key: '_compute_next_words',
    value: function _compute_next_words(total_count) {
      var prediction_array = this._prediction_array;
      if (!(prediction_array && prediction_array.length > 0)) {
        return;
      }

      for (var i = 0; this.predictions.length < this.max_predictions && i < prediction_array.length && prediction_array[i].length > 1; i++) {
        if (!this._matches_partially(prediction_array[i])) {
          continue;
        }
        var predictions = this._create_predictions(prediction_array[i], total_count);
        this._compute_next_multi_words(predictions);
      }
    }
  }, {
    key: '_compute_next_multi_words',
    value: function _compute_next_multi_words(predictions) {
      var _this = this;

      _.each(predictions, function (prediction) {
        if (prediction !== undefined) {
          _this.predictions.push(prediction);
        }
      });
    }
  }, {
    key: '_get_word_hash',
    value: function _get_word_hash(model_item) {
      return this._loader.getMapHash(model_item[INDEX.MODEL.WORD_HASH]);
    }
  }, {
    key: '_matches_partially',
    value: function _matches_partially(prediction) {
      if (this.parsed_input.isWholeWord) {
        return true;
      }
      var word_hash = this._loader.getMapHash(prediction[INDEX.MODEL.WORD_HASH]);
      // TODO what if not a word hash ?
      if (!word_hash) {
        return false;
      }
      var word = word_hash[INDEX.MAP.WORD];
      return this.parsed_input.comparePartial(word);
    }
  }, {
    key: '_create_predictions',
    value: function _create_predictions(next_array, total_count) {
      var creator = new PredictonCreator({ loader: this._loader, model_item: next_array, total_count: total_count, parsed_input: this.parsed_input, continueFn: this._continueFn });
      return creator.getMultiPredictions(undefined, undefined, undefined, this._source);
    }
  }, {
    key: '_get_prediction_array',
    value: function _get_prediction_array() {
      // returns an array from which predictions are to be calculates
      if (this.parsed_input.isPrevious && this._word_model.length > 1) {
        return this._word_model[1];
      } else {
        return this._word_model[0];
      }
    }
  }, {
    key: '_loadInputModel',
    value: function _loadInputModel(word, callbackFn) {
      var nFileIndex = this._findFileIndex(word);
      this._loader.loadModel(nFileIndex, callbackFn);
    }
  }, {
    key: '_findFileIndex',
    value: function _findFileIndex(word) {
      return this._loader.getModelFileNo(word);
    }
  }, {
    key: 'max_predictions',
    set: function set(newValue) {
      this.max_predictions = newValue;
    },
    get: function get() {
      return this._max_predictions;
    }
  }]);

  return NGramPredictor;
}();

module.exports = NGramPredictor;

},{"../../../../lib/rh":25,"./consts":37,"./indices":42,"./prediction_creator":47,"./prediction_list":48}],46:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _utils = require('./utils');

var _utils2 = _interopRequireDefault(_utils);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Prediction = function () {
  function Prediction(term, probability, count, source) {
    _classCallCheck(this, Prediction);

    this.probability = probability;
    this.term = term;
    this.count = count;
    this.source = source;
  }

  _createClass(Prediction, [{
    key: 'merge',
    value: function merge(new_item) {
      this.probability += new_item.probability;
      this.count = Math.max(this.count, new_item.count);
    }
  }, {
    key: 'compare',
    value: function compare(other) {
      return other.probability - this.probability;
    }
  }, {
    key: 'match',
    value: function match(other) {
      return _utils2.default.compareNoCase(other.term, this.term) === 0;
    }
  }]);

  return Prediction;
}();

module.exports = Prediction;

},{"./utils":53}],47:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Prediction = require('./prediction');
var search_utils = require('./utils');
var INDEX = require('./indices');
var InputParser = require('./input_parser');
var search_consts = require('./consts');

var PredictonCreator = function () {
  function PredictonCreator(_ref) {
    var loader = _ref.loader,
        model_item = _ref.model_item,
        total_count = _ref.total_count,
        parsed_input = _ref.parsed_input,
        continueFn = _ref.continueFn;

    _classCallCheck(this, PredictonCreator);

    this._model_item = model_item;
    this.parsed_input = parsed_input || new InputParser("");
    this._init();
    this._total_count = total_count;
    this._continueFn = continueFn || this._isStopWord;
    this._nextModelFn = this._nextModel;
    this._predictions = [];
    this._multi_prediction = false;
    this._loader = loader;
  }

  _createClass(PredictonCreator, [{
    key: '_init',
    value: function _init() {
      this.term = "";
      this.probability = 1;
      this._first_word = true;
      this.isFirstLevel = false;
      this._level = 0;
    }
  }, {
    key: 'getPrediction',
    value: function getPrediction(word_hash, isFirstLevel, previous, source) {
      this.word_hash = word_hash;
      this.isFirstLevel = isFirstLevel;
      this.previous = previous;
      this.source = source;
      if (this.isFirstLevel) {
        this._appendPreviousPredictions(this._model_item);
      }
      this._appendPrediction(this._model_item, word_hash);
      return this._createPrediction();
    }
  }, {
    key: 'getMultiPredictions',
    value: function getMultiPredictions(word_hash, isFirstLevel, previous, source) {
      this._multi_prediction = true;
      this.word_hash = word_hash;
      this.isFirstLevel = isFirstLevel;
      this.previous = previous;
      this.source = source;
      if (this.isFirstLevel) {
        this._appendPreviousPredictions(this._model_item);
      }
      this._appendPrediction(this._model_item, word_hash);
      return this._predictions;
    }
  }, {
    key: 'equalRemaingWord',
    value: function equalRemaingWord(model_item) {
      var word = this._getword(model_item, this.word_hash);
      if (word) {
        if (this.parsed_input.equalRemaingWord(word)) {
          return true;
        }
      }
      return false;
    }
  }, {
    key: '_appendPreviousPredictions',
    value: function _appendPreviousPredictions(model_item) {
      var previous_item = this._getPreviousItem(model_item);
      if (!previous_item) {
        return;
      }
      var previous_probaility = this._getPreviousProbability(previous_item);
      if (previous_probaility > search_consts.minPreviousThreshold) {
        this._appendPreviousTerm(previous_item);
      }
    }
  }, {
    key: '_getPreviousItem',
    value: function _getPreviousItem(model_item) {
      var previous_items = search_utils.getFirstLevelNextModel(model_item, true);
      if (previous_items) {
        var previous_item = search_utils.getSafeElement(previous_items, 0);
        return previous_item;
      }
    }
  }, {
    key: '_appendPreviousTerm',
    value: function _appendPreviousTerm(model_item) {
      var word = this._getword(model_item);
      if (word) {
        if (this.parsed_input.equalLastWord(word)) {
          return;
        }
        this.term = this.parsed_input.replaceLastWord(word);
        this._first_word = false;
      }
    }
  }, {
    key: '_createPrediction',
    value: function _createPrediction() {
      if (this.term !== "") {
        var suggestion_text = this.parsed_input.completeSuggestion(this.term);
        return new Prediction(suggestion_text, this.probability, 1, this.source);
      }
    }
  }, {
    key: '_appendPrediction',
    value: function _appendPrediction(model_item) {
      this.probability = this.probability * this._calculateProbability(model_item);
      this._update_term(model_item);
      if (this._shouldCreatePrediction(model_item)) {
        this._predictions.push(this._createPrediction());
      }
      if (this._continueFn(model_item)) {
        var next_model = this._nextModel(model_item);
        this._total_count = this._getCount(model_item);
        this._level++;
        this._first_word = false;
        this.isFirstLevel = false;
        this.word_hash = undefined;
        if (next_model) {
          this._appendPrediction(next_model);
        }
      }
    }
  }, {
    key: '_getPreviousProbability',
    value: function _getPreviousProbability(previous_item) {
      var total_count = this._getCount(this.model_item);
      var count = search_utils.getCountfromModel(previous_item);
      return count / total_count;
    }
  }, {
    key: '_update_term',
    value: function _update_term(model_item) {
      if (this.parsed_input.isPrevious) {
        this.term = this._nextTerm(model_item) + this.term;
      } else {
        this.term = this.term + this._nextTerm(model_item);
      }
    }
  }, {
    key: '_getword',
    value: function _getword(model_item, word_hash) {
      word_hash = word_hash || this._get_word_hash(model_item);
      return search_utils.getSafeElement(word_hash, INDEX.MAP.WORD);
    }
  }, {
    key: '_get_word_hash',
    value: function _get_word_hash(model_item) {
      return this._loader.getMapHash(model_item[INDEX.MODEL.WORD_HASH]);
    }
  }, {
    key: '_nextModel',
    value: function _nextModel(model_item) {
      var next_model = void 0;
      if (this.isFirstLevel) {
        next_model = search_utils.getFirstLevelNextModel(model_item, this.previous);
      } else {
        next_model = search_utils.getNextModel(model_item);
      }
      if (next_model && next_model.length > 0) {
        return search_utils.getFirstPrediction(next_model);
      }
    }
  }, {
    key: '_nextTerm',
    value: function _nextTerm(model_item) {
      var word = this._getword(model_item, this.word_hash);
      if (word) {
        return this._first_word ? this.parsed_input.completeWord(word) : " " + word;
      }
      return "";
    }
  }, {
    key: '_calculateProbability',
    value: function _calculateProbability(model_item) {
      var count = this._getCount(model_item);
      return count / this._total_count;
    }
  }, {
    key: '_getCount',
    value: function _getCount(model_item) {
      if (this.word_hash) {
        return search_utils.getCountfromWordHash(this.word_hash);
      } else {
        return search_utils.getCountfromModel(model_item);
      }
    }
  }, {
    key: '_shouldCreatePrediction',
    value: function _shouldCreatePrediction(model_item) {

      return this._multi_prediction && !this._isStopWord(model_item) && !this.equalRemaingWord(model_item);
    }
  }, {
    key: '_isStopWord',
    value: function _isStopWord(model_item) {
      var word = this._getword(model_item, this.word_hash);
      if (!word) {
        return false;
      }
      return this._loader.isStopWord(word);
    }
  }]);

  return PredictonCreator;
}();

module.exports = PredictonCreator;

},{"./consts":37,"./indices":42,"./input_parser":43,"./prediction":46,"./utils":53}],48:[function(require,module,exports){
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var PredictionList = function () {
  function PredictionList(list, parsed_input) {
    _classCallCheck(this, PredictionList);

    this.parsed_input = parsed_input;
    this._list = list || [];
  }

  _createClass(PredictionList, [{
    key: "isForInput",
    value: function isForInput(input, previous_input) {
      if (this.parsed_input.isPrevious) {
        return previous_input !== undefined && this.parsed_input.original_text === previous_input.original_text;
      } else {
        return this.parsed_input.original_text === input.original_text;
      }
    }
  }, {
    key: "isEmpty",
    value: function isEmpty() {
      return this._list.length === 0;
    }
  }, {
    key: "predictions",
    get: function get() {
      return this._list;
    }
  }]);

  return PredictionList;
}();

module.exports = PredictionList;

},{}],49:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Loader = require('./loader');
var rh = require("../../../../lib/rh");
var _ = rh._;
var HistoryPredictor = require('./history_predictor');
var NgramPredictor = require('./ngram_predictor');
var GeneralPredictor = require('./general_predictor');
var Corrector = require('./corrector');
var search_consts = require('./consts');

//this.processResult.bind(this)

var PredictorsCreator = function () {
  function PredictorsCreator(history_reader, processResultFn) {
    _classCallCheck(this, PredictorsCreator);

    this._history_reader = history_reader;
    this._processResultFn = processResultFn;
  }

  _createClass(PredictorsCreator, [{
    key: '_createLoaders',
    value: function _createLoaders() {
      return _.map(this.projectPaths, function (path) {
        return new Loader(path);
      });
    }
  }, {
    key: 'createPredictors',
    value: function createPredictors(addFn, prevAddFn, addCorrectorFn) {
      var _this = this;

      this._addFn = addFn;
      this._prevaddFn = prevAddFn;
      this._addCorrectorFn = addCorrectorFn;
      var history_predictor = new HistoryPredictor(this._history_reader, this._processResultFn);
      this._addFn(history_predictor);

      var loaders = this._createLoaders();
      _.each(loaders, function (loader) {
        loader.init(_this.addPredictors.bind(_this));
      });
    }
  }, {
    key: 'addPredictors',
    value: function addPredictors(loader) {
      for (var i = 1; i <= loader.nGram; i++) {

        var ngp = new NgramPredictor({ loader: loader, level: i, callback: this._processResultFn });
        ngp.init();
        this._addFn(ngp);
      }
      for (var _i = 1; _i <= search_consts.previousnGram; _i++) {
        var _ngp = new NgramPredictor({ loader: loader, level: _i, callback: this._processResultFn, previous: true });
        _ngp.init();
        this._prevaddFn(_ngp);
      }

      var general_predictor = new GeneralPredictor(this._processResultFn, loader);
      this._addFn(general_predictor);

      var corrector = new Corrector(loader, this._processResultFn);
      this._addCorrectorFn(corrector);
    }
  }, {
    key: 'projectPaths',
    get: function get() {
      return rh.model.get(rh.consts('KEY_PROJECT_LIST'));
    }
  }]);

  return PredictorsCreator;
}();

module.exports = PredictorsCreator;

},{"../../../../lib/rh":25,"./consts":37,"./corrector":38,"./general_predictor":39,"./history_predictor":40,"./loader":44,"./ngram_predictor":45}],50:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var rh = require("../../../../lib/rh");
var _ = rh._;
var consts = rh.consts;
var history_reader = require('./history_reader');
var InputParser = require('./input_parser');
var PredictonMerger = require('../common/merger');
var TopicCounter = require('./topic_counter');
var search_utils = require('./utils');
var search_consts = require('./consts');
var Seamaphore = require('./../../../common/counting_seamaphore');
var PredictorCreator = require('./predictors_creator');
var SearchHandler = require('../topic/handler');

var max_predictions = 5;

var SearchController = function () {
  function SearchController(widget) {
    var _this = this;

    _classCallCheck(this, SearchController);

    this.widget = widget;
    this._predictors = [];
    this._correctors = [];
    this._previous_predictors = [];
    this.initHandleKeyHash();
    this.max_predictions = max_predictions;
    this.predicton_merger = new PredictonMerger([]);
    widget.model.subscribe(consts('KEY_PROJECT_LIST'), function () {
      _this.init();
    });
  }

  _createClass(SearchController, [{
    key: 'init',
    value: function init() {
      var history_list = rh.storage.fetch(consts('PREV_SEARCH_KEY'));
      history_reader.initHistory(history_list);
      this.create_predictors();
      this.widget.model.csubscribe('EVT_CLOSE_SEARCH_SUGGESTION', this.closeSuggestions.bind(this));
      if (!rh.model.get(rh.consts('KEY_CLASSIC_OUTPUT'))) {
        this.search_handler = new SearchHandler(this.widget);
        this.widget.model.csubscribe('EVT_SEARCH_TERM', this.search.bind(this));
        this.widget.model.csubscribe('EVT_QUERY_SEARCH_RESULTS', this.search.bind(this));
      }
    }
  }, {
    key: 'search',
    value: function search() {
      if (!rh.rhs.doSearch()) {
        var text = this.widget.get(consts('KEY_SEARCH_TERM'));
        this.search_handler.showSearchResults(text);
      }
    }
  }, {
    key: 'create_predictors',
    value: function create_predictors() {
      this._predictors = [];
      var predictor_creator = new PredictorCreator(history_reader, this.processResult.bind(this));
      predictor_creator.createPredictors(this.addPredictor.bind(this), this.addPrevPredictor.bind(this), this.addCorrector.bind(this));
    }
  }, {
    key: 'addPredictor',
    value: function addPredictor(predictor) {
      this._predictors.push(predictor);
    }
  }, {
    key: 'addPrevPredictor',
    value: function addPrevPredictor(predictor) {
      this._previous_predictors.push(predictor);
    }
  }, {
    key: 'addCorrector',
    value: function addCorrector(corrector) {
      this._correctors.push(corrector);
    }
  }, {
    key: 'showSuggestions',
    value: function showSuggestions(keyEvt) {
      this._initSuggestions(keyEvt);
      this._calculateSugguestions();
    }
  }, {
    key: '_initSuggestions',
    value: function _initSuggestions(keyEvt) {
      this._initResult();
      this._initInputs(keyEvt);
      this._resutSeamaphore = new Seamaphore(this.onResultComplete.bind(this));
    }
  }, {
    key: '_initInputs',
    value: function _initInputs(keyEvt) {
      this.parsed_input = new InputParser(keyEvt.text, false, keyEvt.selStart, false);
      if (search_utils.isPrevious(keyEvt)) {
        this._previous_input = new InputParser(keyEvt.text, false, keyEvt.selStart, true);
      }
    }
  }, {
    key: '_calculateSugguestions',
    value: function _calculateSugguestions() {
      var _this2 = this;

      this._resutSeamaphore.wait(this._predictorCount());
      _.each(this._predictors, function (predictor) {
        predictor.getPredictions(_this2.parsed_input);
      });
      if (this._previous_input) {
        _.each(this._previous_predictors, function (predictor) {
          predictor.getPredictions(_this2._previous_input);
        });
      }
    }
  }, {
    key: '_clearPredictors',
    value: function _clearPredictors() {
      _.each(this._predictors, function (predictor) {
        predictor.clear();
      });
      _.each(this._previous_predictors, function (predictor) {
        predictor.clear();
      });
      _.each(this._correctors, function (corrector) {
        corrector.clear();
      });
    }
  }, {
    key: '_predictorCount',
    value: function _predictorCount() {
      var count = this._predictors.length;
      if (this._previous_input) {
        count += this._previous_predictors.length;
      }
      return count;
    }
  }, {
    key: '_initResult',
    value: function _initResult() {
      if (this.predicton_merger) {
        this.predicton_merger.clear();
      }
      this.widget.publish("selected", undefined);
      this._previous_input = undefined;
      this._computing_correction = false;
    }
  }, {
    key: '_clearResult',
    value: function _clearResult() {
      this._resetMovement();
      this._previous_input = undefined;
      this.parsed_input = undefined;
      this._resutSeamaphore = undefined;
      this._clearPredictors();
    }
  }, {
    key: 'isSuggestionsOpen',
    value: function isSuggestionsOpen() {
      var predictions = this.widget.get(consts("SEARCH_RESULTS_KEY"));
      return predictions && predictions.length > 0;
    }
  }, {
    key: 'processResult',
    value: function processResult(predictionList, loader) {
      if (!predictionList.isForInput(this.parsed_input, this._previous_input)) {
        return;
      }
      if (!predictionList.isEmpty()) {
        this.predicton_merger.merge(predictionList.predictions);
        var counter = new TopicCounter(loader);
        this.predictions = counter.computeCounts(this.predictions, this.parsed_input);
      }
      this._resutSeamaphore.signal();
    }
  }, {
    key: 'onResultComplete',
    value: function onResultComplete() {
      if (this.needCorrection()) {
        this.doCorrection();
      } else {
        this.predictions.splice(this.max_predictions);
        this.widget.publish(consts("SEARCH_RESULTS_KEY"), this.predictions);
        this._clearResult();
      }
    }
  }, {
    key: 'needCorrection',
    value: function needCorrection() {
      return !this._computing_correction && this.predictions.length === 0 && this.parsed_input.trimmedText !== "";
    }
  }, {
    key: 'doCorrection',
    value: function doCorrection() {
      var _this3 = this;

      this._computing_correction = true;
      this._resutSeamaphore = new Seamaphore(this.onResultComplete.bind(this));
      this._resutSeamaphore.wait(this._correctors.length);
      _.each(this._correctors, function (corrector) {
        corrector.getCorrections(_this3.parsed_input);
      });
    }
  }, {
    key: 'canDelete',
    value: function canDelete(id) {
      var prediction = this.predictions[id];
      if (prediction === undefined) {
        return false;
      }
      return prediction.source === search_consts.PREDICTOR_SOURCE_ID.HISTORY_PREDICTOR;
    }
  }, {
    key: 'handleDelete',
    value: function handleDelete(id) {
      var prediction = this.predictions[id];
      this._deleteFromHistory(prediction.term);
      this._removePrediction(id);
      this.widget.publish("history_deleted", true);
    }
  }, {
    key: '_removePrediction',
    value: function _removePrediction(id) {
      this.predictions.splice(id, 1);
      this.widget.publish(consts("SEARCH_RESULTS_KEY"), this.predictions);
    }
  }, {
    key: 'handleClick',
    value: function handleClick(id) {
      var history_deleted = this.widget.get("history_deleted");
      if (history_deleted) {
        return;
      }
      var prediction = this.predictions[id];
      if (prediction === undefined) {
        return;
      }

      var new_text = prediction.term;
      this.triggerSearch(new_text);
    }
  }, {
    key: 'triggerSearch',
    value: function triggerSearch(term) {
      this._addToHistory(term);
      this.closeSuggestions();
      this.widget.publish(consts('KEY_SEARCH_TERM'), term);
      this.widget.publish(rh.consts('EVT_SEARCH_TERM'), true);
    }
  }, {
    key: 'handleFocusOut',
    value: function handleFocusOut(key, focus_key) {
      var history_deleted = this.widget.get("history_deleted");
      if (!history_deleted) {
        this.widget.publish(key, false);
      } else {
        this.widget.publish("history_deleted", false);
        this.widget.publish(focus_key, true);
      }
    }
  }, {
    key: 'getFirstSuggestionIndex',
    value: function getFirstSuggestionIndex(length, down) {
      return down ? 0 : length - 1;
    }
  }, {
    key: 'getNextSuggestionIndex',
    value: function getNextSuggestionIndex(curr_selected, length, down) {
      var move = down ? 1 : length - 1;
      curr_selected = curr_selected === undefined ? 0 : curr_selected;
      curr_selected = (curr_selected + move) % length;
      return curr_selected;
    }
  }, {
    key: 'handleArrowKey',
    value: function handleArrowKey(keyEvt) {
      var curr_selected = this.widget.get("selected");
      var down = keyEvt.keyCode === 40;
      var length = this.getPredictionsLength();
      if (length > 0) {
        if (curr_selected === undefined) {
          curr_selected = this.getFirstSuggestionIndex(length, down);
        } else {
          curr_selected = this.getNextSuggestionIndex(curr_selected, length, down);
        }
        this.widget.publish("selected", curr_selected);
        var new_text = this.getNewInputText(this.results[curr_selected]);
        this.widget.publish(consts('KEY_SEARCH_TERM'), new_text);
      }
    }
  }, {
    key: 'getNewInputText',
    value: function getNewInputText(prediction) {
      return prediction.term;
    }
  }, {
    key: 'getPredictionsLength',
    value: function getPredictionsLength() {
      var length = void 0;
      this.results = this.widget.get(consts("SEARCH_RESULTS_KEY"));
      if (this.results) {
        length = this.results.length;
      }
      return length;
    }
  }, {
    key: 'closeSuggestions',
    value: function closeSuggestions() {
      this._clearResult();
      this.widget.publish("selected", undefined);
      this.original_parsed_input = undefined;
      this.widget.publish(consts("SEARCH_RESULTS_KEY"), []);
    }
  }, {
    key: '_deleteFromHistory',
    value: function _deleteFromHistory(text) {
      history_reader.delete(text);
      this._saveHistory();
    }
  }, {
    key: '_addToHistory',
    value: function _addToHistory(text) {
      if (text && text !== "") {
        history_reader.add({
          text: text.trim(),
          count: 10
        }); // TODO change
        this._saveHistory();
      }
    }
  }, {
    key: '_saveHistory',
    value: function _saveHistory() {
      rh.storage.persist(consts('PREV_SEARCH_KEY'), history_reader.getHistory());
    }
  }, {
    key: 'handleDefault',
    value: function handleDefault(keyEvt) {
      if (keyEvt.text === "") {
        this.closeSuggestions();
      } else {
        var substr = (keyEvt.text || '').substr(0, keyEvt.selStart);
        keyEvt.text = substr;
        this.showSuggestions(keyEvt);
      }
    }
  }, {
    key: 'handleShowSuggestion',
    value: function handleShowSuggestion(keyEvt) {
      if (keyEvt.text === "" || search_utils.shouldShowSuggestion(keyEvt) === false) {
        this.closeSuggestions();
      } else {
        this.showSuggestions(keyEvt);
      }
    }
  }, {
    key: 'handleReturn',
    value: function handleReturn(keyEvt) {
      this.triggerSearch(keyEvt.text);
    }
  }, {
    key: '_isMovementKey',
    value: function _isMovementKey(keyCode) {
      return [38, 39, 40].indexOf(keyCode) >= 0;
    }
  }, {
    key: '_resetMovement',
    value: function _resetMovement() {
      this.original_parsed_input = undefined;
      this.widget.publish("selected", undefined);
    }
  }, {
    key: '_isHandlingCursorMove',
    value: function _isHandlingCursorMove() {
      var curr_selected = this.widget.get("selected");
      return curr_selected !== undefined;
    }
  }, {
    key: 'initHandleKeyHash',
    value: function initHandleKeyHash() {
      this.handle_key_hash = {
        up: this.handleArrowKey.bind(this),
        down: this.handleArrowKey.bind(this),
        backspace: this.handleBackSpace.bind(this),
        return: this.handleReturn.bind(this),
        default: this.handleDefault.bind(this),
        escape: this.handleEscape.bind(this),
        right: this.handleRight.bind(this)
      };
    }
  }, {
    key: 'handleRight',
    value: function handleRight(keyEvt) {
      if (!this._isHandlingCursorMove()) {
        this._resetMovement();
        return this.handleShowSuggestion(keyEvt);
      }
      if (search_utils.shouldAppendSpace(keyEvt)) {
        keyEvt.text += " ";
        keyEvt.selStart += 1;
        this.widget.publish(consts('KEY_SEARCH_TERM'), keyEvt.text);
      }
      this._resetMovement();
      this.handleShowSuggestion(keyEvt);
      return false;
    }
  }, {
    key: 'handleBackSpace',
    value: function handleBackSpace(keyEvt) {
      return this.handleShowSuggestion(keyEvt);
    }
  }, {
    key: 'handleEscape',
    value: function handleEscape() {
      this.closeSuggestions();
    }
  }, {
    key: 'handleKey',
    value: function handleKey(event) {

      var keyCode = event.keyCode;
      var keyEvt = {
        keyCode: keyCode,
        selStart: event.target.selectionStart,
        text: event.target.value
      };
      if (!this._isMovementKey(keyCode)) {
        this._resetMovement();
      }
      var index = _.getKeyIndex(keyCode);

      if (index === undefined) {
        return true;
      }
      var handleFn = this.handle_key_hash[index];
      if (handleFn) {
        return handleFn(keyEvt);
      }
    }
  }, {
    key: 'predictions',
    get: function get() {
      return this.predicton_merger.items;
    },
    set: function set(predictions) {
      this.predicton_merger = new PredictonMerger(predictions);
    }
  }]);

  return SearchController;
}();

rh.controller('SearchController', SearchController);

},{"../../../../lib/rh":25,"../common/merger":34,"../topic/handler":54,"./../../../common/counting_seamaphore":26,"./consts":37,"./history_reader":41,"./input_parser":43,"./predictors_creator":49,"./topic_counter":52,"./utils":53}],51:[function(require,module,exports){
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var SortedSet = function () {
  function SortedSet(set) {
    _classCallCheck(this, SortedSet);

    this._set = set || [];
    this._initialised = false;
  }

  _createClass(SortedSet, [{
    key: "intersect",
    value: function intersect(other) {
      if (!Array.isArray(other)) {
        other = other.set;
      }
      var new_set = [];
      var count = 0;
      var i = 0;var j = 0;
      for (; i < this._set.length && j < other.length;) {
        if (this._set[i] < other[j]) {
          i++;
        } else if (this._set[i] > other[j]) {
          j++;
        } else {
          new_set[count++] = this._set[i];
          i++;j++;
        }
      }
      this._set = new_set;
    }
  }, {
    key: "intersectOrSet",
    value: function intersectOrSet(other) {
      if (this._initialised) {
        this.intersect(other);
      } else {
        if (!Array.isArray(other)) {
          other = other.set;
        }
        this.set = other;
        this._initialised = true;
      }
    }
  }, {
    key: "intersectCount",
    value: function intersectCount(other) {
      if (!Array.isArray(other)) {
        other = other.set;
      }
      var count = 0;
      var i = 0;
      var j = 0;
      for (; i < this._set.length && j < other.length;) {
        if (this._set[i] < other[j]) {
          i++;
        } else if (this._set[i] > other[j]) {
          j++;
        } else {
          count++;
          i++;j++;
        }
      }
      return count;
    }
  }, {
    key: "set",
    set: function set(_set) {
      this._set = _set || [];
    },
    get: function get() {
      return this._set;
    }
  }, {
    key: "length",
    get: function get() {
      return this._set.length;
    }
  }]);

  return SortedSet;
}();

module.exports = SortedSet;

},{}],52:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var SortedSet = require('./sorted_set');
var Parser = require('./input_parser');
var Prediction = require('./prediction');
var rh = require("../../../../lib/rh");
var _ = rh._;
var INDEX = require("./indices");

var TopicCounter = function () {
  function TopicCounter(loader) {
    _classCallCheck(this, TopicCounter);

    this.newPredictions = [];
    this.predictionSet = new SortedSet();
    this.inputSet = new SortedSet();
    this._loader = loader;
  }

  _createClass(TopicCounter, [{
    key: 'computeCounts',
    value: function computeCounts(predictions, parsed_input) {
      var _this = this;

      this.newPrediction = [];
      this.parsed_input = parsed_input;
      _.each(predictions, function (prediction) {
        _this.addUpdatedPrediction(prediction);
      });
      return this.newPredictions;
    }
  }, {
    key: 'addUpdatedPrediction',
    value: function addUpdatedPrediction(prediction) {
      var count = 1;
      if (this._loader !== undefined) {
        this.createPredictionSet(prediction);
        count = this.computeTopicCount();
      }
      if (count > 0) {
        var newPrdiction = new Prediction(prediction.term, prediction.probability, count, prediction.source);
        this.newPredictions.push(newPrdiction);
      }
    }
  }, {
    key: 'computeTopicCount',
    value: function computeTopicCount() {
      return this.predictionSet.set.length;
    }
  }, {
    key: 'createPredictionSet',
    value: function createPredictionSet(prediction) {
      var _this2 = this;

      this.predictionSet = new SortedSet();
      var parsed_prediction = new Parser(prediction.term, true);
      _.each(parsed_prediction.words, function (word, index) {
        _this2._addWordToSet(word, _this2.predictionSet, index);
      });
    }
  }, {
    key: 'initInput',
    value: function initInput(parsed_input) {
      var _this3 = this;

      this.inputSet = new SortedSet();
      _.each(parsed_input.words, function (word) {
        _this3._addWordToSet(word, _this3.inputSet);
      });
    }
  }, {
    key: '_addWordToSet',
    value: function _addWordToSet(word, set) {
      if (this._loader.isStopWord(word)) {
        return;
      }
      var wordHash = this._loader._getHashForWord(word);
      if (wordHash && wordHash.length > INDEX.MAP.TOPICS) {
        set.intersectOrSet(wordHash[INDEX.MAP.TOPICS]);
      }
    }
  }]);

  return TopicCounter;
}();

module.exports = TopicCounter;

},{"../../../../lib/rh":25,"./indices":42,"./input_parser":43,"./prediction":46,"./sorted_set":51}],53:[function(require,module,exports){
(function (global){
'use strict';

var INDEX = require('./indices');

var _exports = {
  getNextModel: function getNextModel(model_item) {

    if (model_item && Array.isArray(model_item) && model_item.length > INDEX.MODEL.NEXT_MODEL) {
      return model_item[INDEX.MODEL.NEXT_MODEL];
    }
  },
  getFirstLevelNextModel: function getFirstLevelNextModel(model_item, bprevious) {
    if (model_item && Array.isArray(model_item)) {
      if (!bprevious && model_item.length > INDEX.FIRST_PREDICTION.NEXT) {
        return model_item[INDEX.FIRST_PREDICTION.NEXT];
      }
      if (bprevious && model_item.length > INDEX.FIRST_PREDICTION.PREVIOUS) {
        return model_item[INDEX.FIRST_PREDICTION.PREVIOUS];
      }
    }
  },

  getFirstPrediction: function getFirstPrediction(model_item) {
    if (model_item && Array.isArray(model_item) && model_item.length > 0 && Array.isArray(model_item[0])) {
      return model_item[0];
    }
  },
  compareNoCase: function compareNoCase(word1, word2) {
    if (global.compare !== undefined) {
      return global.compare(word1, word2);
    } else {
      return word1 === word2 ? 0 : -1;
    }
  },
  hammingDistance: function hammingDistance(word1, word2) {
    var minLength = Math.min(word1.length, word2.length);
    var hammingDistance = 0;
    for (var i = 0; i < minLength; i++) {
      if (word1[i] !== word2[i]) {
        hammingDistance++;
      }
    }
    if (word1.length > minLength) {
      hammingDistance += word1.length - minLength;
    }
    return hammingDistance;
  },
  isPrevious: function isPrevious(keyEvt) {
    return keyEvt.selStart < keyEvt.text.length;
  },
  shouldShowSuggestion: function shouldShowSuggestion(keyEvt) {
    var text = keyEvt.text;
    var selStart = keyEvt.selStart;
    if (selStart === 0 || selStart === text.length) {
      return true;
    }
    if (text.length > 0) {
      // if cursor is before the end
      return text[selStart] === ' ' || text[selStart - 1] === ' ';
    }
    return false;
  },
  shouldAppendSpace: function shouldAppendSpace(keyEvt) {
    var text = keyEvt.text;
    var selStart = keyEvt.selStart;
    if (text.length > 0 && selStart === text.length) {
      //cusror at last
      return text[text.length - 1] !== " ";
    }
    return false;
  },
  getSafeElement: function getSafeElement(arr, index) {
    if (arr && Array.isArray(arr) && arr.length > index) {
      return arr[index];
    }
  },
  getCountfromModel: function getCountfromModel(model_item) {
    if (Array.isArray(model_item) && model_item.length > INDEX.MODEL.COUNT) {
      return model_item[INDEX.MODEL.COUNT];
    }
    return 0;
  },
  getCountfromWordHash: function getCountfromWordHash(word_hash) {
    if (Array.isArray(word_hash) && word_hash.length > INDEX.MAP.COUNT) {
      return word_hash[INDEX.MAP.COUNT];
    }
    return 0;
  }
};

module.exports = _exports;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./indices":42}],54:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var QueryProcessor = require('./query/processor');
var rh = require("../../../../lib/rh");
var _ = rh._;
var consts = rh.consts;
var Loader = require('./query/loader');
var ResultMerger = require('../common/merger');
var Seamaphore = require('../../../common/counting_seamaphore');
var SearchResult = require('./result');
var $ = rh.$;
module.exports = function () {
  function SearchHandler(widget) {
    var _this = this;

    var max_results = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 20;

    _classCallCheck(this, SearchHandler);

    this.widget = widget;
    this.initDone = false;
    this.max_results = max_results;
    this.queryProcessors = [];
    this.merger = new ResultMerger([]);
    this._resutSeamaphore = new Seamaphore(this.onResultComplete.bind(this));
    this.widget.model.subscribe(consts('KEY_PROJECT_LIST'), function () {
      _this.init();
    });
  }

  _createClass(SearchHandler, [{
    key: 'init',
    value: function init() {
      var _this2 = this;

      if (!this.initDone) {
        var loaders = this._createLoaders();
        _.each(loaders, function (loader, id) {
          loader.init(id, _this2.addProcessors.bind(_this2));
        });
        this.initDone = true;
        if (this.pendingText) {
          this.showSearchResults(this.pendingText);
          this.pendingText = null;
        }
      }
    }
  }, {
    key: 'addProcessors',
    value: function addProcessors(loader) {
      this.queryProcessors.push(new QueryProcessor(loader));
    }
  }, {
    key: '_createLoaders',
    value: function _createLoaders() {
      return _.map(this.projectPaths, function (path) {
        return new Loader(path);
      });
    }
  }, {
    key: 'showSearchResults',
    value: function showSearchResults(text) {
      var _this3 = this;

      if (!this.initDone) {
        this.pendingText = text;
        return;
      }
      var isNewQuery = _.find(this.queryProcessors, function (processor) {
        return processor.isNewQuery(text, _this3.searchOpts(processor.getPath()));
      });
      if (isNewQuery) {
        this.merger = new ResultMerger([]);
        this._resutSeamaphore = new Seamaphore(this.onResultComplete.bind(this));
        this._resutSeamaphore.wait(this.processorCount);
        //rh.model.publish(rh.consts('EVT_SEARCH_IN_PROGRESS'), true, {sync: true});
        //rh.model.publish(rh.consts('KEY_SEARCH_PROGRESS'), 0, {sync: true});
        _.each(this.queryProcessors, function (processor) {
          processor.search(text, _this3.searchOpts(processor.getPath()), _this3.topicCallback.bind(_this3), _this3.onSearchResults.bind(_this3));
        });
      }
    }
  }, {
    key: 'onSearchResults',
    value: function onSearchResults(text, searchResult, glossary_results) {
      this.processTopicsResults(text, searchResult);
      this.processGlossaryResults(text, glossary_results);
      this._resutSeamaphore.signal();
    }
  }, {
    key: 'onResultComplete',
    value: function onResultComplete() {
      this.widget.publish(rh.consts('EVT_SEARCH_IN_PROGRESS'), false, {
        sync: true
      });
      var searchTerm = this.widget.get(consts('KEY_SEARCH_TERM'));
      var searchTermMap = _defineProperty({}, consts('HASH_KEY_RH_SEARCH'), searchTerm);
      var resultsParams = _.mapToEncodedString(searchTermMap);
      this.widget.publish(consts('KEY_SEARCH_RESULT_PARAMS'), resultsParams);
      this.widget.publish('.p.searchresults', this.merger.items);
      if (window._textToHtml_nonbsp) {
        this.showSearchMsg(this.merger.items.length, window._textToHtml_nonbsp(searchTerm));
      }
      if (rh.model.get(consts('KEY_SHOW_CONTEXT')) === false) {
        this.hideContexts();
      }
    }
  }, {
    key: 'showSearchMsg',
    value: function showSearchMsg(a, b) {
      var c = rh.model.get(rh.consts("KEY_LNG"));
      c = c.ResultsFoundText || "%1 result(s) found for %2";
      c = c.replace("%1", a);
      c = c.replace("%2", "'" + b + "'");
      this.displayMsg(c);
    }
  }, {
    key: 'displayMsg',
    value: function displayMsg(a) {
      var b = document.getElementById("searchMsg");
      if (b) {
        b.innerHTML = a;
      }
    }
  }, {
    key: 'hideContexts',
    value: function hideContexts() {
      var srchCtxts = document.getElementsByClassName("wSearchContext");
      _.defer(function () {
        _.each(srchCtxts, function (ctxtNode) {
          $.addClass(ctxtNode, 'rh-hide');
        });
      });
    }
  }, {
    key: 'searchOpts',
    value: function searchOpts(path) {
      return {
        andSearch: rh.model.get(rh.consts('KEY_AND_SEARCH')) === '1',
        cbt: rh.model.cget('KEY_TAG_EXPRESSION'),
        origin: path
      };
    }
  }, {
    key: 'topicCallback',
    value: function topicCallback(id, summary, url) {
      this.widget.publish('.p.searchsummary' + id, summary);
      this.widget.publish('.p.searchurl' + id, url);
    }
  }, {
    key: 'processGlossaryResults',
    value: function processGlossaryResults(text, glossary_result) {
      var term = glossary_result && Object.keys(glossary_result)[0];
      this.widget.publish(consts('KEY_GLOSSARY_RESULT_TERM'), term);
      this.widget.publish(consts('KEY_GLOSSARY_RESULT'), glossary_result[term]);
    }
  }, {
    key: 'processTopicsResults',
    value: function processTopicsResults(text, topicResults) {
      this.text = text;
      var processedResult = _.map(topicResults, function (result) {
        return new SearchResult(result);
      });
      this.merger.merge(processedResult);
    }
  }, {
    key: 'projectPaths',
    get: function get() {
      return rh.model.get(rh.consts('KEY_PROJECT_LIST'));
    }
  }, {
    key: 'processorCount',
    get: function get() {
      return this.queryProcessors.length;
    }
  }]);

  return SearchHandler;
}();

},{"../../../../lib/rh":25,"../../../common/counting_seamaphore":26,"../common/merger":34,"./query/loader":59,"./query/processor":60,"./result":63}],55:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/*************************************************************************
* ADOBE CONFIDENTIAL
* ___________________
*
* Copyright 2018 Adobe
* All Rights Reserved.
*
* NOTICE: All information contained herein is, and remains
* the property of Adobe and its suppliers, if any. The intellectual
* and technical concepts contained herein are proprietary to Adobe
* and its suppliers and are protected by all applicable intellectual
* property laws, including trade secret and copyright laws.
* Dissemination of this information or reproduction of this material
* is strictly forbidden unless prior written permission is obtained
* from Adobe.
**************************************************************************/
var rh = require("../../../../lib/rh");
var _ = rh._;
var consts = rh.consts;

module.exports = function () {
  function SearchLanguage(code, loader, cb) {
    _classCallCheck(this, SearchLanguage);

    this.cb = cb;
    this.pipeLineFn = {};
    this.code = this._extractCode(code);
    this.useLang = this._useLang();
    this.loader = loader;
  }

  _createClass(SearchLanguage, [{
    key: 'setLanguage',
    value: function setLanguage(lunr) {
      var _this = this;

      if (this.useLang) {
        _.loadScript(this.loader.getUrl(consts('SEARCH_STEMMER_SUPPORT')), true, function () {
          var stemmer = _.exports();
          stemmer(lunr);
          if (_this.code === 'jp') {
            _.loadScript(_this.loader.getUrl(consts('SEARCH_TINY_SEGMENTER')), true, function () {
              var segmenter = _.exports();
              segmenter(lunr);
              _.loadScript(_this.loader.getUrl(consts('SEARCH_LNG_SUPPORT')), true, function () {
                var lngHandler = _.exports();
                lngHandler(lunr);
                return _this.cb && _this.cb(lunr);
              });
            });
          } else {
            _.loadScript(_this.loader.getUrl(consts('SEARCH_LNG_SUPPORT')), true, function () {
              var lngHandler = _.exports();
              lngHandler(lunr);
              return _this.cb && _this.cb(lunr);
            });
          }
        });
      } else {
        this.setTokenizer(lunr);
        return this.cb && this.cb(lunr);
      }
      //this.initFns(lunr)
    }
  }, {
    key: 'replaceFn',
    value: function replaceFn(db, lunr) {
      if (this.useLang) {
        db.pipeline.before(lunr.stemmer, lunr[this.code].stemmer);
        db.pipeline.remove(lunr.stemmer);
        if (lunr[this.code] && lunr[this.code].tokenizer) {
          lunr.tokenizer = lunr[this.code].tokenizer;
        }
      }
    }
  }, {
    key: 'setTokenizer',
    value: function setTokenizer(lunr) {
      lunr.tokenizer.separator = /[\s\.\-\'\,\n;\:\\\/\"]+/;
    }
  }, {
    key: 'initFns',
    value: function initFns(lunr) {
      var _this2 = this;

      var lunrLocalized = this.useLang ? lunr[this.code] : lunr;
      var functions = this.useLang ? this.fn[this.code] || this.fn.en : this.fn.en;
      _.each(functions, function (fnName, fieldName) {
        if (_this2.code !== 'jp') {
          lunr.Pipeline.registerFunction(lunrLocalized[fnName], fieldName);
        }
        _this2.pipeLineFn[fieldName] = lunrLocalized[fnName];
      });
    }
  }, {
    key: 'initIndexing',
    value: function initIndexing(node, lunr) {
      if (this.useLang) {
        node.use(lunr[this.code]);
      }
    }
  }, {
    key: '_useLang',
    value: function _useLang() {
      return this.code && ['en'].indexOf(this.code) === -1 && this.codes.indexOf(this.code) !== -1;
    }
  }, {
    key: '_extractCode',
    value: function _extractCode(code) {
      if (code) {
        var id = code.indexOf('_');
        var lngCode = code.substring(0, id).toLowerCase();
        if (lngCode === 'ja') {
          lngCode = 'jp';
        }
        return lngCode;
      }
    }
  }, {
    key: 'stemmer',
    get: function get() {
      return this.pipeLineFn.stemmer;
    }
  }, {
    key: 'stopWordFilter',
    get: function get() {
      return this.pipeLineFn.stopWordFilter;
    }
  }, {
    key: 'tokenizer',
    get: function get() {
      return this.pipeLineFn.tokenizer;
    }
  }, {
    key: 'codes',
    get: function get() {
      return ["da", "de", "du", "es", "fi", "fr", "hu", "it", "ja", "jp", "no", "pt", "ro", "ru", "sv",
      //"th",
      "tr"];
    }
  }, {
    key: 'fn',
    get: function get() {
      return {
        "da": {
          tokenizer: "trimmer", stopWordFilter: "stopWordFilter", stemmer: "stemmer"
        },
        "de": {
          tokenizer: "trimmer", stopWordFilter: "stopWordFilter", stemmer: "stemmer"
        },
        "du": {
          tokenizer: "trimmer", stopWordFilter: "stopWordFilter", stemmer: "stemmer"
        },
        "en": {
          tokenizer: "tokenizer", stopWordFilter: "stopWordFilter", stemmer: "stemmer"
        },
        "es": {
          tokenizer: "trimmer", stopWordFilter: "stopWordFilter", stemmer: "stemmer"
        },
        "fi": {
          tokenizer: "trimmer", stopWordFilter: "stopWordFilter", stemmer: "stemmer"
        },
        "fr": {
          tokenizer: "trimmer", stopWordFilter: "stopWordFilter", stemmer: "stemmer"
        },
        "it": {
          tokenizer: "trimmer", stopWordFilter: "stopWordFilter", stemmer: "stemmer"
        },
        "ja": {
          tokenizer: "trimmer", stopWordFilter: "stopWordFilter", stemmer: "stemmer"
        },
        "jp": {
          tokenizer: "tokenizer", stopWordFilter: "stopWordFilter", stemmer: "stemmer"
        },
        "no": {
          tokenizer: "trimmer", stopWordFilter: "stopWordFilter", stemmer: "stemmer"
        },
        "pt": {
          tokenizer: "trimmer", stopWordFilter: "stopWordFilter", stemmer: "stemmer"
        },
        "ro": {
          tokenizer: "trimmer", stopWordFilter: "stopWordFilter", stemmer: "stemmer"
        },
        "ru": {
          tokenizer: "trimmer", stopWordFilter: "stopWordFilter", stemmer: "stemmer"
        },
        "sv": {
          tokenizer: "trimmer", stopWordFilter: "stopWordFilter", stemmer: "stemmer"
        },
        "th": {
          tokenizer: "trimmer", stopWordFilter: "stopWordFilter", stemmer: "stemmer"
        },
        "tr": {
          tokenizer: "trimmer", stopWordFilter: "stopWordFilter", stemmer: "stemmer"
        }
      };
    }
  }]);

  return SearchLanguage;
}();

},{"../../../../lib/rh":25}],56:[function(require,module,exports){
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

module.exports = function () {
  function SearchMetadata(data) {
    _classCallCheck(this, SearchMetadata);

    if (data) {
      this.data = JSON.parse(data);
    }
  }

  _createClass(SearchMetadata, [{
    key: "getTopicData",
    value: function getTopicData(id) {
      return this.topicData[id];
    }
  }, {
    key: "getTopicSummary",
    value: function getTopicSummary(id) {
      return this.topicData[id] && this.topicData[id].summary;
    }
  }, {
    key: "getTopicNextId",
    value: function getTopicNextId(id) {
      return this.topicData[id] && this.topicData[id].next;
    }
  }, {
    key: "settings",
    get: function get() {
      return this.data.settings;
    }
  }, {
    key: "topicData",
    get: function get() {
      return this.data.metadata;
    }
  }, {
    key: "context",
    get: function get() {
      return this.settings.context;
    }
  }, {
    key: "contextLimit",
    get: function get() {
      return this.settings.contextLimit;
    }
  }, {
    key: "fields",
    get: function get() {
      return this.settings.fields;
    }
  }]);

  return SearchMetadata;
}();

},{}],57:[function(require,module,exports){
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var rh = require("../../../../../lib/rh");
var _ = rh._;

module.exports = function () {
  function CbtFilter(fields, origin, tagExprs) {
    _classCallCheck(this, CbtFilter);

    this.fileds = fields;
    this.origin = origin;
    this.tagExprs = tagExprs;
  }

  _createClass(CbtFilter, [{
    key: "filter",
    value: function filter(itemList) {
      var _this = this;

      return _.reduce(itemList, function (filtered, item) {
        return filtered || _this._isFilterd(item);
      }, false);
    }
  }, {
    key: "_isFilterd",
    value: function _isFilterd(item) {
      var cbt = this.getCbt(item);
      return cbt && this._isFilteredCbt(cbt);
    }
  }, {
    key: "_isFilteredCbt",
    value: function _isFilteredCbt(cbt) {
      var _this2 = this;

      var ids = cbt.split(';');
      return !_.any(ids, function (id) {
        return _.evalTagExpression(id, _this2.tagExprs, _this2.origin);
      });
    }
  }, {
    key: "getCbt",
    value: function getCbt(item) {
      return item && item.attributes && item.attributes.length > 0 && _.map(item.attributes, function (attr) {
        return attr.value;
      }).join(";");
    }
  }]);

  return CbtFilter;
}();

},{"../../../../../lib/rh":25}],58:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var lunr = require('lunr');
var Synonymns = require('../../common/synonymns');
var rh = require("../../../../../lib/rh");
var _ = rh._;
var LanguageSetter = require('../language');

module.exports = function () {
  function SearchDb(content, loader, settings) {
    _classCallCheck(this, SearchDb);

    this.init(content, loader, settings);
  }

  _createClass(SearchDb, [{
    key: 'init',
    value: function init(content, loader) {
      var settings = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      content = this.fixContent(content);
      this.settings = settings;
      this.content = content;
      this.code = _.get(this.settings, "language.code");
      this.languageSetter = new LanguageSetter(this.code, loader, this.loadDb.bind(this));
      this.languageSetter.setLanguage(lunr);
    }
  }, {
    key: 'fixContent',
    value: function fixContent(content) {
      content.pipeline = content.pipeline || [];
      content.fieldVectors = content.fieldVectors || [];
      content.invertedIndex = content.invertedIndex || [];
      return content;
    }
  }, {
    key: 'loadDb',
    value: function loadDb() {
      this.processSyn();
      this.registerFunctions();
      this.db = lunr.Index.load(this.content);
      if (!_.isEmptyObject(this.content.pipeline)) {
        this.languageSetter.replaceFn(this.db, lunr);
      }
    }
  }, {
    key: 'registerFunctions',
    value: function registerFunctions() {
      var pipelineFunction = this.replaceSynonymn.bind(this);
      var addQueryFunction = this.addQuery.bind(this);
      lunr.Pipeline.registerFunction(pipelineFunction, 'replaceSynonymn');
      lunr.Pipeline.registerFunction(addQueryFunction, 'addQuery');
    }
  }, {
    key: 'processSyn',
    value: function processSyn() {
      var synonymns_words = this.settings && this.settings.synonyms || {};
      var synonyms = new Synonymns(synonymns_words);
      this.settings.rootWords = synonyms.rootWords;
    }
  }, {
    key: 'addQuery',
    value: function addQuery(token) {
      var word = token.toString();
      this.queryWords.push(word);
      this.queryWords = _.unique(this.queryWords);
      return token;
    }
  }, {
    key: 'replaceSynonymn',
    value: function replaceSynonymn(token) {
      var _this = this;

      var word = token.toString();
      var root = this.settings && this.settings.rootWords && this.settings.rootWords[word];
      if (root && root !== word) {
        return token.update(function () {
          return _this.settings.rootWords[word];
        });
      } else {
        return token;
      }
    }
  }, {
    key: 'addStopWords',
    value: function addStopWords(index, stopWords) {
      if (stopWords) {
        var stopWordFilter = lunr.generateStopWordFilter(stopWords);
        index.pipeline.before(lunr.stopWordFilter, stopWordFilter);
        index.pipeline.remove(lunr.stopWordFilter);
      }
    }
  }, {
    key: 'search',
    value: function search(query) {
      var _this2 = this;

      this.queryWords = [];
      var params = query.getParams(this.isStopWord.bind(this));
      var search_results = [];
      var clauses = _.flatten(params);
      search_results = this.db && clauses.length !== 0 && this.db.query(function (q) {
        _.each(clauses, function (clause) {
          return q.term(clause.name, clause);
        });
      }) || [];
      search_results = search_results.sort(function (a, b) {
        return rh._.keys(b.matchData.metadata).length - rh._.keys(a.matchData.metadata).length;
      });
      return query.opts ? _.filter(search_results, function (result) {
        return _this2.match(result, query.opts);
      }) : search_results;
    }
  }, {
    key: 'match',
    value: function match(result, opts) {
      var _this3 = this;

      var retVal = true;
      if (opts.andSearch) {
        var matchingWords = result && result.matchData.metadata || [];
        _.each(this.queryWords, function (word) {
          if (!matchingWords[word] && !_this3.isStopWord(word)) {
            retVal = false;
          }
        });
      }
      return retVal;
    }
  }, {
    key: 'isStopWord',
    value: function isStopWord(word) {
      return this.settings.stopWords.indexOf(word.toLowerCase()) !== -1;
    }
  }, {
    key: 'searchGlossary',
    value: function searchGlossary(query) {
      var _this4 = this;

      var glossary = this.settings && this.settings.glossary || {};
      var queryTokens = this.getRootTokens(query);
      var gossaryResults = _.reduce(glossary, function (result, definition, term) {
        var gloTokens = _this4.getRootTokens(term);
        if (queryTokens.length === gloTokens.length && _this4.matchTokens(queryTokens, gloTokens)) {
          result[term] = definition;
        }
        return result;
      }, {});
      return gossaryResults;
    }
  }, {
    key: 'matchTokens',
    value: function matchTokens(set1, set2) {
      var matched = true;
      _.each(set1, function (term1, index) {
        if (term1 !== set2[index]) {
          matched = false;
        }
      });
      return matched;
    }
  }, {
    key: 'getRootTokens',
    value: function getRootTokens(text) {
      var _this5 = this;

      var tokens = lunr.tokenizer(text);
      return _.map(tokens, function (token) {
        var word = token.toString();
        return _this5.settings.rootWords[word] || word;
      });
    }
  }, {
    key: 'export',
    value: function _export() {
      return this.db.toJSON();
    }
  }]);

  return SearchDb;
}();

},{"../../../../../lib/rh":25,"../../common/synonymns":36,"../language":55,"lunr":21}],59:[function(require,module,exports){
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var rh = require("../../../../../lib/rh");
var _ = rh._;
var Paths = require('../../common/paths');
module.exports = function () {
  function SearchLoader() {
    var path = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";

    _classCallCheck(this, SearchLoader);

    this._paths = new Paths(path);
  }

  _createClass(SearchLoader, [{
    key: "getPath",
    value: function getPath() {
      return this._paths.getPath();
    }
  }, {
    key: "init",
    value: function init(id, callbackFn) {
      this.id = id;
      callbackFn(this);
    }
  }, {
    key: "loadDB",
    value: function loadDB(callbackFn) {
      var path = this._paths.getSearchDbFilePath();
      _.loadScript(path, true, function () {
        var data = _.exports();
        if (callbackFn) {
          callbackFn(data);
        }
      }, true);
    }
  }, {
    key: "getId",
    value: function getId(id) {
      return this.id + "_" + id;
    }
  }, {
    key: "getUrl",
    value: function getUrl(url) {
      return this._paths._getRelativePath(url);
    }
  }, {
    key: "loadMetaData",
    value: function loadMetaData(callbackFn) {
      var path = this._paths.getMetadataFilePath();
      _.loadScript(path, true, function () {
        var data = _.exports();
        if (callbackFn) {
          callbackFn(data);
        }
      }, true);
    }
  }, {
    key: "loadTextData",
    value: function loadTextData(query, id, callbackFn) {
      var path = this._paths.getTextFilePath(id);
      _.loadScript(path, true, function () {
        var data = _.exports();
        if (callbackFn) {
          callbackFn(query, id, data);
        }
      }, true);
    }
  }]);

  return SearchLoader;
}();

},{"../../../../../lib/rh":25,"../../common/paths":35}],60:[function(require,module,exports){
(function (global){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var SearchDb = require('./db');
var Query = require('./query');
var Summary = require('./summary');
var rh = require("../../../../../lib/rh");
var _ = rh._;
var Seamaphore = require('../../../../common/counting_seamaphore');
var TextMerger = require('../text_merger');
var SearchMetadata = require('../metadata');
var CbtFilter = require("./cbt");
module.exports = function () {
  function SearchProcessor(loader) {
    var _this = this;

    _classCallCheck(this, SearchProcessor);

    this.loader = loader;
    this.metadataLoaded = this.dbLoaded = false;
    this.loader.loadDB(function (dbContent) {
      _this.initDB(dbContent);
    });
    this.loader.loadMetaData(function (metadata) {
      _this.initMetadata(metadata);
    });
  }

  _createClass(SearchProcessor, [{
    key: 'getPath',
    value: function getPath() {
      return this.loader.getPath();
    }
  }, {
    key: 'initMetadata',
    value: function initMetadata(metadata) {
      this.metadataLoaded = true;
      this.metadata = new SearchMetadata(metadata);

      if (!this.init && this.dbContent) {
        this.initDB(this.dbContent);
        this.dbContent = null;
      }
      rh.model.publish(rh.consts('KEY_SHOW_CONTEXT'), this.contextLimit > 0);
    }
  }, {
    key: 'initDB',
    value: function initDB(dbContent) {
      if (this.metadataLoaded) {
        this.db = new SearchDb(dbContent, this.loader, this.metadata.settings);
        this.init = true;
        if (this.waiting) {
          this.waiting = false;
          this.getResults();
        }
      } else {
        this.dbContent = dbContent;
      }
    }
  }, {
    key: 'topicsLoaded',
    value: function topicsLoaded() {
      if (this.exactSearch) {
        this.filter();
      }
    }
  }, {
    key: 'isNewQuery',
    value: function isNewQuery(text, opts) {
      if (!this.init) {
        return true;
      }
      if (!this.metadata.settings) {
        return false;
      }
      var query = this.buildQuery(text, opts);
      return !this.query || !this.query.isEqual(query);
    }
  }, {
    key: 'search',
    value: function search(text, opts, callback, resultsCallback) {
      if (this.isNewQuery(text, opts)) {
        this.text = text;
        this.seamaphore = new Seamaphore(this.topicsLoaded.bind(this));
        this.topicCallback = callback;
        this.opts = opts;
        this.summaries = {};
        this.resultsCallback = resultsCallback;
        this.getResults();
      }
    }
  }, {
    key: 'filter',
    value: function filter() {
      var _this2 = this;

      var terms = this.query.exaxctTerms;
      this.results = _.filter(this.results, function (result) {
        var topicText = _this2.resultsMetadata[result.id].topicText;
        return _this2.matchesExact(terms, topicText, result.id);
      });
      this.resultsCallback(this.query.text, this.results, this.glossaryResult);
      this.processSummary();
    }
  }, {
    key: 'processSummary',
    value: function processSummary() {
      var _this3 = this;

      _.each(this.results, function (result) {
        var id = result.id;
        _this3.topicCallback(_this3.loader.getId(id), _this3.summaries[id], _this3.createUrl(id, _this3.query.exaxctTerms));
      });
    }
  }, {
    key: 'matchesExact',
    value: function matchesExact(terms, text, id) {
      var _this4 = this;

      var found = false;
      _.each(terms, function (term) {
        var idx = text.toLowerCase().indexOf(term);
        if (idx !== -1) {
          _this4.addSummary(id, text, idx, term);
          found = true;
        }
      });
      return found;
    }
  }, {
    key: 'addSummary',
    value: function addSummary(id, text, idx, term) {
      var summary = this.metadata.getTopicSummary(id);
      if (this.metadata.context && summary) {
        this.summaries[id] = summary;
      } else {
        var summaryExtractor = new Summary(this.metadata.topicData, this.metadata.context, this.metadata.contextLimit);
        this.summaries[id] = summaryExtractor.getSummaryText(text, idx, term.length, term);
      }
    }
  }, {
    key: 'getResults',
    value: function getResults() {
      if (!this.init) {
        this.waiting = true;
        return;
      }
      this.query = this.buildQuery(this.text, _.extend(this.opts, { searchSubstrings: this.searchSubstrings }));
      this.exactSearch = this.query.exactMatch;
      this.glossaryResult = this.searchGlossary(this.text);
      this.results = this.process();
      if (this.needsCorrection) {
        this.doCorrection();
      }

      if (!this.exactSearch || this.results.length === 0) {
        this.resultsCallback(this.query.text, this.results, this.glossaryResult);
      }
    }
  }, {
    key: 'doCorrection',
    value: function doCorrection() {
      this.query = this.buildQuery(this.query.text, _.extend(this.opts, { fuzzy: true }));
      this.results = this.process();
    }
  }, {
    key: 'searchGlossary',
    value: function searchGlossary() {
      return this.processGlossary();
    }
  }, {
    key: 'buildQuery',
    value: function buildQuery(text, opts) {
      return new Query(text, this.metadata.settings, opts, this.filterItem.bind(this));
    }
  }, {
    key: 'process',
    value: function process() {
      var _this5 = this;

      this.resultsMetadata = {};
      var searchResults = this.db.search(this.query);
      this.seamaphore.wait(searchResults.length);
      _.each(searchResults, function (result) {
        var topicData = _this5.metadata.getTopicData(result.ref);
        _this5.resultsMetadata[result.ref] = result.matchData.metadata;
        _this5.loader.loadTextData(_this5.query, result.ref, _this5.processTopicData.bind(_this5));
        _.extend(result, topicData);
        result.id = result.ref;
        result.ref = _this5.loader.getId(result.ref);
      });
      return searchResults;
    }
  }, {
    key: 'processGlossary',
    value: function processGlossary() {
      return this.db.searchGlossary(this.text);
    }
  }, {
    key: 'processTopicData',
    value: function processTopicData(query, id, data) {
      if (!this.query.isEqual(query)) {
        return;
      }
      var matchResult = this.resultsMetadata[id];
      if (matchResult) {
        var wordlist = [];
        var summaryExtractor = new Summary(this.metadata.topicData, this.metadata.context, this.metadata.contextLimit);
        var summary = summaryExtractor.getSummary(id, matchResult, wordlist, data);
        summary = summary.replace(/\t+/gi, ' ').trim();
        this.resultsMetadata[id].topicText = this.createText(id, data);
        if (!this.exactSearch) {
          this.topicCallback(this.getId(id), summary, this.createUrl(id, wordlist));
        }
      }
      this.seamaphore.signal();
    }
  }, {
    key: 'createText',
    value: function createText(topicId, texts) {
      var nextTexts = this.metadata.getTopicNextId(topicId);
      var merger = new TextMerger(nextTexts, texts, this.filterId.bind(this));
      return merger.getText();
    }
  }, {
    key: 'filterId',
    value: function filterId(id) {
      var fields = this.metadata.fields;
      var fieldItem = fields[id];
      return this.filterItem(fieldItem);
    }
  }, {
    key: 'filterItem',
    value: function filterItem(fieldItem) {
      var fields = this.metadata.fields;
      var filter = new CbtFilter(fields, this.opts.origin, this.opts.cbt);
      return fieldItem && filter.filter(fieldItem);
    }
  }, {
    key: 'getId',
    value: function getId(id) {
      return this.loader.getId(id);
    }
  }, {
    key: 'createUrl',
    value: function createUrl(id, wordlist) {
      var data = this.metadata.getTopicData(id);
      var urlParam = {
        rhsearch: this.query.originalText
      };
      if (global.gbHighLight) {
        var hlTerm = this.exactSearch ? '"' + wordlist[0] + '"' : (wordlist || []).join(' ');
        urlParam.rhhlterm = hlTerm;
      }
      if (data) {
        var resultsParams = '?' + _.mapToEncodedString(urlParam);
        return '' + this.loader.getUrl(data.relUrl) + resultsParams;
      }
    }
  }, {
    key: 'searchSubstrings',
    get: function get() {
      return _.get(this.metadata.settings, 'searchsubstrings');
    }
  }, {
    key: 'contextLimit',
    get: function get() {
      var num = parseInt(this.metadata.contextLimit);
      if (Number.isNaN(num)) {
        return 100;
      }
      return num;
    }
  }, {
    key: 'needsCorrection',
    get: function get() {
      return this.results.length === 0 && this.metadata.settings.fuzzy && !this.query.exactMatch;
    }
  }]);

  return SearchProcessor;
}();

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../../../../lib/rh":25,"../../../../common/counting_seamaphore":26,"../metadata":56,"../text_merger":64,"./cbt":57,"./db":58,"./query":61,"./summary":62}],61:[function(require,module,exports){
(function (global){
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var rh = require("../../../../../lib/rh");
var _ = rh._;
var CbtFilter = require("./cbt");
var lunr = require("lunr");
module.exports = function () {
  function SearchQuery(text, settings, opts) {
    _classCallCheck(this, SearchQuery);

    this.originalText = text.trim();
    this.text = this.originalText.toLowerCase();
    this.settings = settings || {};
    this.opts = opts || {};
    this.opts.gbHighLight = global.gbHighLight;
    this.checkExactMatch();
  }

  _createClass(SearchQuery, [{
    key: "filter",
    value: function filter(itemList) {
      var filter = new CbtFilter(this.settings.fields, this.opts.origin, this.opts.cbt);
      return filter.filter(itemList);
    }
  }, {
    key: "getParams",
    value: function getParams(isStopWordFn) {
      this.isStopWord = isStopWordFn;
      return this.fieldsParam;
    }
  }, {
    key: "isEqual",
    value: function isEqual(other) {
      if (this.text !== other.text || this._bExactMatch !== other._bExactMatch) {
        return false;
      }
      return _.isEqual(this.opts, other.opts);
    }
  }, {
    key: "getFuzzyLength",
    value: function getFuzzyLength(token) {
      return _.max([0, Math.floor(Math.log2(token.length) - 1)]);
    }
    // getQueryText(id, token, boost) {
    //   if (this.isStopWord(token)) {
    //     return ''
    //   }
    //   else if (this.opts.fuzzy) {
    //     return `${id}:${token}~${this.getFuzzyLength(token)}^${boost}`
    //   }
    //   else if (this.opts.searchSubstrings && !this._bExactMatch)
    //   {
    //     return `${id}:${token}^${boost} ${id}:*${token}*^${Math.round(Math.sqrt(boost))}`
    //   }
    //   else {
    //     return `${id}:${token}^${boost}`
    //   }
    // }

  }, {
    key: "getQueryArr",
    value: function getQueryArr(id, token, boost) {
      if (this.isStopWord(token)) {
        return [];
      } else if (this.opts.fuzzy) {
        return [{ name: token, fields: [id], editDistance: this.getFuzzyLength(token), boost: boost }];
      } else if (this.opts.searchSubstrings && !this._bExactMatch) {
        return [{ name: token, fields: [id], boost: boost }, { name: token, fields: [id], boost: Math.round(Math.sqrt(boost)), wildcard: lunr.Query.wildcard.LEADING | lunr.Query.wildcard.TRAILING }];
      } else {
        return [{ name: token, fields: [id], boost: boost }];
      }
    }
  }, {
    key: "checkExactMatch",
    value: function checkExactMatch() {
      if (this._isExactMatch) {
        this._bExactMatch = true;
        this.text = this.text.substring(1, this.text.length - 1);
      }
    }
  }, {
    key: "getFieldBoost",
    value: function getFieldBoost(field) {
      return _.reduce(field, function (max, rule) {
        return rule && rule.boost && rule.boost > max ? rule.boost : max;
      }, 1);
    }
  }, {
    key: "_isExactMatch",
    get: function get() {
      return this.text.length > 2 && this.quotesChar.indexOf(this.text[0]) !== -1 && this.quotesChar.indexOf(this.text[this.text.length - 1]) !== -1;
    }
  }, {
    key: "exactMatch",
    get: function get() {
      return this._bExactMatch;
    }
  }, {
    key: "exaxctTerms",
    get: function get() {
      return [this.text];
    }
  }, {
    key: "quotesChar",
    get: function get() {
      return ["\"", "\'"];
    }
  }, {
    key: "fieldsParam",
    get: function get() {
      var _this = this;

      var fieldqueries = [];
      var tokens = _.filter(_.map(lunr.tokenizer(this.text), function (token) {
        return token.str;
      }), function (str) {
        return !_.isEmptyString(str.trim());
      });
      _.each(tokens, function (token) {
        var qArr = [];
        _.each(_this.settings.fields, function (item, id) {
          if (!_this.filter(item)) {
            var boost = _this.getFieldBoost(item);
            // qText = `${qText} ${this.getQueryText(id, token, boost)}`
            qArr = qArr.concat(_this.getQueryArr(id, token, boost));
          }
        });
        fieldqueries.push(qArr);
      });
      return fieldqueries;
    }
  }]);

  return SearchQuery;
}();

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../../../../lib/rh":25,"./cbt":57,"lunr":21}],62:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var rh = require("../../../../../lib/rh");
var TextMerger = require('../text_merger');
var _ = rh._;
module.exports = function () {
  function SearchSummary(topicData, context, contextLimit) {
    _classCallCheck(this, SearchSummary);

    this.topicData = topicData;
    this.context = context;
    this.contextLimit = Number.parseInt(contextLimit);
    this.rightLimit = Math.ceil(70 * this.contextLimit / 100);
    this.leftLimit = Math.ceil(30 * this.contextLimit / 100);
  }

  _createClass(SearchSummary, [{
    key: 'minDistance',
    value: function minDistance() {
      //_.each()
    }
  }, {
    key: 'getSummary',
    value: function getSummary(id, matchResult, wordlist, data) {
      var _this = this;

      var summaries = [];
      var summary = '';
      if (this.context) {
        summary = this.topicData[id] && (this.topicData[id].summary || "").substring(0, this.contextLimit);
      }
      try {
        summaries = _.map(matchResult, function (metadata) {

          return _.union(metadata, function (posData, fieldId) {
            if (!posData || !posData.position || !posData.position[0]) {
              var texts = data[fieldId];
              return _.map(texts, function (text) {
                return _this.trimRight(text);
              });
            } else {
              return _.union(posData.position, function (fistrPos) {
                if (fistrPos[0] !== undefined && fistrPos[1] !== undefined) {
                  var _texts = data[fieldId];
                  var merger = new TextMerger();
                  var text = merger.getIndexText(_texts);
                  var word = text.substring(fistrPos[0], fistrPos[0] + fistrPos[1]);
                  word = word.toLowerCase();
                  if (wordlist.indexOf(word) === -1) {
                    wordlist.push(word);
                  }
                  return _this.getSummaryText(text, fistrPos[0], fistrPos[1], word);
                }
              });
            }
          });
        });
        if (!this.context || !summary || summary === '') {
          _.each(summaries[0] || [], function (s) {
            if (s.length > summary.length) {
              summary = s;
            }
          });
        }
      } catch (e) {
        summary = '';
      }
      if (summary === '') {
        summary = this.getDefaultSummary(data);
      }
      return summary;
    }
  }, {
    key: 'getDefaultSummary',
    value: function getDefaultSummary(data) {
      var summary = '';
      try {
        var text = '';
        _.each(data, function (value, key) {
          if (key !== 'id') {
            text = text + " ";
          }
        });
        summary = this.getSummaryText(text, 0, this.contextLimit || 100, '');
      } catch (e) {
        summary = '';
      }
      return summary;
    }
  }, {
    key: 'getSummaryText',
    value: function getSummaryText(text, idx, length, word) {
      var leftText = text.substring(0, idx);
      var rightText = text.substring(idx + length);

      return this.trimLeft(leftText) + '<b>' + word + '</b>\n              ' + this.trimRight(rightText);
    }
  }, {
    key: 'trimLeft',
    value: function trimLeft(leftText) {
      var leftIdx = leftText.indexOf(" ", leftText.length - this.leftLimit);
      leftText = leftText.substring(leftIdx, leftText.length);
      return leftText.trimStart();
    }
  }, {
    key: 'trimRight',
    value: function trimRight(rightText) {
      var rightIdx = rightText.indexOf(" ", this.rightLimit);
      rightIdx = rightIdx === -1 ? rightText.length : rightIdx;
      rightText = rightText.substring(0, rightIdx);
      return rightText.trimEnd();
    }
  }]);

  return SearchSummary;
}();

},{"../../../../../lib/rh":25,"../text_merger":64}],63:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _utils = require('../suggestion/utils');

var _utils2 = _interopRequireDefault(_utils);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

module.exports = function () {
  function SearchResult(result) {
    _classCallCheck(this, SearchResult);

    this.fRanking = result.score;
    this.nIndex = 1;
    this.strSummary = '.p.searchsummary' + result.ref;
    this.strTitle = result.title;
    this.strUrl = '.p.searchurl' + result.ref;
    this.strBreadcrumbs = result.relUrl;
  }

  _createClass(SearchResult, [{
    key: 'merge',
    value: function merge(new_item) {
      this.fRanking += new_item.fRanking;
    }
  }, {
    key: 'compare',
    value: function compare(other) {
      return other.fRanking - this.fRanking;
    }
  }, {
    key: 'match',
    value: function match(other) {
      return _utils2.default.compareNoCase(other.strUrl, this.strUrl) === 0;
    }
  }]);

  return SearchResult;
}();

},{"../suggestion/utils":53}],64:[function(require,module,exports){
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var rh = require("../../../../lib/rh");
var _ = rh._;
module.exports = function () {
  function SearchTextMerger(nextTexts, texts, filter) {
    _classCallCheck(this, SearchTextMerger);

    this.nextTexts = nextTexts;
    this.texts = texts;
    this.filter = filter || this.defaultFilter;
  }

  _createClass(SearchTextMerger, [{
    key: "join",
    value: function join(id, start, end) {
      var texts = [];
      for (var i = start; i <= end; i++) {
        if (this.texts[id][i]) {
          texts.push(this.texts[id][i]);
        }
      }
      return texts.join("").replace(/[\n ]+/g, ' ').replace(/\u00A0/gi, " ");
    }
  }, {
    key: "defaultFilter",
    value: function defaultFilter() {
      return false;
    }
  }, {
    key: "getIndexText",
    value: function getIndexText(texts) {
      return texts.join(" ").replace(/\n/gi, " ").trim();
    }
  }, {
    key: "getText",
    value: function getText() {
      var _this = this;

      var texts = [];
      _.each(this.nextTexts, function (item) {
        if (!_this.filter(item[0])) {
          texts.push(_this.join(item[0], item[1], item[2]));
        }
      });
      return texts.join("");
    }
  }]);

  return SearchTextMerger;
}();

},{"../../../../lib/rh":25}],65:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var rh = require("../../lib/rh");
var _ = rh._;
var consts = rh.consts;

var SearchResultController = function () {
  function SearchResultController(widget) {
    _classCallCheck(this, SearchResultController);

    this.widget = widget;
  }

  _createClass(SearchResultController, [{
    key: 'getLink',
    value: function getLink(url) {
      var searchUrl = url;
      var highlightParam = this.widget.get(consts('KEY_SEARCH_RESULT_PARAMS'));
      var searchTerm = this.widget.get(consts('KEY_SEARCH_TERM'));
      var searchTermParam = '';
      if (searchTerm && searchTerm !== '') {
        var key = consts('HASH_KEY_RH_SEARCH');
        var searchTermMap = {};
        searchTermMap[key] = searchTerm;
        searchTermParam = _.mapToEncodedString(searchTermMap);
      }
      if (highlightParam !== undefined && highlightParam !== '') {
        searchUrl = searchUrl + highlightParam + '&' + searchTermParam;
      } else if (searchTermParam !== '') {
        searchUrl = searchUrl + '?' + searchTermParam;
      }
      return searchUrl;
    }
  }]);

  return SearchResultController;
}();

rh.controller('SearchResultController', SearchResultController);

},{"../../lib/rh":25}],66:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var rh = require("../../lib/rh");
var _ = rh._;
var consts = rh.consts;
//const KEY_ACTIVE_BOOKID = 'active_bookid';

var TocBreadcrumbsController = function () {
  function TocBreadcrumbsController(widget) {
    _classCallCheck(this, TocBreadcrumbsController);

    this.widget = widget;
    //this.widget.model.subscribe(KEY_ACTIVE_BOOKID, this.updateBreadcrumbs)
  }

  _createClass(TocBreadcrumbsController, [{
    key: 'select',
    value: function select(id, url) {
      this.widget.publish(consts('KEY_TOC_SELECT_ITEM'), { 'id': id, 'url': url });
    }
  }, {
    key: 'getLink',
    value: function getLink(id) {
      if (id) {
        var breadcrumbs = this.widget.get(consts('KEY_TOC_BREADCRUMBS'));
        var item = breadcrumbs[id];
        if (item && item.hasUrl) {
          return item.url;
        }
      }
    }
  }, {
    key: 'goToHome',
    value: function goToHome(index) {
      if (index) {
        var breadcrumbs = this.widget.get(consts('KEY_TOC_BREADCRUMBS'));
        var item = breadcrumbs[index];
        if (item && !item.hasUrl) {
          _.goToHome({ rhtocid: item.id });
        }
      }
    }
  }]);

  return TocBreadcrumbsController;
}();

rh.controller('TocBreadcrumbsController', TocBreadcrumbsController);

},{"../../lib/rh":25}],67:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var rh = require("../../../lib/rh");
var $ = rh.$;
var CAROUSEL_CHANGE = 'change';
var CAROUSEL_ITEM = '.carousel-item:not(.hide):not(.rh-hide)';

var Carousel = function () {
  function Carousel(widget, opts) {
    var _this = this;

    _classCallCheck(this, Carousel);

    this.widget = widget;
    this.node = this.widget.node;
    this.tab = 0;
    rh.model.subscribeOnce(rh.consts(opts.key), function () {
      _this.widget.publish(CAROUSEL_CHANGE, true);
    });
    rh.model.subscribe(rh.consts('KEY_SCREEN'), function () {
      _this.goto(_this.tab, 0);
    });
    rh.model.subscribe(opts.key + 'gototab', function (bookData) {
      _this.goto(_this.pagecount(), bookData.tab);
    });
  }

  _createClass(Carousel, [{
    key: 'goto',
    value: function goto(from, to) {
      var _this2 = this;

      this.tab = to;
      this.carouselnode = $.find(this.node, '.carousel')[0];
      this.animateLeft(from);
      rh._.delay(function () {
        _this2.widget.publish(CAROUSEL_CHANGE, true);
      }, 1000);
    }
  }, {
    key: 'hasNext',
    value: function hasNext() {
      this.carouselnode = $.find(this.node, '.carousel')[0];
      var lastItem = $.find($.find(this.node, '.carousel')[0], CAROUSEL_ITEM);
      lastItem = lastItem && lastItem.length > 0 ? lastItem[lastItem.length - 1] : null;
      return lastItem.offsetLeft + this.carouselnode.offsetLeft > this.carouselnode.offsetWidth;
    }
  }, {
    key: 'animateLeft',
    value: function animateLeft() {
      var leftVal = 'calc(-' + this.tab * 14 + 'px - ' + this.tab * 100 + '%)';
      $.css(this.carouselnode, 'left', leftVal);
    }
  }, {
    key: 'next',
    value: function next() {
      this.goto(this.tab, this.tab + 1);
    }
  }, {
    key: 'pagecount',
    value: function pagecount() {
      return this.tab;
    }
  }, {
    key: 'previous',
    value: function previous() {
      this.goto(this.tab, this.tab - 1);
    }
  }, {
    key: 'ensureVisible',
    value: function ensureVisible() {}
  }]);

  return Carousel;
}();

rh.controller('Carousel', Carousel);

},{"../../../lib/rh":25}],68:[function(require,module,exports){
'use strict';

var rh = require("../../lib/rh");
var $ = rh.$;
module.exports = {

  nodeType: {
    ELEMENT_NODE: 1,
    ATTRIBUTE_NODE: 2,
    TEXT_NODE: 3,
    CDATA_SECTION_NODE: 4,
    ENTITY_REFERENCE_NODE: 5,
    ENTITY_NODE: 6,
    PROCESSING_INSTRUCTION_NODE: 7,
    COMMENT_NODE: 8,
    DOCUMENT_NODE: 9,
    DOCUMENT_TYPE_NODE: 10,
    DOCUMENT_FRAGMENT_NODE: 11,
    NOTATION_NODE: 12
  },

  removeChild: function removeChild(node) {
    var parent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.parentNode(node);

    return parent && parent.removeChild && parent.removeChild(node);
  },
  appendChild: function appendChild(parent, newNode) {
    return parent && parent.appendChild && parent.appendChild(newNode);
  },
  parentNode: function parentNode(node) {
    return node && node.parentNode;
  },
  childNodes: function childNodes(node) {
    return node && node.childNodes || [];
  },
  toHtmlNode: function toHtmlNode(html) {
    return this.childNodes($.createElement('div', html));
  },
  outerHTML: function outerHTML(node) {
    return node && node.outerHTML || '';
  },
  insertAfter: function insertAfter(node, newNode) {
    return node.parentNode.insertBefore(newNode, node.nextSibling);
  },
  value: function value(node) {
    return node && node.nodeValue;
  },
  name: function name(node) {
    return node && node.nodeName;
  },
  type: function type(node) {
    return node && node.nodeType;
  },
  isElementNode: function isElementNode(node) {
    return this.type(node) === this.nodeType.ELEMENT_NODE;
  },
  isTextNode: function isTextNode(node) {
    return this.type(node) === this.nodeType.TEXT_NODE;
  }
};

},{"../../lib/rh":25}]},{},[27])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJsZW5pZW50X3NyYy9sYXlvdXQvZXZlbnRfaGFuZGxlcnMuanMiLCJsZW5pZW50X3NyYy9sYXlvdXQvZ2xvc3NhcnlfY29udHJvbGxlci5qcyIsImxlbmllbnRfc3JjL2xheW91dC9pbmRleF9jb250cm9sbGVyLmpzIiwibGVuaWVudF9zcmMvbGF5b3V0L3NlYXJjaF91dGlsLmpzIiwibGVuaWVudF9zcmMvbGF5b3V0L3RvY19jb250cm9sbGVyLmpzIiwibGVuaWVudF9zcmMvbGF5b3V0L3RvY19vcmRlci5qcyIsImxlbmllbnRfc3JjL3JvYm9oZWxwL2xheW91dC9icm93c2VzZXF1ZW5jZV9idWlsZGVyLmpzIiwibGVuaWVudF9zcmMvcm9ib2hlbHAvbGF5b3V0L2V4cHJlc3Npb25fYnVpbGRlci5qcyIsImxlbmllbnRfc3JjL3JvYm9oZWxwL2xheW91dC9maWx0ZXJfY29udHJvbGxlci5qcyIsImxlbmllbnRfc3JjL3JvYm9oZWxwL2xheW91dC9maWx0ZXJfaGFuZGxlci5qcyIsImxlbmllbnRfc3JjL3JvYm9oZWxwL2xheW91dC9pbml0LmpzIiwibGVuaWVudF9zcmMvcm9ib2hlbHAvbGF5b3V0L2pzX2xvYWRpbmdfY29udHJvbGxlci5qcyIsImxlbmllbnRfc3JjL3JvYm9oZWxwL2xheW91dC9sYXlvdXRmaXguanMiLCJsZW5pZW50X3NyYy9yb2JvaGVscC9sYXlvdXQvbG9hZF9wcm9qZWN0cy5qcyIsImxlbmllbnRfc3JjL3JvYm9oZWxwL2xheW91dC9tb2Rlcm5fbGF5b3V0X2NvbnRyb2xsZXIuanMiLCJsZW5pZW50X3NyYy9yb2JvaGVscC9sYXlvdXQvbXAuanMiLCJsZW5pZW50X3NyYy9yb2JvaGVscC9sYXlvdXQvc2VhcmNoX2ZpbGVkLmpzIiwibGVuaWVudF9zcmMvcm9ib2hlbHAvbGF5b3V0L3VybF91dGlscy5qcyIsIm5vZGVfbW9kdWxlcy9qcy1wb2x5ZmlsbHMvZXM1LmpzIiwibm9kZV9tb2R1bGVzL2pzLXBvbHlmaWxscy9lczYuanMiLCJub2RlX21vZHVsZXMvbHVuci9sdW5yLmpzIiwic3JjL2ZyYW1ld29ya3Mvc2hpbS5qcyIsInNyYy9mcmFtZXdvcmtzL3NoaW0vYXJyYXkuanMiLCJzcmMvZnJhbWV3b3Jrcy9zaGltL29iamVjdC5qcyIsInNyYy9saWIvcmguanMiLCJzcmMvcmVzcG9uc2l2ZV9oZWxwL2NvbW1vbi9jb3VudGluZ19zZWFtYXBob3JlLmpzIiwic3JjL3Jlc3BvbnNpdmVfaGVscC9sYXlvdXQuanMiLCJzcmMvcmVzcG9uc2l2ZV9oZWxwL2xheW91dC9jdXN0b21fYnV0dG9ucy5qcyIsInNyYy9yZXNwb25zaXZlX2hlbHAvbGF5b3V0L2V4cGFuZF9hbGwuanMiLCJzcmMvcmVzcG9uc2l2ZV9oZWxwL2xheW91dC9mYXZvcml0ZXNfY29udHJvbGxlci5qcyIsInNyYy9yZXNwb25zaXZlX2hlbHAvbGF5b3V0L2hvbWVfY29udHJvbGxlci5qcyIsInNyYy9yZXNwb25zaXZlX2hlbHAvbGF5b3V0L21vZGFsX2RpYWxvZy5qcyIsInNyYy9yZXNwb25zaXZlX2hlbHAvbGF5b3V0L3JoMjAxN2xheW91dGNvbnRyb2xsZXIuanMiLCJzcmMvcmVzcG9uc2l2ZV9oZWxwL2xheW91dC9zZWFyY2gvY29tbW9uL21lcmdlci5qcyIsInNyYy9yZXNwb25zaXZlX2hlbHAvbGF5b3V0L3NlYXJjaC9jb21tb24vcGF0aHMuanMiLCJzcmMvcmVzcG9uc2l2ZV9oZWxwL2xheW91dC9zZWFyY2gvY29tbW9uL3N5bm9ueW1ucy5qcyIsInNyYy9yZXNwb25zaXZlX2hlbHAvbGF5b3V0L3NlYXJjaC9zdWdnZXN0aW9uL2NvbnN0cy5qcyIsInNyYy9yZXNwb25zaXZlX2hlbHAvbGF5b3V0L3NlYXJjaC9zdWdnZXN0aW9uL2NvcnJlY3Rvci5qcyIsInNyYy9yZXNwb25zaXZlX2hlbHAvbGF5b3V0L3NlYXJjaC9zdWdnZXN0aW9uL2dlbmVyYWxfcHJlZGljdG9yLmpzIiwic3JjL3Jlc3BvbnNpdmVfaGVscC9sYXlvdXQvc2VhcmNoL3N1Z2dlc3Rpb24vaGlzdG9yeV9wcmVkaWN0b3IuanMiLCJzcmMvcmVzcG9uc2l2ZV9oZWxwL2xheW91dC9zZWFyY2gvc3VnZ2VzdGlvbi9oaXN0b3J5X3JlYWRlci5qcyIsInNyYy9yZXNwb25zaXZlX2hlbHAvbGF5b3V0L3NlYXJjaC9zdWdnZXN0aW9uL2luZGljZXMuanMiLCJzcmMvcmVzcG9uc2l2ZV9oZWxwL2xheW91dC9zZWFyY2gvc3VnZ2VzdGlvbi9pbnB1dF9wYXJzZXIuanMiLCJzcmMvcmVzcG9uc2l2ZV9oZWxwL2xheW91dC9zZWFyY2gvc3VnZ2VzdGlvbi9sb2FkZXIuanMiLCJzcmMvcmVzcG9uc2l2ZV9oZWxwL2xheW91dC9zZWFyY2gvc3VnZ2VzdGlvbi9uZ3JhbV9wcmVkaWN0b3IuanMiLCJzcmMvcmVzcG9uc2l2ZV9oZWxwL2xheW91dC9zZWFyY2gvc3VnZ2VzdGlvbi9wcmVkaWN0aW9uLmpzIiwic3JjL3Jlc3BvbnNpdmVfaGVscC9sYXlvdXQvc2VhcmNoL3N1Z2dlc3Rpb24vcHJlZGljdGlvbl9jcmVhdG9yLmpzIiwic3JjL3Jlc3BvbnNpdmVfaGVscC9sYXlvdXQvc2VhcmNoL3N1Z2dlc3Rpb24vcHJlZGljdGlvbl9saXN0LmpzIiwic3JjL3Jlc3BvbnNpdmVfaGVscC9sYXlvdXQvc2VhcmNoL3N1Z2dlc3Rpb24vcHJlZGljdG9yc19jcmVhdG9yLmpzIiwic3JjL3Jlc3BvbnNpdmVfaGVscC9sYXlvdXQvc2VhcmNoL3N1Z2dlc3Rpb24vc2VhcmNoX2NvbnRyb2xsZXIuanMiLCJzcmMvcmVzcG9uc2l2ZV9oZWxwL2xheW91dC9zZWFyY2gvc3VnZ2VzdGlvbi9zb3J0ZWRfc2V0LmpzIiwic3JjL3Jlc3BvbnNpdmVfaGVscC9sYXlvdXQvc2VhcmNoL3N1Z2dlc3Rpb24vdG9waWNfY291bnRlci5qcyIsInNyYy9yZXNwb25zaXZlX2hlbHAvbGF5b3V0L3NlYXJjaC9zdWdnZXN0aW9uL3V0aWxzLmpzIiwic3JjL3Jlc3BvbnNpdmVfaGVscC9sYXlvdXQvc2VhcmNoL3RvcGljL2hhbmRsZXIuanMiLCJzcmMvcmVzcG9uc2l2ZV9oZWxwL2xheW91dC9zZWFyY2gvdG9waWMvbGFuZ3VhZ2UuanMiLCJzcmMvcmVzcG9uc2l2ZV9oZWxwL2xheW91dC9zZWFyY2gvdG9waWMvbWV0YWRhdGEuanMiLCJzcmMvcmVzcG9uc2l2ZV9oZWxwL2xheW91dC9zZWFyY2gvdG9waWMvcXVlcnkvY2J0LmpzIiwic3JjL3Jlc3BvbnNpdmVfaGVscC9sYXlvdXQvc2VhcmNoL3RvcGljL3F1ZXJ5L2RiLmpzIiwic3JjL3Jlc3BvbnNpdmVfaGVscC9sYXlvdXQvc2VhcmNoL3RvcGljL3F1ZXJ5L2xvYWRlci5qcyIsInNyYy9yZXNwb25zaXZlX2hlbHAvbGF5b3V0L3NlYXJjaC90b3BpYy9xdWVyeS9wcm9jZXNzb3IuanMiLCJzcmMvcmVzcG9uc2l2ZV9oZWxwL2xheW91dC9zZWFyY2gvdG9waWMvcXVlcnkvcXVlcnkuanMiLCJzcmMvcmVzcG9uc2l2ZV9oZWxwL2xheW91dC9zZWFyY2gvdG9waWMvcXVlcnkvc3VtbWFyeS5qcyIsInNyYy9yZXNwb25zaXZlX2hlbHAvbGF5b3V0L3NlYXJjaC90b3BpYy9yZXN1bHQuanMiLCJzcmMvcmVzcG9uc2l2ZV9oZWxwL2xheW91dC9zZWFyY2gvdG9waWMvdGV4dF9tZXJnZXIuanMiLCJzcmMvcmVzcG9uc2l2ZV9oZWxwL2xheW91dC9zZWFyY2hfcmVzdWx0X2NvbnRyb2xsZXIuanMiLCJzcmMvcmVzcG9uc2l2ZV9oZWxwL2xheW91dC90b2NfYnJlYWRjcnVtYnNfY29udHJvbGxlci5qcyIsInNyYy9yZXNwb25zaXZlX2hlbHAvbGF5b3V0L3VpL2Nhcm91c2VsLmpzIiwic3JjL3Jlc3BvbnNpdmVfaGVscC91dGlscy9ub2RlX3V0aWxzLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Y0NBZSxNO0lBQVAsRSxXQUFBLEU7SUFDQSxDLEdBQU0sRSxDQUFOLEM7SUFDQSxDLEdBQU0sRSxDQUFOLEM7SUFDQSxN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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2ZUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hzSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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bUNmLGFBbkNlLHVCQW1DSCxJQW5DRyxFQW1DRyxPQW5DSCxFQW1DVztBQUN4QixXQUFPLEtBQUssVUFBTCxDQUFnQixZQUFoQixDQUE2QixPQUE3QixFQUFzQyxLQUFLLFdBQTNDLENBQVA7QUFDRCxHQXJDYztBQXNDZixPQXRDZSxpQkFzQ1QsSUF0Q1MsRUFzQ0g7QUFDVixXQUFPLFFBQVEsS0FBSyxTQUFwQjtBQUNELEdBeENjO0FBeUNmLE1BekNlLGdCQXlDVixJQXpDVSxFQXlDSjtBQUNULFdBQU8sUUFBUSxLQUFLLFFBQXBCO0FBQ0QsR0EzQ2M7QUE0Q2YsTUE1Q2UsZ0JBNENWLElBNUNVLEVBNENKO0FBQ1QsV0FBTyxRQUFRLEtBQUssUUFBcEI7QUFDRCxHQTlDYztBQStDZixlQS9DZSx5QkErQ0QsSUEvQ0MsRUErQ0s7QUFDbEIsV0FBTyxLQUFLLElBQUwsQ0FBVSxJQUFWLE1BQW9CLEtBQUssUUFBTCxDQUFjLFlBQXpDO0FBQ0QsR0FqRGM7QUFrRGYsWUFsRGUsc0JBa0RKLElBbERJLEVBa0RFO0FBQ2YsV0FBTyxLQUFLLElBQUwsQ0FBVSxJQUFWLE1BQW9CLEtBQUssUUFBTCxDQUFjLFNBQXpDO0FBQ0Q7QUFwRGMsQ0FBakIiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe2Z1bmN0aW9uIHIoZSxuLHQpe2Z1bmN0aW9uIG8oaSxmKXtpZighbltpXSl7aWYoIWVbaV0pe3ZhciBjPVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmU7aWYoIWYmJmMpcmV0dXJuIGMoaSwhMCk7aWYodSlyZXR1cm4gdShpLCEwKTt2YXIgYT1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK2krXCInXCIpO3Rocm93IGEuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixhfXZhciBwPW5baV09e2V4cG9ydHM6e319O2VbaV1bMF0uY2FsbChwLmV4cG9ydHMsZnVuY3Rpb24ocil7dmFyIG49ZVtpXVsxXVtyXTtyZXR1cm4gbyhufHxyKX0scCxwLmV4cG9ydHMscixlLG4sdCl9cmV0dXJuIG5baV0uZXhwb3J0c31mb3IodmFyIHU9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZSxpPTA7aTx0Lmxlbmd0aDtpKyspbyh0W2ldKTtyZXR1cm4gb31yZXR1cm4gcn0pKCkiLCJjb25zdCB7IHJoIH0gPSB3aW5kb3c7XHJcbmNvbnN0IHsgXyB9ID0gcmg7XHJcbmNvbnN0IHsgJCB9ID0gcmg7XHJcbmNvbnN0IHsgY29uc3RzIH0gPSByaDtcclxuY29uc3QgeyBtb2RlbCB9ID0gcmg7XHJcblxyXG5jb25zdCBIQVNIX0tFWV9SSF9TRUFSQ0ggPSBjb25zdHMoJ0hBU0hfS0VZX1JIX1NFQVJDSCcpO1xyXG5jb25zdCBIQVNIX0tFWV9UT1BJQyA9IGNvbnN0cygnSEFTSF9LRVlfVE9QSUMnKTtcclxuY29uc3QgSEFTSF9LRVlfVUlNT0RFID0gY29uc3RzKCdIQVNIX0tFWV9VSU1PREUnKTtcclxuY29uc3QgSEFTSF9LRVlfUkhfVE9DSUQgPSBjb25zdHMoJ0hBU0hfS0VZX1JIX1RPQ0lEJyk7XHJcbmNvbnN0IEhBU0hfS0VZX1JIX0hJR0hMSUdIVCA9IGNvbnN0cygnSEFTSF9LRVlfUkhfSElHSExJR0hUJyk7XHJcbmNvbnN0IEhBU0hfS0VZX1JBTkRPTSA9IGNvbnN0cygnSEFTSF9LRVlfUkFORE9NJyk7XHJcbmNvbnN0IGhhc2hRdWVyeUtleXMgPSBbXHJcbiAgSEFTSF9LRVlfUkhfSElHSExJR0hULFxyXG4gIGNvbnN0cygnSEFTSF9LRVlfUkhfU1lOUycpLFxyXG4gIEhBU0hfS0VZX1JIX1RPQ0lEXHJcbiAgXTtcclxuXHJcbi8vIEhlbHBlciBtZXRob2RzXHJcbmNvbnN0IGdldE1lcmdlZFBhcmFtc01hcCA9IGZ1bmN0aW9uKHRvcGljVXJsKSB7XHJcbiAgY29uc3QgcGFyYW1zTWFwID0gXy51cmxQYXJhbXMoXy5leHRyYWN0UGFyYW1TdHJpbmcodG9waWNVcmwpKTtcclxuICBjb25zdCBoYXNoTWFwICA9IF8uaGFzaFBhcmFtcyhfLmV4dHJhY3RIYXNoU3RyaW5nKHRvcGljVXJsKSk7XHJcbiAgcmV0dXJuIF8uZXh0ZW5kKHBhcmFtc01hcCwgaGFzaE1hcCk7XHJcbn07XHJcblxyXG5jb25zdCBnZXRUb3BpY1VSTCA9IGZ1bmN0aW9uKG5ld01hcCwgdG9waWNVcmwpIHtcclxuICB0b3BpY1VybCA9IHRvcGljVXJsO1xyXG4gIGNvbnN0IGZpbGVQYXRoID0gXy5maWxlUGF0aCh0b3BpY1VybCk7XHJcbiAgbGV0IGJvb2tNYXJrID0gXy5leHRyYWN0SGFzaFN0cmluZyh0b3BpY1VybCk7XHJcbiAgaWYgKGJvb2tNYXJrLmxlbmd0aCA+IDApIHsgYm9va01hcmsgPSBgIyR7Ym9va01hcmt9YDsgfVxyXG5cclxuICBjb25zdCBwYXJhbXNNYXAgPSBfLnVybFBhcmFtcyhfLmV4dHJhY3RQYXJhbVN0cmluZyh0b3BpY1VybCkpO1xyXG4gIGZvciAobGV0IGtleSBvZiBBcnJheS5mcm9tKGhhc2hRdWVyeUtleXMpKSB7IGlmIChuZXdNYXBba2V5XSAhPSBudWxsKSB7IHBhcmFtc01hcFtrZXldID0gbmV3TWFwW2tleV07IH0gfVxyXG4gIGlmIChtb2RlbC5nZXQoY29uc3RzKCdLRVlfU0NSRUVOX0lPUycpKSkge1xyXG4gICAgcGFyYW1zTWFwW0hBU0hfS0VZX1JBTkRPTV0gPSAoXy51bmlxdWVJZCkoKTtcclxuICB9XHJcbiAgbGV0IHBhcmFtcyA9IF8ubWFwVG9FbmNvZGVkU3RyaW5nKHBhcmFtc01hcCk7XHJcbiAgaWYgKHBhcmFtcy5sZW5ndGggPiAwKSB7IHBhcmFtcyA9IGA/JHtwYXJhbXN9YDsgfVxyXG5cclxuICByZXR1cm4gYCR7ZmlsZVBhdGh9JHtwYXJhbXN9JHtib29rTWFya31gO1xyXG59O1xyXG5cclxuY29uc3QgeyBxdWV1ZVVwZGF0ZUhhc2hNYXAgfSA9IF87XHJcblxyXG5jb25zdCBmaXhIYXNoTWFwRm9yVG9waWMgPSBmdW5jdGlvbihoYXNoTWFwKSB7XHJcbiAgaWYgKGhhc2hNYXAgPT0gbnVsbCkgeyBoYXNoTWFwID0ge307IH1cclxuICBoYXNoTWFwW0hBU0hfS0VZX1VJTU9ERV0gPSBudWxsO1xyXG4gIGhhc2hNYXBbSEFTSF9LRVlfUkFORE9NXSA9IG51bGw7XHJcbiAgaWYgKCFoYXNoTWFwW0hBU0hfS0VZX1JIX1RPQ0lEXSkgeyBoYXNoTWFwW0hBU0hfS0VZX1JIX1RPQ0lEXSA9IG51bGw7IH1cclxuICBpZiAoIWhhc2hNYXBbSEFTSF9LRVlfUkhfSElHSExJR0hUXSkgeyBoYXNoTWFwW0hBU0hfS0VZX1JIX0hJR0hMSUdIVF0gPSBudWxsOyB9XHJcbiAgcmV0dXJuIGhhc2hNYXA7XHJcbn07XHJcblxyXG5cclxuXHJcbmNvbnN0IHNob3dUb3BpYyA9IGZ1bmN0aW9uKHJlbFVybCwgYWRkVG9IaXN0b3J5KSB7XHJcbiAgcmVsVXJsID0gXy5maXhSZWxhdGl2ZVVybChyZWxVcmwpO1xyXG4gIGxldCBoYXNoTWFwID0gXy51cmxQYXJhbXMoXy5leHRyYWN0UGFyYW1TdHJpbmcocmVsVXJsKSk7XHJcbiAgaGFzaE1hcFtIQVNIX0tFWV9UT1BJQ10gPSBfLnN0cmlwUGFyYW0ocmVsVXJsKTtcclxuICBoYXNoTWFwID0gZml4SGFzaE1hcEZvclRvcGljKGhhc2hNYXApO1xyXG4gIHJldHVybiBxdWV1ZVVwZGF0ZUhhc2hNYXAoaGFzaE1hcCwgYWRkVG9IaXN0b3J5KTtcclxufTtcclxuXHJcblxyXG5jb25zdCBzaG93Tm9uVG9waWMgPSBmdW5jdGlvbih1cmwsIGFkZFRvSGlzdG9yeSkge1xyXG4gIGxldCBoYXNoTWFwID0ge307XHJcbiAgaGFzaE1hcFtIQVNIX0tFWV9UT1BJQ10gPSAgdXJsO1xyXG4gIGhhc2hNYXAgPSBmaXhIYXNoTWFwRm9yVG9waWMoaGFzaE1hcCk7XHJcbiAgcmV0dXJuIHF1ZXVlVXBkYXRlSGFzaE1hcChoYXNoTWFwLCBhZGRUb0hpc3RvcnkpO1xyXG59O1xyXG5cclxuKHtpc1NhbWVUb3BpYyh1cmwxLCB1cmwyKSB7fX0pO1xyXG5cclxuLy9FdmVudCBIYW5kbGVyc1xyXG5cclxuY29uc3QgaGFzaENoYW5nZWQgPSBmdW5jdGlvbihvYmopIHtcclxuICBsZXQgc2VhcmNoVGVybUNoYW5nZWQ7XHJcbiAgY29uc3QgeyBuZXdNYXAgfSA9IG9iajtcclxuICBjb25zdCB7IG9sZE1hcCB9ID0gb2JqO1xyXG4gIGNvbnN0IG9sZFVpTW9kZSA9IG9sZE1hcFtIQVNIX0tFWV9VSU1PREVdO1xyXG4gIGNvbnN0IHVpTW9kZSA9IG5ld01hcFtIQVNIX0tFWV9VSU1PREVdO1xyXG5cclxuICByZXR1cm4gXy5nZXREZWZhdWx0VG9waWMoZGVmYXVsdFRvcGljID0+XHJcbiAge1xyXG4gICAgaWYgKEhBU0hfS0VZX1JIX1NFQVJDSCBpbiBuZXdNYXApXHJcbiAgICB7XHJcbiAgICAgIGNvbnN0IHNlYXJjaFRlcm0gPSBuZXdNYXBbSEFTSF9LRVlfUkhfU0VBUkNIXTtcclxuICAgICAgc2VhcmNoVGVybUNoYW5nZWQgPSBzZWFyY2hUZXJtICE9PSBtb2RlbC5nZXQoY29uc3RzKCdLRVlfU0VBUkNIRURfVEVSTScpKTtcclxuICAgICAgbW9kZWwucHVibGlzaChjb25zdHMoJ0tFWV9TRUFSQ0hfVEVSTScpLCBzZWFyY2hUZXJtLCB7IHN5bmM6IHRydWUgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHVpTW9kZSA9PT0gJ3NlYXJjaCcpXHJcbiAgICB7XHJcbiAgICAgIGlmIChzZWFyY2hUZXJtQ2hhbmdlZCAmJiB3aW5kb3cuZ0hvc3QpXHJcbiAgICAgIHtcclxuICAgICAgICBtb2RlbC5wdWJsaXNoKGNvbnN0cygnRVZUX1FVRVJZX1NFQVJDSF9SRVNVTFRTJyksIHRydWUpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCF1aU1vZGUgfHwgbmV3TWFwW0hBU0hfS0VZX1RPUElDXSlcclxuICAgIHtcclxuICAgICAgbGV0IHRvcGljVXJsO1xyXG4gICAgICBjb25zdCBvbGRUb3BpY1VybCA9IG1vZGVsLmdldChjb25zdHMoJ0tFWV9UT1BJQ19JTl9JRlJBTUUnKSk7XHJcbiAgICAgIGlmIChIQVNIX0tFWV9UT1BJQyBpbiBuZXdNYXApIHsgdG9waWNVcmwgPSBuZXdNYXBbSEFTSF9LRVlfVE9QSUNdOyB9XHJcbiAgICAgIGlmICghdG9waWNVcmwpXHJcbiAgICAgIHtcclxuICAgICAgICB0b3BpY1VybCA9IG9sZFRvcGljVXJsO1xyXG4gICAgICB9XHJcbiAgICAgIGNvbnN0IGZlYXR1cmUgPSByaC5tb2RlbC5nZXQocmguY29uc3RzKCdLRVlfRkVBVFVSRScpKTtcclxuXHJcblxyXG4gICAgICBpZiAoIXRvcGljVXJsICYmICghZmVhdHVyZSB8fCBmZWF0dXJlLnNob3dEZWZUb3BpYyAhPT0gZmFsc2UpKVxyXG4gICAgICB7XHJcbiAgICAgICAgdG9waWNVcmwgPSBkZWZhdWx0VG9waWM7XHJcbiAgICAgIH1cclxuICAgICAgY29uc3QgY2hhbmdlZCA9IHRvcGljVXJsICYmICgodG9waWNVcmwgIT09IG9sZFRvcGljVXJsKSB8fFxyXG4gICAgICAgIChvbGRVaU1vZGUgIT09IHVpTW9kZSkgfHxcclxuICAgICAgICAob2xkTWFwW0hBU0hfS0VZX1JIX0hJR0hMSUdIVF0gIT09IG5ld01hcFtIQVNIX0tFWV9SSF9ISUdITElHSFRdKSB8fFxyXG4gICAgICAgIChvbGRNYXBbSEFTSF9LRVlfUkhfVE9DSURdICE9PSBuZXdNYXBbSEFTSF9LRVlfUkhfVE9DSURdKSk7XHJcbiAgICAgIGlmIChjaGFuZ2VkKVxyXG4gICAgICB7XHJcbiAgICAgICAgaWYgKF8uc3RyaXBCb29rbWFyayh0b3BpY1VybCkgIT09IF8uc3RyaXBCb29rbWFyayhvbGRUb3BpY1VybCkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXy5ydW5Ub3BpY0xvYWRpbmdBbmltYXRpb24odHJ1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG1vZGVsLnB1Ymxpc2goY29uc3RzKCdLRVlfVE9QSUNfSU5fSUZSQU1FJyksIHRvcGljVXJsKTtcclxuICAgICAgICB3aW5kb3cubG9hZFRvcGljKGdldFRvcGljVVJMKG5ld01hcCwgdG9waWNVcmwpKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBtb2RlbC5wdWJsaXNoKGNvbnN0cygnS0VZX1VJX01PREUnKSwgbmV3TWFwW0hBU0hfS0VZX1VJTU9ERV0pO1xyXG5cclxuICB9KVxyXG59O1xyXG5cclxuY29uc3QgdG9waWNDaGFuZ2VkID0gZnVuY3Rpb24odG9waWNVcmwpIHtcclxuICBjb25zdCBoYXNoTWFwID0gXy5oYXNoUGFyYW1zKCk7XHJcbiAgaWYgKHRvcGljVXJsICYmICFoYXNoTWFwW0hBU0hfS0VZX1VJTU9ERV0pIHtcclxuICAgIGNvbnN0IGRlY29kZWRVUkkgPSBkZWNvZGVVUkkoZG9jdW1lbnQubG9jYXRpb24uaHJlZik7XHJcbiAgICBjb25zdCByZWxVcmwgPSB3aW5kb3cuX2dldFJlbGF0aXZlRmlsZU5hbWUoZGVjb2RlZFVSSSwgdG9waWNVcmwpO1xyXG4gICAgY29uc3Qgb2xkVXJsID0gaGFzaE1hcFtIQVNIX0tFWV9UT1BJQ107XHJcbiAgICBpZiAoIW9sZFVybCB8fCAoXy5maWxlUGF0aChyZWxVcmwpICE9PSBfLmZpbGVQYXRoKG9sZFVybCkpKSB7XHJcbiAgICAgIG1vZGVsLnB1Ymxpc2goY29uc3RzKCdLRVlfVE9QSUNfSU5fSUZSQU1FJyksIHJlbFVybCk7XHJcbiAgICAgIHJldHVybiBzaG93VG9waWMocmVsVXJsLCBmYWxzZSk7XHJcbiAgICB9XHJcbiAgfVxyXG59O1xyXG5cclxuY29uc3Qgc3BsaXRQYXJhbXMgPSBmdW5jdGlvbiAocGFyYW1zKVxyXG57XHJcbiAgbGV0IHF1ZXJ5UGFyYW1zID0ge31cclxuICBsZXQgcXVlcnlQYXJhbUxpc3QgPSBbY29uc3RzKFwiUkhNQVBJRFwiKSwgY29uc3RzKFwiUkhNQVBOT1wiKSwgY29uc3RzKFwiUkhXSU5ET1dcIiksIGNvbnN0cyhcIlJIQ1NITU9ERVwiKSBdXHJcbiAgXy5lYWNoKHBhcmFtcywgKHZhbHVlLCBrZXkpID0+XHJcbiAgeyBcclxuICAgIGlmIChxdWVyeVBhcmFtTGlzdC5pbmNsdWRlcyhrZXkpKVxyXG4gICAgeyBcclxuICAgICAgcXVlcnlQYXJhbXNba2V5XSA9IHZhbHVlXHJcbiAgICAgIGRlbGV0ZSBwYXJhbXNba2V5XVxyXG4gICAgfSBcclxuICB9KVxyXG5cclxuICByZXR1cm4geyBxdWVyeVBhcmFtcywgaGFzaFBhcmFtczogcGFyYW1zIH1cclxufVxyXG5jb25zdCBuYXZpZ2F0ZVRvVXJsID0gZnVuY3Rpb24ob2JqKSB7XHJcbiAgbGV0IHVybCA9IG9iai5hYnNVcmw7XHJcbiAgaWYgKF8uaXNSb290VXJsKCkpIHtcclxuICAgIGlmIChfLmlzVXJsQWxsb3dkSW5JZnJhbWUodXJsKSkge1xyXG4gICAgICB1cmwgPSBfLm1ha2VSZWxhdGl2ZVVybChfLmZpeFJlbGF0aXZlVXJsKHVybCkpO1xyXG4gICAgICBpZihfLmlzSG9tZVVybCh1cmwpKXtcclxuICAgICAgICByZXR1cm4gZG9jdW1lbnQubG9jYXRpb24uaHJlZiA9IHVybFxyXG4gICAgICB9XHJcbiAgICAgIGNvbnN0IGZpbGVOYW1lID0gdXJsICYmIF8uZmlsZVBhdGgodXJsKTtcclxuICAgICAgaWYgKGZpbGVOYW1lID09PSBjb25zdHMoJ1NUQVJUX0ZJTEVQQVRIJykpIHtcclxuICAgICAgICB1cmwgPSB1cmwuc3Vic3RyaW5nKGZpbGVOYW1lLmxlbmd0aCk7IC8vbmV2ZXIgcGFzcyBzdGFydCBmaWxlIGluc2lkZSBpZnJhbWVcclxuICAgICAgfSBlbHNlIGlmICghdXJsKSB7XHJcbiAgICAgICAgdXJsID0gJyN1eCc7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICgodXJsWzBdID09PSAnIycpIHx8ICh1cmxbMF0gPT09ICc/JykpIHtcclxuICAgICAgICBjb25zdCBoYXNoTWFwID0gXy5oYXNoUGFyYW1zKF8uZXh0cmFjdEhhc2hTdHJpbmcodXJsKSk7XHJcbiAgICAgICAgaWYgKCEoSEFTSF9LRVlfVUlNT0RFIGluIGhhc2hNYXApKSB7IGhhc2hNYXBbSEFTSF9LRVlfVUlNT0RFXSA9IG51bGw7IH1cclxuICAgICAgICByZXR1cm4gcXVldWVVcGRhdGVIYXNoTWFwKGhhc2hNYXAsIHRydWUpO1xyXG4gICAgICB9IGVsc2UgaWYgKHVybCkge1xyXG4gICAgICAgIHJldHVybiBzaG93VG9waWModXJsLCB0cnVlKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmV0dXJuIHNob3dOb25Ub3BpYyh1cmwsIHRydWUpO1xyXG4gICAgfVxyXG4gIH0gZWxzZSB7XHJcbiAgICBpZiAoIV8uaXNSb290VXJsKHVybCkpIHtcclxuICAgICAgbGV0IHBhcmFtcywgcmVsVXJsO1xyXG4gICAgICBjb25zdCByb290VXJsID0gXy5nZXRSb290VXJsKCk7XHJcbiAgICAgIGlmIChfLmlzRXh0ZXJuYWxVcmwodXJsKSkge1xyXG4gICAgICAgIHJlbFVybCA9IHVybDtcclxuICAgICAgfSBlbHNlXHJcbiAgICAgIHtcclxuICAgICAgICByZWxVcmwgPSBfLmZpeFJlbGF0aXZlVXJsKF8ubWFrZVJlbGF0aXZlUGF0aCh1cmwsIHJvb3RVcmwpKTtcclxuICAgICAgICBwYXJhbXMgPSBfLnVybFBhcmFtcyhfLmV4dHJhY3RQYXJhbVN0cmluZyhyZWxVcmwpKTtcclxuICAgICAgICBwYXJhbXNbSEFTSF9LRVlfVE9QSUNdID0gXy5zdHJpcFBhcmFtKHJlbFVybCk7XHJcbiAgICAgICAgcGFyYW1zID0gZml4SGFzaE1hcEZvclRvcGljKHBhcmFtcyk7XHJcbiAgICAgICAgbGV0IHsgcXVlcnlQYXJhbXMsIGhhc2hQYXJhbXMgfSA9IHNwbGl0UGFyYW1zKHBhcmFtcylcclxuICAgICAgICB1cmwgPSBgJHtyb290VXJsfT8ke18ubWFwVG9FbmNvZGVkU3RyaW5nKHF1ZXJ5UGFyYW1zKX0jJHtfLm1hcFRvRW5jb2RlZFN0cmluZyhoYXNoUGFyYW1zKX1gO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZG9jdW1lbnQubG9jYXRpb24uaHJlZiA9IHVybDtcclxuICB9XHJcbn07XHJcblxyXG5tb2RlbC5zdWJzY3JpYmUoY29uc3RzKCdFVlRfV0lER0VUX0xPQURFRCcpLCBmdW5jdGlvbigpIHtcclxuICBfLmFkZEV2ZW50TGlzdGVuZXIoZG9jdW1lbnQsICdjbGljaycsIF8uaG9va0NsaWNrKTtcclxuXHJcbiAgbW9kZWwuc3Vic2NyaWJlKGNvbnN0cygnRVZUX0hBU0hfQ0hBTkdFJyksIGhhc2hDaGFuZ2VkKTtcclxuXHJcbiAgbW9kZWwuc3Vic2NyaWJlKGNvbnN0cygnS0VZX1RPUElDX1VSTCcpLCB0b3BpY0NoYW5nZWQpO1xyXG5cclxuICBtb2RlbC5zdWJzY3JpYmUoY29uc3RzKCdFVlRfTkFWSUdBVEVfVE9fVVJMJyksIG5hdmlnYXRlVG9VcmwpO1xyXG5cclxuICAvLyBjYWxsIHRvIHVwZGF0ZSBvbGQgbGF5b3V0IHNwZWNpZmljIHZhcmlhYmxlc1xyXG4gIG1vZGVsLnN1YnNjcmliZShjb25zdHMoJ0tFWV9UT1BJQ19JTl9JRlJBTUUnKSwgZnVuY3Rpb24odG9waWNVcmwpIHtcclxuICAgIGlmIChgJHt3aW5kb3cuZ0hvc3R9JHt3aW5kb3cuZ0hvc3RQYXRofWAgIT09ICcvJykgeyAvLyB3YWl0IHRvIHJlc29sdmUgZ0hvc3RQYXRoXHJcbiAgICAgIGlmICh3aW5kb3cuc2V0VG9waWMpIHsgKHdpbmRvdy5zZXRUb3BpYykoKTsgfVxyXG4gICAgICBpZiAod2luZG93LmNoYW5nZVRvcGljTGluaykge1xyXG4gICAgICAgIHJldHVybiB3aW5kb3cuY2hhbmdlVG9waWNMaW5rKGRvY3VtZW50LmxvY2F0aW9uLnRvU3RyaW5nKCkpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSk7XHJcblxyXG4gIG1vZGVsLnN1YnNjcmliZShjb25zdHMoJ0VWVF9UT1BJQ19MT0FERUQnKSwgKCkgPT4gXy5ydW5Ub3BpY0xvYWRpbmdBbmltYXRpb24oZmFsc2UpKTtcclxuXHJcbiAgcmV0dXJuIG1vZGVsLnN1YnNjcmliZShjb25zdHMoJ0VWVF9JTlNJREVfSUZSQU1FX0RPTV9DT05URU5UTE9BREVEJyksICgpID0+IF8ucnVuVG9waWNMb2FkaW5nQW5pbWF0aW9uKGZhbHNlKSk7XHJcbn0pO1xyXG4iLCJsZXQgeyByaCB9ID0gd2luZG93O1xyXG5sZXQgeyBtb2RlbCB9ID0gcmg7XHJcbmxldCB7IF8gfSA9IHJoO1xyXG5sZXQgeyBjb25zdHMgfSA9IHJoO1xyXG5sZXQgeyBhcGlDbGllbnQgfSA9IHJoO1xyXG5cclxuXHJcbnZhciBHbG9zc2FyeUNvbnRyb2xsZXIgPSAoZnVuY3Rpb24oKSB7XHJcbiAgbGV0IGVudHJ5cyA9IHVuZGVmaW5lZDtcclxuICBHbG9zc2FyeUNvbnRyb2xsZXIgPSBjbGFzcyBHbG9zc2FyeUNvbnRyb2xsZXIgZXh0ZW5kcyByaC5OYXZDb250cm9sbGVyIHtcclxuICAgIHN0YXRpYyBpbml0Q2xhc3MoKSB7XHJcbiAgXHJcbiAgICAgIGVudHJ5cyA9ICdlbnRyeXMnO1xyXG4gICAgfVxyXG4gICAgY29uc3RydWN0b3Iod2lkZ2V0KSB7XHJcbiAgICAgIHN1cGVyKCk7XHJcbiAgICAgIHRoaXMuZGF0YSA9IFtdO1xyXG4gICAgICB0aGlzLmNodW5rQ291bnQgPSAwO1xyXG4gICAgICB0aGlzLmNvdW50ID0gMDtcclxuICAgICAgdGhpcy5rZXlzID0gJyc7XHJcbiAgICAgIHRoaXMuYWxocGFiZXQgPSAnJztcclxuICAgICAgdGhpcy5sb2FkTmF2RGF0YSgnZ2xvJyk7XHJcbiAgICAgIHRoaXMuZmlsdGVyID0gJyc7XHJcbiAgICAgIHRoaXMud2lkZ2V0ID0gd2lkZ2V0O1xyXG4gICAgICB0aGlzLndpZGdldC5wdWJsaXNoKCdzaG93Jywge30pO1xyXG4gICAgfVxyXG5cclxuICAgIGFkZEVsZW1lbnQoZWxlbWVudHMsIGxpc3QpIHtcclxuICAgICAgcmV0dXJuICgoKSA9PiB7XHJcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xyXG4gICAgICAgIF8uZWFjaChlbGVtZW50c1tlbnRyeXNdLCAoZWxlbWVudCkgPT4ge1xyXG4gICAgICAgICAgaWYgKGVsZW1lbnQgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMubG9va3VwKGxpc3QsIGVsZW1lbnQpKSB7XHJcbiAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobGlzdC5wdXNoKGVsZW1lbnQpKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICByZXN1bHQucHVzaCh1bmRlZmluZWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSwgdGhpcyk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgfSkoKTtcclxuICAgIH1cclxuXHJcbiAgICBnZXRFc2NhcGVkU3RyaW5nKHN0cikge1xyXG4gICAgICByZXR1cm4gc3RyLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKS5yZXBsYWNlKC9cXFxcXFxcXC9nLCAnXFxcXCcpXHJcbiAgICB9XHJcblxyXG4gICAgZXhpc3RzKG5hbWUpIHtcclxuICAgICAgbGV0IGNoID0gdGhpcy5hbHBoYVRleHQobmFtZSk7XHJcbiAgICAgIGlmICh0aGlzLmFsaHBhYmV0LmluZGV4T2YoY2gpID4gLTEpIHsgcmV0dXJuIHRydWU7IH1cclxuICAgICAgdGhpcy5hbGhwYWJldCArPSBjaDtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIGlzRmlsdGVyZWQobmFtZSwgbW9kZWxLZXkpIHtcclxuICAgICAgbGV0IGZpbHRlciA9IG1vZGVsS2V5ID8gbW9kZWwuZ2V0KG1vZGVsS2V5KSA6IHRoaXMuZmlsdGVyO1xyXG4gICAgICByZXR1cm4gZmlsdGVyICYmXHJcbiAgICAgICAobmFtZS50b0xvY2FsZUxvd2VyQ2FzZSgpLmluZGV4T2YoZmlsdGVyLnRvTG9jYWxlTG93ZXJDYXNlKCkpID09PSAtMSk7XHJcbiAgICB9XHJcblxyXG4gICAgYWxwaGFUZXh0KG5hbWUpIHtcclxuICAgICAgcmV0dXJuIG5hbWUudG9VcHBlckNhc2UoKS5jaGFyQXQoMCk7XHJcbiAgICB9XHJcblxyXG4gICAgZmlsdGVyR2xvKHZhbHVlKSB7XHJcbiAgICAgIHRoaXMuZmlsdGVyID0gdmFsdWUudG9Mb2NhbGVMb3dlckNhc2UoKTtcclxuICAgICAgdGhpcy5hbGhwYWJldCA9ICcnO1xyXG4gICAgICByZXR1cm4gbW9kZWwucHVibGlzaChjb25zdHMoJ1BST0pFQ1RfR0xPU1NBUllfREFUQScpLFxyXG4gICAgICAgbW9kZWwuZ2V0KGNvbnN0cygnUFJPSkVDVF9HTE9TU0FSWV9EQVRBJykpKTtcclxuICAgIH1cclxuICB9O1xyXG4gIEdsb3NzYXJ5Q29udHJvbGxlci5pbml0Q2xhc3MoKTtcclxuICByZXR1cm4gR2xvc3NhcnlDb250cm9sbGVyO1xyXG59KSgpO1xyXG5cclxuXHJcblxyXG5yaC5jb250cm9sbGVyKCdHbG9zc2FyeUNvbnRyb2xsZXInLCBHbG9zc2FyeUNvbnRyb2xsZXIpOyIsImxldCB7IHJoIH0gPSB3aW5kb3c7XHJcbmxldCB7IG1vZGVsIH0gPSByaDtcclxubGV0IHsgXyB9ID0gcmg7XHJcbmxldCB7IGNvbnN0cyB9ID0gcmg7XHJcbmxldCB7IGFwaUNsaWVudCB9ID0gcmg7XHJcbmxldCB7IHJocyB9ID0gcmg7XHJcbmxldCB0b3BpY3MgPSAndG9waWNzJztcclxuXHJcblxyXG5jbGFzcyBOYXZDb250cm9sbGVyIHtcclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIHRoaXMudXBkYXRlRGF0YSA9IHRoaXMudXBkYXRlRGF0YS5iaW5kKHRoaXMpO1xyXG4gIH1cclxuXHJcbiAgbG9va3VwKGNoaWxkcmVuLCBrZXkpIHtcclxuICAgIGxldCBlbGVtZW50O1xyXG4gICAgaWYgKChjaGlsZHJlbiAhPSBudWxsKSAmJiAoa2V5ICE9IG51bGwpKSB7XHJcbiAgICAgIF8uYW55KGNoaWxkcmVuLCAoY2hpbGQpID0+ICB7XHJcbiAgICAgICAgaWYgKGNoaWxkICE9IG51bGwpIHtcclxuICAgICAgICAgIGlmICgoa2V5LnR5cGUgPT09IGNoaWxkLnR5cGUpICYmIChrZXkubmFtZSA9PT0gY2hpbGQubmFtZSkgJiZcclxuICAgICAgICAgIF8uaXNFcXVhbChrZXkudXJsLCBjaGlsZC51cmwpKSB7XHJcbiAgICAgICAgICAgIGVsZW1lbnQgPSBjaGlsZDtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHJldHVybiBlbGVtZW50ICE9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICB9LCB0aGlzKTtcclxuICAgIH1cclxuICAgIHJldHVybiBlbGVtZW50O1xyXG4gIH1cclxuXHJcbiAgc29ydChhcnJheSkge1xyXG4gICAgcmV0dXJuIGFycmF5LnNvcnQoKGZpcnN0LCBzZWNvbmQpID0+IHdpbmRvdy5jb21wYXJlKGZpcnN0Lm5hbWUsIHNlY29uZC5uYW1lKSk7XHJcbiAgfVxyXG5cclxuICB1cGRhdGVEYXRhKGV2ZW50LCBjb25zdEtleSwgcHJvamVjdFVybCkge1xyXG4gICAgbGV0IGN1ckRhdGEgPSBfLmV4dHJhY3RUZW1wRGF0YShldmVudCwgdGhpcy53aWRnZXQsIHt9KTtcclxuICAgIHRoaXMuYWRkRWxlbWVudChjdXJEYXRhLCB0aGlzLmRhdGEsIHByb2plY3RVcmwsIHRoaXMua2V5cyk7XHJcbiAgICBpZiAoKC0tdGhpcy5jaHVua0NvdW50ID09PSAwKSAmJiAodGhpcy5jb3VudCA9PT0gMCkpIHtcclxuICAgICAgaWYgKGNvbnN0S2V5ID09PSAnUFJPSkVDVF9JTkRFWF9EQVRBJykge1xyXG4gICAgICAgIHRoaXMuZGF0YSA9IHRoaXMuc29ydEluZGV4RGF0YSh0aGlzLmRhdGEpXHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5zb3J0KHRoaXMuZGF0YSlcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gbW9kZWwucHVibGlzaChjb25zdHMoY29uc3RLZXkpLCB0aGlzLmRhdGEpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgc29ydEluZGV4RGF0YShkYXRhKSB7IFxyXG4gICAgbGV0IGdycGVkRGF0YSA9IF8uZ3JvdXBCeShkYXRhLCAnbmFtZScpXHJcbiAgICBsZXQgbWVyZ2VkRGF0YSA9IF8ubWFwKGdycGVkRGF0YSwga2V5V3JkSXRlbXMgPT4gdGhpcy5tZXJnZWRLZXlXb3JkcyhrZXlXcmRJdGVtcykpXHJcbiAgICByZXR1cm4gbWVyZ2VkRGF0YSA9IHRoaXMuc29ydChtZXJnZWREYXRhKVxyXG4gIH1cclxuXHJcbiAgbWVyZ2VkS2V5V29yZHMoa2V5V3JkSXRlbXMpIHtcclxuICAgIHJldHVybiBfLnJlZHVjZShrZXlXcmRJdGVtcywgKHJlc3VsdCwgaXRlbSkgPT4ge1xyXG4gICAgICByZXN1bHQubmFtZSA9IGl0ZW0ubmFtZVxyXG4gICAgICByZXN1bHQudHlwZSA9IGl0ZW0udHlwZVxyXG4gICAgICByZXN1bHQudXJsID0gaXRlbS51cmxcclxuICAgICAgcmVzdWx0WydkYXRhLXJodGFncyddID0gaXRlbVsnZGF0YS1yaHRhZ3MnXVxyXG4gICAgICBpZiAoaXRlbS50eXBlID09PSAna2V5Jykge1xyXG4gICAgICAgIHJlc3VsdC50b3BpY3MgPSB0aGlzLnNvcnRJbmRleERhdGEoKHJlc3VsdC50b3BpY3MgfHwgW10pLmNvbmNhdChpdGVtLnRvcGljcyB8fCBbXSkpXHJcbiAgICAgICAgcmVzdWx0LmtleXMgPSB0aGlzLnNvcnRJbmRleERhdGEoKHRoaXMuZ2V0S2V5cyhyZXN1bHQpKS5jb25jYXQoaXRlbS5rZXlzIHx8IFtdKSlcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gcmVzdWx0XHJcbiAgICB9LCB7fSlcclxuICB9XHJcblxyXG4gIGdldEtleXMocmVzdWx0KSB7XHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheShyZXN1bHQua2V5cykpIHsgXHJcbiAgICAgIHJldHVybiByZXN1bHQua2V5c1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFtdXHJcbiAgfVxyXG5cclxuICBnZXRDaHVua0RhdGEoZXZlbnQsIHByb2plY3RVcmwsIGtleSkge1xyXG4gICAgdGhpcy5jb3VudC0tO1xyXG4gICAgbGV0IHRlbXBEYXRhID0gXy5leHRyYWN0VGVtcERhdGEoZXZlbnQsIHRoaXMud2lkZ2V0LCB7fSk7XHJcbiAgICBsZXQgYXJyID0gX19ndWFyZF9fKHRlbXBEYXRhLCB4ID0+IHhbJ2NodW5raW5mb3MnXSkgfHwgW107XHJcbiAgICB0aGlzLmNodW5rQ291bnQgKz0gYXJyLmxlbmd0aDtcclxuICAgIHJldHVybiBfLmVhY2goYXJyLCBmdW5jdGlvbihjaHVuaykge1xyXG4gICAgICBpZiAocHJvamVjdFVybCkgeyBwcm9qZWN0VXJsID0gXy5lbnN1cmVTbGFzaChwcm9qZWN0VXJsKTsgfVxyXG4gICAgICByZXR1cm4gXy5sb2FkU2NyaXB0KGAke3Byb2plY3RVcmx9d2h4ZGF0YS8ke2NodW5rLm5vZGV9Lm5ldy5qc2AsXHJcbiAgICAgICAgZmFsc2UsIChldmVudCkgPT4ge1xyXG4gICAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlRGF0YShldmVudCwga2V5LCBwcm9qZWN0VXJsKTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAsIHRoaXMpO1xyXG4gIH1cclxuXHJcbiAgbG9hZE5hdkRhdGEodHlwZSkge1xyXG4gICAgcmV0dXJuIG1vZGVsLnN1YnNjcmliZShjb25zdHMoJ0tFWV9QUk9KRUNUX0xJU1QnKSwgbGlzdCA9PiB7XHJcbiAgICAgIHRoaXMuYWxocGFiZXQgPSAnJztcclxuICAgICAgdGhpcy5jb3VudCArPSBsaXN0Lmxlbmd0aDtcclxuICAgICAgcmV0dXJuIF8uZWFjaChsaXN0LCBmdW5jdGlvbihwcm9qZWN0VXJsKSB7XHJcbiAgICAgICAgaWYgKHByb2plY3RVcmwpIHsgcHJvamVjdFVybCA9IF8uZW5zdXJlU2xhc2gocHJvamVjdFVybCk7IH1cclxuICAgICAgICByZXR1cm4gXy5sb2FkU2NyaXB0KGAke3Byb2plY3RVcmx9d2h4ZGF0YS9cXFxyXG4ke3R5cGUgPT09ICduZHgnID8gJ2lkeCcgOiAnZ2xvJ30ubmV3LmpzYCwgZmFsc2UsIChldmVudCkgPT4ge1xyXG4gICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q2h1bmtEYXRhKGV2ZW50LCBwcm9qZWN0VXJsLCB0eXBlID09PSAnbmR4JyA/ICdQUk9KRUNUX0lOREVYX0RBVEEnXHJcbiAgICAgICAgICA6ICdQUk9KRUNUX0dMT1NTQVJZX0RBVEEnXHJcbiAgICAgICAgICApO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICAgICwgdGhpcyk7XHJcbiAgICB9KTtcclxuICB9XHJcbn1cclxuXHJcbnJoLk5hdkNvbnRyb2xsZXIgPSBOYXZDb250cm9sbGVyO1xyXG5cclxudmFyIEluZGV4Q29udHJvbGxlciA9IChmdW5jdGlvbigpIHtcclxuICBsZXQgZGVmUHJvamVjdCA9IHVuZGVmaW5lZDtcclxuICBJbmRleENvbnRyb2xsZXIgPSBjbGFzcyBJbmRleENvbnRyb2xsZXIgZXh0ZW5kcyByaC5OYXZDb250cm9sbGVyIHtcclxuICAgIHN0YXRpYyBpbml0Q2xhc3MoKSB7XHJcbiAgICAgIGRlZlByb2plY3QgPSAnJztcclxuICAgIH1cclxuICAgIGNvbnN0cnVjdG9yKHdpZGdldCkge1xyXG4gICAgICBzdXBlcigpO1xyXG4gICAgICB0aGlzLmRhdGEgPSBbXTtcclxuICAgICAgdGhpcy5jaHVua0NvdW50ID0gMDtcclxuICAgICAgdGhpcy5jb3VudCA9IDA7XHJcbiAgICAgIHRoaXMuYWxocGFiZXQgPSAnJztcclxuICAgICAgdGhpcy5maWx0ZXIgPSAnJztcclxuICAgICAgdGhpcy5rZXlzID0gJ2tleXMnO1xyXG4gICAgICB0aGlzLndpZGdldCA9IHdpZGdldDtcclxuXHJcbiAgICAgIG1vZGVsLnN1YnNjcmliZU9uY2UoY29uc3RzKCdFVlRfUFJPSkVDVF9MT0FERUQnKSwgKCkgPT4ge1xyXG4gICAgICAgIHRoaXMubG9hZE5hdkRhdGEoJ25keCcpO1xyXG4gICAgICAgICh0aGlzLmdldEluZGV4RGF0YSkoKTtcclxuICAgICAgICByZXR1cm4gbW9kZWwuc3Vic2NyaWJlKGNvbnN0cygnS0VZX0lOREVYX0ZJTFRFUicpLCAoKSA9PiB7XHJcbiAgICAgICAgICByZXR1cm4gdGhpcy5hbGhwYWJldCA9ICcnO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgYWRkRWxlbWVudChlbGVtZW50LCBsaXN0LCBwcm9qZWN0VXJsLCBkYXRhKSB7XHJcbiAgICAgIGlmIChlbGVtZW50W2RhdGFdICE9IG51bGwpIHtcclxuICAgICAgICByZXR1cm4gKCgpID0+IHtcclxuICAgICAgICAgIGxldCByZXN1bHQgPSBbXTtcclxuICAgICAgICAgIF8uZWFjaChlbGVtZW50W2RhdGFdLCAoY2hpbGQpID0+IHtcclxuICAgICAgICAgICAgaWYgKGNoaWxkICE9IG51bGwpIHt2YXIgZXhpc3Rpbmc7XHJcblxyXG4gICAgICAgICAgICAgIGlmICghKGV4aXN0aW5nID0gdGhpcy5sb29rdXAobGlzdCwgY2hpbGQpKSkge1xyXG4gICAgICAgICAgICAgICAgbGV0IG9iaiA9IHt0eXBlOiBjaGlsZC50eXBlLCBuYW1lOiBjaGlsZC5uYW1lfTtcclxuICAgICAgICAgICAgICAgIGlmIChjaGlsZFsnZGF0YS1yaHRhZ3MnXSkge1xyXG4gICAgICAgICAgICAgICAgICBvYmpbJ2RhdGEtcmh0YWdzJ10gPSBgJHtjaGlsZFsnZGF0YS1yaHRhZ3MnXX0rJHtwcm9qZWN0VXJsfWA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoIWNoaWxkLnVybCkgeyBvYmpbdG9waWNzXSA9IFtdOyB9XHJcbiAgICAgICAgICAgICAgICBsZXQgcmVsVXJsID0gXy5tYWtlUmVsYXRpdmVVcmwoYCR7cHJvamVjdFVybH1gLCBkZWZQcm9qZWN0KTtcclxuICAgICAgICAgICAgICAgIGlmIChjaGlsZC51cmwgIT0gbnVsbCkgeyBvYmoudXJsID0gYCR7ZW5jb2RlVVJJKHJlbFVybCl9JHtjaGlsZC51cmx9YDsgfVxyXG4gICAgICAgICAgICAgICAgaWYgKChjaGlsZC51cmwgPT0gbnVsbCkpIHsgb2JqW3RoaXMua2V5c10gPSBbXTsgfVxyXG4gICAgICAgICAgICAgICAgbGlzdC5wdXNoKG9iaik7XHJcbiAgICAgICAgICAgICAgICBleGlzdGluZyA9IGxpc3RbbGlzdC5sZW5ndGggLSAxXTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgdGhpcy5hZGRFbGVtZW50KGNoaWxkLCBleGlzdGluZ1t0aGlzLmtleXNdLCBwcm9qZWN0VXJsLCB0aGlzLmtleXMpO1xyXG4gICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoaXMuYWRkRWxlbWVudChjaGlsZCwgZXhpc3RpbmdbdG9waWNzXSwgcHJvamVjdFVybCwgdG9waWNzKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0sIHRoaXMpO1xyXG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9KSgpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG5cclxuICAgIHNob3dJdGVtKG5hbWUpIHtcclxuICAgICAgbGV0IGZpbHRlciA9IG1vZGVsLmdldChjb25zdHMoJ0tFWV9JTkRFWF9GSUxURVInKSk7XHJcbiAgICAgIHJldHVybiAhZmlsdGVyIHx8XHJcbiAgICAgICAobmFtZS50b0xvY2FsZUxvd2VyQ2FzZSgpLmluZGV4T2YoZmlsdGVyLnRvTG9jYWxlTG93ZXJDYXNlKCkpICE9PSAtMSk7XHJcbiAgICB9XHJcblxyXG4gICAgc2hvd0NhdGVnb3J5KG5hbWUsIGxldmVsKSB7XHJcbiAgICAgIGlmIChsZXZlbCA+IDApIHsgcmV0dXJuIGZhbHNlOyB9XHJcbiAgICAgIGxldCBjaCA9IHRoaXMuYWxwaGFUZXh0KG5hbWUpO1xyXG4gICAgICBpZiAodGhpcy5hbGhwYWJldC5pbmRleE9mKGNoKSA+IC0xKSB7IHJldHVybiBmYWxzZTsgfVxyXG4gICAgICB0aGlzLmFsaHBhYmV0ICs9IGNoO1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICBzaG93TmV4dExldmVsKG5vZGUpIHtcclxuICAgICAgbGV0IGlkID0gbm9kZS5nZXRBdHRyaWJ1dGUoJ2RhdGEtaW5kZXhpZCcpO1xyXG4gICAgICBsZXQgb2xkID0gdGhpcy53aWRnZXQuZ2V0KGBzaG93LiR7aWR9YCk7XHJcbiAgICAgIGxldCBjaGlsZERhdGEgPSB7W2lkXTogIW9sZH07XHJcbiAgICAgIHdoaWxlIChpZCkge1xyXG4gICAgICAgIGlkID0gaWQuc3Vic3RyKDAsIGlkLmxhc3RJbmRleE9mKCdfJykpO1xyXG4gICAgICAgIGNoaWxkRGF0YVtpZF0gPSB0cnVlO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB0aGlzLndpZGdldC5wdWJsaXNoKCdzaG93JywgY2hpbGREYXRhKTtcclxuICAgIH1cclxuXHJcbiAgICBhbHBoYVRleHQobmFtZSkge1xyXG4gICAgICByZXR1cm4gbmFtZS50b1VwcGVyQ2FzZSgpLmNoYXJBdCgwKTtcclxuICAgIH1cclxuXHJcbiAgICBnZXRJbmRleERhdGEoKSB7XHJcbiAgICAgIHJldHVybiBtb2RlbC5zdWJzY3JpYmVPbmNlKGNvbnN0cygnS0VZX1BVQkxJU0hfQkFTRV9VUkwnKSwgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIGxldCBiYXNlVXJsID0gbW9kZWwuZ2V0KGNvbnN0cygnS0VZX1BVQkxJU0hfQkFTRV9VUkwnKSk7XHJcbiAgICAgICAgICBsZXQgYmFzZVVybFBhcnRzID0gcmguXy5zcGxpdFVybChiYXNlVXJsKTtcclxuICAgICAgICAgIGxldCBiYXNlQ29udGV4dCA9IGJhc2VVcmxQYXJ0cy5wYXRobmFtZTtcclxuICAgICAgICAgIGlmIChiYXNlQ29udGV4dCAmJiAhXy5pc0VtcHR5U3RyaW5nKGJhc2VDb250ZXh0KSkge1xyXG4gICAgICAgICAgICBsZXQgaGFzaFN0cmluZyA9IF8ubWFwVG9FbmNvZGVkU3RyaW5nKF8uZXh0ZW5kKF8uYWRkUGF0aE5hbWVLZXkoe2FyZWE6IHJocy5hcmVhKCksXHJcbiAgICAgICAgICAgIHByajogcmhzLnByb2plY3QoKSwgdHlwZTogKHJocy50eXBlKSgpLCBhZ3Q6ICduZHgnLCBtZ3I6ICdhZ20nXHJcbiAgICAgICAgICAgIH0pKVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICByZXR1cm4gYXBpQ2xpZW50LmdldChgJHtiYXNlQ29udGV4dH0/JHtoYXNoU3RyaW5nfWApLnN1Y2Nlc3MoZnVuY3Rpb24oZGF0YSwgc3RhdHVzKSB7XHJcbiAgICAgICAgICAgICAgZGF0YSA9IEpTT04ucGFyc2UoZGF0YSk7XHJcbiAgICAgICAgICAgICAgbGV0IGxpc3QgPSBbXTtcclxuICAgICAgICAgICAgICBsZXQgcm9vdFByanMgPSBbXTtcclxuICAgICAgICAgICAgICBsZXQgcHJvamVjdHMgPSBkYXRhLmFsbFByb2plY3RzO1xyXG4gICAgICAgICAgICAgIGxldCB7IG1hc3RlclByb2plY3RzIH0gPSBkYXRhO1xyXG4gICAgICAgICAgICAgIGlmIChwcm9qZWN0cy5sZW5ndGgpIHsgcHJvamVjdHNbMF0gPSBfLmVuc3VyZVNsYXNoKHByb2plY3RzWzBdKTsgfVxyXG4gICAgICAgICAgICAgIGxldCBtYWtlbGlzdCA9IChwcm9qZWN0TGlzdCwgb3V0TGlzdCkgPT5cclxuICAgICAgICAgICAgICAgIF8uZWFjaChwcm9qZWN0TGlzdCwgaXRlbSA9PiBvdXRMaXN0LnB1c2goXy5tYWtlUmVsYXRpdmVVcmwoaXRlbSwgcHJvamVjdHNbMF0pKSlcclxuICAgICAgICAgICAgICA7XHJcbiAgICAgICAgICAgICAgbWFrZWxpc3QocHJvamVjdHMsIGxpc3QpO1xyXG4gICAgICAgICAgICAgIG1ha2VsaXN0KG1hc3RlclByb2plY3RzLCByb290UHJqcyk7XHJcbiAgICAgICAgICAgICAgdmFyIHVwZGF0ZUxpc3QgPSBmdW5jdGlvbihpdGVtLGluZGV4LGxpc3QpIHtcclxuICAgICAgICAgICAgICAgIGlmKF8uaXNFbXB0eVN0cmluZyhpdGVtKSkge1xyXG4gICAgICAgICAgICAgICAgICBsaXN0W2luZGV4XSA9ICcuJztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgIF8uZWFjaChsaXN0LCB1cGRhdGVMaXN0KTtcclxuICAgICAgICAgICAgICBfLmVhY2gocm9vdFByanMsIHVwZGF0ZUxpc3QpO1xyXG4gICAgICAgICAgICAgIG1vZGVsLnB1Ymxpc2goY29uc3RzKCdLRVlfUFJPSkVDVF9MSVNUJyksIGxpc3QpO1xyXG4gICAgICAgICAgICAgIHJldHVybiBtb2RlbC5wdWJsaXNoKGNvbnN0cygnS0VZX01BU1RFUl9QUk9KRUNUX0xJU1QnKSwgcm9vdFByanMpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgIGlmIChyaC5fZGVidWcpIHsgcmV0dXJuIHJoLl9kKCd3YXJuJywgZXJyLm1lc3NhZ2UpOyB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9O1xyXG4gIEluZGV4Q29udHJvbGxlci5pbml0Q2xhc3MoKTtcclxuICByZXR1cm4gSW5kZXhDb250cm9sbGVyO1xyXG59KSgpO1xyXG5cclxuXHJcbnJoLmNvbnRyb2xsZXIoJ0luZGV4Q29udHJvbGxlcicsIEluZGV4Q29udHJvbGxlcik7XHJcblxyXG5mdW5jdGlvbiBfX2d1YXJkX18odmFsdWUsIHRyYW5zZm9ybSkge1xyXG4gIHJldHVybiAodHlwZW9mIHZhbHVlICE9PSAndW5kZWZpbmVkJyAmJiB2YWx1ZSAhPT0gbnVsbCkgPyB0cmFuc2Zvcm0odmFsdWUpIDogdW5kZWZpbmVkO1xyXG59XHJcbiIsImxldCByaCA9IHJlcXVpcmUoXCIuLi8uLi9zcmMvbGliL3JoXCIpXHJcbmxldCBfID0gcmguXztcclxuXHJcbl8uZmluZEVkaXREaXN0ID0gKGZpcnN0LCBzZWNvbmQpID0+e1xyXG4gICAgaWYoZmlyc3QgPT0gc2Vjb25kKVxyXG4gICAgICByZXR1cm4gMDtcclxuICAgIGxldCBwcmV2RGlzdD1bXTtcclxuICAgIGxldCBkaXN0PVtdO1xyXG4gICAgZm9yKHZhciBpPTA7aTxzZWNvbmQubGVuZ3RoKzE7aSsrKVxyXG4gICAge1xyXG4gICAgICBwcmV2RGlzdC5wdXNoKGkpO1xyXG4gICAgICBkaXN0LnB1c2goMCk7ICAgICAgIC8vanVzdCB0byBjcmVhdGUgYSBhcnJheSBvZiBzaXplIHNlY29uZC5sZW5ndGgrMVxyXG4gICAgfVxyXG5cclxuICBmb3IodmFyIGk9MDtpPGZpcnN0Lmxlbmd0aDtpKyspXHJcbiAge1xyXG4gICAgZGlzdFswXT1pKzE7XHJcblxyXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBzZWNvbmQubGVuZ3RoOyBqKyspXHJcbiAgICB7XHJcbiAgICAgICAgbGV0IGN1cnI7XHJcbiAgICAgICAgaWYoZmlyc3RbaV09PXNlY29uZFtqXSlcclxuICAgICAgICAgIGN1cnI9MDtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICBjdXJyPTE7XHJcblxyXG4gICAgICAgIGRpc3RbaiArIDFdID0gTWF0aC5taW4oZGlzdFtqXSArIDEsIHByZXZEaXN0W2ogKyAxXSArIDEsIHByZXZEaXN0W2pdICsgY3Vycik7XHJcbiAgICB9XHJcblxyXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBwcmV2RGlzdC5sZW5ndGg7IGorKykgICAgICAgICBcclxuICAgICAgcHJldkRpc3Rbal0gPSBkaXN0W2pdO1xyXG4gIH0gICBcclxuICByZXR1cm4gIGRpc3RbZGlzdC5sZW5ndGgtMV1cclxufTsiLCJjb25zdCBiaW5kID0gKGZuLCBtZSkgPT4gZnVuY3Rpb24oKXsgcmV0dXJuIGZuLmFwcGx5KG1lLCBhcmd1bWVudHMpOyB9O1xyXG5cclxubGV0IHJoID0gcmVxdWlyZShcIi4uLy4uL3NyYy9saWIvcmhcIilcclxubGV0IG5vZGVVdGlsID0gcmVxdWlyZSgnLi4vLi4vc3JjL3Jlc3BvbnNpdmVfaGVscC91dGlscy9ub2RlX3V0aWxzJylcclxubGV0IF8gPSByaC5fO1xyXG5sZXQgJCA9IHJoLiQ7XHJcbmxldCBtb2RlbCA9IHJoLm1vZGVsO1xyXG5sZXQgY29uc3RzID0gcmguY29uc3RzO1xyXG5sZXQgS0VZX1RPQ19EUklMTF9ET1dOID0gY29uc3RzKCdLRVlfVE9DX0RSSUxMX0RPV04nKTtcclxubGV0IEFOSU1fVElNRSA9IDcwMDtcclxubGV0IFN5bmNUb2M7XHJcbmxldCBUb2NDb250cm9sbGVyO1xyXG5cclxuU3luY1RvYyA9ICgoKCkgPT4ge1xyXG4gIGNsYXNzIFN5bmNUb2Mge1xyXG4gICAgc3luYyh0YywgaW5mbykge1xyXG4gICAgICBsZXQgbm9kZTtcclxuICAgICAgdGMudXBkYXRlQWN0aXZlQm9va0luZm8oMCwgJ18nKTtcclxuXHJcbiAgICAgIG5vZGUgPSB0Yy53aWRnZXQubm9kZTtcclxuICAgICAgLy90Yy51cGRhdGVCcmVhZGNydW1iSW5mbyh0Yy53aWRnZXQubm9kZSk7XHJcblxyXG4gICAgICB0aGlzLnJlc2V0KGluZm8pO1xyXG4gICAgICByZXR1cm4gdGhpcy5zeW5jVG9Qcm9qZWN0VG9jKHRjLCBub2RlLmNoaWxkcmVuLCAoKF90aGlzID0+IG5vZGVzID0+IF90aGlzLnN5bmNUb1RvY0l0ZW0odGMsIG5vZGVzKSkpKHRoaXMpKTtcclxuICAgIH1cclxuXHJcbiAgICByZXNldChpbmZvKSB7XHJcbiAgICAgIGxldCBpZHg7XHJcbiAgICAgIHRoaXMucGFyc2VUb2NJbmZvKGluZm8pO1xyXG4gICAgICBpZHggPSB0aGlzLm9yZGVyLmxhc3RJbmRleE9mKCdAJyk7XHJcbiAgICAgIHJldHVybiB0aGlzLnBhcmVudE9yZGVyID0gaWR4ICE9PSAtMSA/IHRoaXMub3JkZXIuc3Vic3RyaW5nKDAsIGlkeCkgOiAnJztcclxuICAgIH1cclxuXHJcbiAgICBwYXJzZVRvY0luZm8oaW5mbykge1xyXG4gICAgICBsZXQgcGF0aDtcclxuICAgICAgdGhpcy5vcmRlciA9IGluZm8uY2hpbGRPcmRlciB8fCAnJztcclxuICAgICAgcGF0aCA9IF8uc3BsaXRBbmRUcmltKGluZm8uY2hpbGRQcmVmaXgsICcuJyk7XHJcbiAgICAgIHRoaXMudG9jUGF0aCA9IF8ucmVkdWNlKHBhdGgsIChyZXN1bHQsIHByZWZpeCkgPT4ge1xyXG4gICAgICAgIGxldCBhcnIsIGJvb2tObztcclxuICAgICAgICBhcnIgPSBfLnNwbGl0QW5kVHJpbShwcmVmaXgsICdAJyk7XHJcbiAgICAgICAgaWYgKGJvb2tObyA9IGFyci5zaGlmdCgpKSB7XHJcbiAgICAgICAgICByZXN1bHQucHVzaCh7XHJcbiAgICAgICAgICAgIGJvb2tObzogXy5wYXJzZUludChib29rTm8sIDApLFxyXG4gICAgICAgICAgICBvcmRlcjogYXJyLmxlbmd0aCA+IDAgPyBgQCR7YXJyLmpvaW4oJ0AnKX1gIDogJydcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICB9LCBbXSk7XHJcbiAgICAgIHBhdGggPSBfLnNwbGl0QW5kVHJpbShpbmZvLnRvcGljSUQgfHwgJzAnLCAnXycpO1xyXG4gICAgICB0aGlzLmJvb2tOb3MgPSBfLm1hcChwYXRoLnNoaWZ0KCkuc3BsaXQoJy4nKSwgaXRlbSA9PiBfLnBhcnNlSW50KGl0ZW0sIDApKTtcclxuICAgICAgcmV0dXJuIHRoaXMucGFnZU5vID0gXy5wYXJzZUludChwYXRoLnNoaWZ0KCksIDApO1xyXG4gICAgfVxyXG5cclxuICAgIHN5bmNUb1Byb2plY3RUb2ModGMsIG5vZGVzLCBzdWNjZXNzKSB7XHJcbiAgICAgIGxldCBjdXJCb29rTm8sIGlkeCwgcGF0aDtcclxuICAgICAgaWYgKHRoaXMudG9jUGF0aC5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgY3VyQm9va05vID0gMDtcclxuICAgICAgICBwYXRoID0gdGhpcy50b2NQYXRoLnNoaWZ0KCk7XHJcbiAgICAgICAgaWR4ID0gXy5maW5kSW5kZXgobm9kZXMsIGNoaWxkID0+IHtcclxuICAgICAgICAgIGxldCBjaGlsZE9yZGVyO1xyXG4gICAgICAgICAgY2hpbGRPcmRlciA9ICQuZGF0YXNldChjaGlsZCwgJ2NoaWxkb3JkZXInKSB8fCAnJztcclxuICAgICAgICAgIGlmIChjaGlsZE9yZGVyID09PSBwYXRoLm9yZGVyICYmIHRjLmlzQm9va05vZGUoY2hpbGQpKSB7XHJcbiAgICAgICAgICAgIGN1ckJvb2tObysrO1xyXG4gICAgICAgICAgICBpZiAoY3VyQm9va05vID09PSBwYXRoLmJvb2tObykge1xyXG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKGlkeCAhPT0gLTEpIHtcclxuICAgICAgICAgIHJldHVybiB0Yy5vcGVuQm9vayhub2Rlc1tpZHhdLCB0cnVlLCAoKF90aGlzID0+ICgpID0+IF8uZGVmZXIoKCkgPT4ge1xyXG4gICAgICAgICAgICBsZXQgY2hpbGQsIGNoaWxkTm9kZXM7XHJcbiAgICAgICAgICAgIGNoaWxkID0gbm9kZXNbaWR4ICsgMV07XHJcbiAgICAgICAgICAgIGlmIChjaGlsZE5vZGVzID0gY2hpbGQuY2hpbGRyZW4gJiYgY2hpbGQuY2hpbGRyZW5bMF0pIHtcclxuICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuc3luY1RvUHJvamVjdFRvYyh0YywgY2hpbGROb2Rlcy5jaGlsZHJlbiwgc3VjY2Vzcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0pKSkodGhpcykpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIGlmIChzdWNjZXNzKSB7XHJcbiAgICAgICAgcmV0dXJuIHN1Y2Nlc3Mobm9kZXMpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgc3luY1RvVG9jSXRlbSh0Yywgbm9kZXMsIHdhaXQpIHtcclxuICAgICAgbGV0IGN1ckJvb2tObywgY3VyUGFnZU5vLCBsYXN0Qm9va05vZGU7XHJcbiAgICAgIGlmICh3YWl0ID09IG51bGwpIHtcclxuICAgICAgICB3YWl0ID0gMTtcclxuICAgICAgfVxyXG4gICAgICBjdXJQYWdlTm8gPSAwO1xyXG4gICAgICBjdXJCb29rTm8gPSAwO1xyXG4gICAgICBsYXN0Qm9va05vZGUgPSBudWxsO1xyXG4gICAgICByZXR1cm4gXy5hbnkobm9kZXMsICgoX3RoaXMgPT4gY2hpbGQgPT4ge1xyXG4gICAgICAgIGxldCBib29rTm9kZSwgY2hpbGRPcmRlciwgaGFzQ2hpbGQsIHBhZ2VOb2RlLCB0b3BpY05vZGU7XHJcbiAgICAgICAgY2hpbGRPcmRlciA9ICQuZGF0YXNldChjaGlsZCwgJ2NoaWxkb3JkZXInKSB8fCAnJztcclxuICAgICAgICBpZiAoY2hpbGRPcmRlciAhPT0gX3RoaXMub3JkZXIpIHtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRjLmlzQm9va05vZGUoY2hpbGQpKSB7XHJcbiAgICAgICAgICBib29rTm9kZSA9IGNoaWxkO1xyXG4gICAgICAgICAgbGFzdEJvb2tOb2RlID0gYm9va05vZGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChib29rTm9kZSkge1xyXG4gICAgICAgICAgY3VyQm9va05vKys7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChfdGhpcy5ib29rTm9zWzBdICE9PSBjdXJCb29rTm8pIHtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRjLmlzUGFnZU5vZGUoY2hpbGQpKSB7XHJcbiAgICAgICAgICBwYWdlTm9kZSA9IGNoaWxkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocGFnZU5vZGUpIHtcclxuICAgICAgICAgIGN1clBhZ2VObysrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoX3RoaXMuYm9va05vcy5sZW5ndGggPT09IDEpIHtcclxuICAgICAgICAgIGlmIChfdGhpcy5wYWdlTm8gPT09IDApIHtcclxuICAgICAgICAgICAgdG9waWNOb2RlID0gY2hpbGQ7XHJcbiAgICAgICAgICAgIGlmIChsYXN0Qm9va05vZGUpIHtcclxuICAgICAgICAgICAgICB0Yy5vcGVuQm9vayhsYXN0Qm9va05vZGUsIHRydWUsICgpID0+IHRjLnVwZGF0ZUJvb2tJbmZvKCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKHBhZ2VOb2RlICYmIGN1clBhZ2VObyA9PT0gX3RoaXMucGFnZU5vKSB7XHJcbiAgICAgICAgICAgIHRvcGljTm9kZSA9IGNoaWxkO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgdGMudXBkYXRlQm9va0luZm8oKTtcclxuICAgICAgICAgIGlmICh0b3BpY05vZGUpIHtcclxuICAgICAgICAgICAgdGMuc2VsZWN0TGluayh0b3BpY05vZGUsIHRydWUsIHdhaXQpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSBpZiAobGFzdEJvb2tOb2RlICYmIChoYXNDaGlsZCA9ICQuaGFzQ2xhc3MoY2hpbGQsICdjaGlsZCcpKSkge1xyXG4gICAgICAgICAgX3RoaXMuYm9va05vcy5zaGlmdCgpO1xyXG4gICAgICAgICAgdGMub3BlbkJvb2sobGFzdEJvb2tOb2RlLCB0cnVlLCAoKSA9PiBfLmRlZmVyKCgpID0+IHtcclxuICAgICAgICAgICAgbGV0IGNoaWxkTm9kZXM7XHJcbiAgICAgICAgICAgIGlmIChjaGlsZE5vZGVzID0gY2hpbGQuY2hpbGRyZW4gJiYgY2hpbGQuY2hpbGRyZW5bMF0pIHtcclxuICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuc3luY1RvVG9jSXRlbSh0YywgY2hpbGROb2Rlcy5jaGlsZHJlbiwgQU5JTV9USU1FKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0b3BpY05vZGUgIT0gbnVsbDtcclxuICAgICAgfSkpKHRoaXMpKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiBTeW5jVG9jO1xyXG59KSkoKTtcclxuXHJcblRvY0NvbnRyb2xsZXIgPSAoKCgpID0+IHtcclxuICBsZXQgQUNUSVZFX0NMQVNTLCBDT0xMQVBTSU5HX0NMQVNTLCBFWFBBTkRFRF9DTEFTUywgRVhQQU5ESU5HX0NMQVNTLCBLRVlfQUNUSVZFX0JPT0tJRCwgS0VZX0FDVElWRV9CT09LX0xFVkVMLCBLRVlfQk9PS0lELCBLRVlfQk9PS19MRVZFTCwgS0VZX1NIT1dfQ0hJTEQsIEtFWV9UT0MsIExPQURJTkdfQk9PSywgU0VMRUNURURfQ0xBU1M7XHJcblxyXG4gIEVYUEFOREVEX0NMQVNTID0gJ2V4cGFuZGVkJztcclxuXHJcbiAgQUNUSVZFX0NMQVNTID0gJ2FjdGl2ZSc7XHJcblxyXG4gIENPTExBUFNJTkdfQ0xBU1MgPSAnY29sbGFwc2luZyc7XHJcblxyXG4gIEVYUEFORElOR19DTEFTUyA9ICdleHBhbmRpbmcnO1xyXG5cclxuICBMT0FESU5HX0JPT0sgPSAnbG9hZGluZy1ib29rJztcclxuXHJcbiAgU0VMRUNURURfQ0xBU1MgPSAnc2VsZWN0ZWQnO1xyXG5cclxuICBLRVlfU0hPV19DSElMRCA9ICdzaG93X2NoaWxkJztcclxuXHJcbiAgS0VZX0JPT0tJRCA9ICdib29raWQnO1xyXG5cclxuICBLRVlfQUNUSVZFX0JPT0tJRCA9ICdhY3RpdmVfYm9va2lkJztcclxuXHJcbiAgS0VZX0JPT0tfTEVWRUwgPSAnbGV2ZWwnO1xyXG5cclxuICBLRVlfQUNUSVZFX0JPT0tfTEVWRUwgPSAnYWN0aXZlX2xldmVsJztcclxuXHJcbiAgS0VZX1RPQyA9ICcucC50b2MnO1xyXG4gIGxldCBDVVJSRU5UX1RPQ19LRVkgPSAnY3VydG9jJywgVE9DX0lURU1fQVRUUiA9ICdkYXRhLXRvY2l0ZW0nO1xyXG5cclxuICBsZXQgS0VZX0JSRUFEQ1JVTUJTID0gY29uc3RzKCdLRVlfVE9DX0JSRUFEQ1JVTUJTJyk7XHJcblxyXG5cclxuICBjbGFzcyBUb2NDb250cm9sbGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKHdpZGdldCkge1xyXG4gICAgICB0aGlzLndpZGdldCA9IHdpZGdldDtcclxuICAgICAgdGhpcy5zdWJzY3JpYmVUb3BpY0lEID0gYmluZCh0aGlzLnN1YnNjcmliZVRvcGljSUQsIHRoaXMpO1xyXG4gICAgICB0aGlzLnVybHMgPSBbXVxyXG5cclxuICAgICAgdGhpcy5vbkNsaWNrID0gYmluZCh0aGlzLm9uQ2xpY2ssIHRoaXMpO1xyXG4gICAgICB0aGlzLnVwZGF0ZUJvb2tJbmZvID0gYmluZCh0aGlzLnVwZGF0ZUJvb2tJbmZvLCB0aGlzKTtcclxuICAgICAgdGhpcy5fZGF0YSA9IHt9O1xyXG4gICAgICB0aGlzLnByb2plY3RBYnNSZWYgPSBbXTtcclxuICAgICAgaWYgKHRoaXMuc3luY1RvYyA9PSBudWxsKSB7XHJcbiAgICAgICAgdGhpcy5zeW5jVG9jID0gbmV3IFN5bmNUb2M7XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy53aWRnZXQucHVibGlzaChLRVlfQk9PS19MRVZFTCwgMCk7XHJcbiAgICAgIHRoaXMud2lkZ2V0LnB1Ymxpc2goS0VZX0JPT0tJRCwgJ18nKTtcclxuICAgICAgcmgubW9kZWwuc3Vic2NyaWJlKEtFWV9UT0MsIChkYXRhKSA9PiB7XHJcbiAgICAgICAgdGhpcy53aWRnZXQucHVibGlzaChDVVJSRU5UX1RPQ19LRVksIGRhdGEpO1xyXG4gICAgICAgIHRoaXMud2lkZ2V0LnB1Ymxpc2goJ2N1cmxldmVsJywgMCk7XHJcbiAgICAgIH0pO1xyXG4gICAgICB0aGlzLndpZGdldC5zdWJzY3JpYmUoY29uc3RzKCdLRVlfVE9DX1NFTEVDVF9JVEVNJyksIHRoaXMuc2VsZWN0VG9jSXRlbS5iaW5kKHRoaXMpKTtcclxuICAgICAgbW9kZWwuc3Vic2NyaWJlKGNvbnN0cygnS0VZX1RPQ19CQUNLX0JVVFRPTl9QUkVTU0VEJyksIHRoaXMub25CYWNrQnV0dG9uQ2xpY2tlZC5iaW5kKHRoaXMpKTtcclxuICAgICAgbW9kZWwuc3Vic2NyaWJlT25jZShbY29uc3RzKCdFVlRfUFJPSkVDVF9MT0FERUQnKSwgY29uc3RzKCdLRVlfVE9DX09SREVSJyldLCAoKF90aGlzID0+ICgpID0+IHtcclxuICAgICAgICBpZiAobW9kZWwuZ2V0KGNvbnN0cygnS0VZX1BVQkxJU0hfTU9ERScpKSkge1xyXG4gICAgICAgICAgcmV0dXJuIF90aGlzLmdldFRPQ0RhdGEoKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgcmV0dXJuIF90aGlzLmxvYWRUb2MoS0VZX1RPQywgJycsICgpID0+IHtcclxuICAgICAgICAgICAgX3RoaXMud2lkZ2V0LnB1Ymxpc2goY29uc3RzKCdFVlRfVE9DX0xPQURFRCcpLCB0cnVlKTtcclxuICAgICAgICAgICAgcmV0dXJuIF8uZGVmZXIoKCkgPT4gX3RoaXMud2lkZ2V0LnN1YnNjcmliZShyaC5jb25zdHMoJ0tFWV9UT1BJQ19JRCcpLCBfdGhpcy5zdWJzY3JpYmVUb3BpY0lEKSk7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pKSh0aGlzKSk7XHJcbiAgICB9XHJcblxyXG4gICAgZXhwYW5kQm9vayhsZXZlbCwgaWQsIG5vZGUsIGl0ZW0pIHtcclxuICAgICAgdGhpcy5zZWxlY3RUb2NJdGVtKHsnaWQnOiBpZH0pO1xyXG4gICAgICBsZXQga2V5ID0gJC5nZXRBdHRyaWJ1dGUobm9kZSwgJ2RhdGEtaXRlbWtleScpO1xyXG4gICAgICByaC5tb2RlbC5wdWJsaXNoKCdFVlRfVE9DX0xPQURFRCcrJ2dvdG90YWInLFxyXG4gICAgICAgIHsndGFiJzogMCwgJ2tleSc6IGtleSwgJ2l0ZW0nOiBpdGVtfSk7XHJcbiAgICB9XHJcblxyXG4gICAgdXBkYXRlQm9va0luZm8oKSB7XHJcbiAgICAgIGxldCBpZCwgbmV3TGV2ZWw7XHJcbiAgICAgIGlkID0gdGhpcy53aWRnZXQuZ2V0KEtFWV9BQ1RJVkVfQk9PS0lEKTtcclxuICAgICAgaWYgKChpZCAhPSBudWxsKSAmJiBpZCAhPT0gdGhpcy53aWRnZXQuZ2V0KEtFWV9CT09LSUQpKSB7XHJcbiAgICAgICAgdGhpcy53aWRnZXQucHVibGlzaChLRVlfQk9PS0lELCBpZCk7XHJcbiAgICAgIH1cclxuICAgICAgbmV3TGV2ZWwgPSB0aGlzLndpZGdldC5nZXQoS0VZX0FDVElWRV9CT09LX0xFVkVMKTtcclxuICAgICAgaWYgKChuZXdMZXZlbCAhPSBudWxsKSAmJiBuZXdMZXZlbCAhPT0gdGhpcy53aWRnZXQuZ2V0KEtFWV9CT09LX0xFVkVMKSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLndpZGdldC5wdWJsaXNoKEtFWV9CT09LX0xFVkVMLCBuZXdMZXZlbCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB1cGRhdGVBY3RpdmVCb29rSW5mbyhsZXZlbCwgaWQpIHtcclxuICAgICAgdGhpcy53aWRnZXQucHVibGlzaChLRVlfQUNUSVZFX0JPT0tJRCwgaWQpO1xyXG5cclxuICAgICAgcmV0dXJuIHRoaXMud2lkZ2V0LnB1Ymxpc2goS0VZX0FDVElWRV9CT09LX0xFVkVMLCBsZXZlbCk7XHJcbiAgICB9XHJcbiAgICAvKlxyXG4gICAgX2FkZEJvb2ttYXJrKG5vZGUpe1xyXG4gICAgICBsZXQgdGhhdCA9IHRoaXMudGhpcztcclxuICAgICAgaWYoIUFycmF5LmlzQXJyYXkodGhpcy5wYXRoKSB8fCB0aGlzLnBhdGgubGVuZ3RoID09PSAwKXtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgICAgaWYodGhhdC5pc1RPQ0l0ZW0obm9kZSkpe1xyXG4gICAgICAgIGlmKHRoaXMuY3VyckluZGV4ID09PSB0aGlzLnBhdGhbMF0pe1xyXG4gICAgICAgICAgbGV0IGluZGV4ID0gdGhpcy5wYXRoLnNoaWZ0KCk7XHJcbiAgICAgICAgICB0aGlzLmN1cnJfcGF0aCArPSAodGhpcy5jdXJyX3BhdGggPT09IFwiXCIpPyBpbmRleC50b1N0cmluZygpIDogXCJfXCIgKyBpbmRleC50b1N0cmluZygpO1xyXG4gICAgICAgICAgbGV0IHRleHQgPSB0aGF0LmdldFRleHQobm9kZSk7XHJcbiAgICAgICAgICB0aGlzLmJvb2ttYXJrcy5wdXNoKHt0ZXh0OiB0ZXh0LCBwYXRoOiB0aGlzLmN1cnJfcGF0aCB9KTtcclxuICAgICAgICAgIHRoaXMuaW5kZXggPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNle1xyXG4gICAgICAgIC8vdHJhdmVyc2VDaGlsZCA9ZmFsc2U7XHJcbiAgICAgICAgICB0aGlzLmN1cnJJbmRleCArPSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgKi9cclxuICAgIGdldFRleHQobm9kZSl7XHJcbiAgICAgIHJldHVybiBub2RlLnRleHRDb250ZW50LnRyaW0oKTtcclxuICAgIH1cclxuICAgIF9nZXRQcmV2aW91c0l0ZW1Ob2RlKG5vZGUpe1xyXG4gICAgICBsZXQgcGlkID0gdGhpcy5waWQoJC5nZXRBdHRyaWJ1dGUobm9kZSwgJ2RhdGEtaXRlbWlkJykpXHJcbiAgICAgIHJldHVybiAkLmZpbmQodGhpcy53aWRnZXQubm9kZSwgJ1tkYXRhLWl0ZW1pZD1cXFwiJyArIHBpZCArJ1xcXCJdJylbMF1cclxuICAgIH1cclxuXHJcbiAgICB1cGRhdGVCcmVhZGNydW1iSW5mbyhub2RlKXtcclxuICAgICAgbGV0ICRsZWFmbm9kZSA9IG5vZGU7XHJcbiAgICAgIGxldCAkbm9kZVxyXG4gICAgICBsZXQgYnJlYWRjcnVtYnMgPSBbXVxyXG4gICAgICBpZighdGhpcy5pc1RPQ0l0ZW0obm9kZSkpe1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICBicmVhZGNydW1icy5wdXNoKHRoaXMuX2NyZWF0ZUJyZWFkY3J1bWJJdGVtKCRsZWFmbm9kZSkpXHJcbiAgICAgIHdoaWxlKCRub2RlID0gdGhpcy5fZ2V0UHJldmlvdXNJdGVtTm9kZSgkbGVhZm5vZGUpKXtcclxuICAgICAgICBicmVhZGNydW1icy5wdXNoKHRoaXMuX2NyZWF0ZUJyZWFkY3J1bWJJdGVtKCRub2RlKSk7XHJcbiAgICAgICAgJGxlYWZub2RlID0gJG5vZGVcclxuICAgICAgfVxyXG4gICAgICBicmVhZGNydW1icy5yZXZlcnNlKCk7XHJcbiAgICAgIGlmKGJyZWFkY3J1bWJzLmxlbmd0aCA+IDApe1xyXG4gICAgICAgIGJyZWFkY3J1bWJzW2JyZWFkY3J1bWJzLmxlbmd0aC0xXS5sYXN0Tm9kZSA9IHRydWU7XHJcbiAgICAgIH1cclxuICAgICAgYnJlYWRjcnVtYnMuY3VybGV2ZWwgPSB0aGlzLndpZGdldC5nZXQoXCJjdXJsZXZlbFwiKTtcclxuICAgICAgdGhpcy53aWRnZXQucHVibGlzaChLRVlfQlJFQURDUlVNQlMsIGJyZWFkY3J1bWJzKTtcclxuICAgIH1cclxuICAgIF9jcmVhdGVCcmVhZGNydW1iSXRlbShub2RlKXtcclxuICAgICAgbGV0IGxpbmtOb2RlID0gbm9kZVxyXG4gICAgICBpZighdGhpcy5oYXNUT0NJdGVtTGluayhub2RlKSl7XHJcbiAgICAgICAgbGlua05vZGUgPSB0aGlzLl9maW5kRmlyc3RMaW5rKG5vZGUpXHJcbiAgICAgIH1cclxuICAgICAgbGV0IHVybCA9IChsaW5rTm9kZSAmJiAoJC5nZXRBdHRyaWJ1dGUobGlua05vZGUsJ2hyZWYnKVxyXG4gICAgICAgIHx8ICQuZ2V0QXR0cmlidXRlKGxpbmtOb2RlLCdsaW5rJykpKVxyXG4gICAgICAgIHx8ICcjJztcclxuICAgICAgcmV0dXJuIHtpZDokLmdldEF0dHJpYnV0ZShub2RlLCdkYXRhLWl0ZW1pZCcpLFxyXG4gICAgICAgICAgICAgIHRleHQ6IHRoaXMuZ2V0VGV4dChub2RlKSxcclxuICAgICAgICAgICAgICB1cmw6IHVybCxcclxuICAgICAgICAgICAgICBoYXNVcmw6IHRoaXMuaGFzVE9DSXRlbUxpbmsobm9kZSksXHJcbiAgICAgICAgICAgICAgbGFzdE5vZGU6ZmFsc2V9O1xyXG4gICAgfVxyXG4gICAgaXNUT0NJdGVtKG5vZGUpe1xyXG5cclxuICAgICAgcmV0dXJuICQubm9kZU5hbWUobm9kZSkgPT09ICdMSSdcclxuICAgICAgICB8fCAkLmdldEF0dHJpYnV0ZShub2RlLCBUT0NfSVRFTV9BVFRSKVxyXG4gICAgfVxyXG5cclxuICAgIF9maW5kRmlyc3RMaW5rKGJvb2tOb2RlKXtcclxuICAgICAgbGV0IGNvbnRleHQgPSB7dGhhdDp0aGlzfTtcclxuXHJcbiAgICAgIGxldCBub2RlID0gbm9kZVV0aWwucGFyZW50Tm9kZShib29rTm9kZSk7XHJcbiAgICAgIGNvbnRleHQuYm9va2lkID0gJC5nZXRBdHRyaWJ1dGUoYm9va05vZGUsICdkYXRhLWl0ZW1pZCcpXHJcbiAgICAgICQudHJhdmVyc2VOb2RlKG5vZGUsIHRoaXMuX2ZpbmRMaW5rRm4sIG51bGwsIG51bGwsIGNvbnRleHQpO1xyXG4gICAgICByZXR1cm4gY29udGV4dC5saW5rTm9kZVxyXG4gICAgfVxyXG4gICAgX2lzUGFyZW50VG9jSXRlbShub2RlKXtcclxuICAgICAgcmV0dXJuIHRoaXMuYm9va05vZGUgIT09IG5vZGUgJiYgdGhpcy50aGF0LmlzVE9DSXRlbShub2RlKVxyXG4gICAgfVxyXG5cclxuICAgIF9maW5kTGlua0ZuKG5vZGUpe1xyXG4gICAgICBsZXQgaWQgPSAkLmdldEF0dHJpYnV0ZShub2RlLCAnZGF0YS1pdGVtaWQnKVxyXG4gICAgICBpZihpZCA9PT0gdGhpcy5ib29raWQpe1xyXG4gICAgICAgIHRoaXMuYm9va0ZvdW5kID0gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgICBpZiAodGhpcy5ib29rRm91bmQgJiYgdGhpcy50aGF0Lmhhc1RPQ0l0ZW1MaW5rKG5vZGUpICYmIHRoaXMubGlua05vZGUgPT09IHVuZGVmaW5lZCl7XHJcbiAgICAgICAgdGhpcy5saW5rTm9kZSA9IG5vZGU7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgbmV4dExldmVsKG5vZGUpIHtcclxuICAgICAgbGV0IGxldmVsO1xyXG4gICAgICBsZXZlbCA9IF8ucGFyc2VJbnQoJC5kYXRhc2V0KG5vZGUsICdpdGVtbGV2ZWwnKSwgMCk7XHJcbiAgICAgIGlmICgkLmhhc0NsYXNzKG5vZGUsIEVYUEFOREVEX0NMQVNTKSkge1xyXG4gICAgICAgIHJldHVybiBsZXZlbDtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gbGV2ZWwgKyAxO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgb25DbGljayhldmVudCkge1xyXG4gICAgICBsZXQgY2xpY2tOb2RlLCBoYXNMaW5rLCBub2RlLCB0b3BOb2RlO1xyXG4gICAgICB0b3BOb2RlID0gZXZlbnQuY3VycmVudFRhcmdldDtcclxuICAgICAgY2xpY2tOb2RlID0gZXZlbnQudGFyZ2V0O1xyXG4gICAgICBoYXNMaW5rID0gdGhpcy5oYXNMaW5rKGNsaWNrTm9kZSk7XHJcbiAgICAgIG5vZGUgPSB0aGlzLmdldEl0ZW1Ob2RlKGNsaWNrTm9kZSwgdG9wTm9kZSk7XHJcbiAgICAgIGlmICh0aGlzLmlzQm9va05vZGUobm9kZSkpIHtcclxuICAgICAgICBpZiAoIShoYXNMaW5rICYmIHRoaXMuc2VsZWN0ZWROb2RlICE9PSBub2RlICYmIHRoaXMuaXNPcGVuQm9vayhub2RlKSkpIHtcclxuICAgICAgICAgIHRoaXMudG9nZ2xlQm9vayhub2RlLCBmYWxzZSk7XHJcbiAgICAgICAgICB0aGlzLnVwZGF0ZUJyZWFkY3J1bWJJbmZvKG5vZGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKCEoIWhhc0xpbmsgfHwgdGhpcy5pc1VybE5vZGUobm9kZSkgJiYgdGhpcy5oYXNFeHRlcm5hbExpbmsoY2xpY2tOb2RlKSkpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3RMaW5rKG5vZGUsIGZhbHNlKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuXHJcbiAgICBzZWxlY3RMaW5rKG5vZGUsIHNjcm9sbEludG9WaWV3LCB3YWl0KSB7XHJcbiAgICAgIGlmICh3YWl0ID09IG51bGwpIHtcclxuICAgICAgICB3YWl0ID0gQU5JTV9USU1FO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICh0aGlzLnNlbGVjdGVkTm9kZSkge1xyXG4gICAgICAgICQucmVtb3ZlQ2xhc3ModGhpcy5zZWxlY3RlZE5vZGUsIFNFTEVDVEVEX0NMQVNTKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoc2Nyb2xsSW50b1ZpZXcgJiYgdGhpcy5zZWxlY3RlZE5vZGUgIT09IG5vZGUpIHtcclxuICAgICAgICBfLmRlbGF5KCgoKSA9PiBub2RlLnNjcm9sbEludG9WaWV3KHRydWUpKSwgd2FpdCk7XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5zZWxlY3RlZE5vZGUgPSBub2RlO1xyXG4gICAgICBpZiAobm9kZSkge1xyXG4gICAgICAgIHRoaXMudXBkYXRlQnJlYWRjcnVtYkluZm8obm9kZSk7XHJcbiAgICAgICAgbW9kZWwucHVibGlzaChjb25zdHMoJ0VWVF9UT0NfU0VMRUNURURfSVRFTV9DSEFOR0VEJykpXHJcbiAgICAgICAgcmV0dXJuICQuYWRkQ2xhc3Mobm9kZSwgU0VMRUNURURfQ0xBU1MpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgc2VsZWN0VG9jSXRlbSh0b2NPYmope1xyXG4gICAgICBsZXQgaWQgPSB0b2NPYmouaWQgKyAnXzAnXHJcbiAgICAgIGlmKGlkKXtcclxuICAgICAgICBsZXQgY2hpbGREYXRhID0ge30sIGxldmVsID0gLTE7XHJcbiAgICAgICAgd2hpbGUoaWQpe1xyXG4gICAgICAgICAgbGV2ZWwrKztcclxuICAgICAgICAgIGNoaWxkRGF0YVtpZF0gPSB0cnVlO1xyXG4gICAgICAgICAgaWQgPSBpZC5zdWJzdHIoMCwgaWQubGFzdEluZGV4T2YoJ18nKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMud2lkZ2V0LnB1Ymxpc2goXCJzaG93X2NoaWxkXCIsIGNoaWxkRGF0YSk7XHJcbiAgICAgICAgdGhpcy53aWRnZXQucHVibGlzaChcImN1cmxldmVsXCIsIGxldmVsKTtcclxuICAgICAgICBpZih0b2NPYmoudXJsKVxyXG4gICAgICAgICAgcmgubW9kZWwucHVibGlzaCgnRVZUX1RPQ19MT0FERUQnKydnb3RvdGFiJyxcclxuICAgICAgICAgICAgICB7J3RhYic6IDAsICdpdGVtJzogeyd1cmwnOiB0b2NPYmoudXJsfX0pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0SXRlbU5vZGUobm9kZSwgdG9wTm9kZSkge1xyXG4gICAgICByZXR1cm4gXy5maW5kUGFyZW50Tm9kZShub2RlLCB0b3BOb2RlLCB0aGlzLmlzVE9DSXRlbSk7XHJcbiAgICB9XHJcbiAgICBnZXRDaGlsZEl0ZW1Ob2RlKG5vZGUsIGluZGV4KSB7XHJcbiAgICAgIHJldHVybiAkLmZpbmQobm9kZSwgIG5vZGUgPT4gJC5ub2RlTmFtZShub2RlKSA9PT0gJ0xJJ1xyXG4gICAgICAgIHx8ICQuZ2V0QXR0cmlidXRlKG5vZGUsIFRPQ19JVEVNX0FUVFIpKTtcclxuICAgIH1cclxuICAgIGhhc1RPQ0l0ZW1MaW5rKG5vZGUpe1xyXG4gICAgICBsZXQgaHJlZiA9ICQuZ2V0QXR0cmlidXRlKG5vZGUsICdkYXRhLWhhc2xpbmsnKTtcclxuICAgICAgcmV0dXJuIGhyZWYgPT09ICd0cnVlJztcclxuICAgIH1cclxuICAgIGhhc0xpbmsobm9kZSkge1xyXG4gICAgICBsZXQgaHJlZjtcclxuICAgICAgaHJlZiA9ICQuZ2V0QXR0cmlidXRlKG5vZGUsICdocmVmJyk7XHJcbiAgICAgIHJldHVybiBocmVmICYmIGhyZWYgIT09ICcjJztcclxuICAgIH1cclxuXHJcbiAgICBpc0Jvb2tOb2RlKG5vZGUpIHtcclxuICAgICAgcmV0dXJuICQuaGFzQ2xhc3Mobm9kZSwgJ2Jvb2snKTtcclxuICAgIH1cclxuXHJcbiAgICBpc1RvcGljTm9kZShub2RlKSB7XHJcbiAgICAgIHJldHVybiAkLmhhc0NsYXNzKG5vZGUsICdpdGVtJyk7XHJcbiAgICB9XHJcblxyXG4gICAgaXNVcmxOb2RlKG5vZGUpIHtcclxuICAgICAgcmV0dXJuICQuaGFzQ2xhc3Mobm9kZSwgJ3VybCcpO1xyXG4gICAgfVxyXG5cclxuICAgIGlzUGFnZU5vZGUobm9kZSkge1xyXG4gICAgICByZXR1cm4gdGhpcy5pc1RvcGljTm9kZShub2RlKSB8fCB0aGlzLmlzVXJsTm9kZShub2RlKTtcclxuICAgIH1cclxuXHJcbiAgICBpc09wZW5Cb29rKG5vZGUpIHtcclxuICAgICAgaWYgKHRoaXMud2lkZ2V0LmdldChLRVlfVE9DX0RSSUxMX0RPV04pKSB7XHJcbiAgICAgICAgcmV0dXJuICQuaGFzQ2xhc3Mobm9kZSwgQUNUSVZFX0NMQVNTKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gJC5oYXNDbGFzcyhub2RlLCBFWFBBTkRFRF9DTEFTUyk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBoYXNFeHRlcm5hbExpbmsobm9kZSkge1xyXG4gICAgICBsZXQgaHJlZjtcclxuICAgICAgaHJlZiA9ICQuZ2V0QXR0cmlidXRlKG5vZGUsICdocmVmJyk7XHJcbiAgICAgIGlmICghKGhyZWYgJiYgIV8uaXNSZWxhdGl2ZVVybChocmVmKSkpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuICFfLmlzVXJsQWxsb3dkSW5JZnJhbWUoaHJlZik7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0Qm9va05vZGUobm9kZSwgdG9wTm9kZSkge1xyXG4gICAgICBsZXQgaXRlbU5vZGU7XHJcbiAgICAgIGl0ZW1Ob2RlID0gdGhpcy5nZXRJdGVtTm9kZShub2RlLCB0b3BOb2RlKTtcclxuICAgICAgaWYgKHRoaXMuaXNCb29rTm9kZShpdGVtTm9kZSkpIHtcclxuICAgICAgICByZXR1cm4gaXRlbU5vZGU7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBhbmltYXRlQ29sbGFwc2UoYm9va05vZGUpIHtcclxuICAgICAgcmV0dXJuIF8uZWFjaChbYm9va05vZGUsIGJvb2tOb2RlLm5leHRFbGVtZW50U2libGluZ10sIG5vZGUgPT4ge1xyXG4gICAgICAgICQuYWRkQ2xhc3Mobm9kZSwgQ09MTEFQU0lOR19DTEFTUyk7XHJcbiAgICAgICAgcmV0dXJuIF8uZGVsYXkoKCkgPT4gJC5yZW1vdmVDbGFzcyhub2RlLCBDT0xMQVBTSU5HX0NMQVNTKSwgQU5JTV9USU1FKTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgYW5pbWF0ZUV4cGFuZChib29rTm9kZSkge1xyXG4gICAgICByZXR1cm4gXy5lYWNoKFtib29rTm9kZSwgYm9va05vZGUubmV4dEVsZW1lbnRTaWJsaW5nXSwgbm9kZSA9PiB7XHJcbiAgICAgICAgJC5hZGRDbGFzcyhub2RlLCBFWFBBTkRJTkdfQ0xBU1MpO1xyXG4gICAgICAgIHJldHVybiBfLmRlbGF5KCgpID0+ICQucmVtb3ZlQ2xhc3Mobm9kZSwgRVhQQU5ESU5HX0NMQVNTKSwgQU5JTV9USU1FKTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgdG9nZ2xlQm9vayhib29rTm9kZSwgc2Nyb2xsSW50b1ZpZXcpIHtcclxuICAgICAgaWYgKHNjcm9sbEludG9WaWV3ID09IG51bGwpIHtcclxuICAgICAgICBzY3JvbGxJbnRvVmlldyA9IHRydWU7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHRoaXMuaXNPcGVuQm9vayhib29rTm9kZSkpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jbG9zZUJvb2soYm9va05vZGUpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm9wZW5Cb29rKGJvb2tOb2RlLCBzY3JvbGxJbnRvVmlldyk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBvbkJhY2tCdXR0b25DbGlja2VkKCl7XHJcbiAgICAgIGxldCBub2RlID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnZXhwYW5kZWQgYWN0aXZlJykgJiYgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnZXhwYW5kZWQgYWN0aXZlJylbMF1cclxuICAgICAgaWYobm9kZSl7XHJcbiAgICAgICAgdGhpcy5jbG9zZUJvb2sobm9kZSlcclxuICAgICAgICBfLmRlZmVyKCgpID0+IHtcclxuICAgICAgICAgIHRoaXMud2lkZ2V0LnN1YnNjcmliZShLRVlfQUNUSVZFX0JPT0tJRCwgaWQgPT4ge1xyXG4gICAgICAgICAgICBsZXQgc2VuZERhdGFcclxuICAgICAgICAgICAgaWYoaWQgPT09ICdfJyl7XHJcbiAgICAgICAgICAgICAgc2VuZERhdGEgPSBmYWxzZVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIHNlbmREYXRhID0gdHJ1ZVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG1vZGVsLnB1Ymxpc2gocmguY29uc3RzKCdLRVlfU0hPV19UT0NfQkFDS19CVVRUT04nKSwgc2VuZERhdGEpXHJcbiAgICAgICAgICB9KVxyXG4gICAgICAgIH0pXHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBjbG9zZUJvb2sobm9kZSkge1xyXG4gICAgICBsZXQgaWQsIGtleVNob3c7XHJcbiAgICAgIGlkID0gJC5kYXRhc2V0KG5vZGUsICdpdGVtaWQnKTtcclxuICAgICAga2V5U2hvdyA9IGAke0tFWV9TSE9XX0NISUxEfSR7aWR9YDtcclxuICAgICAgaWYgKGZhbHNlICE9PSB0aGlzLndpZGdldC5nZXQoa2V5U2hvdykpIHtcclxuICAgICAgICB0aGlzLndpZGdldC5wdWJsaXNoKGtleVNob3csIGZhbHNlKTtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLnVwZGF0ZUFjdGl2ZUJvb2tJbmZvKHRoaXMubmV4dExldmVsKG5vZGUpLCB0aGlzLnBpZChpZCkpO1xyXG4gICAgICB0aGlzLnVwZGF0ZUJvb2tJbmZvKCk7XHJcbiAgICAgIGlmICgkLmhhc0NsYXNzKG5vZGUsIEVYUEFOREVEX0NMQVNTKSkge1xyXG4gICAgICAgICQucmVtb3ZlQ2xhc3Mobm9kZSwgRVhQQU5ERURfQ0xBU1MpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmFuaW1hdGVDb2xsYXBzZShub2RlKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIG9wZW5Cb29rKG5vZGUsIHNjcm9sbEludG9WaWV3LCBzdWNjZXNzKSB7XHJcbiAgICAgIG1vZGVsLnB1Ymxpc2gocmguY29uc3RzKCdLRVlfU0hPV19UT0NfQkFDS19CVVRUT04nKSwgdHJ1ZSlcclxuICAgICAgbGV0IGNoaWxkT3JkZXIsIGlkLCBrZXksIGtleVNob3c7XHJcbiAgICAgIGlmIChzdWNjZXNzID09IG51bGwpIHtcclxuICAgICAgICBzdWNjZXNzID0gdGhpcy51cGRhdGVCb29rSW5mbztcclxuICAgICAgfVxyXG4gICAgICBrZXkgPSAkLmRhdGFzZXQobm9kZSwgJ2l0ZW1rZXknKTtcclxuICAgICAgaWQgPSAkLmRhdGFzZXQobm9kZSwgJ2l0ZW1pZCcpO1xyXG4gICAgICBjaGlsZE9yZGVyID0gJC5kYXRhc2V0KG5vZGUsICdjaGlsZG9yZGVyJyk7XHJcbiAgICAgIGtleVNob3cgPSBgJHtLRVlfU0hPV19DSElMRH0ke2lkfWA7XHJcbiAgICAgIGlmICh0cnVlICE9PSB0aGlzLndpZGdldC5nZXQoa2V5U2hvdykpIHtcclxuICAgICAgICB0aGlzLndpZGdldC5wdWJsaXNoKGtleVNob3csIHRydWUpO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMudXBkYXRlQWN0aXZlQm9va0luZm8odGhpcy5uZXh0TGV2ZWwobm9kZSksIGlkKTtcclxuICAgICAgaWYgKHRoaXMud2lkZ2V0LmdldChrZXkpKSB7XHJcbiAgICAgICAgaWYgKCEkLmhhc0NsYXNzKG5vZGUsIEVYUEFOREVEX0NMQVNTKSkge1xyXG4gICAgICAgICAgJC5hZGRDbGFzcyhub2RlLCBFWFBBTkRFRF9DTEFTUyk7XHJcbiAgICAgICAgICB0aGlzLmFuaW1hdGVFeHBhbmQobm9kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzdWNjZXNzKCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgJC5hZGRDbGFzcyhub2RlLCBMT0FESU5HX0JPT0spO1xyXG4gICAgICAgIGlmIChzY3JvbGxJbnRvVmlldykge1xyXG4gICAgICAgICAgbm9kZS5zY3JvbGxJbnRvVmlldyhmYWxzZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLmxvYWRUb2Moa2V5LCBjaGlsZE9yZGVyLCAoKF90aGlzID0+ICgpID0+IHtcclxuICAgICAgICAgICQucmVtb3ZlQ2xhc3Mobm9kZSwgTE9BRElOR19CT09LKTtcclxuICAgICAgICAgICQuYWRkQ2xhc3Mobm9kZSwgRVhQQU5ERURfQ0xBU1MpO1xyXG4gICAgICAgICAgX3RoaXMuYW5pbWF0ZUV4cGFuZChub2RlKTtcclxuICAgICAgICAgIHJldHVybiBzdWNjZXNzKCk7XHJcbiAgICAgICAgfSkpKHRoaXMpKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGV4dHJhY3RUZW1wRGF0YShldmVudCkge1xyXG4gICAgICBsZXQgdGVtcEl0ZW1zO1xyXG4gICAgICBpZihldmVudCAmJiBldmVudC50eXBlID09PSAnZXJyb3InKSB7XHJcbiAgICAgICAgdGVtcEl0ZW1zID0gW107XHJcbiAgICAgICAgcmV0dXJuIHRlbXBJdGVtcztcclxuICAgICAgfVxyXG4gICAgICB0ZW1wSXRlbXMgPSB0aGlzLndpZGdldC5nZXQocmguY29uc3RzKCdLRVlfVEVNUF9EQVRBJykpO1xyXG4gICAgICB0aGlzLndpZGdldC5wdWJsaXNoKHJoLmNvbnN0cygnS0VZX1RFTVBfREFUQScpKTtcclxuICAgICAgcmV0dXJuIHRlbXBJdGVtcztcclxuICAgIH1cclxuXHJcbiAgICBsb2FkVG9jKGZ1bGxLZXksIHBhcmVudE9yZGVyLCBzdWNjZXNzKSB7XHJcbiAgICAgIGxldCBhYnNSZWYsIGtleSwgcGFyZW50UGF0aCwgcmVmMTtcclxuICAgICAgcmVmMSA9IHRoaXMucGFyc2VLZXkoZnVsbEtleSksIGFic1JlZiA9IHJlZjEuYWJzUmVmLCBrZXkgPSByZWYxLmtleTtcclxuICAgICAgcGFyZW50UGF0aCA9IGFic1JlZiA/IGAke2Fic1JlZn0vYCA6ICcnO1xyXG4gICAgICByZXR1cm4gXy5sb2FkU2NyaXB0KGAke3BhcmVudFBhdGh9d2h4ZGF0YS8ke2tleX0ubmV3LmpzYCwgdHJ1ZSwgKChfdGhpcyA9PiAoZXZlbnQpID0+IHtcclxuICAgICAgICBsZXQgdGVtcEl0ZW1zO1xyXG4gICAgICAgIHRlbXBJdGVtcyA9IF90aGlzLmV4dHJhY3RUZW1wRGF0YShldmVudCkgfHwgW107XHJcbiAgICAgICAgXy5lYWNoKHRlbXBJdGVtcywgaXRlbSA9PiB7XHJcbiAgICAgICAgICBpdGVtLmFic1JlZiA9IGFic1JlZjtcclxuICAgICAgICAgIGlmKGl0ZW0udHlwZSA9PT0gJ3JlbW90ZWl0ZW0nKSB7XHJcbiAgICAgICAgICAgIGl0ZW0udXJsID0gaXRlbS51cmwgJiYgZGVjb2RlVVJJKGl0ZW0udXJsKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmIChwYXJlbnRPcmRlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gaXRlbS5jaGlsZE9yZGVyID0gcGFyZW50T3JkZXI7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzLmxvYWRSZWZUb2ModGVtcEl0ZW1zLCBpdGVtcyA9PiB7XHJcbiAgICAgICAgICBfdGhpcy53aWRnZXQucHVibGlzaChmdWxsS2V5LCBpdGVtcyk7XHJcbiAgICAgICAgICBpZiAoc3VjY2Vzcykge1xyXG4gICAgICAgICAgICByZXR1cm4gc3VjY2VzcygpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9KSkodGhpcykpO1xyXG4gICAgfVxyXG5cclxuICAgIGxvYWRSZWZUb2MoaXRlbXMsIHN1Y2Nlc3MpIHtcclxuICAgICAgbGV0IGFic1JlZiwgaW5kZXgsIGl0ZW07XHJcbiAgICAgIGlmIChpdGVtcyA9PSBudWxsKSB7XHJcbiAgICAgICAgaXRlbXMgPSBbXTtcclxuICAgICAgfVxyXG4gICAgICBpbmRleCA9IF8uZmluZEluZGV4KGl0ZW1zLCBpdGVtID0+IHtcclxuICAgICAgICBpZiAoaXRlbS5yZWYpIHtcclxuICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcclxuICAgICAgICBpdGVtID0gaXRlbXNbaW5kZXhdO1xyXG4gICAgICAgIGFic1JlZiA9IGl0ZW0uYWJzUmVmIHx8ICcnO1xyXG4gICAgICAgIGlmIChhYnNSZWYpIHtcclxuICAgICAgICAgIGFic1JlZiArPSAnLyc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGFic1JlZiArPSBpdGVtLnJlZjtcclxuICAgICAgICBsZXQgcHJqT3JkZXIgPSBtb2RlbC5nZXQoY29uc3RzKCdLRVlfVE9DX09SREVSJykpXHJcbiAgICAgICAgbGV0IGNoaWxkT3JkZXIgPSAnJ1xyXG4gICAgICAgIGlmIChwcmpPcmRlclthYnNSZWZdKSB7IFxyXG4gICAgICAgICAgY2hpbGRPcmRlciA9IHByak9yZGVyW2Fic1JlZl0ub3JkZXJcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIF8ubG9hZFNjcmlwdChgJHthYnNSZWZ9L3doeGRhdGEvdG9jLm5ldy5qc2AsIHRydWUsIChldmVudCkgPT4ge1xyXG4gICAgICAgICAgbGV0IHRlbXBJdGVtcztcclxuICAgICAgICAgIHRlbXBJdGVtcyA9IHRoaXMuZXh0cmFjdFRlbXBEYXRhKGV2ZW50KSB8fCBbXTtcclxuICAgICAgICAgIF8uZWFjaCh0ZW1wSXRlbXMsIGl0ZW0gPT4ge1xyXG4gICAgICAgICAgICBpdGVtLmFic1JlZiA9IGFic1JlZjtcclxuICAgICAgICAgICAgaWYgKGNoaWxkT3JkZXIpIHtcclxuICAgICAgICAgICAgICByZXR1cm4gaXRlbS5jaGlsZE9yZGVyID0gY2hpbGRPcmRlcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgICBBcnJheS5wcm90b3R5cGUuc3BsaWNlLmFwcGx5KGl0ZW1zLCBbaW5kZXgsIDFdLmNvbmNhdCh0ZW1wSXRlbXMpKTtcclxuICAgICAgICAgIHJldHVybiB0aGlzLmxvYWRSZWZUb2MoaXRlbXMsIHN1Y2Nlc3MpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9IGVsc2UgaWYgKHN1Y2Nlc3MpIHtcclxuICAgICAgICByZXR1cm4gc3VjY2VzcyhpdGVtcyk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBnZXRUT0NEYXRhKCkge1xyXG4gICAgICByZXR1cm4gbW9kZWwuc3Vic2NyaWJlT25jZShjb25zdHMoJ0tFWV9QVUJMSVNIX0JBU0VfVVJMJyksIChmdW5jdGlvbihfdGhpcykge1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgIHZhciBlcnI7XHJcbiAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICByZXR1cm4gbW9kZWwuc3Vic2NyaWJlKGNvbnN0cygnS0VZX1BST0pFQ1RfTElTVCcpLCBmdW5jdGlvbihhbGxQcm9qZWN0cykge1xyXG4gICAgICAgICAgICAgIHJldHVybiBtb2RlbC5zdWJzY3JpYmUoY29uc3RzKCdLRVlfTUFTVEVSX1BST0pFQ1RfTElTVCcpLCBmdW5jdGlvbihsaXN0KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaXRlbXMsIGxlbjtcclxuICAgICAgICAgICAgICAgIGxlbiA9IGxpc3QubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgaXRlbXMgPSBbXTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfLmVhY2gobGlzdCwgZnVuY3Rpb24ocHJqKSB7XHJcbiAgICAgICAgICAgICAgICAgIHByaiA9IF8ubWFrZVJlbGF0aXZlVXJsKHByaiwgYWxsUHJvamVjdHNbMF0pO1xyXG4gICAgICAgICAgICAgICAgICBpZiAocHJqKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJqID0gcHJqICsgXCIvXCI7XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgcmV0dXJuIF8ubG9hZFNjcmlwdChwcmogKyBcIndoeGRhdGEvdG9jLm5ldy5qc1wiLCB0cnVlLCAoZnVuY3Rpb24oX3RoaXMpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oZXZlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgIHZhciB0ZW1wSXRlbXM7XHJcbiAgICAgICAgICAgICAgICAgICAgICB0ZW1wSXRlbXMgPSBfdGhpcy5leHRyYWN0VGVtcERhdGEoZXZlbnQpIHx8IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgXy5lYWNoKHRlbXBJdGVtcywgZnVuY3Rpb24gKGl0ZW0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5hYnNSZWYgPSBwcmpcclxuICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmxvYWRSZWZUb2ModGVtcEl0ZW1zLCBmdW5jdGlvbihyZXNvbHZlZEl0ZW1zKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlbi0tO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtcyA9IGl0ZW1zLmNvbmNhdChyZXNvbHZlZEl0ZW1zKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxlbiA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLndpZGdldC5wdWJsaXNoKEtFWV9UT0MsIGl0ZW1zKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy53aWRnZXQucHVibGlzaChjb25zdHMoJ0VWVF9UT0NfTE9BREVEJyksIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy53aWRnZXQuc3Vic2NyaWJlKHJoLmNvbnN0cygnS0VZX1RPUElDX0lEJyksIF90aGlzLnN1YnNjcmliZVRvcGljSUQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICB9KSh0aGlzKSk7XHJcbiAgICAgICAgICAgICAgICB9LCBfdGhpcyk7XHJcbiAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgZXJyID0gZXJyb3I7XHJcbiAgICAgICAgICAgIGlmIChyaC5fZGVidWcpIHtcclxuICAgICAgICAgICAgICByZXR1cm4gcmguX2QoJ3dhcm4nLCBlcnIubWVzc2FnZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICB9KSh0aGlzKSk7XHJcbiAgICB9XHJcblxyXG4gICAgbmV4dENoaWxkT3JkZXIoY2hpbGRPcmRlcikge1xyXG4gICAgICBsZXQgb3JkZXJzO1xyXG4gICAgICBvcmRlcnMgPSBjaGlsZE9yZGVyLnNwbGl0KCdAJyk7XHJcbiAgICAgIG9yZGVyc1tvcmRlcnMubGVuZ3RoIC0gMV0gPSAxICsgXy5wYXJzZUludChvcmRlcnNbb3JkZXJzLmxlbmd0aCAtIDFdLCAwKTtcclxuICAgICAgcmV0dXJuIG9yZGVycy5qb2luKCdAJyk7XHJcbiAgICB9XHJcblxyXG4gICAgY2hpbGRPcmRlcihwYXJlbnRPcmRlcikge1xyXG4gICAgICBpZiAocGFyZW50T3JkZXIpIHtcclxuICAgICAgICByZXR1cm4gYCR7cGFyZW50T3JkZXJ9QDFgO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiAnQDEnO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcGlkKGlkKSB7XHJcbiAgICAgIGxldCBwYXRoO1xyXG4gICAgICBwYXRoID0gaWQuc3BsaXQoJ18nKTtcclxuICAgICAgcGF0aC5wb3AoKTtcclxuICAgICAgcmV0dXJuIHBhdGguam9pbignXycpIHx8ICdfJztcclxuICAgIH1cclxuXHJcbiAgICBrZXkoYWJzUmVmLCBrZXkpIHtcclxuICAgICAgbGV0IGlkeDtcclxuICAgICAgaWYgKGFic1JlZiA9PSBudWxsKSB7XHJcbiAgICAgICAgYWJzUmVmID0gJyc7XHJcbiAgICAgIH1cclxuICAgICAgaWR4ID0gXy5maW5kSW5kZXgodGhpcy5wcm9qZWN0QWJzUmVmLCByZWYgPT4gcmVmID09PSBhYnNSZWYpO1xyXG4gICAgICBpZiAoaWR4ID09PSAtMSkge1xyXG4gICAgICAgIGlkeCA9IHRoaXMucHJvamVjdEFic1JlZi5sZW5ndGg7XHJcbiAgICAgICAgdGhpcy5wcm9qZWN0QWJzUmVmLnB1c2goYWJzUmVmKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gYC5wLmNoaWxkX3RvYy4ke2lkeH0uJHtrZXl9YDtcclxuICAgIH1cclxuXHJcbiAgICBwYXJzZUtleShrZXkpIHtcclxuICAgICAgbGV0IGFic1JlZiwga2V5cywgbGFzdEtleTtcclxuICAgICAga2V5ID0ga2V5LnN1YnN0cmluZygzKTtcclxuICAgICAga2V5cyA9IGtleS5zcGxpdCgnLicpO1xyXG4gICAgICBsYXN0S2V5ID0ga2V5cy5wb3AoKTtcclxuICAgICAgYWJzUmVmID0gdGhpcy5wcm9qZWN0QWJzUmVmW2tleXMucG9wKCldIHx8ICcnO1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIGtleTogbGFzdEtleSxcclxuICAgICAgICBhYnNSZWZcclxuICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICB1cmwoaXRlbSwgaWQpIHtcclxuICAgICAgbGV0IGJvb2tNYXJrLCBmaWxlUGF0aCwgcGFyYW1zLCBwYXJlbnRQYXRoLCB1cmw7XHJcbiAgICAgIGlmICghaXRlbS51cmwpIHtcclxuICAgICAgICByZXR1cm4gJyMnO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChpdGVtLnR5cGUgPT09ICdyZW1vdGVpdGVtJykge1xyXG4gICAgICAgIHJldHVybiBlbmNvZGVVUkkoaXRlbS51cmwpO1xyXG4gICAgICB9XHJcbiAgICAgIHBhcmVudFBhdGggPSBpdGVtLmFic1JlZiA/IF8uZW5zdXJlU2xhc2goaXRlbS5hYnNSZWYpIDogJyc7XHJcbiAgICAgIHVybCA9IGAke3BhcmVudFBhdGh9JHtpdGVtLnVybH1gO1xyXG4gICAgICBib29rTWFyayA9IF8uZXh0cmFjdEhhc2hTdHJpbmcodXJsKTtcclxuICAgICAgaWYgKHRoaXMudXJscy5pbmRleE9mKHVybCkgIT09IC0xIHx8IGJvb2tNYXJrLmxlbmd0aCA+IDApIHtcclxuICAgICAgICBib29rTWFyayA9IGJvb2tNYXJrICYmIGAjJHtib29rTWFya31gO1xyXG4gICAgICAgIGZpbGVQYXRoID0gXy5maWxlUGF0aCh1cmwpO1xyXG4gICAgICAgIHBhcmFtcyA9IF8uZXh0cmFjdFBhcmFtU3RyaW5nKHVybCk7XHJcbiAgICAgICAgaWYgKHBhcmFtcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICBwYXJhbXMgPSBgJHtwYXJhbXN9JmA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHBhcmFtcyA9IGA/JHtwYXJhbXN9cmh0b2NpZD0ke2lkfWA7XHJcbiAgICAgICAgdXJsID0gYCR7ZmlsZVBhdGh9JHtwYXJhbXN9JHtib29rTWFyayB8fCAnJ31gO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMudXJscy5wdXNoKHVybClcclxuICAgICAgcmV0dXJuIGVuY29kZVVSSSh1cmwpO1xyXG4gICAgfVxyXG5cclxuICAgIHRhZ3MoaXRlbSkge1xyXG4gICAgICBsZXQgcGFyZW50UGF0aDtcclxuICAgICAgcGFyZW50UGF0aCA9IGl0ZW0uYWJzUmVmID8gYCske2l0ZW0uYWJzUmVmfWAgOiAnJztcclxuICAgICAgaWYgKGl0ZW1bJ2RhdGEtcmh0YWdzJ10pIHtcclxuICAgICAgICByZXR1cm4gaXRlbVsnZGF0YS1yaHRhZ3MnXSArIHBhcmVudFBhdGg7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgc3Vic2NyaWJlVG9waWNJRCh0b2NJbmZvKSB7XHJcbiAgICAgIGxldCBwYXRoLCB0b2NpZDtcclxuICAgICAgaWYgKHRvY0luZm8gPT0gbnVsbCkge1xyXG4gICAgICAgIHRvY0luZm8gPSB7fTtcclxuICAgICAgfVxyXG4gICAgICB0b2NpZCA9IF8uaGFzaFBhcmFtcygpWydyaHRvY2lkJ107XHJcbiAgICAgIGlmICh0b2NpZCkge1xyXG4gICAgICAgIHBhdGggPSB0aGlzLmdldFBhdGhmcm9tSWQodG9jaWQpO1xyXG4gICAgICAgIHRoaXMuc2VsZWN0VG9jQnlJZChwYXRoLCB0aGlzLndpZGdldC5ub2RlKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICByaC5tb2RlbC5zdWJzY3JpYmUocmguY29uc3RzKCdLRVlfTUFTVEVSX1BST0pFQ1RfTElTVCcpLCAobGlzdCkgPT4ge1xyXG4gICAgICAgICAgaWYobGlzdCAmJiBsaXN0Lmxlbmd0aCA8IDIpXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN5bmNUb2Muc3luYyh0aGlzLCB0b2NJbmZvKTtcclxuICAgICAgICB9KVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgc3Vic2NyaWJlQm9va0lkKGJvb2tJZCkge1xyXG4gICAgICAvLyBzdWt1bWFyOiBUT0RPIHJlbW92ZSB0aGlzIGxpbmVcclxuICAgICAgbGV0IGJvb2tzO1xyXG4gICAgICBsZXQgcGF0aDtcclxuICAgICAgaWYgKGJvb2tJZCkge1xyXG4gICAgICAgIHBhdGggPSB0aGlzLmdldFBhdGhmcm9tSWQoYm9va0lkKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3RUb2NCeUlkKHBhdGgsIHRoaXMud2lkZ2V0Lm5vZGUsIG51bGwsIGJvb2tzKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGdldFBhdGhmcm9tSWQoaWQpe1xyXG4gICAgICBsZXQgcGF0aDtcclxuICAgICAgcGF0aCA9IGlkLnNwbGl0KCdfJyk7XHJcbiAgICAgIHBhdGguc2hpZnQoKTtcclxuICAgICAgcGF0aCA9IF8ubWFwKHBhdGgsIGl0ZW0gPT4gXy5wYXJzZUludChpdGVtLCAwKSk7XHJcbiAgICAgIHJldHVybiBwYXRoO1xyXG5cclxuICAgIH1cclxuICAgIHNlbGVjdFRvY0J5SWQocGF0aCwgbm9kZSwgd2FpdCwgYm9va3MpIHtcclxuICAgICAgbGV0IGNoaWxkLCBpbmRleDtcclxuICAgICAgaWYgKHdhaXQgPT0gbnVsbCkge1xyXG4gICAgICAgIHdhaXQgPSAxO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICghKG5vZGUgJiYgbm9kZS5jaGlsZHJlbikpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgaW5kZXggPSBwYXRoLnNoaWZ0KCk7XHJcbiAgICAgIGNoaWxkID0gXy5maW5kKG5vZGUuY2hpbGRyZW4sIGZ1bmN0aW9uKGNoaWxkKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNCb29rTm9kZShjaGlsZCkgfHwgdGhpcy5pc1BhZ2VOb2RlKGNoaWxkKSkge1xyXG4gICAgICAgICAgaWYgKGluZGV4ID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaW5kZXgtLTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9LCB0aGlzKTtcclxuICAgICAgaWYgKCFjaGlsZCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHBhdGgubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgdGhpcy5zZWxlY3RMaW5rKGNoaWxkLCB0cnVlLCB3YWl0KTtcclxuICAgICAgfVxyXG4gICAgICBpZiAodGhpcy5pc0Jvb2tOb2RlKGNoaWxkKSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm9wZW5Cb29rKGNoaWxkLCB0cnVlLCAoKF90aGlzID0+ICgpID0+IF8uZGVmZXIoKCkgPT4ge1xyXG4gICAgICAgICAgbGV0IGNoaWxkTm9kZSwgcGFyZW50Tm9kZTtcclxuICAgICAgICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gX3RoaXMudXBkYXRlQm9va0luZm8oKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNoaWxkTm9kZSA9IGNoaWxkLm5leHRFbGVtZW50U2libGluZztcclxuICAgICAgICAgICAgcGFyZW50Tm9kZSA9IGNoaWxkTm9kZS5jaGlsZHJlbiAmJiBjaGlsZE5vZGUuY2hpbGRyZW5bMF07XHJcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5zZWxlY3RUb2NCeUlkKHBhdGgsIHBhcmVudE5vZGUsIEFOSU1fVElNRSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSkpKSh0aGlzKSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlQm9va0luZm8oKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgVG9jQ29udHJvbGxlci5wcm90b3R5cGVbXCJjbGFzc1wiXSA9IGl0ZW0gPT4ge1xyXG4gICAgaWYgKGl0ZW0udHlwZSA9PT0gJ3JlbW90ZWl0ZW0nKSB7XHJcbiAgICAgIHJldHVybiAndXJsJztcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJldHVybiBpdGVtLnR5cGU7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIFRvY0NvbnRyb2xsZXI7XHJcbn0pKSgpO1xyXG5cclxucmguY29udHJvbGxlcignVG9jQ29udHJvbGxlcicsIFRvY0NvbnRyb2xsZXIpO1xyXG4iLCJsZXQgcmggPSByZXF1aXJlKFwiLi4vLi4vc3JjL2xpYi9yaFwiKVxyXG5sZXQgXyA9IHJoLl87XHJcbmxldCAkID0gcmguJDtcclxubGV0IG1vZGVsID0gcmgubW9kZWw7XHJcbmxldCBjb25zdHMgPSByaC5jb25zdHM7XHJcblxyXG5jbGFzcyBUT0NMZXZlbCB7XHJcbiAgY29uc3RydWN0b3IoKSB7XHJcbiAgICB0aGlzLmRhdGEgPSB7JycgOiB7b3JkZXI6ICcnLCBuZXh0Q2hpbGQ6IDB9fVxyXG4gICAgbW9kZWwuc3Vic2NyaWJlT25jZShjb25zdHMoJ0tFWV9QUk9KRUNUX0xJU1QnKSwgYWxsUHJvamVjdHMgPT4ge1xyXG4gICAgICBfLmVhY2goYWxsUHJvamVjdHMsIHByaiA9PiB7XHJcbiAgICAgICAgcHJqID0gXy5tYWtlUmVsYXRpdmVVcmwodGhpcy50cmltRmlyc3QocHJqLCAnLicpLCBhbGxQcm9qZWN0c1swXSk7XHJcbiAgICAgICAgdGhpcy5jaGlsZE9yZGVyKHByailcclxuICAgICAgfSlcclxuICAgICAgbW9kZWwucHVibGlzaChjb25zdHMoJ0tFWV9UT0NfT1JERVInKSwgdGhpcy5kYXRhKVxyXG4gICAgfSlcclxuICB9XHJcblxyXG4gIHRyaW1GaXJzdChwYXRoLCBjaGFyKSB7XHJcbiAgICByZXR1cm4gcGF0aCA9IChwYXRoLmxlbmd0aCAmJiBwYXRoWzBdID09PSBjaGFyICYmIHBhdGhbMV0gIT09IGNoYXIpPyBwYXRoLnN1YnN0cmluZygxKSA6IHBhdGhcclxuICB9XHJcblxyXG4gIGNoaWxkT3JkZXIoYWJzUmVmKSB7XHJcbiAgICBhYnNSZWYgPSB0aGlzLnRyaW1GaXJzdChhYnNSZWYsICcvJylcclxuICAgIGlmKCF0aGlzLmRhdGFbYWJzUmVmXSkge1xyXG4gICAgICBsZXQgcGF0aCA9IGFic1JlZlxyXG4gICAgICBwYXRoID0gIHBhdGguc3Vic3RyaW5nKDAsIHBhdGgubGFzdEluZGV4T2YoJy8nKSlcclxuICAgICAgcGF0aCA9ICBwYXRoLnN1YnN0cmluZygwLCBwYXRoLmxhc3RJbmRleE9mKCcvJykpXHJcbiAgICAgIGxldCBwYXJlbnQgPSB0aGlzLmRhdGFbcGF0aF1cclxuICAgICAgcGFyZW50Lm5leHRDaGlsZCsrXHJcbiAgICAgIHRoaXMuZGF0YVthYnNSZWZdID0ge29yZGVyOiBwYXJlbnQub3JkZXIgKyAnQCcgKyBwYXJlbnQubmV4dENoaWxkLCBuZXh0Q2hpbGQ6IDB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcy5kYXRhW2Fic1JlZl0ub3JkZXJcclxuICB9XHJcbn1cclxuXHJcbm5ldyBUT0NMZXZlbCIsImxldCB7IHJoIH0gPSB3aW5kb3c7XHJcbmxldCB7IF8gfSA9IHJoO1xyXG5sZXQgeyAkIH0gPSByaDtcclxuXHJcbmNsYXNzIEJyb3dzZVNlcXVlbmNlQnVpbGRlciB7XHJcblxyXG4gIGNvbnN0cnVjdG9yKCkge1xyXG5cclxuICAgIGxldCBoYW5kbGVUb3BpY0NoYW5nZSA9IGZ1bmN0aW9uKGRvTm90VXNlKSB7XHJcbiAgICAgIGxldCBicnNNYXAgPSByaC5tb2RlbC5nZXQoJ3QuYnJzbWFwJyk7XHJcbiAgICAgIGlmIChicnNNYXAgIT0gbnVsbCkge1xyXG4gICAgICAgIGxldCBuZXh0ID0gKGJyc01hcFsnbiddICYmIGJyc01hcFsnbiddWzBdKSB8fCAnJztcclxuICAgICAgICBsZXQgcHJldiA9IChicnNNYXBbJ3AnXSAmJiBicnNNYXBbJ3AnXVswXSkgfHwgJyc7XHJcbiAgICAgICAgbGV0IGRlY29kZWRVUkkgPSB3aW5kb3cuZGVjb2RlVVJJKGRvY3VtZW50LmxvY2F0aW9uLmhyZWYpO1xyXG5cclxuICAgICAgICBpZiAoIV8uaXNFbXB0eVN0cmluZyhuZXh0KSkge1xyXG4gICAgICAgICAgbmV4dCA9IHdpbmRvdy5fZ2V0UmVsYXRpdmVGaWxlTmFtZShkZWNvZGVkVVJJLCBuZXh0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFfLmlzRW1wdHlTdHJpbmcpIHtcclxuICAgICAgICAgIHByZXYgPSB3aW5kb3cuX2dldFJlbGF0aXZlRmlsZU5hbWUoZGVjb2RlZFVSSSwgcHJldik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByaC5tb2RlbC5wdWJsaXNoKCdsLmJyc0JhY2snLCBwcmV2KTtcclxuICAgICAgICByZXR1cm4gcmgubW9kZWwucHVibGlzaCgnbC5icnNOZXh0JywgbmV4dCk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgbGV0IHVwZGF0ZVNob3dCcnMgPSBmdW5jdGlvbigpIHtcclxuICAgICAgbGV0IHVpTW9kZSA9IHJoLm1vZGVsLmdldChyaC5jb25zdHMoJ0tFWV9VSV9NT0RFJykpO1xyXG4gICAgICBsZXQgcHJldiA9IHJoLm1vZGVsLmdldCgnbC5icnNCYWNrJyk7XHJcbiAgICAgIGxldCBuZXh0ID0gcmgubW9kZWwuZ2V0KCdsLmJyc05leHQnKTtcclxuICAgICAgbGV0IHNob3dCcnMgPSAhdWlNb2RlICYmIChwcmV2IHx8IG5leHQpID8gdHJ1ZSA6IGZhbHNlO1xyXG4gICAgICByZXR1cm4gcmgubW9kZWwucHVibGlzaCgnbC5zaG93X2JycycsIHNob3dCcnMpO1xyXG4gICAgfTtcclxuXHJcbiAgICByaC5tb2RlbC5zdWJzY3JpYmUoJ3QudG9waWN1cmwnLCBfLmRlYm91bmNlKGhhbmRsZVRvcGljQ2hhbmdlLCAyMDApKTtcclxuICAgIHJoLm1vZGVsLnN1YnNjcmliZSgndC5icnNtYXAnLCBfLmRlYm91bmNlKGhhbmRsZVRvcGljQ2hhbmdlLCAyMDApKTtcclxuXHJcbiAgICByaC5tb2RlbC5zdWJzY3JpYmUoJ2wuYnJzQmFjaycsIHVwZGF0ZVNob3dCcnMpO1xyXG4gICAgcmgubW9kZWwuc3Vic2NyaWJlKCdsLmJyc05leHQnLCB1cGRhdGVTaG93QnJzKTtcclxuICAgIHJoLm1vZGVsLnN1YnNjcmliZShyaC5jb25zdHMoJ0tFWV9VSV9NT0RFJyksICB1cGRhdGVTaG93QnJzKTtcclxuICB9XHJcbn1cclxuXHJcbi8vVE9ETzogbW92ZSBpdCB0byBjb250cm9sbGVyXHJcbnJoLndpZGdldHMuQnJvd3NlU2VxdWVuY2VCdWlsZGVyID0gQnJvd3NlU2VxdWVuY2VCdWlsZGVyO1xyXG4iLCJsZXQgeyByaCB9ID0gd2luZG93O1xyXG5sZXQgeyBfIH0gPSByaDtcclxubGV0IHsgJCB9ID0gcmg7XHJcbmxldCB7IGNvbnN0cyB9ID0gcmg7XHJcbmxldCB7IHN0b3JhZ2UgfSA9IHJoO1xyXG5sZXQgdXJsRmlsdGVyID0gcmguX3BhcmFtcy5maWx0ZXI7XHJcblxyXG52YXIgRXhwcmVzc2lvbkJ1aWxkZXIgPSAoZnVuY3Rpb24oKSB7XHJcbiAgbGV0IEdSUF9TRVBBUkFUT1IgPSB1bmRlZmluZWQ7XHJcbiAgbGV0IFRBR19TRVBBUkFUT1IgPSB1bmRlZmluZWQ7XHJcbiAgbGV0IEVMRU1FTlRfU0VQQVJBVE9SID0gdW5kZWZpbmVkO1xyXG4gIEV4cHJlc3Npb25CdWlsZGVyID0gY2xhc3MgRXhwcmVzc2lvbkJ1aWxkZXIge1xyXG4gICAgc3RhdGljIGluaXRDbGFzcygpIHtcclxuICAgIFxyXG4gICAgICBHUlBfU0VQQVJBVE9SID0gJzonO1xyXG4gICAgICBUQUdfU0VQQVJBVE9SID0gJzsnO1xyXG4gICAgICBFTEVNRU5UX1NFUEFSQVRPUiA9ICcsJztcclxuICAgIH1cclxuICBcclxuICAgIGNvbnN0cnVjdG9yKGNvbmZpZykge1xyXG4gICAgICB0aGlzLmdldFVuY2hlY2tlZCA9IHRoaXMuZ2V0VW5jaGVja2VkLmJpbmQodGhpcyk7XHJcbiAgICAgIHRoaXMuaGFuZGxlVGFnU3RhdGVzID0gdGhpcy5oYW5kbGVUYWdTdGF0ZXMuYmluZCh0aGlzKTtcclxuICAgICAgc3RvcmFnZS5pbml0KGNvbnN0cygnSEVMUF9JRCcpKTtcclxuICAgIFxyXG4gICAgICB0aGlzLmFsbFRhZ05hbWVzID0gdGhpcy5jb21wdXRlTmFtZXMocmgubW9kZWwuZ2V0KGNvbnN0cygnS0VZX01FUkdFRF9GSUxURVJfS0VZJykpKTtcclxuICAgIFxyXG4gICAgICB0aGlzLnByZXBhcmVUYWdTdGF0ZXMoKTtcclxuICAgIFxyXG4gICAgICB0aGlzLmhhbmRsZVRhZ1N0YXRlcyhyaC5tb2RlbC5nZXQoY29uc3RzKCdLRVlfUFJPSkVDVF9UQUdfU1RBVEVTJykpKTtcclxuICAgIFxyXG4gICAgICByaC5tb2RlbC5zdWJzY3JpYmUoY29uc3RzKCdLRVlfUFJPSkVDVF9UQUdfU1RBVEVTJyksXHJcbiAgICAgICAgXy5kZWJvdW5jZSh0aGlzLmhhbmRsZVRhZ1N0YXRlcywgMzAwKSxcclxuICAgICAgICB7aW5pdERvbmU6IHRydWV9KTtcclxuICAgIH1cclxuXHJcbiAgICBjb21wdXRlTmFtZXModGFncykge1xyXG4gICAgICByZXR1cm4gXy5yZWR1Y2UodGFncywgZnVuY3Rpb24ocmVzdWx0LCB0YWcpIHtcclxuICAgICAgICByZXN1bHQucHVzaCh0YWcuY2hpbGRyZW4gPyB0aGlzLmNvbXB1dGVOYW1lcyh0YWcuY2hpbGRyZW4pIDogdGFnLm5hbWUpO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgIH1cclxuICAgICAgLCBbXSwgdGhpcyk7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0VW5jaGVja2VkKGluZGV4LCBjaGVja2VkKSB7XHJcbiAgICAgIHJldHVybiBfLmZpbHRlcih0aGlzLmFsbFRhZ05hbWVzW2luZGV4XSwgaXRlbSA9PiAtMSA9PT0gY2hlY2tlZC5pbmRleE9mKGl0ZW0pKTtcclxuICAgIH1cclxuXHJcbiAgICBjb21wdXRlRXhwcmVzc2lvbihzdGF0ZXMpIHtcclxuICAgICAgaWYgKCFzdGF0ZXMgfHwgIXRoaXMuYWxsVGFnTmFtZXMpIHtcclxuICAgICAgICByZXR1cm4gcmgubW9kZWwucHVibGlzaChjb25zdHMoJ0tFWV9UQUdfRVhQUkVTU0lPTicpLCBbXSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGxldCBncm91cEV4cHJzID0gXy5yZWR1Y2Uoc3RhdGVzLCBmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcclxuICAgICAgICBpZiAoXy5pc1N0cmluZyh2YWx1ZSkpIHtcclxuICAgICAgICAgIHJlc3VsdC5wdXNoKHtjOiBbdmFsdWVdLCB1OiBbXX0pO1xyXG4gICAgICAgIH0gZWxzZSBpZiAodmFsdWUgIT0gbnVsbCkge1xyXG4gICAgICAgICAgbGV0IHZhbGlkVmFsdWVzO1xyXG4gICAgICAgICAgaWYgKCh2YWxpZFZhbHVlcyA9IF8uY29tcGFjdCh2YWx1ZSkpICYmICh2YWxpZFZhbHVlcy5sZW5ndGggPiAwKSkge1xyXG4gICAgICAgICAgICByZXN1bHQucHVzaCh7XHJcbiAgICAgICAgICAgICAgYzogdmFsaWRWYWx1ZXMsXHJcbiAgICAgICAgICAgICAgdTogdGhpcy5nZXRVbmNoZWNrZWQoa2V5LCB2YWxpZFZhbHVlcylcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgIH1cclxuICAgICAgLCBbXSwgdGhpcyk7XHJcblxyXG4gICAgICByZXR1cm4gcmgubW9kZWwucHVibGlzaChjb25zdHMoJ0tFWV9UQUdfRVhQUkVTU0lPTicpLCBncm91cEV4cHJzKTtcclxuICAgIH1cclxuXHJcbiAgICBoYW5kbGVUYWdTdGF0ZXMoc3RhdGVzKSB7XHJcbiAgICAgIGlmIChzdGF0ZXMgPT0gbnVsbCkgeyBzdGF0ZXMgPSB7fTsgfVxyXG4gICAgICB0aGlzLmNvbXB1dGVFeHByZXNzaW9uKHN0YXRlcyk7XHJcbiAgICBcclxuICAgICAgLy8gUGVyc2lzdCBuZXcgdGFnIHN0YXRlIGluIGxvY2FsREIgb3IgY29va2llc1xyXG4gICAgICByZXR1cm4gc3RvcmFnZS5wZXJzaXN0KCd0YWdfc3RhdGVzJywgc3RhdGVzKTtcclxuICAgIH1cclxuXHJcbiAgICBwcmVwYXJlVGFnU3RhdGVzKCkge1xyXG4gICAgICByZXR1cm4gcmgubW9kZWwuc3Vic2NyaWJlKGNvbnN0cygnS0VZX1BST0pFQ1RfRklMVEVSX1RZUEUnKSwgKCkgPT4ge1xyXG4gICAgICAgIGxldCB0YWdTdGF0ZXM7XHJcbiAgICAgICAgaWYgKHVybEZpbHRlcikge1xyXG4gICAgICAgICAgbGV0IGZpbHRlciA9IHJoLm1vZGVsLmdldChjb25zdHMoJ0tFWV9NRVJHRURfRklMVEVSX0tFWScpKTtcclxuICAgICAgICAgIHRhZ1N0YXRlcyA9IHRoaXMucGFyc2VVcmxGaWx0ZXIoZmlsdGVyLCB1cmxGaWx0ZXIuc3BsaXQoRUxFTUVOVF9TRVBBUkFUT1IpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKCF0YWdTdGF0ZXMpIHsgdGFnU3RhdGVzID0gc3RvcmFnZS5mZXRjaCgndGFnX3N0YXRlcycpOyB9XHJcbiAgICAgIFxyXG4gICAgICAgIGlmICghdGFnU3RhdGVzKSB7XHJcbiAgICAgICAgICB0YWdTdGF0ZXMgPSBfLmNsb25lKHJoLm1vZGVsLmdldChjb25zdHMoJ0tFWV9ERUZBVUxUX0ZJTFRFUicpKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodGFnU3RhdGVzKSB7IHJldHVybiByaC5tb2RlbC5wdWJsaXNoKGNvbnN0cygnS0VZX1BST0pFQ1RfVEFHX1NUQVRFUycpLCB0YWdTdGF0ZXMpOyB9XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHBhcnNlRmlsdGVyRWxlbW50KGZpbHRlciwgZWxlbWVudCkge1xyXG4gICAgICBsZXQgdGVtcCA9IGVsZW1lbnQuc3BsaXQoR1JQX1NFUEFSQVRPUik7XHJcbiAgICAgIGxldCBuYW1lID0gdGVtcFswXTtcclxuICAgICAgbGV0IGVsZW1lbnRzID0gdGVtcFsxXSAmJiB0ZW1wWzFdLnNwbGl0KFRBR19TRVBBUkFUT1IpO1xyXG4gICAgICBsZXQgaW5kZXggPSBfLmZpbmRJbmRleChmaWx0ZXIsIGl0ZW0gPT4gKChlbGVtZW50cyAhPSBudWxsKSA9PT0gKGl0ZW0uY2hpbGRyZW4gIT0gbnVsbCkpICYmIChpdGVtLmRpc3BsYXkgPT09IG5hbWUpKTtcclxuICAgICAgcmV0dXJuIHtpbmRleCwgZWxlbWVudHN9O1xyXG4gICAgfVxyXG5cclxuICAgIHBhcnNlVXJsRmlsdGVyKGZpbHRlciwgYXJyYXkpIHtcclxuICAgICAgaWYgKCFhcnJheSAmJiAhYXJyYXkubGVuZ3RoKSB7IHJldHVybjsgfVxyXG4gICAgICBsZXQgcmFkaW9Nb2RlID0gcmgubW9kZWwuZ2V0KGNvbnN0cygnS0VZX1BST0pFQ1RfRklMVEVSX1RZUEUnKSkgPT09ICdyYWRpbyc7XHJcbiAgICAgIGxldCBmaXJzdFN0cmluZyA9IHRydWU7XHJcbiAgICAgIHJldHVybiBfLnJlZHVjZShhcnJheSwgZnVuY3Rpb24ocmVzdWx0LCBlbGVtZW50LCBpbmRleCkge1xyXG4gICAgICAgIGxldCBlbGVtZW50cztcclxuICAgICAgICAoe2luZGV4LCBlbGVtZW50c30gPSB0aGlzLnBhcnNlRmlsdGVyRWxlbW50KGZpbHRlciwgZWxlbWVudCkpO1xyXG4gICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcclxuICAgICAgICAgIGxldCBub2RlID0gZmlsdGVyW2luZGV4XTtcclxuICAgICAgICAgIGlmIChub2RlLmNoaWxkcmVuKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdFtpbmRleF0gPSB0aGlzLnBhcnNlVXJsRmlsdGVyKG5vZGUuY2hpbGRyZW4sIGVsZW1lbnRzKTtcclxuICAgICAgICAgIH0gZWxzZSBpZiAoIXJhZGlvTW9kZSB8fCBmaXJzdFN0cmluZykge1xyXG4gICAgICAgICAgICBmaXJzdFN0cmluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICByZXN1bHRbaW5kZXhdID0gbm9kZS5uYW1lO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICB9XHJcbiAgICAgICwge30sIHRoaXMpO1xyXG4gICAgfVxyXG4gIH07XHJcbiAgRXhwcmVzc2lvbkJ1aWxkZXIuaW5pdENsYXNzKCk7XHJcbiAgcmV0dXJuIEV4cHJlc3Npb25CdWlsZGVyO1xyXG59KSgpO1xyXG4gIFxyXG5yaC53aWRnZXRzLkV4cHJlc3Npb25CdWlsZGVyID0gRXhwcmVzc2lvbkJ1aWxkZXI7IiwibGV0IHsgcmggfSA9IHdpbmRvdztcclxubGV0IHsgXyB9ID0gcmg7XHJcbmxldCB7ICQgfSA9IHJoO1xyXG5sZXQgeyBjb25zdHMgfSA9IHJoO1xyXG5cclxudmFyIEZpbHRlckNvbnRyb2xsZXIgPSAoZnVuY3Rpb24oKSB7XHJcbiAgbGV0IEdST1VQX0NMQVNTID0gdW5kZWZpbmVkO1xyXG4gIGxldCBJVEVNX0NMQVNTID0gdW5kZWZpbmVkO1xyXG4gIGxldCBLRVlfUFJPSkVDVF9GSUxURVJfVFlQRSA9IHVuZGVmaW5lZDtcclxuICBGaWx0ZXJDb250cm9sbGVyID0gY2xhc3MgRmlsdGVyQ29udHJvbGxlciB7XHJcbiAgICBzdGF0aWMgaW5pdENsYXNzKCkge1xyXG4gIFxyXG4gICAgICBHUk9VUF9DTEFTUyA9ICdncm91cCc7XHJcbiAgICAgIElURU1fQ0xBU1MgPSAnaXRlbSc7XHJcbiAgICAgIEtFWV9QUk9KRUNUX0ZJTFRFUl9UWVBFID0gY29uc3RzKCdLRVlfUFJPSkVDVF9GSUxURVJfVFlQRScpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0cnVjdG9yKHdpZGdldCkge1xyXG4gICAgICB0aGlzLmNsaWNrID0gdGhpcy5jbGljay5iaW5kKHRoaXMpO1xyXG4gICAgICB0aGlzLndpZGdldCA9IHdpZGdldDtcclxuICAgIH1cclxuICBcclxuICAgIGNsaWNrKGUpIHtcclxuICAgICAgbGV0IHRvcE5vZGUgPSBlLmN1cnJlbnRUYXJnZXQ7XHJcbiAgICAgIGxldCBjbGlja05vZGUgPSBlLnRhcmdldDtcclxuICAgICAgbGV0IG5vZGUgPSB0aGlzLmdldEl0ZW1Ob2RlKGNsaWNrTm9kZSwgdG9wTm9kZSk7XHJcbiAgICAgIGxldCBzZWxUYWdFeHByc1BhdGggPSBgJHtjb25zdHMoJ0tFWV9QUk9KRUNUX1RBR19TVEFURVMnKX0ke3RoaXMuZ2V0SXRlbUtleShub2RlKX1gO1xyXG4gICAgICBsZXQgc2VsVGFnRXhwcnMgPSB0aGlzLndpZGdldC5nZXQoc2VsVGFnRXhwcnNQYXRoKTtcclxuICAgICAgaWYgKHRoaXMuZmlsdGVyVHlwZSgpICE9PSAncmFkaW8nKSB7XHJcbiAgICAgICAgdGhpcy5oYW5kbGVDaGVja2JveENsaWNrKG5vZGUsIHNlbFRhZ0V4cHJzUGF0aCwgc2VsVGFnRXhwcnMpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMuaGFuZGxlUmFkaW9DbGljayhub2RlLCBzZWxUYWdFeHByc1BhdGgsIHNlbFRhZ0V4cHJzKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gXy5wcmV2ZW50RGVmYXVsdChlKTtcclxuICAgIH1cclxuXHJcbiAgICBoYW5kbGVSYWRpb0NsaWNrKG5vZGUsIHNlbFRhZ0V4cHJzUGF0aCwgc2VsVGFnRXhwcnMpIHtcclxuICAgICAgaWYgKCF0aGlzLmlzR3JvdXBOb2RlKG5vZGUpICYmICFzZWxUYWdFeHBycykge1xyXG4gICAgICAgIGxldCB7cGFyZW50S2V5LCBrZXl9ID0gXy5zcGxpdEtleShzZWxUYWdFeHByc1BhdGgpO1xyXG4gICAgICAgIGxldCBuZXdWYWx1ZSA9IHt9O1xyXG4gICAgICAgIG5ld1ZhbHVlW2tleV0gPSB0aGlzLmdldEl0ZW1WYWx1ZShub2RlKTtcclxuICAgICAgICByZXR1cm4gdGhpcy53aWRnZXQucHVibGlzaChwYXJlbnRLZXksIG5ld1ZhbHVlKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGhhbmRsZUNoZWNrYm94Q2xpY2sobm9kZSwgc2VsVGFnRXhwcnNQYXRoLCBzZWxUYWdFeHBycykge1xyXG4gICAgICBsZXQgbmV3VmFsdWU7XHJcbiAgICAgIGlmICh0aGlzLmlzR3JvdXBOb2RlKG5vZGUpKSB7XHJcbiAgICAgICAgbGV0IGNoZWNrZWQgPSBfLmFueShzZWxUYWdFeHBycywgdGFnRXhwciA9PiB0YWdFeHByKTtcclxuICAgICAgICBuZXdWYWx1ZSA9IGNoZWNrZWQgPyB1bmRlZmluZWQgOiB0aGlzLmdldEdyb3VwSXRlbUV4cHJzKG5vZGUpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLndpZGdldC5wdWJsaXNoKHNlbFRhZ0V4cHJzUGF0aCwgbmV3VmFsdWUpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIG5ld1ZhbHVlID0gc2VsVGFnRXhwcnMgPyB1bmRlZmluZWQgOiB0aGlzLmdldEl0ZW1WYWx1ZShub2RlKTtcclxuICAgICAgICByZXR1cm4gdGhpcy53aWRnZXQucHVibGlzaChzZWxUYWdFeHByc1BhdGgsIG5ld1ZhbHVlKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGdldEl0ZW1Ob2RlKG5vZGUsIHRvcE5vZGUpIHtcclxuICAgICAgcmV0dXJuIF8uZmluZFBhcmVudE5vZGUobm9kZSwgdG9wTm9kZSwgbm9kZSA9PiAkLm5vZGVOYW1lKG5vZGUpID09PSAnTEknKTtcclxuICAgIH1cclxuXHJcbiAgICBnZXRJdGVtVmFsdWUobm9kZSkgeyByZXR1cm4gJC5kYXRhc2V0KG5vZGUsICdpdGVtdmFsdWUnKTsgfVxyXG5cclxuICAgIGdldEdyb3VwSXRlbUV4cHJzKG5vZGUpIHtcclxuICAgICAgbGV0IGtleSA9ICQuZGF0YXNldChub2RlLCAnaXRlbWtleScpO1xyXG4gICAgICBsZXQgZ3JvdXBUYWcgPSB0aGlzLndpZGdldC5nZXQoYCR7dGhpcy53aWRnZXQua2V5fSR7a2V5fWApO1xyXG4gICAgICByZXR1cm4gXy5tYXAoZ3JvdXBUYWcuY2hpbGRyZW4sIHRhZyA9PiB0YWcubmFtZSk7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0SXRlbUtleShub2RlKSB7IHJldHVybiAkLmRhdGFzZXQobm9kZSwgJ2l0ZW1rZXknKTsgfVxyXG5cclxuICAgIGlzR3JvdXBOb2RlKG5vZGUpIHsgcmV0dXJuICQuaGFzQ2xhc3Mobm9kZSwgR1JPVVBfQ0xBU1MpOyB9XHJcblxyXG4gICAgaXNJdGVtTm9kZShub2RlKSB7IHJldHVybiAkLmhhc0NsYXNzKG5vZGUsIElURU1fQ0xBU1MpOyB9XHJcblxyXG4gICAgY2xhc3MoaXRlbSkgeyBpZiAoaXRlbS5jaGlsZHJlbikgeyByZXR1cm4gR1JPVVBfQ0xBU1M7IH0gZWxzZSB7IHJldHVybiBJVEVNX0NMQVNTOyB9IH1cclxuXHJcbiAgICB2YWx1ZShpdGVtKSB7IGlmIChpdGVtLmNoaWxkcmVuKSB7IHJldHVybiBudWxsOyB9IGVsc2UgeyByZXR1cm4gaXRlbS5uYW1lOyB9IH1cclxuXHJcbiAgICBmaWx0ZXJUeXBlKCkgeyByZXR1cm4gdGhpcy53aWRnZXQuZ2V0KEtFWV9QUk9KRUNUX0ZJTFRFUl9UWVBFKSB8fCAnY2hlY2tib3gnOyB9XHJcblxyXG4gICAgaW5wdXRUeXBlKGl0ZW0pIHtcclxuICAgICAgbGV0IHR5cGUgPSB0aGlzLmZpbHRlclR5cGUoKTtcclxuICAgICAgaWYgKGl0ZW0uY2hpbGRyZW4gJiYgKHR5cGUgPT09ICdyYWRpbycpKSB7IHR5cGUgPSB1bmRlZmluZWQ7IH1cclxuICAgICAgcmV0dXJuIHR5cGU7XHJcbiAgICB9XHJcbiAgfTtcclxuICBGaWx0ZXJDb250cm9sbGVyLmluaXRDbGFzcygpO1xyXG4gIHJldHVybiBGaWx0ZXJDb250cm9sbGVyO1xyXG59KSgpO1xyXG5cclxucmguY29udHJvbGxlcignRmlsdGVyQ29udHJvbGxlcicsIEZpbHRlckNvbnRyb2xsZXIpOyIsImNvbnN0IHsgcmggfSA9IHdpbmRvdztcclxuY29uc3QgeyBtb2RlbCB9ID0gcmg7XHJcbmNvbnN0IHsgXyB9ID0gcmg7XHJcbmNvbnN0IHsgY29uc3RzIH0gPSByaDtcclxuY29uc3QgeyBhcGlDbGllbnQgfSA9IHJoO1xyXG5jb25zdCB7IHJocyB9ID0gcmg7XHJcblxyXG5cclxudmFyIEZpbHRlclJlcG9ydCA9IChmdW5jdGlvbigpIHtcclxuICBsZXQgZ2V0UG9zdFVybCA9IHVuZGVmaW5lZDtcclxuICBGaWx0ZXJSZXBvcnQgPSBjbGFzcyBGaWx0ZXJSZXBvcnQge1xyXG4gICAgc3RhdGljIGluaXRDbGFzcygpIHtcclxuXHJcblxyXG4gICAgICBnZXRQb3N0VXJsID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgY29uc3QgaG9zdCA9IGRvY3VtZW50LmxvY2F0aW9uLm9yaWdpbjtcclxuICAgICAgICBjb25zdCBiYXNlQ29udGV4dCA9IG1vZGVsLmdldChjb25zdHMoJ0tFWV9QVUJMSVNIX0JBU0VfVVJMJykpLnN1YnN0cihob3N0Lmxlbmd0aCk7XHJcbiAgICAgICAgaWYgKGJhc2VDb250ZXh0ICYmICFfLmlzRW1wdHlTdHJpbmcoYmFzZUNvbnRleHQpKSB7XHJcbiAgICAgICAgICBjb25zdCBoYXNoU3RyaW5nID0gXy5tYXBUb0VuY29kZWRTdHJpbmcoXy5leHRlbmQoXy5hZGRQYXRoTmFtZUtleSh7YXJlYTogcmhzLmFyZWEoKSxcclxuICAgICAgICAgIHByajogcmhzLnByb2plY3QoKSwgdHlwZTogKHJocy50eXBlKSgpLCBhZ3Q6ICdmbHRScHQnLCBtZ3I6ICdhZ20nXHJcbiAgICAgICAgICB9KVxyXG4gICAgICAgICAgKSk7XHJcbiAgICAgICAgICByZXR1cm4gYCR7YmFzZUNvbnRleHR9PyR7aGFzaFN0cmluZ31gO1xyXG4gICAgICAgIH1cclxuICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgY29uc3QgdGltZXIgPSAzMDAwO1xyXG4gICAgICBtb2RlbC5zdWJzY3JpYmVPbmNlKGNvbnN0cygnRVZUX1BST0pFQ1RfTE9BREVEJyksICgpID0+XHJcbiAgICAgICAgbW9kZWwuc3Vic2NyaWJlT25jZShjb25zdHMoJ0tFWV9QVUJMSVNIX01PREUnKSwgZnVuY3Rpb24odmFsKSB7XHJcbiAgICAgICAgICBpZiAoIXZhbCkgeyByZXR1cm47IH1cclxuICAgICAgICAgIHZhciB1cmwgPSB1cmwgfHwgZ2V0UG9zdFVybCgpO1xyXG4gICAgICAgICAgbGV0IGNrVGFncyA9IFtdO1xyXG4gICAgICAgICAgY29uc3QgcG9zdFRvU2VydmVyID0gXy5kZWJvdW5jZSgoKSA9PlxyXG4gICAgICAgICAgYXBpQ2xpZW50LnBvc3QodXJsLCBKU09OLnN0cmluZ2lmeShja1RhZ3MpKVxyXG4gICAgICAgICAgICAuZXJyb3IoZnVuY3Rpb24oZGF0YSwgc3RhdHVzKSB7XHJcbiAgICAgICAgICAgICAgaWYgKHJoLl9kZWJ1ZykgeyByZXR1cm4gcmguX2QoJ2Vycm9yJywgJ0ZpbHRlciByZXBvcnQgc3RhdHVzICcsIHN0YXR1cyk7IH1cclxuICAgICAgICAgICAgfSlcclxuXHJcbiAgICAgICAgICAsIHRpbWVyLCBmYWxzZSk7XHJcblxyXG4gICAgICAgICAgcmV0dXJuIG1vZGVsLnN1YnNjcmliZShjb25zdHMoJ0tFWV9UQUdfRVhQUkVTU0lPTicpLCAgZnVuY3Rpb24oZXhwcikge1xyXG4gICAgICAgICAgICBja1RhZ3MgPSBbXTtcclxuICAgICAgICAgICAgY29uc3QgZmlsdGVyRGF0YSA9IHJoLm1vZGVsLmdldChjb25zdHMoJ0tFWV9NRVJHRURfRklMVEVSX0tFWScpKTtcclxuICAgICAgICAgICAgZm9yIChsZXQgdGFncyBvZiBBcnJheS5mcm9tKGV4cHIpKSB7XHJcbiAgICAgICAgICAgICAgZm9yIChsZXQgdGFnIG9mIEFycmF5LmZyb20odGFncy5jKSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHRhZ0RhdGE7XHJcbiAgICAgICAgICAgICAgICBpZiAodGFnRGF0YSA9IHJoLmZpbHRlck9iamVjdC5sb29rdXAoZmlsdGVyRGF0YSwgdGFnLCBmYWxzZSkpIHtcclxuICAgICAgICAgICAgICAgICAgY2tUYWdzLnB1c2godGFnRGF0YS5kaXNwbGF5KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGNrVGFncy5sZW5ndGggPiAwKSB7IHJldHVybiBwb3N0VG9TZXJ2ZXIoKTsgfVxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfSlcclxuICAgICAgKTtcclxuICAgIH1cclxuICB9O1xyXG4gIEZpbHRlclJlcG9ydC5pbml0Q2xhc3MoKTtcclxuICByZXR1cm4gRmlsdGVyUmVwb3J0O1xyXG59KSgpO1xyXG5cclxubmV3IEZpbHRlclJlcG9ydDtcclxuIiwibGV0IHsgcmggfSA9IHdpbmRvdztcclxubGV0IHsgXyB9ID0gcmg7XHJcbmxldCB7ICQgfSA9IHJoO1xyXG5sZXQgeyBjb25zdHMgfSA9IHJoO1xyXG5sZXQgeyBtb2RlbCB9ID0gcmg7XHJcblxyXG5tb2RlbC5wdWJsaXNoKGNvbnN0cygnS0VZX1NIT1dfVEFHUycpLCByaC5fcGFyYW1zLnNob3d0YWdzID09PSAndHJ1ZScpO1xyXG5tb2RlbC5wdWJsaXNoKGNvbnN0cygnS0VZX0lGUkFNRV9FVkVOVFMnKSwge2NsaWNrOiB0cnVlfSk7XHJcblxyXG5sZXQgb2xkSGFzaE1hcCA9IHt9O1xyXG5sZXQgaGFzaENoYW5nZWQgPSBmdW5jdGlvbigpIHtcclxuICBsZXQgbmV3SGFzaE1hcCA9IF8uaGFzaFBhcmFtcygpO1xyXG4gIG1vZGVsLnB1Ymxpc2goY29uc3RzKCdFVlRfSEFTSF9DSEFOR0UnKSxcclxuICAgIHtvbGRNYXA6IG9sZEhhc2hNYXAsIG5ld01hcDogbmV3SGFzaE1hcH0sXHJcbiAgICB7c3luYzogdHJ1ZX0pO1xyXG4gIHJldHVybiBvbGRIYXNoTWFwID0gbmV3SGFzaE1hcDtcclxufTtcclxuXHJcbmxldCByZWRpcmVjdFRvRGVmYXVsdFRvcGljID0gZnVuY3Rpb24oKSB7XHJcbiAgICBsZXQgcGFyYW1zU3RyID0gXy5leHRyYWN0UGFyYW1TdHJpbmcoZG9jdW1lbnQubG9jYXRpb24uaHJlZik7XHJcbiAgICBsZXQgcGFyYW1zTWFwID0gXy51cmxQYXJhbXMocGFyYW1zU3RyKTtcclxuICAgIGxldCBoYXNoU3RyID0gXy5leHRyYWN0SGFzaFN0cmluZyhkb2N1bWVudC5sb2NhdGlvbi5ocmVmKTtcclxuICAgIGxldCBoYXNoTWFwID0gXy5oYXNoUGFyYW1zKGhhc2hTdHIpO1xyXG4gICAgbGV0IG1hcG5vYXR0ciA9IGNvbnN0cygnUkhNQVBOTycpO1xyXG4gICAgbGV0IHRvcGljS2V5ID0gY29uc3RzKCdIQVNIX0tFWV9UT1BJQycpO1xyXG4gICAgaWYgKCEobWFwbm9hdHRyIGluIHBhcmFtc01hcCkgJiYgISh0b3BpY0tleSBpbiBoYXNoTWFwKSkge1xyXG4gICAgICByZXR1cm4gZG9jdW1lbnQubG9jYXRpb24gPSBjb25zdHMoJ0RFRkFVTFRfVE9QSUMnKTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuXy5hZGRFdmVudExpc3RlbmVyKHdpbmRvdywgJ2hhc2hjaGFuZ2UnLCBoYXNoQ2hhbmdlZCk7XHJcblxyXG5fLmFkZEV2ZW50TGlzdGVuZXIod2luZG93LCAnb3JpZW50YXRpb25jaGFuZ2UnLCBmdW5jdGlvbihlKSB7XHJcbiAgbW9kZWwucHVibGlzaChjb25zdHMoJ0VWVF9PUklFTlRBVElPTl9DSEFOR0UnKSwgbnVsbCk7XHJcbiAgaWYgKG1vZGVsLmdldChjb25zdHMoJ0tFWV9TQ1JFRU5fSVBBRCcpKSkge1xyXG4gICAgbGV0IHRvcGljRnJhbWU7XHJcbiAgICBpZiAodG9waWNGcmFtZSA9IF8uZ2V0VG9waWNGcmFtZSgpKSB7XHJcbiAgICAgIGxldCB7IGRpc3BsYXkgfSA9IHRvcGljRnJhbWUuc3R5bGU7XHJcbiAgICAgIHRvcGljRnJhbWUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcclxuICAgICAgdG9waWNGcmFtZS5vZmZzZXRIZWlnaHQ7XHJcbiAgICAgIHJldHVybiBfLmRlZmVyKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHRvcGljRnJhbWUuc3R5bGUuZGlzcGxheSA9IGRpc3BsYXk7XHJcbiAgICAgICAgcmV0dXJuIF8uZGVsYXkoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICB0b3BpY0ZyYW1lLm9mZnNldEhlaWdodDtcclxuICAgICAgICAgIHJldHVybiBfLmRlbGF5KCgpID0+IC8vIExldCB0cnkgb25jZSBtb3JlXHJcbiAgICAgICAgICAgIHRvcGljRnJhbWUub2Zmc2V0SGVpZ2h0XHJcbiAgICAgICAgICBcclxuICAgICAgICAgICwgNTAwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLCAyMDApO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9XHJcbn0pO1xyXG4gICBcclxuXHJcbi8vIFRPRE9cclxuLy9tb2RlbC5zdWJzY3JpYmUgY29uc3RzKCdFVlRfT1JJRU5UQVRJT05fQ0hBTkdFJyksIF8uZGVib3VuY2UgLT5cclxuLy8gIG1ldGEgPSAkKCdtZXRhW25hbWU9dmlld3BvcnRdJywgMClcclxuLy8gIG1ldGEuY29udGVudCA9IFwid2lkdGg9I3t3aW5kb3cuaW5uZXJXaWR0aH0sIGluaXRpYWwtc2NhbGU9MSxcclxuLy8gIG1heGltdW0tc2NhbGU9MywgdXNlci1zY2FsYWJsZT15ZXNcIlxyXG4vLyAgaWYgbW9kZWwuZ2V0IGNvbnN0cyAnS0VZX1NDUkVFTl9JT1MnXHJcbi8vICAgIG1vZGVsLnB1Ymxpc2ggY29uc3RzKCdFVlRfUkVMT0FEX1RPUElDJyksIG51bGxcclxuLy8sIDI1MFxyXG5cclxubW9kZWwuc3Vic2NyaWJlKGNvbnN0cygnRVZUX1dJREdFVF9MT0FERUQnKSwgZnVuY3Rpb24oKSB7XHJcbiAgLy8gQ3JlYXRlIEV4cHJlc3Npb25CdWlsZGVyIHdpZGdldCBvbiBldmVyeSBwYWdlXHJcbiAgbGV0IHRvcGljRnJhbWU7XHJcbiAgbW9kZWwuc3Vic2NyaWJlKGNvbnN0cygnS0VZX01FUkdFRF9GSUxURVJfS0VZJyksICgpID0+IG5ldyByaC53aWRnZXRzLkV4cHJlc3Npb25CdWlsZGVyKCkpO1xyXG5cclxuICAvLyBDcmVhdGUgQnJvd3NlU2VxdWVuY2VCdWlsZGVyIHdpZGdldCBvbiBldmVyeSBwYWdlXHJcbiAgbmV3IHJoLndpZGdldHMuQnJvd3NlU2VxdWVuY2VCdWlsZGVyKCk7XHJcblxyXG4gIGhhc2hDaGFuZ2VkKCk7XHJcblxyXG4gIC8vIHJlcGxhY2UgZGVmYXVsdCBwcmludCBtZXRob2QgdG8gc3VwcG9ydCBpRnJhbWVcclxuICByaC5sYXlvdXRQcmludCA9IHdpbmRvdy5wcmludDtcclxuICB3aW5kb3cucHJpbnQgPSAoKSA9PlxyXG4gICAgLy8gcHVibGlzaCBpdCB3aXRoIG51bGwgdmFsdWUsIHRvIHN0b3AgdGhlIGF1dG1hdGljIHN1YnNjcmliZSBjYWxsc1xyXG4gICAgbW9kZWwucHVibGlzaChjb25zdHMoJ0VWVF9QUklOVF9UT1BJQycpLCBudWxsKVxyXG4gIDtcclxuXHJcbiAgbGV0IHRvcGljRmlsZU5hbWUgPSBfLmdldEZpbGVOYW1lKGRvY3VtZW50LmxvY2F0aW9uLmhyZWYpO1xyXG4gIGlmICh0b3BpY0ZpbGVOYW1lID09PSBjb25zdHMoJ1RPUElDX0ZJTEUnKSkge1xyXG4gICAgbGV0IHJlZGlyZWN0VXJsID0gcmVkaXJlY3RUb0RlZmF1bHRUb3BpYygpO1xyXG4gICAgaWYgKHJlZGlyZWN0VXJsKSB7IHJldHVybiByZWRpcmVjdFVybDsgfVxyXG4gIH1cclxuXHJcbiAgaWYgKHRvcGljRnJhbWUgPSBfLmdldFRvcGljRnJhbWUoKSkge1xyXG4gICAgcmV0dXJuIHRvcGljRnJhbWUub25sb2FkID0gKCkgPT4gbW9kZWwucHVibGlzaChjb25zdHMoJ0VWVF9UT1BJQ19MT0FERUQnKSwgbnVsbCk7XHJcbiAgfSBlbHNlIHtcclxuICAgIGxldCBwYXJhbXNTdHIgPSBfLmV4dHJhY3RQYXJhbVN0cmluZyhkb2N1bWVudC5sb2NhdGlvbi5ocmVmKTtcclxuICAgIGxldCBwYXJhbXNNYXAgPSBfLnVybFBhcmFtcyhwYXJhbXNTdHIpO1xyXG4gICAgbGV0IG1hcG5vYXR0ciA9IGNvbnN0cygnUkhNQVBOTycpO1xyXG4gICAgaWYoIG1hcG5vYXR0ciBpbiBwYXJhbXNNYXAgKSB7XHJcbiAgICAgIHJldHVybiBkb2N1bWVudC5sb2NhdGlvbiA9IGNvbnN0cygnVE9QSUNfRklMRScpICsgXCI/XCIgKyBwYXJhbXNTdHI7XHJcbiAgICB9XHJcbiAgfVxyXG59KTtcclxubW9kZWwuc3Vic2NyaWJlKGAke2NvbnN0cygnRVZUX0JPT0tNQVJLJyl9I2NvbnRlbnRfdG9wX3BsYWNlaG9sZGVyYCwgKCkgPT5cclxuICAvLyBIYWNrICNjb250ZW50X3RvcF9saW5rIGNsaWNrcyBhbmQgc2VuZCB0aGVtIHRvIGNvbnRlbnQgaWZyYW1lXHJcbiAgbW9kZWwucHVibGlzaChjb25zdHMoJ0VWVF9TQ1JPTExfVE9fVE9QJyksIG51bGwpXHJcbik7XHJcblxyXG5tb2RlbC5zdWJzY3JpYmUoY29uc3RzKCdLRVlfUFJPSkVDVF9MSVNUJyksICgpID0+IHJoLmZpbHRlck9iamVjdCA9IG5ldyByaC5NZXJnZVByb2opO1xyXG5cclxubW9kZWwuc3Vic2NyaWJlKGNvbnN0cygnRVZUX1BST0pFQ1RfTE9BREVEJyksIGZ1bmN0aW9uKCkge1xyXG4gIGxldCBkZXZpY2VSZWFkeSA9IFwiZGV2aWNlcmVhZHlcIjtcclxuICByZXR1cm4gZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihkZXZpY2VSZWFkeSwgZnVuY3Rpb24oKSB7XHJcbiAgICBpZiAod2luZG93LmNvcmRvdmEgIT0gbnVsbCkgeyByZXR1cm4gbW9kZWwucHVibGlzaChjb25zdHMoJ0tFWV9NT0JJTEVfQVBQX01PREUnKSwgdHJ1ZSk7IH1cclxuICB9KTtcclxufSk7XHJcblxyXG5tb2RlbC5zdWJzY3JpYmUoY29uc3RzKCdHT19UT19ERUZBVUxUX1RPUElDJyksIGZ1bmN0aW9uICgpXHJcbntcclxuICBfLmdvVG9EZWZhdWx0VG9waWMoKVxyXG59KTtcclxuIiwidmFyIEpzTG9hZGluZ0NvbnRyb2xsZXIgPSAoZnVuY3Rpb24oKSB7XHJcbiAgbGV0IHJoID0gdW5kZWZpbmVkO1xyXG4gIGxldCAkID0gdW5kZWZpbmVkO1xyXG4gIGxldCBfID0gdW5kZWZpbmVkO1xyXG4gIEpzTG9hZGluZ0NvbnRyb2xsZXIgPSBjbGFzcyBKc0xvYWRpbmdDb250cm9sbGVyIHtcclxuICAgIHN0YXRpYyBpbml0Q2xhc3MoKSB7XHJcbiAgICAgICh7IHJoIH0gPSB3aW5kb3cpO1xyXG4gICAgICAoeyAkIH0gPSByaCk7XHJcbiAgICAgICh7IF8gfSA9IHJoKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdHJ1Y3Rvcih3aWRnZXQsIG9wdHMpIHtcclxuICAgICAgbGV0IHJlbW92ZUNsYXNzZXMgPSAob3B0cyAhPSBudWxsID8gb3B0cy5yZW1vdmVDbGFzc2VzIDogdW5kZWZpbmVkKSB8fCBbJ2hpZGUtY2hpbGRyZW4nLCAnbG9hZGluZyddO1xyXG4gICAgICBfLmVhY2gocmVtb3ZlQ2xhc3NlcywgY2xhc3NOYW1lID0+ICQucmVtb3ZlQ2xhc3Mod2lkZ2V0Lm5vZGUsIGNsYXNzTmFtZSkpO1xyXG4gICAgICBfLmVhY2gob3B0cyAhPSBudWxsID8gb3B0cy5hZGRDbGFzc2VzIDogdW5kZWZpbmVkLCBjbGFzc05hbWUgPT4gJC5hZGRDbGFzcyh3aWRnZXQubm9kZSwgY2xhc3NOYW1lKSk7XHJcbiAgICB9XHJcbiAgfTtcclxuICBKc0xvYWRpbmdDb250cm9sbGVyLmluaXRDbGFzcygpO1xyXG4gIHJldHVybiBKc0xvYWRpbmdDb250cm9sbGVyO1xyXG59KSgpO1xyXG5cclxud2luZG93LnJoLmNvbnRyb2xsZXIoJ0pzTG9hZGluZ0NvbnRyb2xsZXInLCBKc0xvYWRpbmdDb250cm9sbGVyKTtcclxuIiwibGV0IHsgcmggfSA9IHdpbmRvdztcclxubGV0IHsgXyB9ID0gcmg7XHJcbmxldCB7ICQgfSA9IHJoO1xyXG5sZXQgeyBjb25zdHMgfSA9IHJoO1xyXG5cclxucmgubW9kZWwuc3Vic2NyaWJlKGNvbnN0cygnRVZUX1dJREdFVF9CRUZPUkVMT0FEJyksIGZ1bmN0aW9uKCkge1xyXG4gIGlmICgkKCdhLndTaG93JywgMCkgIT09IG51bGwpIHtcclxuICAgIGxldCBjb250ZW50RGl2ID0gJCgnLmNvbnRlbnR0b3BpYycsIDApO1xyXG4gICAgJC5zZXRBdHRyaWJ1dGUoY29udGVudERpdiwgJ2RhdGEtcmh3aWRnZXQnLCAnQmFzaWMnKTtcclxuICAgIHJldHVybiAkLnNldEF0dHJpYnV0ZShjb250ZW50RGl2LCAnZGF0YS1jbGFzcycsXHJcbiAgICAgICdnb3Z0X2NzaDpALmwuY3NoX21vZGU7Z292dF9ub2NzaDohQC5sLmNzaF9tb2RlJyk7XHJcbiAgfVxyXG59KTsiLCJsZXQgeyByaCB9ID0gd2luZG93O1xyXG5sZXQgeyBfIH0gPSByaDtcclxubGV0IHsgbW9kZWwgfSA9IHJoO1xyXG5sZXQgeyBjb25zdHMgfSA9IHJoO1xyXG5cclxudmFyIFByb2plY3RzID0gKGZ1bmN0aW9uICgpIHtcclxuICBsZXQgcHJvamVjdExpc3QgPSB1bmRlZmluZWQ7XHJcbiAgbGV0IHByb2plY3RzVG9CZUxvYWRlZCA9IHVuZGVmaW5lZDtcclxuICBsZXQgcHJvamVjdFF1ZXVlID0gdW5kZWZpbmVkO1xyXG4gIGxldCBwcm9qRGF0YUZpbGUgPSB1bmRlZmluZWQ7XHJcbiAgbGV0IFJFTU9URU5PREUgPSB1bmRlZmluZWQ7XHJcbiAgbGV0IFBST0pOT0RFID0gdW5kZWZpbmVkO1xyXG4gIGxldCBVUkwgPSB1bmRlZmluZWQ7XHJcbiAgbGV0IGxvYWRlZCA9IHVuZGVmaW5lZDtcclxuICBsZXQgbG9hZFByb2plY3RGaWxlID0gdW5kZWZpbmVkO1xyXG4gIGxldCBnZXRQcm9qZWN0TGlzdCA9IHVuZGVmaW5lZDtcclxuICBQcm9qZWN0cyA9IGNsYXNzIFByb2plY3RzIHtcclxuICAgIHN0YXRpYyBpbml0Q2xhc3MoKSB7XHJcbiAgICAgIHByb2plY3RMaXN0ID0gW107XHJcbiAgICAgIHByb2plY3RzVG9CZUxvYWRlZCA9IFtdO1xyXG4gICAgICBwcm9qZWN0UXVldWUgPSBbXTtcclxuICAgICAgcHJvakRhdGFGaWxlID0gJ3Byb2plY3RkYXRhLmpzJztcclxuICAgICAgUkVNT1RFTk9ERSA9ICdyZW1vdGUnO1xyXG4gICAgICBQUk9KTk9ERSA9ICdwcm9qZWN0JztcclxuICAgICAgVVJMID0gJ3VybCc7XHJcbiAgICAgIGxvYWRlZCA9IDA7XHJcblxyXG4gICAgICBsb2FkUHJvamVjdEZpbGUgPSBmdW5jdGlvbiAoY3VyUHJvalBhdGgpIHtcclxuICAgICAgICBsZXQgY3VyUHJvakRhdGFGaWxlID0gY3VyUHJvalBhdGggKyAnLycgKyBwcm9qRGF0YUZpbGU7XHJcbiAgICAgICAgcmV0dXJuIHdpbmRvdy54bWxKc1JlYWRlci5sb2FkRmlsZShjdXJQcm9qRGF0YUZpbGUsIGZ1bmN0aW9uICh4bWxEb2MsIGN1clByb2pQYXRoKSB7XHJcbiAgICAgICAgICBsZXQgcmVtb3RlTm9kZXM7XHJcbiAgICAgICAgICBsZXQgbGVuID0gMDtcclxuICAgICAgICAgIGxvYWRlZCsrO1xyXG4gICAgICAgICAgaWYgKHhtbERvYyAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIGxldCBwcm9qWG1sTm9kZSA9IHhtbERvYy5nZXRFbGVtZW50c0J5VGFnTmFtZShQUk9KTk9ERSlbMF07XHJcbiAgICAgICAgICAgIHJlbW90ZU5vZGVzID0gcHJvalhtbE5vZGUuZ2V0RWxlbWVudHNCeVRhZ05hbWUoUkVNT1RFTk9ERSk7XHJcbiAgICAgICAgICAgIGxlbiA9IHJlbW90ZU5vZGVzLmxlbmd0aDtcclxuICAgICAgICAgIH0gZWxzZSBpZiAoKGN1clByb2pQYXRoLmxlbmd0aCA+IDApKSB7XHJcbiAgICAgICAgICAgIGxldCBpbmRleCA9IHByb2plY3RzVG9CZUxvYWRlZC5pbmRleE9mKGN1clByb2pQYXRoWzBdKVxyXG4gICAgICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xyXG4gICAgICAgICAgICAgIHByb2plY3RzVG9CZUxvYWRlZC5zcGxpY2UoaW5kZXgsIDEpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICAgIF8uZWFjaChyZW1vdGVOb2RlcywgZnVuY3Rpb24gKHJlbW90ZU5vZGUpIHtcclxuICAgICAgICAgICAgbGV0IHBhdGggPSBjdXJQcm9qUGF0aCArICcvJyArIHJlbW90ZU5vZGUuZ2V0QXR0cmlidXRlKFVSTCk7XHJcbiAgICAgICAgICAgIHByb2plY3RMaXN0LnB1c2gocGF0aCk7XHJcbiAgICAgICAgICAgIHByb2plY3RzVG9CZUxvYWRlZC5wdXNoKHBhdGgpXHJcbiAgICAgICAgICAgIHJldHVybiBwcm9qZWN0UXVldWUucHVzaChwYXRoKTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgZ2V0UHJvamVjdExpc3QoKTtcclxuICAgICAgICAgIGlmICgocHJvamVjdFF1ZXVlLmxlbmd0aCA9PT0gMCkgJiYgKGxvYWRlZCA9PT0gcHJvamVjdExpc3QubGVuZ3RoKSkge1xyXG4gICAgICAgICAgICBtb2RlbC5wdWJsaXNoKGNvbnN0cygnS0VZX1BST0pFQ1RfTElTVCcpLCBwcm9qZWN0c1RvQmVMb2FkZWQpO1xyXG4gICAgICAgICAgICByZXR1cm4gbW9kZWwucHVibGlzaChjb25zdHMoJ0tFWV9NQVNURVJfUFJPSkVDVF9MSVNUJyksIFtcIi5cIl0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAgICwgY3VyUHJvalBhdGgpO1xyXG4gICAgICB9O1xyXG5cclxuICAgICAgZ2V0UHJvamVjdExpc3QgPSAoKSA9PlxyXG4gICAgICAgICgoKSA9PiB7XHJcbiAgICAgICAgICBsZXQgcmVzdWx0ID0gW107XHJcbiAgICAgICAgICB3aGlsZSAocHJvamVjdFF1ZXVlLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgbGV0IHByb2plY3QgPSBwcm9qZWN0UXVldWUuc3BsaWNlKDAsIDEpO1xyXG4gICAgICAgICAgICByZXN1bHQucHVzaChsb2FkUHJvamVjdEZpbGUocHJvamVjdCkpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9KSgpXHJcbiAgICAgICAgO1xyXG4gICAgfVxyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgIHByb2plY3RMaXN0LnB1c2goJy4nKTtcclxuICAgICAgcHJvamVjdHNUb0JlTG9hZGVkLnB1c2goJy4nKVxyXG4gICAgICBwcm9qZWN0UXVldWUucHVzaCgnLicpO1xyXG4gICAgICBnZXRQcm9qZWN0TGlzdCgpO1xyXG4gICAgfVxyXG4gIH07XHJcbiAgUHJvamVjdHMuaW5pdENsYXNzKCk7XHJcbiAgcmV0dXJuIFByb2plY3RzO1xyXG59KSgpO1xyXG5cclxubW9kZWwuc3Vic2NyaWJlKGNvbnN0cygnRVZUX1BST0pFQ1RfTE9BREVEJyksICgpID0+XHJcbiAgXy5kZWZlcihmdW5jdGlvbiAoKSB7XHJcbiAgICBpZiAoIW1vZGVsLmdldChjb25zdHMoJ0tFWV9QVUJMSVNIX01PREUnKSkgJiYgIXdpbmRvdy5nYlByZXZpZXdNb2RlKSB7XHJcbiAgICAgIHJldHVybiBuZXcgUHJvamVjdHM7XHJcbiAgICB9XHJcbiAgfSlcclxuKTtcclxuIiwidmFyIE1vZGVybkxheW91dENvbnRyb2xsZXIgPSAoZnVuY3Rpb24oKSB7XHJcbiAgbGV0IHJoID0gdW5kZWZpbmVkO1xyXG4gIGxldCBfID0gdW5kZWZpbmVkO1xyXG4gIGxldCAkID0gdW5kZWZpbmVkO1xyXG4gIGxldCBjb25zdHMgPSB1bmRlZmluZWQ7XHJcbiAgbGV0IEtFWV9GRUFUVVJFID0gdW5kZWZpbmVkO1xyXG4gIGxldCBLRVlfRklMVEVSX0xPQ0FUSU9OID0gdW5kZWZpbmVkO1xyXG4gIGxldCBLRVlfU0VBUkNIX0xPQ0FUSU9OID0gdW5kZWZpbmVkO1xyXG4gIGxldCBLRVlfQUNUSVZFX1RBQiA9IHVuZGVmaW5lZDtcclxuICBsZXQgS0VZX1VJX01PREUgPSB1bmRlZmluZWQ7XHJcbiAgbGV0IEtFWV9NT0JJTEVfVE9DX0RSSUxMX0RPV04gPSB1bmRlZmluZWQ7XHJcbiAgbGV0IEtFWV9UT0NfRFJJTExfRE9XTiA9IHVuZGVmaW5lZDtcclxuICBsZXQgREVTS1RPUCA9IHVuZGVmaW5lZDtcclxuICBsZXQgVEFCTEVUID0gdW5kZWZpbmVkO1xyXG4gIGxldCBQSE9ORSA9IHVuZGVmaW5lZDtcclxuICBsZXQgU0hPV19GSUxURVJfVUkgPSB1bmRlZmluZWQ7XHJcbiAgbGV0IHRhYnMgPSB1bmRlZmluZWQ7XHJcbiAgbGV0IHNpZGVCYXJUYWJzID0gdW5kZWZpbmVkO1xyXG4gIGxldCBkZWxheUxvYWRUYWJzID0gdW5kZWZpbmVkO1xyXG4gIE1vZGVybkxheW91dENvbnRyb2xsZXIgPSBjbGFzcyBNb2Rlcm5MYXlvdXRDb250cm9sbGVyIHtcclxuICAgIHN0YXRpYyBpbml0Q2xhc3MoKSB7XHJcblxyXG4gICAgICAoeyByaCB9ID0gd2luZG93KTtcclxuICAgICAgKHsgXyB9ID0gcmgpO1xyXG4gICAgICAoeyAkIH0gPSByaCk7XHJcbiAgICAgICh7IGNvbnN0cyB9ID0gcmgpO1xyXG4gICAgICBLRVlfRkVBVFVSRSA9IGNvbnN0cygnS0VZX0ZFQVRVUkUnKTtcclxuICAgICAgS0VZX0ZJTFRFUl9MT0NBVElPTiA9IGNvbnN0cygnS0VZX0ZJTFRFUl9MT0NBVElPTicpO1xyXG4gICAgICBLRVlfU0VBUkNIX0xPQ0FUSU9OID0gY29uc3RzKCdLRVlfU0VBUkNIX0xPQ0FUSU9OJyk7XHJcbiAgICAgIEtFWV9BQ1RJVkVfVEFCID0gY29uc3RzKCdLRVlfQUNUSVZFX1RBQicpO1xyXG4gICAgICBLRVlfVUlfTU9ERSA9IGNvbnN0cygnS0VZX1VJX01PREUnKTtcclxuICAgICAgS0VZX01PQklMRV9UT0NfRFJJTExfRE9XTiA9IGNvbnN0cygnS0VZX01PQklMRV9UT0NfRFJJTExfRE9XTicpO1xyXG4gICAgICBLRVlfVE9DX0RSSUxMX0RPV04gPSBjb25zdHMoJ0tFWV9UT0NfRFJJTExfRE9XTicpO1xyXG4gICAgICBERVNLVE9QID0gJ2Rlc2t0b3AnO1xyXG4gICAgICBUQUJMRVQgPSAndGFibGV0JztcclxuICAgICAgUEhPTkUgPSAncGhvbmUnO1xyXG4gICAgICBTSE9XX0ZJTFRFUl9VSSA9IHJoLl9wYXJhbXMuaGlkZVVJICE9PSAnZmlsdGVyJztcclxuICAgICAgdGFicyA9IHtcclxuICAgICAgICBkZXNrdG9wOiBbJ3RvYycsICdpZHgnLCAnZ2xvJywgJ2ZpbHRlcicsICdmdHMnXSxcclxuICAgICAgICB0YWJsZXQ6IFsndG9jJywgJ2lkeCcsICdnbG8nLCAnZmlsdGVyJywgJ2Z0cyddLFxyXG4gICAgICAgIHBob25lOiBbJ3RvYycsICdpZHgnLCAnZ2xvJywgJ2ZpbHRlcicsICdmdHMnXVxyXG4gICAgICB9O1xyXG5cclxuICAgICAgc2lkZUJhclRhYnMgPSB7XHJcbiAgICAgICAgZGVza3RvcDogWyd0b2MnLCAnaWR4JywgJ2dsbycsICdmaWx0ZXInLCAnZnRzJ10sXHJcbiAgICAgICAgdGFibGV0OiBbJ3RvYycsICdpZHgnLCAnZ2xvJywgJ2ZpbHRlcicsICdmdHMnXSxcclxuICAgICAgICBwaG9uZTogWyd0b2MnLCAnaWR4JywgJ2dsbyddXHJcbiAgICAgIH07XHJcbiAgICAgIGRlbGF5TG9hZFRhYnMgPSB7XHJcbiAgICAgICAgJ2lkeCc6IHtldnQ6ICdFVlRfTE9BRF9JRFgnLCBmX2tleTogJ2RlbGF5X2xvYWRfaWR4J30sXHJcbiAgICAgICAgJ2dsbyc6IHtldnQ6ICdFVlRfTE9BRF9HTE8nLCBmX2tleTogJ2RlbGF5X2xvYWRfZ2xvJ31cclxuICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdHJ1Y3Rvcih3aWRnZXQpIHtcclxuICAgICAgdGhpcy50cmlnZ2VyRGVsYXlMb2FkV2lkZ2V0cyA9IHRoaXMudHJpZ2dlckRlbGF5TG9hZFdpZGdldHMuYmluZCh0aGlzKTtcclxuICAgICAgdGhpcy53aWRnZXQgPSB3aWRnZXQ7XHJcbiAgICAgICh0aGlzLmluaXQpKCk7XHJcbiAgICAgICh0aGlzLnN1YnNjcmliZUFjdGl2ZVRhYikoKTtcclxuICAgICAgKHRoaXMuc3Vic2NyaWJlVG9Mb2NhdGlvbnMpKCk7XHJcbiAgICAgICh0aGlzLnN1YnNjcmliZVNjcmVlbnMpKCk7XHJcblxyXG4gICAgICB0aGlzLndpZGdldC5zdWJzY3JpYmUoY29uc3RzKCdFVlRfUFJPSkVDVF9MT0FERUQnKSwgKCkgPT4ge1xyXG4gICAgICAgICh0aGlzLnN1YnNjcmliZVVJTW9kZSkoKTtcclxuICAgICAgICAodGhpcy5zdWJzY3JpYmVNZXJnZWRGaWx0ZXIpKCk7XHJcbiAgICAgICAgKHRoaXMuc3Vic2NyaWJlVG9waWNDbGljaykoKTtcclxuICAgICAgICAodGhpcy5zdWJzY3JpYmVUb3BpY1Njcm9sbCkoKTtcclxuICAgICAgICAodGhpcy5zdWJzY3JpYkZvclNlYXJjaFJlc3VsdCkoKTtcclxuICAgICAgICAodGhpcy5zdWJzY3JpYmVUb3BpY05hdmlnYXRlKSgpO1xyXG4gICAgICAgICh0aGlzLnN1YnNjcmliZVRvRGVsYXlMb2FkRXZlbnRzKSgpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLndpZGdldC5wdWJsaXNoKGNvbnN0cygnS0VZX0lGUkFNRV9FVkVOVFMnKSwge2NsaWNrOiB0cnVlLCBzY3JvbGw6IGZhbHNlfSk7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGluaXQoKSB7XHJcbiAgICAgIHRoaXMuc2NyZWVucyA9IHRoaXMud2lkZ2V0LmdldChjb25zdHMoJ0tFWV9TQ1JFRU5fTkFNRVMnKSk7XHJcbiAgICAgIHJoLnN0b3JhZ2UuaW5pdChjb25zdHMoJ0hFTFBfSUQnKSk7XHJcbiAgICAgIHRoaXMuYWN0aXZlU2NyZWVuID0gXy5maW5kKHRoaXMuc2NyZWVucywgZnVuY3Rpb24oc2NyZWVuKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMud2lkZ2V0LmdldChgJHtjb25zdHMoJ0tFWV9TQ1JFRU4nKX0uJHtzY3JlZW59LmF0dGFjaGVkYCk7XHJcbiAgICAgIH1cclxuICAgICAgLCB0aGlzKTtcclxuICAgICAgaWYgKHRoaXMuYWN0aXZlU2NyZWVuID09IG51bGwpIHsgdGhpcy5hY3RpdmVTY3JlZW4gPSB0aGlzLndpZGdldC5nZXQoY29uc3RzKCdLRVlfREVGQVVMVF9TQ1JFRU4nKSk7IH1cclxuXHJcbiAgICAgIHRoaXMuYXNzdXJlTG9jYXRpb25zKHRoaXMuYWN0aXZlU2NyZWVuKTtcclxuXHJcbiAgICAgICh0aGlzLmluaXREZWZhdWxzKSgpO1xyXG5cclxuICAgICAgcmV0dXJuICh0aGlzLmluaXRBY3RpdmVUYWIpKCk7XHJcbiAgICB9XHJcblxyXG4gICAgaW5pdERlZmF1bHMoKSB7XHJcbiAgICAgIGxldCBkZWZhdWx0VGFiID0gdGhpcy53aWRnZXQuZ2V0KGNvbnN0cygnS0VZX0RFRkFVTFRfVEFCJykpO1xyXG4gICAgICBpZiAoIXRoaXMuaGFzRmVhdHVyZShkZWZhdWx0VGFiKSkgeyBkZWZhdWx0VGFiID0gbnVsbDsgfVxyXG5cclxuICAgICAgdGhpcy5kZWZhdWx0VGFicyA9IHt9O1xyXG5cclxuICAgICAgcmV0dXJuIF8uZWFjaCh0aGlzLnNjcmVlbnMsIGZ1bmN0aW9uKHNjcmVlbikge1xyXG4gICAgICAgIHRhYnNbc2NyZWVuXSA9IF8uZmlsdGVyKHRhYnNbc2NyZWVuXSwgKGZ1bmN0aW9uKHRhYikgeyByZXR1cm4gdGhpcy5oYXNGZWF0dXJlKHRhYik7IH0pLCB0aGlzKTtcclxuXHJcbiAgICAgICAgc2lkZUJhclRhYnNbc2NyZWVuXSA9IF8uZmlsdGVyKHNpZGVCYXJUYWJzW3NjcmVlbl0sIGZ1bmN0aW9uKHRhYikge1xyXG4gICAgICAgICAgcmV0dXJuIHRoaXMuaGFzRmVhdHVyZSh0YWIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAsIHRoaXMpO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5kZWZhdWx0VGFic1tzY3JlZW5dID1cclxuICAgICAgICAgIGRlZmF1bHRUYWIgJiYgKC0xICE9PSB0YWJzW3NjcmVlbl0uaW5kZXhPZihkZWZhdWx0VGFiKSkgP1xyXG4gICAgICAgICAgICBkZWZhdWx0VGFiXHJcbiAgICAgICAgICA6XHJcbiAgICAgICAgICAgIHRhYnNbc2NyZWVuXVswXTtcclxuICAgICAgfVxyXG4gICAgICAsIHRoaXMpO1xyXG4gICAgfVxyXG5cclxuICAgIGluaXRBY3RpdmVUYWIoKSB7XHJcbiAgICAgIGxldCBhY3RpdmVUYWIgPSByaC5zdG9yYWdlLmZldGNoKCdhY3RpdmV0YWInKTtcclxuICAgICAgaWYgKChhY3RpdmVUYWIgIT09IHVuZGVmaW5lZCkgJiYgYWN0aXZlVGFiICYmIHRoaXMuaGFzRmVhdHVyZShhY3RpdmVUYWIpKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMud2lkZ2V0LnB1Ymxpc2goS0VZX0FDVElWRV9UQUIsIGFjdGl2ZVRhYik7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpc1ZhbGlkVGFiKHRhYiwgc2NyZWVuKSB7XHJcbiAgICAgIGlmIChzY3JlZW4gPT0gbnVsbCkgeyBzY3JlZW4gPSB0aGlzLmFjdGl2ZVNjcmVlbjsgfVxyXG4gICAgICBpZiAoIXRhYiB8fCAhdGhpcy5oYXNGZWF0dXJlKHRhYikpIHsgcmV0dXJuIGZhbHNlOyB9XHJcblxyXG4gICAgICBpZiAoc2NyZWVuID09PSBERVNLVE9QKSB7XHJcbiAgICAgICAgaWYgKCgodGFiID09PSAnZmlsdGVyJykgJiYgKCdjb250ZW50JyA9PT0gdGhpcy53aWRnZXQuZ2V0KEtFWV9GSUxURVJfTE9DQVRJT04pKSkgfHxcclxuICAgICAgICAoKHRhYiA9PT0gJ2Z0cycpICYmICgnY29udGVudCcgPT09IHRoaXMud2lkZ2V0LmdldChLRVlfU0VBUkNIX0xPQ0FUSU9OKSkpKSB7XHJcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gLTEgIT09IHRhYnNbc2NyZWVuXS5pbmRleE9mKHRhYik7XHJcbiAgICB9XHJcblxyXG4gICAgZGVmYXVsdFRhYihzY3JlZW4pIHtcclxuICAgICAgaWYgKHNjcmVlbiA9PSBudWxsKSB7IHNjcmVlbiA9IHRoaXMuYWN0aXZlU2NyZWVuOyB9XHJcbiAgICAgIGxldCBkZWZhdWx0VGFiID0gdGhpcy5kZWZhdWx0VGFic1tzY3JlZW5dO1xyXG4gICAgICBpZiAoIXRoaXMuaXNWYWxpZFRhYihkZWZhdWx0VGFiKSkge1xyXG4gICAgICAgIGRlZmF1bHRUYWIgPSBfLmZpbmQodGFic1tzY3JlZW5dLCAoZnVuY3Rpb24odGFiKSB7IHJldHVybiB0aGlzLmlzVmFsaWRUYWIodGFiKTsgfSksIHRoaXMpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBkZWZhdWx0VGFiO1xyXG4gICAgfVxyXG5cclxuICAgIGFzc3VyZVZhbGlkQWN0aXZlVGFiKHNjcmVlbikge1xyXG4gICAgICBpZiAoc2NyZWVuID09IG51bGwpIHsgc2NyZWVuID0gdGhpcy5hY3RpdmVTY3JlZW47IH1cclxuICAgICAgbGV0IGFjdGl2ZXRhYiA9IHRoaXMud2lkZ2V0LmdldChLRVlfQUNUSVZFX1RBQik7XHJcbiAgICAgIGlmICgoc2NyZWVuID09PSBERVNLVE9QKSB8fCBhY3RpdmV0YWIpIHtcclxuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZFRhYihhY3RpdmV0YWIpKSB7IGFjdGl2ZXRhYiA9IHRoaXMuZGVmYXVsdFRhYigpOyB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMud2lkZ2V0LnB1Ymxpc2goS0VZX0FDVElWRV9UQUIsIGFjdGl2ZXRhYik7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB0b2dnbGVTaWRlQmFyKCkge1xyXG4gICAgICBpZiAodGhpcy53aWRnZXQuZ2V0KEtFWV9BQ1RJVkVfVEFCKSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLndpZGdldC5wdWJsaXNoKEtFWV9BQ1RJVkVfVEFCLCBudWxsKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gdGhpcy53aWRnZXQucHVibGlzaChLRVlfQUNUSVZFX1RBQiwgdGhpcy5sYXN0TW9iaWxlVGFiIHx8IHRoaXMuZGVmYXVsdFRhYigpKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHRvZ2dsZUFjdGl2ZVRhYih0YWIpIHtcclxuICAgICAgcmV0dXJuIHRoaXMud2lkZ2V0LnB1Ymxpc2goS0VZX0FDVElWRV9UQUIsXHJcbiAgICAgICAgIXRoaXMuaXNEZXNrdG9wU2NyZWVuKCkgJiYgKHRhYiA9PT0gdGhpcy53aWRnZXQuZ2V0KEtFWV9BQ1RJVkVfVEFCKSkgPyBudWxsXHJcbiAgICAgICAgOiB0YWJcclxuICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICB0cmlnZ2VyRGVsYXlMb2FkV2lkZ2V0cyh0YWIpIHtcclxuICAgICAgbGV0IHRhYk9iaiA9IGRlbGF5TG9hZFRhYnNbdGFiXTtcclxuICAgICAgaWYgKHRhYk9iaiAmJiB0aGlzLmhhc0ZlYXR1cmUodGFiT2JqLmZfa2V5KSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLndpZGdldC5wdWJsaXNoKGNvbnN0cyh0YWJPYmouZXZ0KSwgdHJ1ZSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBzdWJzY3JpYmVUb0RlbGF5TG9hZEV2ZW50cygpIHtcclxuICAgICAgcmV0dXJuIHRoaXMud2lkZ2V0LnN1YnNjcmliZShLRVlfQUNUSVZFX1RBQiwgdGhpcy50cmlnZ2VyRGVsYXlMb2FkV2lkZ2V0cyk7XHJcbiAgICB9XHJcblxyXG4gICAgZmlsdGVyRG9uZSgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMud2lkZ2V0LnB1Ymxpc2goS0VZX0FDVElWRV9UQUIsIHRoaXMuc2VhcmNoTW9kZSA/ICdmdHMnIDogbnVsbCk7XHJcbiAgICB9XHJcblxyXG4gICAgaGFzRmVhdHVyZShmZWF0dXJlKSB7XHJcbiAgICAgIHJldHVybiAoZmVhdHVyZSA9PT0gdW5kZWZpbmVkKSB8fCAoZmFsc2UgIT09IHRoaXMud2lkZ2V0LmdldChgJHtLRVlfRkVBVFVSRX0uJHtmZWF0dXJlfWApKTtcclxuICAgIH1cclxuXHJcbiAgICBzdWJzY3JpYmVVSU1vZGUoKSB7XHJcbiAgICAgIGxldCBzZXRTZWFyY2hUYWIgPSAoKSA9PiB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWRUYWIoJ2Z0cycpKSB7IHJldHVybjsgfVxyXG4gICAgICAgIGlmICghdGhpcy5pc0Rlc2t0b3BTY3JlZW4oKSB8fCAoJ3RhYmJhcicgPT09IHRoaXMud2lkZ2V0LmdldChLRVlfU0VBUkNIX0xPQ0FUSU9OKSkpIHtcclxuICAgICAgICAgIHJldHVybiB0aGlzLndpZGdldC5wdWJsaXNoKEtFWV9BQ1RJVkVfVEFCLCAnZnRzJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9O1xyXG5cclxuICAgICAgdGhpcy53aWRnZXQuc3Vic2NyaWJlKEtFWV9VSV9NT0RFLCBtb2RlID0+IHtcclxuICAgICAgICByZXR1cm4gdGhpcy53aWRnZXQucHVibGlzaCgnYWN0aXZlX2NvbnRlbnQnLCBtb2RlKTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICB0aGlzLndpZGdldC5zdWJzY3JpYmUoJ2FjdGl2ZV9jb250ZW50JywgbW9kZSA9PiB7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNNb2JpbGVTY3JlZW4oKSAmJiAhbW9kZSkge1xyXG4gICAgICAgICAgcmV0dXJuIHRoaXMud2lkZ2V0LnB1Ymxpc2goS0VZX0FDVElWRV9UQUIsIG51bGwpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoJ3NlYXJjaCcgPT09IG1vZGUpIHtcclxuICAgICAgICAgIHJldHVybiBzZXRTZWFyY2hUYWIoKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgLCB7aW5pdERvbmU6IHRydWV9KTtcclxuICAgICAgaWYgKCdzZWFyY2gnID09PSB0aGlzLndpZGdldC5nZXQoJ2FjdGl2ZV9jb250ZW50JykpIHsgcmV0dXJuIHNldFNlYXJjaFRhYigpOyB9XHJcbiAgICB9XHJcblxyXG4gICAgc3Vic2NyaWJlTWVyZ2VkRmlsdGVyKCkge1xyXG4gICAgICBsZXQgZmVhdHVyZUZpbHRlcktleTtcclxuICAgICAgaWYgKHRoaXMud2lkZ2V0LmdldChmZWF0dXJlRmlsdGVyS2V5ID0gYCR7S0VZX0ZFQVRVUkV9LmZpbHRlcmApKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMud2lkZ2V0LnN1YnNjcmliZShjb25zdHMoJ0tFWV9NRVJHRURfRklMVEVSX0tFWScpLCB0YWdzID0+IHtcclxuICAgICAgICAgIHRoaXMud2lkZ2V0LnB1Ymxpc2goZmVhdHVyZUZpbHRlcktleSxcclxuICAgICAgICAgICAgdGFncyAmJiB0YWdzLmxlbmd0aCAmJiBTSE9XX0ZJTFRFUl9VSSA/IHRydWUgOiBmYWxzZSk7XHJcbiAgICAgICAgICByZXR1cm4gKHRoaXMuYXNzdXJlVmFsaWRBY3RpdmVUYWIpKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBzdWJzY3JpYmVUb3BpY0NsaWNrKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy53aWRnZXQuc3Vic2NyaWJlKGNvbnN0cygnRVZUX0NMSUNLX0lOU0lERV9JRlJBTUUnKSwgKCkgPT4ge1xyXG4gICAgICAgIGlmICgodGhpcy5hY3RpdmVTY3JlZW4gPT09IFBIT05FKSAmJiB0aGlzLndpZGdldC5nZXQoS0VZX0FDVElWRV9UQUIpKSB7XHJcbiAgICAgICAgICByZXR1cm4gKHRoaXMudG9nZ2xlU2lkZUJhcikoKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHN1YnNjcmliZVRvcGljTmF2aWdhdGUoKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLndpZGdldC5zdWJzY3JpYmUoY29uc3RzKCdFVlRfTkFWSUdBVEVfVE9fVVJMJyksIG9iaiA9PiB7XHJcbiAgICAgICAgaWYgKG9iai5hYnNVcmwgJiYgXy5pc1VybEFsbG93ZEluSWZyYW1lKG9iai5hYnNVcmwpKSB7XHJcbiAgICAgICAgICByZXR1cm4gdGhpcy53aWRnZXQucHVibGlzaCgnYWN0aXZlX2NvbnRlbnQnLCBudWxsKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHN1YnNjcmliZVRvcGljU2Nyb2xsKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy53aWRnZXQuc3Vic2NyaWJlKGNvbnN0cygnRVZUX1NDUk9MTF9JTlNJREVfSUZSQU1FJyksIGluZm8gPT4ge1xyXG4gICAgICAgIGxldCBoaWRlX2hlYWRlciA9IChpbmZvLmRpciA9PT0gJ2Rvd24nKSB8fCAoaW5mby5zY3JvbGxUb3AgPiAxMCk7XHJcbiAgICAgICAgdGhpcy53aWRnZXQucHVibGlzaCgnaGlkZV9oZWFkZXInLCBoaWRlX2hlYWRlcik7XHJcblxyXG4gICAgICAgIGxldCBoaWRlX21vYmlsZV9mdW5jdGlvbnMgPSAoaW5mby5kaXIgPT09ICdkb3duJykgJiYgKGluZm8uc2Nyb2xsVG9wID4gMTApO1xyXG4gICAgICAgIHJldHVybiB0aGlzLndpZGdldC5wdWJsaXNoKCdoaWRlX21vYmlsZV9mdW5jdGlvbnMnLCBoaWRlX21vYmlsZV9mdW5jdGlvbnMpO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBzdWJzY3JpYmVBY3RpdmVUYWIoKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLndpZGdldC5zdWJzY3JpYmUoS0VZX0FDVElWRV9UQUIsIGFjdGl2ZVRhYiA9PiB7XHJcbiAgICAgICAgcmguc3RvcmFnZS5wZXJzaXN0KCdhY3RpdmV0YWInLCBhY3RpdmVUYWIpO1xyXG4gICAgICAgIHRoaXMuc2V0Rm9jdXNJblRhYihhY3RpdmVUYWIpO1xyXG4gICAgICAgIGlmICh0aGlzLmlzTW9iaWxlU2NyZWVuKCkpIHtcclxuICAgICAgICAgIGlmICh0aGlzLmlzU2lkZWJhclRhYihhY3RpdmVUYWIpKSB7IHRoaXMubGFzdE1vYmlsZVRhYiA9IGFjdGl2ZVRhYjsgfVxyXG4gICAgICAgICAgcmV0dXJuIHRoaXMuc2VhcmNoTW9kZSA9XHJcbiAgICAgICAgICAgIChhY3RpdmVUYWIgPT09ICdmdHMnKSB8fCAodGhpcy5zZWFyY2hNb2RlICYmIChhY3RpdmVUYWIgPT09ICdmaWx0ZXInKSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHJldHVybiB0aGlzLnNlYXJjaE1vZGUgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHNldEZvY3VzSW5UYWIodGFiKSB7XHJcbiAgICAgIHZhciBjbGFzc05hbWVcclxuICAgICAgc3dpdGNoICh0YWIpIHtcclxuICAgICAgY2FzZSAnZnRzJzpcclxuICAgICAgICBjbGFzc05hbWUgPSAnd1NlYXJjaEZpZWxkJ1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlICdpZHgnOlxyXG4gICAgICAgIGNsYXNzTmFtZSA9ICdJZHhGaWx0ZXInXHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgJ2dsbyc6XHJcbiAgICAgICAgY2xhc3NOYW1lID0gJ0dsb0ZpbHRlcidcclxuICAgICAgICBicmVhaztcclxuXHJcbiAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIHZhciBpbnB1dEVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKGNsYXNzTmFtZSlcclxuICAgICAgaWYgKGlucHV0RWxlbWVudCAmJiBpbnB1dEVsZW1lbnQubGVuZ3RoKSB7XHJcbiAgICAgICAgXy5kZWZlcihmdW5jdGlvbiAoKSB7IGlucHV0RWxlbWVudFswXS5mb2N1cygpIH0pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgc3Vic2NyaWJlU2NyZWVucygpIHtcclxuICAgICAgcmV0dXJuIF8uZWFjaCh0aGlzLnNjcmVlbnMsIGZ1bmN0aW9uKHNjcmVlbikge1xyXG4gICAgICAgIGxldCBrZXkgPSBgJHtjb25zdHMoJ0tFWV9TQ1JFRU4nKX0uJHtzY3JlZW59LmF0dGFjaGVkYDtcclxuICAgICAgICBpZiAodGhpcy53aWRnZXQuZ2V0KGtleSkpIHsgdGhpcy5oYW5kbGVTY3JlZW4odHJ1ZSwgc2NyZWVuKTsgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLndpZGdldC5zdWJzY3JpYmUoa2V5LCBhdHRhY2hlZCA9PiB7XHJcbiAgICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVTY3JlZW4oYXR0YWNoZWQsIHNjcmVlbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgICwge2luaXREb25lOiB0cnVlfSk7XHJcbiAgICAgIH1cclxuICAgICAgLCB0aGlzKTtcclxuICAgIH1cclxuXHJcbiAgICBzdWJzY3JpYmVUb0xvY2F0aW9ucygpIHtcclxuICAgICAgdGhpcy53aWRnZXQuc3Vic2NyaWJlKEtFWV9TRUFSQ0hfTE9DQVRJT04sICgpID0+IHtcclxuICAgICAgICByZXR1cm4gdGhpcy5hc3N1cmVWYWxpZEFjdGl2ZVRhYih0aGlzLmFjdGl2ZVNjcmVlbik7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgcmV0dXJuIHRoaXMud2lkZ2V0LnN1YnNjcmliZShLRVlfRklMVEVSX0xPQ0FUSU9OLCAoKSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYXNzdXJlVmFsaWRBY3RpdmVUYWIodGhpcy5hY3RpdmVTY3JlZW4pO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBzdWJzY3JpYkZvclNlYXJjaFJlc3VsdCgpIHtcclxuICAgICAgbGV0IHVwZGF0ZVNlYXJjaFJlc3VsdHMgPSAoKSA9PiB7XHJcbiAgICAgICAgbGV0IHRhZ0V4cHIgPSB0aGlzLndpZGdldC5nZXQoY29uc3RzKCdLRVlfVEFHX0VYUFJFU1NJT04nKSk7XHJcbiAgICAgICAgbGV0IHNlYXJjaFRhZ0V4cHIgPSB0aGlzLndpZGdldC5nZXQoY29uc3RzKCdLRVlfT05TRUFSQ0hfVEFHX0VYUFInKSk7XHJcbiAgICAgICAgaWYgKHNlYXJjaFRhZ0V4cHIgJiYgKHNlYXJjaFRhZ0V4cHIgIT09IEpTT04uc3RyaW5naWZ5KHRhZ0V4cHIpKSkge1xyXG4gICAgICAgICAgcmV0dXJuIHRoaXMud2lkZ2V0LnB1Ymxpc2goY29uc3RzKCdFVlRfU0VBUkNIX1RFUk0nKSwgdHJ1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9O1xyXG5cclxuICAgICAgdGhpcy53aWRnZXQuc3Vic2NyaWJlKGNvbnN0cygnS0VZX1RBR19FWFBSRVNTSU9OJyksIF8uZGVib3VuY2UoKCkgPT4ge1xyXG4gICAgICAgIGlmICh0aGlzLmlzVmFsaWRUYWIoJ2Z0cycpICYmICgnZnRzJyAhPT0gdGhpcy53aWRnZXQuZ2V0KEtFWV9BQ1RJVkVfVEFCKSkpIHsgcmV0dXJuOyB9XHJcbiAgICAgICAgaWYgKCF0aGlzLmlzU2VhcmNoTW9kZSh0aGlzLndpZGdldC5nZXQoS0VZX0FDVElWRV9UQUIpKSkgeyByZXR1cm47IH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHVwZGF0ZVNlYXJjaFJlc3VsdHMoKTtcclxuICAgICAgfVxyXG4gICAgICAsIDMwMClcclxuICAgICAgKTtcclxuXHJcbiAgICAgIHJldHVybiB0aGlzLndpZGdldC5zdWJzY3JpYmUoS0VZX0FDVElWRV9UQUIsIGZ1bmN0aW9uKHRhYikge1xyXG4gICAgICAgIGlmICh0YWIgPT09ICdmdHMnKSB7IHJldHVybiB1cGRhdGVTZWFyY2hSZXN1bHRzKCk7IH1cclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgaXNNb2JpbGVTY3JlZW4oKSB7IHJldHVybiB0aGlzLmFjdGl2ZVNjcmVlbiA9PT0gUEhPTkU7IH1cclxuXHJcbiAgICBpc0Rlc2t0b3BTY3JlZW4oKSB7IHJldHVybiB0aGlzLmFjdGl2ZVNjcmVlbiA9PT0gREVTS1RPUDsgfVxyXG5cclxuICAgIGlzVGFibGV0U2NyZWVuKCkgeyByZXR1cm4gdGhpcy5hY3RpdmVTY3JlZW4gPT09IFRBQkxFVDsgfVxyXG5cclxuICAgIGlzU2lkZWJhclRhYih0YWIpIHtcclxuICAgICAgcmV0dXJuIHRhYiAmJiAoLTEgIT09IHNpZGVCYXJUYWJzW3RoaXMuYWN0aXZlU2NyZWVuXS5pbmRleE9mKHRhYikpO1xyXG4gICAgfVxyXG5cclxuICAgIGlzU2VhcmNoTW9kZSh0YWIpIHtcclxuICAgICAgbGV0IHRvcGljVGFiID0gdGhpcy53aWRnZXQuZ2V0KCdhY3RpdmVfY29udGVudCcpO1xyXG4gICAgICByZXR1cm4gKHRhYiA9PT0gJ2Z0cycpIHx8ICgodG9waWNUYWIgPT09ICdzZWFyY2gnKSAmJiB0aGlzLmlzRGVza3RvcFNjcmVlbigpICYmXHJcbiAgICAgICgnY29udGVudCcgPT09IHRoaXMud2lkZ2V0LmdldChLRVlfU0VBUkNIX0xPQ0FUSU9OKSkpO1xyXG4gICAgfVxyXG5cclxuICAgIGhhbmRsZVNjcmVlbihhdHRhY2hlZCwgc2NyZWVuKSB7XHJcbiAgICAgIGlmIChhdHRhY2hlZCkge1xyXG4gICAgICAgIHRoaXMuYWN0aXZlU2NyZWVuID0gc2NyZWVuO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmhhbmRsZUF0dGFjaGVkKHNjcmVlbik7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlRGV0YWNoZWQoc2NyZWVuKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGhhbmRsZURldGFjaGVkKHNjcmVlbikgeyByZXR1cm4gXy5kZWZlcigoKSA9PiB7XHJcbiAgICAgIGlmIChzY3JlZW4gPT09IERFU0tUT1ApIHtcclxuICAgICAgICByZXR1cm4gdGhpcy53aWRnZXQucHVibGlzaChLRVlfQUNUSVZFX1RBQixcclxuICAgICAgICAgICgnc2VhcmNoJyA9PT0gdGhpcy53aWRnZXQuZ2V0KCdhY3RpdmVfY29udGVudCcpKSAmJiB0aGlzLmlzVmFsaWRUYWIoJ2Z0cycpID9cclxuICAgICAgICAgICAgJ2Z0cydcclxuICAgICAgICAgIDogbnVsbFxyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuICAgIH0pOyB9XHJcblxyXG4gICAgaGFuZGxlQXR0YWNoZWQoc2NyZWVuKSB7XHJcbiAgICAgIHRoaXMuYXNzdXJlTG9jYXRpb25zKHNjcmVlbik7XHJcbiAgICAgIHRoaXMuYXNzdXJlVmFsaWRBY3RpdmVUYWIoc2NyZWVuKTtcclxuICAgICAgcmV0dXJuIHRoaXMuYXNzdXJlVE9DTW9kZShzY3JlZW4pO1xyXG4gICAgfVxyXG5cclxuICAgIGFzc3VyZUxvY2F0aW9ucyhzY3JlZW4pIHtcclxuICAgICAgaWYgKHNjcmVlbiA9PSBudWxsKSB7IHNjcmVlbiA9IHRoaXMuYWN0aXZlU2NyZWVuOyB9XHJcbiAgICAgIHRoaXMud2lkZ2V0LnB1Ymxpc2goS0VZX1NFQVJDSF9MT0NBVElPTixcclxuICAgICAgICBzY3JlZW4gPT09IERFU0tUT1AgP1xyXG4gICAgICAgICAgdGhpcy53aWRnZXQuZ2V0KGNvbnN0cygnS0VZX0RFRkFVTFRfU0VBUkNIX0xPQ0FUSU9OJykpXHJcbiAgICAgICAgOiBzY3JlZW4gPT09IFRBQkxFVCA/XHJcbiAgICAgICAgICAndGFiYmFyJ1xyXG4gICAgICAgIDpcclxuICAgICAgICAgICdjb250ZW50J1xyXG4gICAgICApO1xyXG4gICAgICByZXR1cm4gdGhpcy53aWRnZXQucHVibGlzaChLRVlfRklMVEVSX0xPQ0FUSU9OLFxyXG4gICAgICAgIChzY3JlZW4gPT09IERFU0tUT1ApIHx8IChzY3JlZW4gPT09IFRBQkxFVCkgPyAndGFiYmFyJyA6ICdjb250ZW50Jyk7XHJcbiAgICB9XHJcblxyXG4gICAgYXNzdXJlVE9DTW9kZShzY3JlZW4pIHtcclxuICAgICAgaWYgKHNjcmVlbiA9PSBudWxsKSB7IHNjcmVlbiA9IHRoaXMuYWN0aXZlU2NyZWVuOyB9XHJcbiAgICAgIHJldHVybiB0aGlzLndpZGdldC5wdWJsaXNoKEtFWV9UT0NfRFJJTExfRE9XTixcclxuICAgICAgICAoc2NyZWVuICE9PSBERVNLVE9QKSAmJiB0aGlzLndpZGdldC5nZXQoS0VZX01PQklMRV9UT0NfRFJJTExfRE9XTikpO1xyXG4gICAgfVxyXG5cclxuICAgIG5ld1NlYXJjaCh0ZXh0LCBrZXlDb2RlLCBldmVudCkge1xyXG4gICAgICByZXR1cm5cclxuICAgICAgaWYgKGtleUNvZGUgPT09IDEzKSB7XHJcbiAgICAgICAgbGV0IG9sZFRleHQgPSB0aGlzLndpZGdldC5nZXQoY29uc3RzKCdLRVlfU0VBUkNIX1RFUk0nKSk7XHJcbiAgICAgICAgaWYgKG9sZFRleHQgIT09IHRleHQpIHsgdGhpcy53aWRnZXQucHVibGlzaChjb25zdHMoJ0tFWV9TRUFSQ0hfVEVSTScpLCB0ZXh0KTsgfVxyXG4gICAgICAgIHRoaXMud2lkZ2V0LnB1Ymxpc2goY29uc3RzKCdFVlRfU0VBUkNIX1RFUk0nKSwgdHJ1ZSk7XHJcbiAgICAgICAgaWYgKGV2ZW50ICE9IG51bGwgPyBldmVudC50YXJnZXQgOiB1bmRlZmluZWQpIHsgcmV0dXJuIChldmVudC50YXJnZXQuYmx1cikoKTsgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaXNUYWdTdGF0ZXNDaGFuZ2VkKCkge1xyXG4gICAgICBsZXQgY3VycmVudFN0YXRlID0gXy5jb21wYWN0T2JqZWN0KHRoaXMud2lkZ2V0LmdldChjb25zdHMoJ0tFWV9QUk9KRUNUX1RBR19TVEFURVMnKSkpO1xyXG4gICAgICBsZXQgZGVmYXVsdFN0YXRlID0gXy5jb21wYWN0T2JqZWN0KHRoaXMud2lkZ2V0LmdldChjb25zdHMoJ0tFWV9ERUZBVUxUX0ZJTFRFUicpKSk7XHJcbiAgICAgIHJldHVybiAhXy5pc0VxdWFsKGN1cnJlbnRTdGF0ZSwgZGVmYXVsdFN0YXRlKTtcclxuICAgIH1cclxuXHJcbiAgICBzZXREZWZhdWx0VGFnU3RhdGVzKCkge1xyXG4gICAgICBsZXQgZGVmYXVsdFN0YXRlID0gdGhpcy53aWRnZXQuZ2V0KGNvbnN0cygnS0VZX0RFRkFVTFRfRklMVEVSJykpO1xyXG4gICAgICByZXR1cm4gdGhpcy53aWRnZXQucHVibGlzaChjb25zdHMoJ0tFWV9QUk9KRUNUX1RBR19TVEFURVMnKSwgXy5jbG9uZShkZWZhdWx0U3RhdGUpKTtcclxuICAgIH1cclxuICB9O1xyXG4gIE1vZGVybkxheW91dENvbnRyb2xsZXIuaW5pdENsYXNzKCk7XHJcbiAgcmV0dXJuIE1vZGVybkxheW91dENvbnRyb2xsZXI7XHJcbn0pKCk7XHJcblxyXG53aW5kb3cucmguY29udHJvbGxlcignTW9kZXJuTGF5b3V0Q29udHJvbGxlcicsIE1vZGVybkxheW91dENvbnRyb2xsZXIpO1xyXG4iLCIvLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDEuOS4xXHJcbigoKSA9PiB7XHJcbiAgdmFyIE1lcmdlUHJvaiwgXywgY29uc3RzLCBtb2RlbCwgcmg7XHJcblxyXG4gIHJoID0gd2luZG93LnJoO1xyXG5cclxuICBtb2RlbCA9IHJoLm1vZGVsO1xyXG5cclxuICBfID0gcmguXztcclxuXHJcbiAgY29uc3RzID0gcmguY29uc3RzO1xyXG5cclxuICBNZXJnZVByb2ogPSAoKCgpID0+IHtcclxuICAgIHZhciBncm91cDtcclxuXHJcbiAgICBmdW5jdGlvbiBNZXJnZVByb2ooKSB7XHJcbiAgICAgIHRoaXMudGFnQ29tYnMgPSBbXTtcclxuICAgICAgdGhpcy5pZG1hcCA9IHt9O1xyXG4gICAgICB0aGlzLmZpbHRlciA9IFtdO1xyXG4gICAgICB0aGlzLmdycFR5cGUgPSAnZ3JvdXAnO1xyXG4gICAgICB0aGlzLmRhdGFMb2FkZWQgPSBmYWxzZTtcclxuICAgICAgdGhpcy5sb2FkVGFnRGF0YShtb2RlbC5nZXQoY29uc3RzKCdLRVlfUFJPSkVDVF9MSVNUJykpKTtcclxuICAgICAgdGhpcy5jYXB0aW9uID0gdGhpcy50eXBlID0gdGhpcy5kZWZGaWx0ZXIgPSB2b2lkIDA7XHJcbiAgICB9XHJcblxyXG4gICAgTWVyZ2VQcm9qLnByb3RvdHlwZS51cGRhdGVUYWdDb21icyA9IGZ1bmN0aW9uKHByb2plY3QpIHtcclxuICAgICAgdmFyIGJhc2UsIGNvbWJzO1xyXG4gICAgICBjb21icyA9IG1vZGVsLmdldChjb25zdHMoJ0tFWV9QUk9KRUNUX1RBR19DT01CSU5BVElPTlMnKSk7XHJcbiAgICAgIGlmIChjb21icyAhPSBudWxsKSB7XHJcbiAgICAgICAgcHJvamVjdCA9IF8ucGFyc2VQcm9qZWN0TmFtZShwcm9qZWN0KTtcclxuICAgICAgICByZXR1cm4gKGJhc2UgPSB0aGlzLmlkbWFwKVtwcm9qZWN0XSAhPSBudWxsID8gYmFzZVtwcm9qZWN0XSA6IGJhc2VbcHJvamVjdF0gPSBjb21icztcclxuICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBNZXJnZVByb2oucHJvdG90eXBlLmxvb2t1cCA9IGZ1bmN0aW9uKGNoaWxkcmVuLCBrZXksIGlzR3JwVHlwZSkge1xyXG4gICAgICB2YXIgY2hpbGQsIGNvbXBLZXksIGVsZW1lbnQsIGksIGxlbjtcclxuICAgICAgaWYgKGlzR3JwVHlwZSA9PSBudWxsKSB7XHJcbiAgICAgICAgaXNHcnBUeXBlID0gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoKGNoaWxkcmVuICE9IG51bGwpICYmIChrZXkgIT0gbnVsbCkpIHtcclxuICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgY2hpbGQgPSBjaGlsZHJlbltpXTtcclxuICAgICAgICAgIGlmICghKGNoaWxkICE9IG51bGwpKSB7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgY29tcEtleSA9IGNoaWxkLm5hbWUgfHwgY2hpbGQuZGlzcGxheTtcclxuICAgICAgICAgIGlmIChpc0dycFR5cGUgPT09IChjaGlsZC5jaGlsZHJlbiAhPSBudWxsKSAmJiBjb21wS2V5ID09PSBrZXkpIHtcclxuICAgICAgICAgICAgZWxlbWVudCA9IGNoaWxkO1xyXG4gICAgICAgICAgfSBlbHNlIGlmICgoY2hpbGQuY2hpbGRyZW4gIT0gbnVsbCkgJiYgIWlzR3JwVHlwZSkge1xyXG4gICAgICAgICAgICBlbGVtZW50ID0gdGhpcy5sb29rdXAoY2hpbGQuY2hpbGRyZW4sIGtleSwgaXNHcnBUeXBlKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmIChlbGVtZW50ICE9IG51bGwpIHtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBlbGVtZW50O1xyXG4gICAgfTtcclxuXHJcbiAgICBncm91cCA9IGZ1bmN0aW9uKGRpc3ApIHtcclxuICAgICAgdmFyIG9iamVjdDtcclxuICAgICAgcmV0dXJuIG9iamVjdCA9IHtcclxuICAgICAgICB0eXBlOiAnZ3JvdXAnLFxyXG4gICAgICAgIGRpc3BsYXk6IGRpc3AsXHJcbiAgICAgICAgY2hpbGRyZW46IFtdXHJcbiAgICAgIH07XHJcbiAgICB9O1xyXG5cclxuICAgIE1lcmdlUHJvai5wcm90b3R5cGUuYWRkVGFnID0gZnVuY3Rpb24oY2hpbGRBcnIsIHRhZ0VsZW1lbnQpIHtcclxuICAgICAgdmFyIHRhZztcclxuICAgICAgaWYgKHRoaXMubG9va3VwKHRoaXMuZmlsdGVyLCB0YWdFbGVtZW50Lm5hbWUsIGZhbHNlKSA9PSBudWxsKSB7XHJcbiAgICAgICAgdGFnID0ge1xyXG4gICAgICAgICAgZGlzcGxheTogdGFnRWxlbWVudC5kaXNwbGF5LFxyXG4gICAgICAgICAgbmFtZTogdGFnRWxlbWVudC5uYW1lXHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gY2hpbGRBcnIucHVzaCh0YWcpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIE1lcmdlUHJvai5wcm90b3R5cGUuYWRkR3JvdXAgPSBmdW5jdGlvbihncnBFbGVtZW50KSB7XHJcbiAgICAgIHZhciBlbGVtZW50LCBncnAsIGksIGxlbiwgcmVmO1xyXG4gICAgICBncnAgPSB0aGlzLmxvb2t1cCh0aGlzLmZpbHRlciwgZ3JwRWxlbWVudC5kaXNwbGF5KTtcclxuICAgICAgaWYgKGdycCA9PSBudWxsKSB7XHJcbiAgICAgICAgZ3JwID0gZ3JvdXAoZ3JwRWxlbWVudC5kaXNwbGF5KTtcclxuICAgICAgICB0aGlzLmZpbHRlci5wdXNoKGdycCk7XHJcbiAgICAgIH1cclxuICAgICAgcmVmID0gZ3JwRWxlbWVudC5jaGlsZHJlbjtcclxuICAgICAgZm9yIChpID0gMCwgbGVuID0gcmVmLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgZWxlbWVudCA9IHJlZltpXTtcclxuICAgICAgICBpZiAoZWxlbWVudCAhPSBudWxsKSB7XHJcbiAgICAgICAgICBpZiAoZWxlbWVudC5jaGlsZHJlbiA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkVGFnKGdycC5jaGlsZHJlbiwgZWxlbWVudCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGlmIChncnAuY2hpbGRyZW4ubGVuZ3RoID09PSAwICYmIHRoaXMuZmlsdGVyLmluZGV4T2YoZ3JwKSA+IC0xKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyLnNwbGljZSh0aGlzLmZpbHRlci5pbmRleE9mKGdycCksIDEpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIE1lcmdlUHJvai5wcm90b3R5cGUudXBkYXRlRmlsdGVyID0gZnVuY3Rpb24oZXZlbnQpIHtcclxuICAgICAgdmFyIGN1cmZpbHRlciwgZWxlbWVudCwgaSwgbGVuLCByZXN1bHRzO1xyXG4gICAgICBjdXJmaWx0ZXIgPSBfLmV4dHJhY3RUZW1wRGF0YShldmVudCwgbW9kZWwsIHt9KTtcclxuICAgICAgaWYgKCF0aGlzLmNhcHRpb24pIHtcclxuICAgICAgICB0aGlzLmNhcHRpb24gPSBjdXJmaWx0ZXJbJ2NhcHRpb24nXTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoIXRoaXMudHlwZSkge1xyXG4gICAgICAgIHRoaXMudHlwZSA9IGN1cmZpbHRlclsndHlwZSddO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICh0eXBlb2YgdGhpcy5kZWZGaWx0ZXIgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgdGhpcy5kZWZGaWx0ZXIgPSBjdXJmaWx0ZXJbJ2RlZmF1bHQnXTtcclxuICAgICAgfVxyXG4gICAgICBjdXJmaWx0ZXIgPSBjdXJmaWx0ZXJbJ3RhZ3MnXSB8fCBbXTtcclxuICAgICAgcmVzdWx0cyA9IFtdO1xyXG4gICAgICBmb3IgKGkgPSAwLCBsZW4gPSBjdXJmaWx0ZXIubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICBlbGVtZW50ID0gY3VyZmlsdGVyW2ldO1xyXG4gICAgICAgIGlmIChlbGVtZW50ICE9IG51bGwpIHtcclxuICAgICAgICAgIGlmIChlbGVtZW50LmNoaWxkcmVuICE9IG51bGwpIHtcclxuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHRoaXMuYWRkR3JvdXAoZWxlbWVudCkpO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHRoaXMuYWRkVGFnKHRoaXMuZmlsdGVyLCBlbGVtZW50KSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiByZXN1bHRzO1xyXG4gICAgfTtcclxuXHJcbiAgICBNZXJnZVByb2oucHJvdG90eXBlLm9uTG9hZFNjcmlwdCA9IGZ1bmN0aW9uKGV2ZW50LCBwcm9qZWN0LCBjb3VudCkge1xyXG4gICAgICB0aGlzLnVwZGF0ZVRhZ0NvbWJzKHByb2plY3QpO1xyXG4gICAgICB0aGlzLnVwZGF0ZUZpbHRlcihldmVudCk7XHJcbiAgICAgIGlmICghY291bnQpIHtcclxuICAgICAgICBtb2RlbC5wdWJsaXNoKGNvbnN0cygnS0VZX01FUkdFRF9GSUxURVJfS0VZJyksIHRoaXMuZmlsdGVyKTtcclxuICAgICAgICBtb2RlbC5wdWJsaXNoKGNvbnN0cygnS0VZX01FUkdFRF9QUk9KRUNUX01BUCcpLCB0aGlzLmlkbWFwKTtcclxuICAgICAgICBtb2RlbC5wdWJsaXNoKGNvbnN0cygnS0VZX1BST0pFQ1RfRklMVEVSX0NBUFRJT04nKSwgdGhpcy5jYXB0aW9uKTtcclxuICAgICAgICBtb2RlbC5wdWJsaXNoKGNvbnN0cygnS0VZX1BST0pFQ1RfRklMVEVSX1RZUEUnKSwgdGhpcy50eXBlKTtcclxuICAgICAgICBtb2RlbC5wdWJsaXNoKGNvbnN0cygnS0VZX0RFRkFVTFRfRklMVEVSJyksIHRoaXMuZGVmRmlsdGVyKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5kYXRhTG9hZGVkID0gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBNZXJnZVByb2oucHJvdG90eXBlLmxvYWRUYWdEYXRhID0gZnVuY3Rpb24ocHJvakxpc3QpIHtcclxuICAgICAgdmFyIGNvdW50LCBpLCBsZW4sIHByb2plY3QsIHJlc3VsdHM7XHJcbiAgICAgIGlmICghdGhpcy5kYXRhTG9hZGVkKSB7XHJcbiAgICAgICAgY291bnQgPSBwcm9qTGlzdC5sZW5ndGg7XHJcbiAgICAgICAgcmVzdWx0cyA9IFtdO1xyXG4gICAgICAgIGxldCBkYXRhID0ge3Byb2plY3QsIGNvdW50fVxyXG4gICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHByb2pMaXN0Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICBwcm9qZWN0ID0gcHJvakxpc3RbaV07XHJcbiAgICAgICAgICBpZiAocHJvamVjdCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIGlmIChwcm9qZWN0KSB7XHJcbiAgICAgICAgICAgICAgcHJvamVjdCA9IHByb2plY3QgKyBcIi9cIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBkYXRhLnByb2plY3QgPSBwcm9qZWN0XHJcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaChcclxuICAgICAgICAgICAgICBfLmxvYWRTY3JpcHQoXHJcbiAgICAgICAgICAgICAgICBcIlwiICsgcHJvamVjdCArIChjb25zdHMoJ1BBVEhfUFJPSkVDVF9UQUdEQVRBX0ZJTEUnKSksIFxyXG4gICAgICAgICAgICAgICAgZmFsc2UsXHJcbiAgICAgICAgICAgICAgICB0aGlzLmdldExvYWRDYWxsYmFjayhkYXRhKVxyXG4gICAgICAgICAgICAgIClcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaCh2b2lkIDApO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0cztcclxuICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBNZXJnZVByb2oucHJvdG90eXBlLmdldExvYWRDYWxsYmFjayA9IGZ1bmN0aW9uKGRhdGEpIHtcclxuICAgICAgbGV0IHByb2ogPSBkYXRhLnByb2plY3RcclxuICAgICAgcmV0dXJuIChldmVudCkgPT4gdGhpcy5vbkxvYWRTY3JpcHQoZXZlbnQsIHByb2osIC0tZGF0YS5jb3VudCk7XHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiBNZXJnZVByb2o7XHJcblxyXG4gIH0pKSgpO1xyXG5cclxuICByaC5NZXJnZVByb2ogPSBNZXJnZVByb2o7XHJcblxyXG59KS5jYWxsKHRoaXMpO1xyXG4iLCJsZXQgeyByaCB9ID0gd2luZG93O1xyXG5sZXQgeyBfIH0gPSByaDtcclxubGV0IHsgY29uc3RzIH0gPSByaDtcclxubGV0IHsgbW9kZWwgfSA9IHJoO1xyXG5sZXQgdW5zdWIgPSBudWxsO1xyXG5cclxudW5zdWIgPSBtb2RlbC5zdWJzY3JpYmUoY29uc3RzKCdLRVlfVEFHX0VYUFJFU1NJT04nKSwgKGZ1bmN0aW9uKCkge1xyXG4gIGxldCBkb25lID0gZmFsc2U7XHJcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xyXG4gICAgaWYgKHVuc3ViKSB7IHVuc3ViKCk7IH1cclxuICAgIGlmIChkb25lKSB7IHJldHVybjsgfVxyXG4gICAgZG9uZSA9IHRydWU7XHJcbiAgICByZXR1cm4gbW9kZWwuc3Vic2NyaWJlKGNvbnN0cygnS0VZX1NFQVJDSEVEX1RFUk0nKSwgKCkgPT5cclxuICAgICAgbW9kZWwucHVibGlzaChjb25zdHMoJ0tFWV9PTlNFQVJDSF9UQUdfRVhQUicpLFxyXG4gICAgICAgSlNPTi5zdHJpbmdpZnkobW9kZWwuZ2V0KGNvbnN0cygnS0VZX1RBR19FWFBSRVNTSU9OJykpKSlcclxuICAgICk7XHJcbiAgfTtcclxufSkoKVxyXG4pO1xyXG5cclxubW9kZWwuc3Vic2NyaWJlKGNvbnN0cygnRVZUX1NFQVJDSF9URVJNJyksIGZ1bmN0aW9uKCkge1xyXG4gIGxldCBjYW5IYW5kbGVTZWFyY2ggPSBtb2RlbC5nZXQoY29uc3RzKCdLRVlfQ0FOX0hBTkRMRV9TRUFSQ0gnKSk7XHJcbiAgbGV0IHNlYXJjaFRlcm0gPSBtb2RlbC5nZXQoY29uc3RzKCdLRVlfU0VBUkNIX1RFUk0nKSkgfHwgbnVsbDtcclxuICBsZXQgbmV3TWFwID0ge307XHJcbiAgbmV3TWFwW2NvbnN0cygnSEFTSF9LRVlfUkhfU0VBUkNIJyldID0gc2VhcmNoVGVybTtcclxuICBuZXdNYXBbY29uc3RzKCdIQVNIX0tFWV9VSU1PREUnKV0gPSAnc2VhcmNoJztcclxuICBtb2RlbC5wdWJsaXNoKGNvbnN0cygnREVTS1RPUF9TSURFQkFSX1ZJU0lCTEUnKSwgdHJ1ZSk7XHJcbiAgbGV0IHNlYXJjaFJlc3VsdEluVGFiYmFyID0gbW9kZWwuZ2V0KGNvbnN0cygnS0VZX0RFRkFVTFRfU0VBUkNIX0xPQ0FUSU9OJykpID09PSAndGFiYmFyJ1xyXG4gIGlmIChzZWFyY2hSZXN1bHRJblRhYmJhcikge1xyXG4gICAgbW9kZWwucHVibGlzaChjb25zdHMoJ0tFWV9BQ1RJVkVfVEFCJyksICdmdHMnKTtcclxuICB9XHJcbiAgXHJcbiAgbGV0IGhsVGVybSA9IF8udXJsUGFyYW0oY29uc3RzKCdIQVNIX0tFWV9SSF9ISUdITElHSFQnKSwgZG9jdW1lbnQubG9jYXRpb24uaHJlZilcclxuICBpZiAoc2VhcmNoVGVybSAhPT0gaGxUZXJtKSB7XHJcbiAgICBuZXdNYXBbY29uc3RzKCdIQVNIX0tFWV9SSF9ISUdITElHSFQnKV0gPSAnJ1xyXG4gICAgfVxyXG4gIGlmIChjYW5IYW5kbGVTZWFyY2ggIT09IHRydWUpIHtcclxuICAgIHJldHVybiBkb2N1bWVudC5sb2NhdGlvbiA9IGAke3dpbmRvdy5nUm9vdFJlbFBhdGh9L2AgK1xyXG4gICAgICBgJHt3aW5kb3cuZ1NlYXJjaFBhZ2VGaWxlUGF0aCB8fCBjb25zdHMoJ1NUQVJUX0ZJTEVQQVRIJyl9YCArXHJcbiAgICAgIGA/IyR7Xy5tYXBUb0VuY29kZWRTdHJpbmcobmV3TWFwKX1gO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBtb2RlbC5wdWJsaXNoKGNvbnN0cygnRVZUX1FVRVJZX1NFQVJDSF9SRVNVTFRTJyksIHRydWUpO1xyXG4gICAgcmV0dXJuIF8uZGVmZXIoKCkgPT4gXy51cGRhdGVIYXNoTWFwKG5ld01hcCwgdHJ1ZSkpO1xyXG4gIH1cclxufSk7XHJcblxyXG5tb2RlbC5zdWJzY3JpYmUoY29uc3RzKCdFVlRfUFJPSkVDVF9MT0FERUQnKSwgZnVuY3Rpb24oKSB7XHJcbiAgaWYocmgubW9kZWwuZ2V0KHJoLmNvbnN0cygnS0VZX0NMQVNTSUNfT1VUUFVUJykpKSB7XHJcbiAgICB3aW5kb3cucmVhZFNldHRpbmcoUkhBTkRTRUFSQ0gsIGZ1bmN0aW9uKHN0YXRlKSB7XHJcbiAgICAgIHJldHVybiBtb2RlbC5wdWJsaXNoKGNvbnN0cygnS0VZX0FORF9TRUFSQ0gnKSwgc3RhdGUpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG4gIHJldHVybiBtb2RlbC5zdWJzY3JpYmUoY29uc3RzKCdLRVlfQU5EX1NFQVJDSCcpLCBmdW5jdGlvbihzdGF0ZSkge1xyXG4gICAgaWYocmgubW9kZWwuZ2V0KHJoLmNvbnN0cygnS0VZX0NMQVNTSUNfT1VUUFVUJykpKSB7XHJcbiAgICAgIHJldHVybiBzYXZlU2V0dGluZyhSSEFORFNFQVJDSCwgKHN0YXRlID09PSAnMScgPyAnMScgOiAnMCcpLCB0cnVlKTtcclxuICAgIH1cclxuICB9KTtcclxufSk7XHJcbm1vZGVsLnN1YnNjcmliZShjb25zdHMoJ0VWVF9RVUVSWV9TRUFSQ0hfUkVTVUxUUycpLCBmdW5jdGlvbigpIHtcclxuICBpZihyaC5tb2RlbC5nZXQocmguY29uc3RzKCdLRVlfQ0xBU1NJQ19PVVRQVVQnKSkpIHtcclxuICAgIHJldHVybiB3aW5kb3cuZG9TZWFyY2goKTtcclxuICB9XHJcbn0pO1xyXG4iLCJsZXQgeyByaCB9ID0gd2luZG93O1xyXG5sZXQgeyBfIH0gPSByaDtcclxubGV0IHsgJCB9ID0gcmg7XHJcbmxldCB7IGNvbnN0cyB9ID0gcmg7XHJcbmxldCB7IG1vZGVsIH0gPSByaDtcclxuXHJcbl8uZ2V0Um9vdFVybCA9IChmdW5jdGlvbigpIHtcclxuICBsZXQgcm9vdFVybCA9IG51bGw7XHJcbiAgcmV0dXJuICgpID0+IHJvb3RVcmwgIT0gbnVsbCA/IHJvb3RVcmwgOiAocm9vdFVybCA9IGAke18uZ2V0SG9zdEZvbGRlcigpfSR7Y29uc3RzKCdTVEFSVF9GSUxFUEFUSCcpfWApO1xyXG59KSgpO1xyXG5cclxuXy5nZXREZWZhdWx0VG9waWMgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcclxuICBsZXQgZ0RlZmF1bHRUb3BpYyA9IHdpbmRvdy5nRGVmYXVsdFRvcGljICYmIHdpbmRvdy5nRGVmYXVsdFRvcGljLnN1YnN0cmluZygxKVxyXG4gIGlmIChnRGVmYXVsdFRvcGljICYmIGdEZWZhdWx0VG9waWMuZW5kc1dpdGgoXCJyaHBqXCIpKVxyXG4gIHtcclxuICAgIGxldCBwcm9qUGF0aCA9IGAuL21lcmdlZFByb2plY3RzLyR7Z0RlZmF1bHRUb3BpYy5zdWJzdHJpbmcoMCwgZ0RlZmF1bHRUb3BpYy5sZW5ndGggLSA1KX1gXHJcbiAgICBsZXQgZmlsZVBhdGggPSBgJHtwcm9qUGF0aH0vd2h4ZGF0YS9wcm9qZWN0c2V0dGluZ3MuanNgXHJcbiAgICBfLmxvYWRTY3JpcHQoZmlsZVBhdGgsIHRydWUsICgpID0+XHJcbiAgICB7XHJcbiAgICAgIGdEZWZhdWx0VG9waWMgPSBfLmV4cG9ydHMoKVxyXG4gICAgICBnRGVmYXVsdFRvcGljID0gYCR7cHJvalBhdGh9LyR7Z0RlZmF1bHRUb3BpY31gXHJcbiAgICAgIHdpbmRvdy5nRGVmYXVsdFRvcGljID0gYCMke2dEZWZhdWx0VG9waWN9YFxyXG4gICAgICBjYWxsYmFjayhnRGVmYXVsdFRvcGljKVxyXG4gICAgfSlcclxuICB9XHJcbiAgZWxzZXsgXHJcbiAgICBjYWxsYmFjayhnRGVmYXVsdFRvcGljKSAgICBcclxuICB9XHJcbn1cclxuXHJcbl8ucnVuVG9waWNMb2FkaW5nQW5pbWF0aW9uID0gKGZ1bmN0aW9uKCkge1xyXG4gIGxldCBydW5BbmltYXRpb24gPSBudWxsO1xyXG4gIGxldCB0b3BpY0xvYWRpbmcgPSBmYWxzZTtcclxuICByZXR1cm4gZnVuY3Rpb24oZmxhZykge1xyXG4gICAgdG9waWNMb2FkaW5nID0gZmxhZztcclxuICAgIGlmIChmbGFnKSB7XHJcbiAgICAgIGlmIChydW5BbmltYXRpb24gPT0gbnVsbCkgeyBydW5BbmltYXRpb24gPSBfLmRlYm91bmNlKCgpID0+IG1vZGVsLnB1Ymxpc2goY29uc3RzKCdFVlRfVE9QSUNfTE9BRElORycpLCB0b3BpY0xvYWRpbmcpXHJcbiAgICAgICwgNzAwKTsgfVxyXG4gICAgICByZXR1cm4gcnVuQW5pbWF0aW9uKCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBydW5BbmltYXRpb24gPSBudWxsO1xyXG4gICAgICByZXR1cm4gbW9kZWwucHVibGlzaChjb25zdHMoJ0VWVF9UT1BJQ19MT0FESU5HJyksIGZhbHNlKTtcclxuICAgIH1cclxuICB9O1xyXG59KSgpO1xyXG5cclxuXy5nZXRUb3BpY0ZyYW1lID0gZnVuY3Rpb24oKSB7XHJcbiAgbGV0IHRvcGljRnJhbWVOYW1lID0gd2luZG93LmdUb3BpY0ZyYW1lTmFtZSB8fCAncmhfZGVmYXVsdF90b3BpY19mcmFtZV9uYW1lJztcclxuICByZXR1cm4gJChgW25hbWU9JHt0b3BpY0ZyYW1lTmFtZX1dYCwgMCk7XHJcbn07XHJcblxyXG5fLmdvVG9EZWZhdWx0VG9waWMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgbGV0IG5ld01hcCA9IHt9O1xyXG4gIF8uZ2V0RGVmYXVsdFRvcGljKGRlZmF1bHRUb3BpYyA9PiB7XHJcbiAgICBuZXdNYXBbY29uc3RzKCdIQVNIX0tFWV9UT1BJQycpXSA9IGRlZmF1bHRUb3BpYztcclxuICAgIF8udXBkYXRlSGFzaE1hcChuZXdNYXAsIHRydWUpICAgIFxyXG4gIH1cclxuICApXHJcbiAgcmV0dXJuIGZhbHNlXHJcbn1cclxuIiwiLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbi8vXHJcbi8vIEVDTUFTY3JpcHQgNSBQb2x5ZmlsbHNcclxuLy9cclxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuLy8gRVM1IDE1LjIgT2JqZWN0IE9iamVjdHNcclxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG4vL1xyXG4vLyBFUzUgMTUuMi4zIFByb3BlcnRpZXMgb2YgdGhlIE9iamVjdCBDb25zdHJ1Y3RvclxyXG4vL1xyXG5cclxuLy8gRVM1IDE1LjIuMy4yIE9iamVjdC5nZXRQcm90b3R5cGVPZiAoIE8gKVxyXG4vLyBGcm9tIGh0dHA6Ly9lam9obi5vcmcvYmxvZy9vYmplY3RnZXRwcm90b3R5cGVvZi9cclxuLy8gTk9URTogd29uJ3Qgd29yayBmb3IgdHlwaWNhbCBmdW5jdGlvbiBUKCkge307IFQucHJvdG90eXBlID0ge307IG5ldyBUOyBjYXNlXHJcbi8vIHNpbmNlIHRoZSBjb25zdHJ1Y3RvciBwcm9wZXJ0eSBpcyBkZXN0cm95ZWQuXHJcbmlmICghT2JqZWN0LmdldFByb3RvdHlwZU9mKSB7XHJcbiAgT2JqZWN0LmdldFByb3RvdHlwZU9mID0gZnVuY3Rpb24gKG8pIHtcclxuICAgIGlmIChvICE9PSBPYmplY3QobykpIHsgdGhyb3cgVHlwZUVycm9yKFwiT2JqZWN0LmdldFByb3RvdHlwZU9mIGNhbGxlZCBvbiBub24tb2JqZWN0XCIpOyB9XHJcbiAgICByZXR1cm4gby5fX3Byb3RvX18gfHwgby5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgfHwgT2JqZWN0LnByb3RvdHlwZTtcclxuICB9O1xyXG59XHJcblxyXG4vLyAgICAvLyBFUzUgMTUuMi4zLjMgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciAoIE8sIFAgKVxyXG4vLyAgICBpZiAodHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgIT09IFwiZnVuY3Rpb25cIikge1xyXG4vLyAgICAgICAgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IGZ1bmN0aW9uIChvLCBuYW1lKSB7XHJcbi8vICAgICAgICAgICAgaWYgKG8gIT09IE9iamVjdChvKSkgeyB0aHJvdyBUeXBlRXJyb3IoKTsgfVxyXG4vLyAgICAgICAgICAgIGlmIChvLmhhc093blByb3BlcnR5KG5hbWUpKSB7XHJcbi8vICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbi8vICAgICAgICAgICAgICAgICAgICB2YWx1ZTogb1tuYW1lXSxcclxuLy8gICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbi8vICAgICAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuLy8gICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4vLyAgICAgICAgICAgICAgICB9O1xyXG4vLyAgICAgICAgICAgIH1cclxuLy8gICAgICAgIH07XHJcbi8vICAgIH1cclxuXHJcbi8vIEVTNSAxNS4yLjMuNCBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyAoIE8gKVxyXG5pZiAodHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzICE9PSBcImZ1bmN0aW9uXCIpIHtcclxuICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyA9IGZ1bmN0aW9uIChvKSB7XHJcbiAgICBpZiAobyAhPT0gT2JqZWN0KG8pKSB7IHRocm93IFR5cGVFcnJvcihcIk9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIGNhbGxlZCBvbiBub24tb2JqZWN0XCIpOyB9XHJcbiAgICB2YXIgcHJvcHMgPSBbXSwgcDtcclxuICAgIGZvciAocCBpbiBvKSB7XHJcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobywgcCkpIHtcclxuICAgICAgICBwcm9wcy5wdXNoKHApO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcHJvcHM7XHJcbiAgfTtcclxufVxyXG5cclxuLy8gRVM1IDE1LjIuMy41IE9iamVjdC5jcmVhdGUgKCBPIFssIFByb3BlcnRpZXNdIClcclxuaWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlICE9PSBcImZ1bmN0aW9uXCIpIHtcclxuICBPYmplY3QuY3JlYXRlID0gZnVuY3Rpb24gKHByb3RvdHlwZSwgcHJvcGVydGllcykge1xyXG4gICAgaWYgKHR5cGVvZiBwcm90b3R5cGUgIT09IFwib2JqZWN0XCIpIHsgdGhyb3cgVHlwZUVycm9yKCk7IH1cclxuICAgIGZ1bmN0aW9uIEN0b3IoKSB7fVxyXG4gICAgQ3Rvci5wcm90b3R5cGUgPSBwcm90b3R5cGU7XHJcbiAgICB2YXIgbyA9IG5ldyBDdG9yKCk7XHJcbiAgICBpZiAocHJvdG90eXBlKSB7IG8uY29uc3RydWN0b3IgPSBDdG9yOyB9XHJcbiAgICBpZiAocHJvcGVydGllcyAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIGlmIChwcm9wZXJ0aWVzICE9PSBPYmplY3QocHJvcGVydGllcykpIHsgdGhyb3cgVHlwZUVycm9yKCk7IH1cclxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMobywgcHJvcGVydGllcyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbztcclxuICB9O1xyXG59XHJcblxyXG4vLyBFUyAxNS4yLjMuNiBPYmplY3QuZGVmaW5lUHJvcGVydHkgKCBPLCBQLCBBdHRyaWJ1dGVzIClcclxuLy8gUGFydGlhbCBzdXBwb3J0IGZvciBtb3N0IGNvbW1vbiBjYXNlIC0gZ2V0dGVycywgc2V0dGVycywgYW5kIHZhbHVlc1xyXG4oZnVuY3Rpb24oKSB7XHJcbiAgaWYgKCFPYmplY3QuZGVmaW5lUHJvcGVydHkgfHxcclxuICAgICAgIShmdW5jdGlvbiAoKSB7IHRyeSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ3gnLCB7fSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9ICgpKSkge1xyXG4gICAgdmFyIG9yaWcgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkgPSBmdW5jdGlvbiAobywgcHJvcCwgZGVzYykge1xyXG4gICAgICAvLyBJbiBJRTggdHJ5IGJ1aWx0LWluIGltcGxlbWVudGF0aW9uIGZvciBkZWZpbmluZyBwcm9wZXJ0aWVzIG9uIERPTSBwcm90b3R5cGVzLlxyXG4gICAgICBpZiAob3JpZykgeyB0cnkgeyByZXR1cm4gb3JpZyhvLCBwcm9wLCBkZXNjKTsgfSBjYXRjaCAoZSkge30gfVxyXG5cclxuICAgICAgaWYgKG8gIT09IE9iamVjdChvKSkgeyB0aHJvdyBUeXBlRXJyb3IoXCJPYmplY3QuZGVmaW5lUHJvcGVydHkgY2FsbGVkIG9uIG5vbi1vYmplY3RcIik7IH1cclxuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuX19kZWZpbmVHZXR0ZXJfXyAmJiAoJ2dldCcgaW4gZGVzYykpIHtcclxuICAgICAgICBPYmplY3QucHJvdG90eXBlLl9fZGVmaW5lR2V0dGVyX18uY2FsbChvLCBwcm9wLCBkZXNjLmdldCk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuX19kZWZpbmVTZXR0ZXJfXyAmJiAoJ3NldCcgaW4gZGVzYykpIHtcclxuICAgICAgICBPYmplY3QucHJvdG90eXBlLl9fZGVmaW5lU2V0dGVyX18uY2FsbChvLCBwcm9wLCBkZXNjLnNldCk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKCd2YWx1ZScgaW4gZGVzYykge1xyXG4gICAgICAgIG9bcHJvcF0gPSBkZXNjLnZhbHVlO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBvO1xyXG4gICAgfTtcclxuICB9XHJcbn0oKSk7XHJcblxyXG4vLyBFUyAxNS4yLjMuNyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyAoIE8sIFByb3BlcnRpZXMgKVxyXG5pZiAodHlwZW9mIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzICE9PSBcImZ1bmN0aW9uXCIpIHtcclxuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyA9IGZ1bmN0aW9uIChvLCBwcm9wZXJ0aWVzKSB7XHJcbiAgICBpZiAobyAhPT0gT2JqZWN0KG8pKSB7IHRocm93IFR5cGVFcnJvcihcIk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzIGNhbGxlZCBvbiBub24tb2JqZWN0XCIpOyB9XHJcbiAgICB2YXIgbmFtZTtcclxuICAgIGZvciAobmFtZSBpbiBwcm9wZXJ0aWVzKSB7XHJcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocHJvcGVydGllcywgbmFtZSkpIHtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgbmFtZSwgcHJvcGVydGllc1tuYW1lXSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBvO1xyXG4gIH07XHJcbn1cclxuXHJcblxyXG4vLyBFUzUgMTUuMi4zLjE0IE9iamVjdC5rZXlzICggTyApXHJcbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9rZXlzXHJcbmlmICghT2JqZWN0LmtleXMpIHtcclxuICBPYmplY3Qua2V5cyA9IGZ1bmN0aW9uIChvKSB7XHJcbiAgICBpZiAobyAhPT0gT2JqZWN0KG8pKSB7IHRocm93IFR5cGVFcnJvcignT2JqZWN0LmtleXMgY2FsbGVkIG9uIG5vbi1vYmplY3QnKTsgfVxyXG4gICAgdmFyIHJldCA9IFtdLCBwO1xyXG4gICAgZm9yIChwIGluIG8pIHtcclxuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvLCBwKSkge1xyXG4gICAgICAgIHJldC5wdXNoKHApO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmV0O1xyXG4gIH07XHJcbn1cclxuXHJcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4vLyBFUzUgMTUuMyBGdW5jdGlvbiBPYmplY3RzXHJcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cclxuLy9cclxuLy8gRVM1IDE1LjMuNCBQcm9wZXJ0aWVzIG9mIHRoZSBGdW5jdGlvbiBQcm90b3R5cGUgT2JqZWN0XHJcbi8vXHJcblxyXG4vLyBFUzUgMTUuMy40LjUgRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgKCB0aGlzQXJnIFssIGFyZzEgWywgYXJnMiwgLi4uIF1dIClcclxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRnVuY3Rpb24vYmluZFxyXG5pZiAoIUZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kKSB7XHJcbiAgRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbiAobykge1xyXG4gICAgaWYgKHR5cGVvZiB0aGlzICE9PSAnZnVuY3Rpb24nKSB7IHRocm93IFR5cGVFcnJvcihcIkJpbmQgbXVzdCBiZSBjYWxsZWQgb24gYSBmdW5jdGlvblwiKTsgfVxyXG5cclxuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSxcclxuICAgICAgICBzZWxmID0gdGhpcyxcclxuICAgICAgICBub3AgPSBmdW5jdGlvbigpIHt9LFxyXG4gICAgICAgIGJvdW5kID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgcmV0dXJuIHNlbGYuYXBwbHkodGhpcyBpbnN0YW5jZW9mIG5vcCA/IHRoaXMgOiBvLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJncy5jb25jYXQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSkpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgaWYgKHRoaXMucHJvdG90eXBlKVxyXG4gICAgICBub3AucHJvdG90eXBlID0gdGhpcy5wcm90b3R5cGU7XHJcbiAgICBib3VuZC5wcm90b3R5cGUgPSBuZXcgbm9wKCk7XHJcbiAgICByZXR1cm4gYm91bmQ7XHJcbiAgfTtcclxufVxyXG5cclxuXHJcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4vLyBFUzUgMTUuNCBBcnJheSBPYmplY3RzXHJcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cclxuLy9cclxuLy8gRVM1IDE1LjQuMyBQcm9wZXJ0aWVzIG9mIHRoZSBBcnJheSBDb25zdHJ1Y3RvclxyXG4vL1xyXG5cclxuXHJcbi8vIEVTNSAxNS40LjMuMiBBcnJheS5pc0FycmF5ICggYXJnIClcclxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvaXNBcnJheVxyXG5BcnJheS5pc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAobykgeyByZXR1cm4gQm9vbGVhbihvICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChPYmplY3QobykpID09PSAnW29iamVjdCBBcnJheV0nKTsgfTtcclxuXHJcblxyXG4vL1xyXG4vLyBFUzUgMTUuNC40IFByb3BlcnRpZXMgb2YgdGhlIEFycmF5IFByb3RvdHlwZSBPYmplY3RcclxuLy9cclxuXHJcbi8vIEVTNSAxNS40LjQuMTQgQXJyYXkucHJvdG90eXBlLmluZGV4T2YgKCBzZWFyY2hFbGVtZW50IFsgLCBmcm9tSW5kZXggXSApXHJcbi8vIEZyb20gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvaW5kZXhPZlxyXG5pZiAoIUFycmF5LnByb3RvdHlwZS5pbmRleE9mKSB7XHJcbiAgQXJyYXkucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiAoc2VhcmNoRWxlbWVudCAvKiwgZnJvbUluZGV4ICovKSB7XHJcbiAgICBpZiAodGhpcyA9PT0gdm9pZCAwIHx8IHRoaXMgPT09IG51bGwpIHsgdGhyb3cgVHlwZUVycm9yKCk7IH1cclxuXHJcbiAgICB2YXIgdCA9IE9iamVjdCh0aGlzKTtcclxuICAgIHZhciBsZW4gPSB0Lmxlbmd0aCA+Pj4gMDtcclxuICAgIGlmIChsZW4gPT09IDApIHsgcmV0dXJuIC0xOyB9XHJcblxyXG4gICAgdmFyIG4gPSAwO1xyXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB7XHJcbiAgICAgIG4gPSBOdW1iZXIoYXJndW1lbnRzWzFdKTtcclxuICAgICAgaWYgKGlzTmFOKG4pKSB7XHJcbiAgICAgICAgbiA9IDA7XHJcbiAgICAgIH0gZWxzZSBpZiAobiAhPT0gMCAmJiBuICE9PSAoMSAvIDApICYmIG4gIT09IC0oMSAvIDApKSB7XHJcbiAgICAgICAgbiA9IChuID4gMCB8fCAtMSkgKiBNYXRoLmZsb29yKE1hdGguYWJzKG4pKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmIChuID49IGxlbikgeyByZXR1cm4gLTE7IH1cclxuXHJcbiAgICB2YXIgayA9IG4gPj0gMCA/IG4gOiBNYXRoLm1heChsZW4gLSBNYXRoLmFicyhuKSwgMCk7XHJcblxyXG4gICAgZm9yICg7IGsgPCBsZW47IGsrKykge1xyXG4gICAgICBpZiAoayBpbiB0ICYmIHRba10gPT09IHNlYXJjaEVsZW1lbnQpIHtcclxuICAgICAgICByZXR1cm4gaztcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIC0xO1xyXG4gIH07XHJcbn1cclxuXHJcbi8vIEVTNSAxNS40LjQuMTUgQXJyYXkucHJvdG90eXBlLmxhc3RJbmRleE9mICggc2VhcmNoRWxlbWVudCBbICwgZnJvbUluZGV4IF0gKVxyXG4vLyBGcm9tIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L2xhc3RJbmRleE9mXHJcbmlmICghQXJyYXkucHJvdG90eXBlLmxhc3RJbmRleE9mKSB7XHJcbiAgQXJyYXkucHJvdG90eXBlLmxhc3RJbmRleE9mID0gZnVuY3Rpb24gKHNlYXJjaEVsZW1lbnQgLyosIGZyb21JbmRleCovKSB7XHJcbiAgICBpZiAodGhpcyA9PT0gdm9pZCAwIHx8IHRoaXMgPT09IG51bGwpIHsgdGhyb3cgVHlwZUVycm9yKCk7IH1cclxuXHJcbiAgICB2YXIgdCA9IE9iamVjdCh0aGlzKTtcclxuICAgIHZhciBsZW4gPSB0Lmxlbmd0aCA+Pj4gMDtcclxuICAgIGlmIChsZW4gPT09IDApIHsgcmV0dXJuIC0xOyB9XHJcblxyXG4gICAgdmFyIG4gPSBsZW47XHJcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcclxuICAgICAgbiA9IE51bWJlcihhcmd1bWVudHNbMV0pO1xyXG4gICAgICBpZiAobiAhPT0gbikge1xyXG4gICAgICAgIG4gPSAwO1xyXG4gICAgICB9IGVsc2UgaWYgKG4gIT09IDAgJiYgbiAhPT0gKDEgLyAwKSAmJiBuICE9PSAtKDEgLyAwKSkge1xyXG4gICAgICAgIG4gPSAobiA+IDAgfHwgLTEpICogTWF0aC5mbG9vcihNYXRoLmFicyhuKSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB2YXIgayA9IG4gPj0gMCA/IE1hdGgubWluKG4sIGxlbiAtIDEpIDogbGVuIC0gTWF0aC5hYnMobik7XHJcblxyXG4gICAgZm9yICg7IGsgPj0gMDsgay0tKSB7XHJcbiAgICAgIGlmIChrIGluIHQgJiYgdFtrXSA9PT0gc2VhcmNoRWxlbWVudCkge1xyXG4gICAgICAgIHJldHVybiBrO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gLTE7XHJcbiAgfTtcclxufVxyXG5cclxuLy8gRVM1IDE1LjQuNC4xNiBBcnJheS5wcm90b3R5cGUuZXZlcnkgKCBjYWxsYmFja2ZuIFsgLCB0aGlzQXJnIF0gKVxyXG4vLyBGcm9tIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L2V2ZXJ5XHJcbmlmICghQXJyYXkucHJvdG90eXBlLmV2ZXJ5KSB7XHJcbiAgQXJyYXkucHJvdG90eXBlLmV2ZXJ5ID0gZnVuY3Rpb24gKGZ1biAvKiwgdGhpc3AgKi8pIHtcclxuICAgIGlmICh0aGlzID09PSB2b2lkIDAgfHwgdGhpcyA9PT0gbnVsbCkgeyB0aHJvdyBUeXBlRXJyb3IoKTsgfVxyXG5cclxuICAgIHZhciB0ID0gT2JqZWN0KHRoaXMpO1xyXG4gICAgdmFyIGxlbiA9IHQubGVuZ3RoID4+PiAwO1xyXG4gICAgaWYgKHR5cGVvZiBmdW4gIT09IFwiZnVuY3Rpb25cIikgeyB0aHJvdyBUeXBlRXJyb3IoKTsgfVxyXG5cclxuICAgIHZhciB0aGlzcCA9IGFyZ3VtZW50c1sxXSwgaTtcclxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICBpZiAoaSBpbiB0ICYmICFmdW4uY2FsbCh0aGlzcCwgdFtpXSwgaSwgdCkpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9O1xyXG59XHJcblxyXG4vLyBFUzUgMTUuNC40LjE3IEFycmF5LnByb3RvdHlwZS5zb21lICggY2FsbGJhY2tmbiBbICwgdGhpc0FyZyBdIClcclxuLy8gRnJvbSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9zb21lXHJcbmlmICghQXJyYXkucHJvdG90eXBlLnNvbWUpIHtcclxuICBBcnJheS5wcm90b3R5cGUuc29tZSA9IGZ1bmN0aW9uIChmdW4gLyosIHRoaXNwICovKSB7XHJcbiAgICBpZiAodGhpcyA9PT0gdm9pZCAwIHx8IHRoaXMgPT09IG51bGwpIHsgdGhyb3cgVHlwZUVycm9yKCk7IH1cclxuXHJcbiAgICB2YXIgdCA9IE9iamVjdCh0aGlzKTtcclxuICAgIHZhciBsZW4gPSB0Lmxlbmd0aCA+Pj4gMDtcclxuICAgIGlmICh0eXBlb2YgZnVuICE9PSBcImZ1bmN0aW9uXCIpIHsgdGhyb3cgVHlwZUVycm9yKCk7IH1cclxuXHJcbiAgICB2YXIgdGhpc3AgPSBhcmd1bWVudHNbMV0sIGk7XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgaWYgKGkgaW4gdCAmJiBmdW4uY2FsbCh0aGlzcCwgdFtpXSwgaSwgdCkpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9O1xyXG59XHJcblxyXG4vLyBFUzUgMTUuNC40LjE4IEFycmF5LnByb3RvdHlwZS5mb3JFYWNoICggY2FsbGJhY2tmbiBbICwgdGhpc0FyZyBdIClcclxuLy8gRnJvbSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9mb3JFYWNoXHJcbmlmICghQXJyYXkucHJvdG90eXBlLmZvckVhY2gpIHtcclxuICBBcnJheS5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIChmdW4gLyosIHRoaXNwICovKSB7XHJcbiAgICBpZiAodGhpcyA9PT0gdm9pZCAwIHx8IHRoaXMgPT09IG51bGwpIHsgdGhyb3cgVHlwZUVycm9yKCk7IH1cclxuXHJcbiAgICB2YXIgdCA9IE9iamVjdCh0aGlzKTtcclxuICAgIHZhciBsZW4gPSB0Lmxlbmd0aCA+Pj4gMDtcclxuICAgIGlmICh0eXBlb2YgZnVuICE9PSBcImZ1bmN0aW9uXCIpIHsgdGhyb3cgVHlwZUVycm9yKCk7IH1cclxuXHJcbiAgICB2YXIgdGhpc3AgPSBhcmd1bWVudHNbMV0sIGk7XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgaWYgKGkgaW4gdCkge1xyXG4gICAgICAgIGZ1bi5jYWxsKHRoaXNwLCB0W2ldLCBpLCB0KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH07XHJcbn1cclxuXHJcblxyXG4vLyBFUzUgMTUuNC40LjE5IEFycmF5LnByb3RvdHlwZS5tYXAgKCBjYWxsYmFja2ZuIFsgLCB0aGlzQXJnIF0gKVxyXG4vLyBGcm9tIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L01hcFxyXG5pZiAoIUFycmF5LnByb3RvdHlwZS5tYXApIHtcclxuICBBcnJheS5wcm90b3R5cGUubWFwID0gZnVuY3Rpb24gKGZ1biAvKiwgdGhpc3AgKi8pIHtcclxuICAgIGlmICh0aGlzID09PSB2b2lkIDAgfHwgdGhpcyA9PT0gbnVsbCkgeyB0aHJvdyBUeXBlRXJyb3IoKTsgfVxyXG5cclxuICAgIHZhciB0ID0gT2JqZWN0KHRoaXMpO1xyXG4gICAgdmFyIGxlbiA9IHQubGVuZ3RoID4+PiAwO1xyXG4gICAgaWYgKHR5cGVvZiBmdW4gIT09IFwiZnVuY3Rpb25cIikgeyB0aHJvdyBUeXBlRXJyb3IoKTsgfVxyXG5cclxuICAgIHZhciByZXMgPSBbXTsgcmVzLmxlbmd0aCA9IGxlbjtcclxuICAgIHZhciB0aGlzcCA9IGFyZ3VtZW50c1sxXSwgaTtcclxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICBpZiAoaSBpbiB0KSB7XHJcbiAgICAgICAgcmVzW2ldID0gZnVuLmNhbGwodGhpc3AsIHRbaV0sIGksIHQpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHJlcztcclxuICB9O1xyXG59XHJcblxyXG4vLyBFUzUgMTUuNC40LjIwIEFycmF5LnByb3RvdHlwZS5maWx0ZXIgKCBjYWxsYmFja2ZuIFsgLCB0aGlzQXJnIF0gKVxyXG4vLyBGcm9tIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L0ZpbHRlclxyXG5pZiAoIUFycmF5LnByb3RvdHlwZS5maWx0ZXIpIHtcclxuICBBcnJheS5wcm90b3R5cGUuZmlsdGVyID0gZnVuY3Rpb24gKGZ1biAvKiwgdGhpc3AgKi8pIHtcclxuICAgIGlmICh0aGlzID09PSB2b2lkIDAgfHwgdGhpcyA9PT0gbnVsbCkgeyB0aHJvdyBUeXBlRXJyb3IoKTsgfVxyXG5cclxuICAgIHZhciB0ID0gT2JqZWN0KHRoaXMpO1xyXG4gICAgdmFyIGxlbiA9IHQubGVuZ3RoID4+PiAwO1xyXG4gICAgaWYgKHR5cGVvZiBmdW4gIT09IFwiZnVuY3Rpb25cIikgeyB0aHJvdyBUeXBlRXJyb3IoKTsgfVxyXG5cclxuICAgIHZhciByZXMgPSBbXTtcclxuICAgIHZhciB0aGlzcCA9IGFyZ3VtZW50c1sxXSwgaTtcclxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICBpZiAoaSBpbiB0KSB7XHJcbiAgICAgICAgdmFyIHZhbCA9IHRbaV07IC8vIGluIGNhc2UgZnVuIG11dGF0ZXMgdGhpc1xyXG4gICAgICAgIGlmIChmdW4uY2FsbCh0aGlzcCwgdmFsLCBpLCB0KSkge1xyXG4gICAgICAgICAgcmVzLnB1c2godmFsKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcmVzO1xyXG4gIH07XHJcbn1cclxuXHJcblxyXG4vLyBFUzUgMTUuNC40LjIxIEFycmF5LnByb3RvdHlwZS5yZWR1Y2UgKCBjYWxsYmFja2ZuIFsgLCBpbml0aWFsVmFsdWUgXSApXHJcbi8vIEZyb20gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvUmVkdWNlXHJcbmlmICghQXJyYXkucHJvdG90eXBlLnJlZHVjZSkge1xyXG4gIEFycmF5LnByb3RvdHlwZS5yZWR1Y2UgPSBmdW5jdGlvbiAoZnVuIC8qLCBpbml0aWFsVmFsdWUgKi8pIHtcclxuICAgIGlmICh0aGlzID09PSB2b2lkIDAgfHwgdGhpcyA9PT0gbnVsbCkgeyB0aHJvdyBUeXBlRXJyb3IoKTsgfVxyXG5cclxuICAgIHZhciB0ID0gT2JqZWN0KHRoaXMpO1xyXG4gICAgdmFyIGxlbiA9IHQubGVuZ3RoID4+PiAwO1xyXG4gICAgaWYgKHR5cGVvZiBmdW4gIT09IFwiZnVuY3Rpb25cIikgeyB0aHJvdyBUeXBlRXJyb3IoKTsgfVxyXG5cclxuICAgIC8vIG5vIHZhbHVlIHRvIHJldHVybiBpZiBubyBpbml0aWFsIHZhbHVlIGFuZCBhbiBlbXB0eSBhcnJheVxyXG4gICAgaWYgKGxlbiA9PT0gMCAmJiBhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7IHRocm93IFR5cGVFcnJvcigpOyB9XHJcblxyXG4gICAgdmFyIGsgPSAwO1xyXG4gICAgdmFyIGFjY3VtdWxhdG9yO1xyXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gMikge1xyXG4gICAgICBhY2N1bXVsYXRvciA9IGFyZ3VtZW50c1sxXTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGRvIHtcclxuICAgICAgICBpZiAoayBpbiB0KSB7XHJcbiAgICAgICAgICBhY2N1bXVsYXRvciA9IHRbaysrXTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gaWYgYXJyYXkgY29udGFpbnMgbm8gdmFsdWVzLCBubyBpbml0aWFsIHZhbHVlIHRvIHJldHVyblxyXG4gICAgICAgIGlmICgrK2sgPj0gbGVuKSB7IHRocm93IFR5cGVFcnJvcigpOyB9XHJcbiAgICAgIH1cclxuICAgICAgd2hpbGUgKHRydWUpO1xyXG4gICAgfVxyXG5cclxuICAgIHdoaWxlIChrIDwgbGVuKSB7XHJcbiAgICAgIGlmIChrIGluIHQpIHtcclxuICAgICAgICBhY2N1bXVsYXRvciA9IGZ1bi5jYWxsKHVuZGVmaW5lZCwgYWNjdW11bGF0b3IsIHRba10sIGssIHQpO1xyXG4gICAgICB9XHJcbiAgICAgIGsrKztcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gYWNjdW11bGF0b3I7XHJcbiAgfTtcclxufVxyXG5cclxuXHJcbi8vIEVTNSAxNS40LjQuMjIgQXJyYXkucHJvdG90eXBlLnJlZHVjZVJpZ2h0ICggY2FsbGJhY2tmbiBbLCBpbml0aWFsVmFsdWUgXSApXHJcbi8vIEZyb20gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvUmVkdWNlUmlnaHRcclxuaWYgKCFBcnJheS5wcm90b3R5cGUucmVkdWNlUmlnaHQpIHtcclxuICBBcnJheS5wcm90b3R5cGUucmVkdWNlUmlnaHQgPSBmdW5jdGlvbiAoY2FsbGJhY2tmbiAvKiwgaW5pdGlhbFZhbHVlICovKSB7XHJcbiAgICBpZiAodGhpcyA9PT0gdm9pZCAwIHx8IHRoaXMgPT09IG51bGwpIHsgdGhyb3cgVHlwZUVycm9yKCk7IH1cclxuXHJcbiAgICB2YXIgdCA9IE9iamVjdCh0aGlzKTtcclxuICAgIHZhciBsZW4gPSB0Lmxlbmd0aCA+Pj4gMDtcclxuICAgIGlmICh0eXBlb2YgY2FsbGJhY2tmbiAhPT0gXCJmdW5jdGlvblwiKSB7IHRocm93IFR5cGVFcnJvcigpOyB9XHJcblxyXG4gICAgLy8gbm8gdmFsdWUgdG8gcmV0dXJuIGlmIG5vIGluaXRpYWwgdmFsdWUsIGVtcHR5IGFycmF5XHJcbiAgICBpZiAobGVuID09PSAwICYmIGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHsgdGhyb3cgVHlwZUVycm9yKCk7IH1cclxuXHJcbiAgICB2YXIgayA9IGxlbiAtIDE7XHJcbiAgICB2YXIgYWNjdW11bGF0b3I7XHJcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAyKSB7XHJcbiAgICAgIGFjY3VtdWxhdG9yID0gYXJndW1lbnRzWzFdO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgZG8ge1xyXG4gICAgICAgIGlmIChrIGluIHRoaXMpIHtcclxuICAgICAgICAgIGFjY3VtdWxhdG9yID0gdGhpc1trLS1dO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBpZiBhcnJheSBjb250YWlucyBubyB2YWx1ZXMsIG5vIGluaXRpYWwgdmFsdWUgdG8gcmV0dXJuXHJcbiAgICAgICAgaWYgKC0tayA8IDApIHsgdGhyb3cgVHlwZUVycm9yKCk7IH1cclxuICAgICAgfVxyXG4gICAgICB3aGlsZSAodHJ1ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgd2hpbGUgKGsgPj0gMCkge1xyXG4gICAgICBpZiAoayBpbiB0KSB7XHJcbiAgICAgICAgYWNjdW11bGF0b3IgPSBjYWxsYmFja2ZuLmNhbGwodW5kZWZpbmVkLCBhY2N1bXVsYXRvciwgdFtrXSwgaywgdCk7XHJcbiAgICAgIH1cclxuICAgICAgay0tO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBhY2N1bXVsYXRvcjtcclxuICB9O1xyXG59XHJcblxyXG5cclxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbi8vIEVTNSAxNS41IFN0cmluZyBPYmplY3RzXHJcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cclxuLy9cclxuLy8gRVM1IDE1LjUuNCBQcm9wZXJ0aWVzIG9mIHRoZSBTdHJpbmcgUHJvdG90eXBlIE9iamVjdFxyXG4vL1xyXG5cclxuXHJcbi8vIEVTNSAxNS41LjQuMjAgU3RyaW5nLnByb3RvdHlwZS50cmltKClcclxuaWYgKCFTdHJpbmcucHJvdG90eXBlLnRyaW0pIHtcclxuICBTdHJpbmcucHJvdG90eXBlLnRyaW0gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gU3RyaW5nKHRoaXMpLnJlcGxhY2UoL15cXHMrLywgJycpLnJlcGxhY2UoL1xccyskLywgJycpO1xyXG4gIH07XHJcbn1cclxuXHJcblxyXG5cclxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbi8vIEVTNSAxNS45IERhdGUgT2JqZWN0c1xyXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcblxyXG4vL1xyXG4vLyBFUyAxNS45LjQgUHJvcGVydGllcyBvZiB0aGUgRGF0ZSBDb25zdHJ1Y3RvclxyXG4vL1xyXG5cclxuLy8gRVM1IDE1LjkuNC40IERhdGUubm93ICggKVxyXG4vLyBGcm9tIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0NvcmVfSmF2YVNjcmlwdF8xLjVfUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0RhdGUvbm93XHJcbmlmICghRGF0ZS5ub3cpIHtcclxuICBEYXRlLm5vdyA9IGZ1bmN0aW9uIG5vdygpIHtcclxuICAgIHJldHVybiBOdW1iZXIobmV3IERhdGUoKSk7XHJcbiAgfTtcclxufVxyXG5cclxuXHJcbi8vXHJcbi8vIEVTNSAxNS45LjUgUHJvcGVydGllcyBvZiB0aGUgRGF0ZSBQcm90b3R5cGUgT2JqZWN0XHJcbi8vXHJcblxyXG4vLyBFUzUgMTUuOS40LjQzIERhdGUucHJvdG90eXBlLnRvSVNPU3RyaW5nICggKVxyXG4vLyBJbnNwaXJlZCBieSBodHRwOi8vd3d3Lmpzb24ub3JnL2pzb24yLmpzXHJcbmlmICghRGF0ZS5wcm90b3R5cGUudG9JU09TdHJpbmcpIHtcclxuICBEYXRlLnByb3RvdHlwZS50b0lTT1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIHBhZDIobikgeyByZXR1cm4gKCcwMCcgKyBuKS5zbGljZSgtMik7IH1cclxuICAgIGZ1bmN0aW9uIHBhZDMobikgeyByZXR1cm4gKCcwMDAnICsgbikuc2xpY2UoLTMpOyB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXMuZ2V0VVRDRnVsbFllYXIoKSArICctJyArXHJcbiAgICAgIHBhZDIodGhpcy5nZXRVVENNb250aCgpICsgMSkgKyAnLScgK1xyXG4gICAgICBwYWQyKHRoaXMuZ2V0VVRDRGF0ZSgpKSArICdUJyArXHJcbiAgICAgIHBhZDIodGhpcy5nZXRVVENIb3VycygpKSArICc6JyArXHJcbiAgICAgIHBhZDIodGhpcy5nZXRVVENNaW51dGVzKCkpICsgJzonICtcclxuICAgICAgcGFkMih0aGlzLmdldFVUQ1NlY29uZHMoKSkgKyAnLicgK1xyXG4gICAgICBwYWQzKHRoaXMuZ2V0VVRDTWlsbGlzZWNvbmRzKCkpICsgJ1onO1xyXG4gIH07XHJcbn1cclxuIiwiLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbi8vXHJcbi8vIEVDTUFTY3JpcHQgMjAxNSBQb2x5ZmlsbHNcclxuLy9cclxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG4oZnVuY3Rpb24gKGdsb2JhbCkge1xyXG4gIFwidXNlIHN0cmljdFwiO1xyXG5cclxuICAvLyBTZXQgdGhpcyB0byBhbHdheXMgb3ZlcnJpZGUgbmF0aXZlIGltcGxlbWVudGF0aW9ucywgZm9yIHRlc3RpbmdcclxuICAvLyB0aGUgcG9seWZpbGwgaW4gYnJvd3NlcnMgd2l0aCBwYXJ0aWFsL2Z1bGwgRVMyMDE1IHN1cHBvcnQuXHJcbiAgdmFyIE9WRVJSSURFX05BVElWRV9GT1JfVEVTVElORyA9IGZhbHNlO1xyXG5cclxuICB2YXIgdW5kZWZpbmVkID0gKHZvaWQgMCk7IC8vIFBhcmFub2lhXHJcblxyXG4gIC8vIEhlbHBlcnNcclxuXHJcbiAgZnVuY3Rpb24gc3RyaWN0KG8pIHtcclxuICAgIHJldHVybiBvID09PSBnbG9iYWwgPyB1bmRlZmluZWQgOiBvO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gaXNTeW1ib2wocykge1xyXG4gICAgcmV0dXJuICh0eXBlb2YgcyA9PT0gJ3N5bWJvbCcpIHx8ICgnU3ltYm9sJyBpbiBnbG9iYWwgJiYgcyBpbnN0YW5jZW9mIGdsb2JhbC5TeW1ib2wpO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZ2V0UHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwgbmFtZSkge1xyXG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwgbmFtZSk7XHJcbiAgICB2YXIgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGFyZ2V0KTtcclxuICAgIHdoaWxlICghZGVzYyAmJiBwcm90bykge1xyXG4gICAgICBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihwcm90bywgbmFtZSk7XHJcbiAgICAgIHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHByb3RvKTtcclxuICAgIH1cclxuICAgIHJldHVybiBkZXNjO1xyXG4gIH1cclxuXHJcbiAgdmFyIGVucXVldWUgPSAoZnVuY3Rpb24obmF0aXZlUHJvbWlzZSwgbmF0aXZlU2V0SW1tZWRpYXRlKSB7XHJcbiAgICBpZiAobmF0aXZlUHJvbWlzZSlcclxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGpvYikgeyBuYXRpdmVQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uKCkgeyBqb2IoKTsgfSk7IH07XHJcbiAgICBpZiAobmF0aXZlU2V0SW1tZWRpYXRlKVxyXG4gICAgICByZXR1cm4gZnVuY3Rpb24oam9iKSB7IG5hdGl2ZVNldEltbWVkaWF0ZShqb2IpOyB9O1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uKGpvYikgeyBzZXRUaW1lb3V0KGpvYiwgMCk7IH07XHJcbiAgfShnbG9iYWxbJ1Byb21pc2UnXSwgZ2xvYmFsWydzZXRJbW1lZGlhdGUnXSkpO1xyXG5cclxuICBmdW5jdGlvbiBkZWZpbmUobywgcCwgdiwgb3ZlcnJpZGUpIHtcclxuICAgIGlmIChwIGluIG8gJiYgIW92ZXJyaWRlICYmICFPVkVSUklERV9OQVRJVkVfRk9SX1RFU1RJTkcpXHJcbiAgICAgIHJldHVybjtcclxuXHJcbiAgICBpZiAodHlwZW9mIHYgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgLy8gU2FuaXR5IGNoZWNrIHRoYXQgZnVuY3Rpb25zIGFyZSBhcHByb3ByaWF0ZWx5IG5hbWVkICh3aGVyZSBwb3NzaWJsZSlcclxuICAgICAgLy9jb25zb2xlLmFzc2VydChpc1N5bWJvbChwKSB8fCAhKCduYW1lJyBpbiB2KSB8fCB2Lm5hbWUgPT09IHAgfHwgdi5uYW1lID09PSBwICsgJ18nLCAnRXhwZWN0ZWQgZnVuY3Rpb24gbmFtZSBcIicgKyBwLnRvU3RyaW5nKCkgKyAnXCIsIHdhcyBcIicgKyB2Lm5hbWUgKyAnXCInKTtcclxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIHAsIHtcclxuICAgICAgICB2YWx1ZTogdixcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgd3JpdGFibGU6IHRydWVcclxuICAgICAgfSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgcCwge1xyXG4gICAgICAgIHZhbHVlOiB2LFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgd3JpdGFibGU6IGZhbHNlXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gc2V0X2ludGVybmFsKG8sIHAsIHYpIHtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBwLCB7XHJcbiAgICAgIHZhbHVlOiB2LFxyXG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxyXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgd3JpdGFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLy8gU25hcHNob3QgaW50cmluc2ljIGZ1bmN0aW9uc1xyXG4gIHZhciAkaXNOYU4gPSBnbG9iYWwuaXNOYU4sXHJcbiAgICAgICRwYXJzZUludCA9IGdsb2JhbC5wYXJzZUludCxcclxuICAgICAgJHBhcnNlRmxvYXQgPSBnbG9iYWwucGFyc2VGbG9hdDtcclxuXHJcbiAgdmFyIEUgPSBNYXRoLkUsXHJcbiAgICAgIExPRzEwRSA9IE1hdGguTE9HMTBFLFxyXG4gICAgICBMT0cyRSA9IE1hdGguTE9HMkUsXHJcbiAgICAgIGFicyA9IE1hdGguYWJzLFxyXG4gICAgICBjZWlsID0gTWF0aC5jZWlsLFxyXG4gICAgICBleHAgPSBNYXRoLmV4cCxcclxuICAgICAgZmxvb3IgPSBNYXRoLmZsb29yLFxyXG4gICAgICBsb2cgPSBNYXRoLmxvZyxcclxuICAgICAgbWF4ID0gTWF0aC5tYXgsXHJcbiAgICAgIG1pbiA9IE1hdGgubWluLFxyXG4gICAgICBwb3cgPSBNYXRoLnBvdyxcclxuICAgICAgcmFuZG9tID0gTWF0aC5yYW5kb20sXHJcbiAgICAgIHNxcnQgPSBNYXRoLnNxcnQ7XHJcblxyXG4gIHZhciBvcmlnX21hdGNoID0gU3RyaW5nLnByb3RvdHlwZS5tYXRjaCxcclxuICAgICAgb3JpZ19yZXBsYWNlID0gU3RyaW5nLnByb3RvdHlwZS5yZXBsYWNlLFxyXG4gICAgICBvcmlnX3NlYXJjaCA9IFN0cmluZy5wcm90b3R5cGUuc2VhcmNoLFxyXG4gICAgICBvcmlnX3NwbGl0ID0gU3RyaW5nLnByb3RvdHlwZS5zcGxpdDtcclxuXHJcbiAgLy8gVGhlc2UgYXJlIHVzZWQgZm9yIGltcGxlbWVudGluZyB0aGUgcG9seWZpbGxzLCBidXQgbm90IGV4cG9ydGVkLlxyXG5cclxuICAvLyBJbnNwaXJlZCBieSBodHRwczovL2dpc3QuZ2l0aHViLmNvbS8xNjM4MDU5XHJcbiAgLyoqIEBjb25zdHJ1Y3RvciAqL1xyXG4gIGZ1bmN0aW9uIEVwaGVtZXJvblRhYmxlKCkge1xyXG4gICAgdmFyIHNlY3JldEtleSA9IE9iamVjdENyZWF0ZShudWxsKTtcclxuXHJcbiAgICBmdW5jdGlvbiBjb25jZWFsKG8pIHtcclxuICAgICAgdmFyIG9WYWx1ZU9mID0gby52YWx1ZU9mLCBzZWNyZXRzID0gT2JqZWN0Q3JlYXRlKG51bGwpO1xyXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgJ3ZhbHVlT2YnLCB7XHJcbiAgICAgICAgICB2YWx1ZTogKGZ1bmN0aW9uKHNlY3JldEtleSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGspIHtcclxuICAgICAgICAgICAgICByZXR1cm4gKGsgPT09IHNlY3JldEtleSkgPyBzZWNyZXRzIDogb1ZhbHVlT2YuYXBwbHkobywgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgIH0oc2VjcmV0S2V5KSksXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIHdyaXRlYWJsZTogdHJ1ZSxcclxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICByZXR1cm4gc2VjcmV0cztcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiByZXZlYWwobykge1xyXG4gICAgICB2YXIgdiA9IHR5cGVvZiBvLnZhbHVlT2YgPT09ICdmdW5jdGlvbicgJiYgby52YWx1ZU9mKHNlY3JldEtleSk7XHJcbiAgICAgIHJldHVybiB2ID09PSBvID8gbnVsbCA6IHY7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgY2xlYXI6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHNlY3JldEtleSA9IE9iamVjdENyZWF0ZShudWxsKTtcclxuICAgICAgfSxcclxuICAgICAgcmVtb3ZlOiBmdW5jdGlvbihrZXkpIHtcclxuICAgICAgICB2YXIgc2VjcmV0cyA9IHJldmVhbChrZXkpO1xyXG4gICAgICAgIGlmIChzZWNyZXRzICYmIEhhc093blByb3BlcnR5KHNlY3JldHMsICd2YWx1ZScpKSB7XHJcbiAgICAgICAgICBkZWxldGUgc2VjcmV0cy52YWx1ZTtcclxuICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH0sXHJcbiAgICAgIGdldDogZnVuY3Rpb24oa2V5LCBkZWZhdWx0VmFsdWUpIHtcclxuICAgICAgICB2YXIgc2VjcmV0cyA9IHJldmVhbChrZXkpO1xyXG4gICAgICAgIHJldHVybiAoc2VjcmV0cyAmJiBIYXNPd25Qcm9wZXJ0eShzZWNyZXRzLCAndmFsdWUnKSkgPyBzZWNyZXRzLnZhbHVlIDogZGVmYXVsdFZhbHVlO1xyXG4gICAgICB9LFxyXG4gICAgICBoYXM6IGZ1bmN0aW9uKGtleSkge1xyXG4gICAgICAgIHZhciBzZWNyZXRzID0gcmV2ZWFsKGtleSk7XHJcbiAgICAgICAgcmV0dXJuIEJvb2xlYW4oc2VjcmV0cyAmJiBIYXNPd25Qcm9wZXJ0eShzZWNyZXRzLCAndmFsdWUnKSk7XHJcbiAgICAgIH0sXHJcbiAgICAgIHNldDogZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xyXG4gICAgICAgIHZhciBzZWNyZXRzID0gcmV2ZWFsKGtleSkgfHwgY29uY2VhbChrZXkpO1xyXG4gICAgICAgIHNlY3JldHMudmFsdWUgPSB2YWx1ZTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIHZhciBlbXB0eSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XHJcblxyXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gIC8vXHJcbiAgLy8gRUNNQVNjcmlwdCAyMDE1XHJcbiAgLy8gaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC9cclxuICAvL1xyXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cclxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAvLyAxOS40IFN5bWJvbCBPYmplY3RzXHJcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG4gIC8vIE5PVEU6IFN5bWJvbHMgYXJlIGRlZmluZWQgaGVyZSAtIG91dCBvZiBzcGVjIG9yZGVyIC0gc2luY2Ugd2UgbmVlZCB0aGVcclxuICAvLyBwcm9wZXJ0aWVzIGFuZCBwcm90b3R5cGUgdG8gYmUgcG9wdWxhdGVkIGZvciBvdGhlciBwb2x5ZmlsbHMuXHJcblxyXG4gIC8vIE5PVEU6IE5vdCBzZWN1cmUsIG5vciBpcyBvYmpbJCRzeW1ib2xdIGhpZGRlbiBmcm9tIE9iamVjdC5rZXlzKClcclxuXHJcbiAgdmFyIHN5bWJvbEZvcktleTtcclxuICAoZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgc2VjcmV0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuICAgIHZhciBzeW1ib2xNYXAgPSB7fTtcclxuICAgIHN5bWJvbEZvcktleSA9IGZ1bmN0aW9uKGspIHtcclxuICAgICAgcmV0dXJuIHN5bWJvbE1hcFtrXTtcclxuICAgIH07XHJcblxyXG4gICAgdmFyIEdsb2JhbFN5bWJvbFJlZ2lzdHJ5ID0gW107XHJcblxyXG4gICAgZnVuY3Rpb24gdW5pcXVlKGJpdHMpIHtcclxuICAgICAgcmV0dXJuIEFycmF5KGJpdHMgKyAxKS5qb2luKCd4JykucmVwbGFjZSgveC9nLCBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gcmFuZG9tKCkgPCAwLjUgPyAnXFx1MjAwQycgOiAnXFx1MjAwRCc7IC8vIEpXTkogLyBaV0pcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gMTkuNC4xIFRoZSBTeW1ib2wgQ29uc3RydWN0b3JcclxuICAgIC8vIDE5LjQuMS4xIFN5bWJvbCAoIGRlc2NyaXB0aW9uPXVuZGVmaW5lZCApXHJcbiAgICBmdW5jdGlvbiBTeW1ib2woZGVzY3JpcHRpb24pIHtcclxuICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFN5bWJvbCkpIHJldHVybiBuZXcgU3ltYm9sKGRlc2NyaXB0aW9uLCBzZWNyZXQpO1xyXG4gICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIFN5bWJvbCAmJiBhcmd1bWVudHNbMV0gIT09IHNlY3JldCkgdGhyb3cgVHlwZUVycm9yKCk7XHJcblxyXG4gICAgICB2YXIgZGVzY1N0cmluZyA9IGRlc2NyaXB0aW9uID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBTdHJpbmcoZGVzY3JpcHRpb24pO1xyXG5cclxuICAgICAgc2V0X2ludGVybmFsKHRoaXMsICdbW1N5bWJvbERhdGFdXScsIHVuaXF1ZSgxMjgpKTtcclxuICAgICAgc2V0X2ludGVybmFsKHRoaXMsICdbW0Rlc2NyaXB0aW9uXV0nLCBkZXNjU3RyaW5nKTtcclxuXHJcbiAgICAgIHN5bWJvbE1hcFt0aGlzXSA9IHRoaXM7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghKCdTeW1ib2wnIGluIGdsb2JhbCkgfHwgT1ZFUlJJREVfTkFUSVZFX0ZPUl9URVNUSU5HKVxyXG4gICAgICBnbG9iYWwuU3ltYm9sID0gU3ltYm9sO1xyXG5cclxuICAgIC8vIDE5LjQuMiBQcm9wZXJ0aWVzIG9mIHRoZSBTeW1ib2wgQ29uc3RydWN0b3JcclxuXHJcbiAgICAvLyAxOS40LjIuMSBTeW1ib2wuZm9yIChrZXkpXHJcbiAgICBkZWZpbmUoU3ltYm9sLCAnZm9yJywgZnVuY3Rpb24gZm9yXyhrZXkpIHtcclxuICAgICAgdmFyIHN0cmluZ0tleSA9IFN0cmluZyhrZXkpO1xyXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IEdsb2JhbFN5bWJvbFJlZ2lzdHJ5Lmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgdmFyIGUgPSBHbG9iYWxTeW1ib2xSZWdpc3RyeVtpXTtcclxuICAgICAgICBpZiAoU2FtZVZhbHVlKGVbJ1tba2V5XV0nXSwgc3RyaW5nS2V5KSkgcmV0dXJuIGVbJ1tbc3ltYm9sXV0nXTtcclxuICAgICAgfVxyXG4gICAgICB2YXIgbmV3U3ltYm9sID0gU3ltYm9sKGtleSk7XHJcbiAgICAgIEdsb2JhbFN5bWJvbFJlZ2lzdHJ5LnB1c2goeydbW2tleV1dJzogc3RyaW5nS2V5LCAnW1tzeW1ib2xdXSc6IG5ld1N5bWJvbH0pO1xyXG4gICAgICByZXR1cm4gbmV3U3ltYm9sO1xyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gMTkuNC4yLjIgU3ltYm9sLmhhc0luc3RhbmNlXHJcbiAgICAvLyAxOS40LjIuMyBTeW1ib2wuaXNDb25jYXRTcHJlYWRhYmxlXHJcblxyXG4gICAgLy8gMTkuNC4yLjQgU3ltYm9sLml0ZXJhdG9yXHJcbiAgICBkZWZpbmUoZ2xvYmFsLlN5bWJvbCwgJ2l0ZXJhdG9yJywgZ2xvYmFsLlN5bWJvbCgnU3ltYm9sLml0ZXJhdG9yJykpO1xyXG5cclxuICAgIC8vIDE5LjQuMi41IFN5bWJvbC5rZXlGb3IgKHN5bSlcclxuICAgIGRlZmluZShTeW1ib2wsICdrZXlGb3InLCBmdW5jdGlvbiBrZXlGb3Ioc3ltKSB7XHJcbiAgICAgIGlmICghKHN5bSBpbnN0YW5jZW9mIFN5bWJvbCkpIHRocm93IFR5cGVFcnJvcigpO1xyXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IEdsb2JhbFN5bWJvbFJlZ2lzdHJ5Lmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgdmFyIGUgPSBHbG9iYWxTeW1ib2xSZWdpc3RyeVtpXTtcclxuICAgICAgICBpZiAoU2FtZVZhbHVlKGVbJ1tbc3ltYm9sXV0nXSwgc3ltKSkgcmV0dXJuIGVbJ1tba2V5XV0nXTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gMTkuNC4yLjYgU3ltYm9sLm1hdGNoXHJcbiAgICBkZWZpbmUoZ2xvYmFsLlN5bWJvbCwgJ21hdGNoJywgZ2xvYmFsLlN5bWJvbCgnU3ltYm9sLm1hdGNoJykpO1xyXG5cclxuICAgIC8vIDE5LjQuMi43IFN5bWJvbC5wcm90b3R5cGVcclxuXHJcbiAgICAvLyAxOS40LjIuOCBTeW1ib2wucmVwbGFjZVxyXG4gICAgZGVmaW5lKGdsb2JhbC5TeW1ib2wsICdyZXBsYWNlJywgZ2xvYmFsLlN5bWJvbCgnU3ltYm9sLnJlcGxhY2UnKSk7XHJcblxyXG4gICAgLy8gMTkuNC4yLjkgU3ltYm9sLnNlYXJjaFxyXG4gICAgZGVmaW5lKGdsb2JhbC5TeW1ib2wsICdzZWFyY2gnLCBnbG9iYWwuU3ltYm9sKCdTeW1ib2wuc2VhcmNoJykpO1xyXG5cclxuICAgIC8vIDE5LjQuMi4xMCBTeW1ib2wuc3BlY2llc1xyXG5cclxuICAgIC8vIDE5LjQuMi4xMSBTeW1ib2wuc2VhcmNoXHJcbiAgICBkZWZpbmUoZ2xvYmFsLlN5bWJvbCwgJ3NwbGl0JywgZ2xvYmFsLlN5bWJvbCgnU3ltYm9sLnNwbGl0JykpO1xyXG5cclxuICAgIC8vIDE5LjQuMi4xMiBTeW1ib2wudG9QcmltaXRpdmVcclxuXHJcbiAgICAvLyAxOS40LjIuMTMgU3ltYm9sLnRvU3RyaW5nVGFnXHJcbiAgICBkZWZpbmUoZ2xvYmFsLlN5bWJvbCwgJ3RvU3RyaW5nVGFnJywgZ2xvYmFsLlN5bWJvbCgnU3ltYm9sLnRvU3RyaW5nVGFnJykpO1xyXG5cclxuICAgIC8vIDE5LjQuMi4xNCBTeW1ib2wudW5zY29wYWJsZXNcclxuXHJcbiAgICAvLyAxOS40LjMgUHJvcGVydGllcyBvZiB0aGUgU3ltYm9sIFByb3RvdHlwZSBPYmplY3RcclxuICAgIC8vIDE5LjQuMy4xIFN5bWJvbC5wcm90b3R5cGUuY29uc3RydWN0b3JcclxuXHJcbiAgICAvLyAxOS40LjMuMiBTeW1ib2wucHJvdG90eXBlLnRvU3RyaW5nICggKVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFN5bWJvbC5wcm90b3R5cGUsICd0b1N0cmluZycsIHtcclxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xyXG4gICAgICAgIHZhciBzID0gc3RyaWN0KHRoaXMpO1xyXG4gICAgICAgIHZhciBkZXNjID0gc1snW1tEZXNjcmlwdGlvbl1dJ107XHJcbiAgICAgICAgcmV0dXJuICdTeW1ib2woJyArIChkZXNjID09PSB1bmRlZmluZWQgPyAnJyA6IGRlc2MpICsgc1snW1tTeW1ib2xEYXRhXV0nXSArICcpJztcclxuICAgICAgfSxcclxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0ZWFibGU6IHRydWUsIGVudW1lcmFibGU6IGZhbHNlIH0pO1xyXG5cclxuICAgIC8vIDE5LjQuMy4zIFN5bWJvbC5wcm90b3R5cGUudmFsdWVPZiAoIClcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTeW1ib2wucHJvdG90eXBlLCAndmFsdWVPZicsIHtcclxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlT2YoKSB7XHJcbiAgICAgICAgLy8gVG8gcHJldmVudCBhdXRvbWF0aWMgc3RyaW5nIGNvbnZlcnNpb246XHJcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKCk7XHJcblxyXG4gICAgICAgIC8vIFNwZWMgaGFzIGFwcHJveGltYXRlbHkgdGhlIGZvbGxvd2luZzpcclxuICAgICAgICAvL3ZhciBzID0gc3RyaWN0KHRoaXMpO1xyXG4gICAgICAgIC8vaWYgKFR5cGUocykgPT09ICdzeW1ib2wnKSByZXR1cm4gcztcclxuICAgICAgICAvL2lmIChUeXBlKHMpICE9PSAnb2JqZWN0JykgdGhyb3cgVHlwZUVycm9yKCk7XHJcbiAgICAgICAgLy9pZiAoISgnW1tTeW1ib2xEYXRhXV0nIGluIHMpKSB0aHJvdyBUeXBlRXJyb3IoKTtcclxuICAgICAgICAvL3JldHVybiBzWydbW1N5bWJvbERhdGFdXSddO1xyXG4gICAgICB9LFxyXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsIHdyaXRlYWJsZTogdHJ1ZSwgZW51bWVyYWJsZTogZmFsc2UgfSk7XHJcblxyXG4gICAgLy8gMTkuNC4zLjQgU3ltYm9sLnByb3RvdHlwZSBbIEBAdG9TdHJpbmdUYWcgXVxyXG4gICAgLy8gKERvbmUgbGF0ZXIgdG8gcG9seWZpbGwgcGFydGlhbCBpbXBsZW1lbnRhdGlvbnMpXHJcblxyXG4gICAgLy8gMTkuNC40IFByb3BlcnRpZXMgb2YgU3ltYm9sIEluc3RhbmNlc1xyXG4gIH0oKSk7XHJcblxyXG4gIGNvbnNvbGUuYXNzZXJ0KHR5cGVvZiBnbG9iYWwuU3ltYm9sKCkgPT09ICdzeW1ib2wnIHx8IHN5bWJvbEZvcktleShTdHJpbmcoZ2xvYmFsLlN5bWJvbCgneCcpKSkgIT09IHVuZGVmaW5lZCk7XHJcblxyXG4gIC8vIERlZmluZWQgaGVyZSBzbyB0aGF0IG90aGVyIHByb3RvdHlwZXMgY2FuIHJlZmVyZW5jZSBpdFxyXG4gIC8vIDI1LjEuMiBUaGUgJUl0ZXJhdG9yUHJvdG90eXBlJSBPYmplY3RcclxuICB2YXIgJEl0ZXJhdG9yUHJvdG90eXBlJCA9IHt9O1xyXG5cclxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAvLyA2IEVDTUFTY3JpcHQgRGF0YSBUeXBlcyBhbmQgVmFsdWVzXHJcbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG4gIC8vIDYuMSBFQ01BU2NyaXB0IExhbmd1YWdlIFR5cGVzXHJcblxyXG4gIC8vIFwiVHlwZSh4KVwiIGlzIHVzZWQgYXMgc2hvcnRoYW5kIGZvciBcInRoZSB0eXBlIG9mIHhcIi4uLlxyXG4gIGZ1bmN0aW9uIFR5cGUodikge1xyXG4gICAgc3dpdGNoICh0eXBlb2Ygdikge1xyXG4gICAgY2FzZSAndW5kZWZpbmVkJzogcmV0dXJuICd1bmRlZmluZWQnO1xyXG4gICAgY2FzZSAnYm9vbGVhbic6IHJldHVybiAnYm9vbGVhbic7XHJcbiAgICBjYXNlICdudW1iZXInOiByZXR1cm4gJ251bWJlcic7XHJcbiAgICBjYXNlICdzdHJpbmcnOiByZXR1cm4gJ3N0cmluZyc7XHJcbiAgICBjYXNlICdzeW1ib2wnOiByZXR1cm4gJ3N5bWJvbCc7XHJcbiAgICBkZWZhdWx0OlxyXG4gICAgICBpZiAodiA9PT0gbnVsbCkgcmV0dXJuICdudWxsJztcclxuICAgICAgaWYgKHYgaW5zdGFuY2VvZiBnbG9iYWwuU3ltYm9sKSByZXR1cm4gJ3N5bWJvbCc7XHJcbiAgICAgIHJldHVybiAnb2JqZWN0JztcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIDYuMS41LjEgV2VsbC1Lbm93biBTeW1ib2xzXHJcbiAgdmFyICQkaXRlcmF0b3IgPSBnbG9iYWwuU3ltYm9sLml0ZXJhdG9yLFxyXG4gICAgICAkJG1hdGNoID0gZ2xvYmFsLlN5bWJvbC5tYXRjaCxcclxuICAgICAgJCRyZXBsYWNlID0gZ2xvYmFsLlN5bWJvbC5yZXBsYWNlLFxyXG4gICAgICAkJHNlYXJjaCA9IGdsb2JhbC5TeW1ib2wuc2VhcmNoLFxyXG4gICAgICAkJHNwbGl0ID0gZ2xvYmFsLlN5bWJvbC5zcGxpdCxcclxuICAgICAgJCR0b1N0cmluZ1RhZyA9IGdsb2JhbC5TeW1ib2wudG9TdHJpbmdUYWc7XHJcblxyXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gIC8vIDcgQWJzdHJhY3QgT3BlcmF0aW9uc1xyXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cclxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAvLyA3LjEgVHlwZSBDb252ZXJzaW9uXHJcbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG4gIC8vIDcuMS4xIFRvUHJpbWl0aXZlICggaW5wdXQgWywgUHJlZmVycmVkVHlwZV0gKVxyXG4gIC8vIGp1c3QgdXNlIHZhbHVlT2YoKVxyXG5cclxuICAvLyA3LjEuMiBUb0Jvb2xlYW4gKCBhcmd1bWVudCApXHJcbiAgLy8ganVzdCB1c2UgQm9vbGVhbigpXHJcblxyXG4gIC8vIDcuMS4zIFRvTnVtYmVyICggYXJndW1lbnQgKVxyXG4gIC8vIGp1c3QgdXNlIE51bWJlcigpXHJcblxyXG4gIC8vIDcuMS40IFRvSW50ZWdlciAoIGFyZ3VtZW50IClcclxuICBmdW5jdGlvbiBUb0ludGVnZXIobikge1xyXG4gICAgbiA9IE51bWJlcihuKTtcclxuICAgIGlmICgkaXNOYU4obikpIHJldHVybiAwO1xyXG4gICAgaWYgKG4gPT09IDAgfHwgbiA9PT0gSW5maW5pdHkgfHwgbiA9PT0gLUluZmluaXR5KSByZXR1cm4gbjtcclxuICAgIHJldHVybiAoKG4gPCAwKSA/IC0xIDogMSkgKiBmbG9vcihhYnMobikpO1xyXG4gIH1cclxuXHJcbiAgLy8gNy4xLjUgVG9JbnQzMiAoIGFyZ3VtZW50IClcclxuICBmdW5jdGlvbiBUb0ludDMyKHYpIHsgcmV0dXJuIHYgPj4gMDsgfVxyXG5cclxuICAvLyA3LjEuNiBUb1VpbnQzMiAoIGFyZ3VtZW50IClcclxuICBmdW5jdGlvbiBUb1VpbnQzMih2KSB7IHJldHVybiB2ID4+PiAwOyB9XHJcblxyXG4gIC8vIDcuMS43IFRvSW50MTYgKCBhcmd1bWVudCApXHJcbiAgZnVuY3Rpb24gVG9JbnQxNih2KSB7IHJldHVybiAodiA8PCAxNikgPj4gMTY7IH1cclxuXHJcbiAgLy8gNy4xLjggVG9VaW50MTYgKCBhcmd1bWVudCApXHJcbiAgZnVuY3Rpb24gVG9VaW50MTYodikgeyByZXR1cm4gdiAmIDB4RkZGRjsgfVxyXG5cclxuICAvLyA3LjEuOSBUb0ludDggKCBhcmd1bWVudCApXHJcbiAgZnVuY3Rpb24gVG9JbnQ4KHYpIHsgcmV0dXJuICh2IDw8IDI0KSA+PiAyNDsgfVxyXG5cclxuICAvLyA3LjEuMTAgVG9VaW50OCAoIGFyZ3VtZW50IClcclxuICBmdW5jdGlvbiBUb1VpbnQ4KHYpIHsgcmV0dXJuIHYgJiAweEZGOyB9XHJcblxyXG4gIC8vIDcuMS4xMSBUb1VpbnQ4Q2xhbXAgKCBhcmd1bWVudCApXHJcbiAgZnVuY3Rpb24gVG9VaW50OENsYW1wKGFyZ3VtZW50KSB7XHJcbiAgICB2YXIgbnVtYmVyID0gTnVtYmVyKGFyZ3VtZW50KTtcclxuICAgIGlmICgkaXNOYU4obnVtYmVyKSkgcmV0dXJuIDA7XHJcbiAgICBpZiAobnVtYmVyIDw9IDApIHJldHVybiAwO1xyXG4gICAgaWYgKG51bWJlciA+PSAyNTUpIHJldHVybiAyNTU7XHJcbiAgICB2YXIgZiA9IGZsb29yKG51bWJlcik7XHJcbiAgICBpZiAoKGYgKyAwLjUpIDwgbnVtYmVyKSByZXR1cm4gZiArIDE7XHJcbiAgICBpZiAobnVtYmVyIDwgKGYgKyAwLjUpKSByZXR1cm4gZjtcclxuICAgIGlmIChmICUgMikgcmV0dXJuIGYgKyAxO1xyXG4gICAgcmV0dXJuIGY7XHJcbiAgfVxyXG5cclxuICAvLyA3LjEuMTIgVG9TdHJpbmcgKCBhcmd1bWVudCApXHJcbiAgLy8ganVzdCB1c2UgU3RyaW5nKClcclxuXHJcbiAgLy8gNy4xLjEzIFRvT2JqZWN0ICggYXJndW1lbnQgKVxyXG4gIGZ1bmN0aW9uIFRvT2JqZWN0KHYpIHtcclxuICAgIGlmICh2ID09PSBudWxsIHx8IHYgPT09IHVuZGVmaW5lZCkgdGhyb3cgVHlwZUVycm9yKCk7XHJcbiAgICByZXR1cm4gT2JqZWN0KHYpO1xyXG4gIH1cclxuXHJcbiAgLy8gNy4xLjE0IFRvUHJvcGVydHlLZXkgKCBhcmd1bWVudCApXHJcbiAgZnVuY3Rpb24gVG9Qcm9wZXJ0eUtleSh2KSB7XHJcbiAgICByZXR1cm4gU3RyaW5nKHYpO1xyXG4gIH1cclxuXHJcbiAgLy8gNy4xLjE1IFRvTGVuZ3RoICggYXJndW1lbnQgKVxyXG4gIGZ1bmN0aW9uIFRvTGVuZ3RoKHYpIHtcclxuICAgIHZhciBsZW4gPSBUb0ludGVnZXIodik7XHJcbiAgICBpZiAobGVuIDw9IDApIHJldHVybiAwO1xyXG4gICAgaWYgKGxlbiA9PT0gSW5maW5pdHkpIHJldHVybiAweDIwMDAwMDAwMDAwMDAwIC0gMTsgLy8gMl41My0xXHJcbiAgICByZXR1cm4gbWluKGxlbiwgMHgyMDAwMDAwMDAwMDAwMCAtIDEpOyAvLyAyXjUzLTFcclxuICB9XHJcblxyXG4gIC8vIDcuMS4xNiBDYW5vbmljYWxOdW1lcmljSW5kZXhTdHJpbmcgKCBhcmd1bWVudCApXHJcblxyXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gIC8vIDcuMiBUZXN0aW5nIGFuZCBDb21wYXJpc29uIE9wZXJhdGlvbnNcclxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcbiAgLy8gNy4yLjEgUmVxdWlyZU9iamVjdENvZXJjaWJsZSAoIGFyZ3VtZW50IClcclxuICAvLyA3LjIuMiBJc0FycmF5ICggYXJndW1lbnQgKVxyXG5cclxuICAvLyA3LjIuMyBJc0NhbGxhYmxlICggYXJndW1lbnQgKVxyXG4gIGZ1bmN0aW9uIElzQ2FsbGFibGUobykgeyByZXR1cm4gdHlwZW9mIG8gPT09ICdmdW5jdGlvbic7IH1cclxuXHJcbiAgLy8gNy4yLjQgSXNDb25zdHJ1Y3RvciAoIGFyZ3VtZW50IClcclxuICBmdW5jdGlvbiBJc0NvbnN0cnVjdG9yKG8pIHtcclxuICAgIC8vIEhhY2tzIGZvciBTYWZhcmkgNyBUeXBlZEFycmF5IFhYWENvbnN0cnVjdG9yIG9iamVjdHNcclxuICAgIGlmICgvQ29uc3RydWN0b3IvLnRlc3QoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pKSkgcmV0dXJuIHRydWU7XHJcbiAgICBpZiAoL0Z1bmN0aW9uLy50ZXN0KE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKSkpIHJldHVybiB0cnVlO1xyXG4gICAgLy8gVE9ETzogQ2FuIHRoaXMgYmUgaW1wcm92ZWQgb24/XHJcbiAgICByZXR1cm4gdHlwZW9mIG8gPT09ICdmdW5jdGlvbic7XHJcbiAgfVxyXG5cclxuICAvLyA3LjIuNSBJc0V4dGVuc2libGUgKE8pXHJcbiAgLy8gNy4yLjYgSXNJbnRlZ2VyICggYXJndW1lbnQgKVxyXG5cclxuICAvLyA3LjIuNyBJc1Byb3BlcnR5S2V5ICggYXJndW1lbnQgKVxyXG4gIGZ1bmN0aW9uIElzUHJvcGVydHlLZXkoYXJndW1lbnQpIHtcclxuICAgIGlmIChUeXBlKGFyZ3VtZW50KSA9PT0gJ3N0cmluZycpIHJldHVybiB0cnVlO1xyXG4gICAgaWYgKFR5cGUoYXJndW1lbnQpID09PSAnc3ltYm9sJykgcmV0dXJuIHRydWU7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG5cclxuICAvLyA3LjIuOCBJc1JlZ0V4cCAoIGFyZ3VtZW50IClcclxuXHJcbiAgLy8gNy4yLjkgU2FtZVZhbHVlKHgsIHkpXHJcbiAgZnVuY3Rpb24gU2FtZVZhbHVlKHgsIHkpIHtcclxuICAgIGlmICh0eXBlb2YgeCAhPT0gdHlwZW9mIHkpIHJldHVybiBmYWxzZTtcclxuICAgIHN3aXRjaCAodHlwZW9mIHgpIHtcclxuICAgIGNhc2UgJ3VuZGVmaW5lZCc6XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgY2FzZSAnbnVtYmVyJzpcclxuICAgICAgaWYgKHggIT09IHggJiYgeSAhPT0geSkgcmV0dXJuIHRydWU7XHJcbiAgICAgIGlmICh4ID09PSAwICYmIHkgPT09IDApIHJldHVybiAxL3ggPT09IDEveTtcclxuICAgICAgcmV0dXJuIHggPT09IHk7XHJcbiAgICBjYXNlICdib29sZWFuJzpcclxuICAgIGNhc2UgJ3N0cmluZyc6XHJcbiAgICBjYXNlICdvYmplY3QnOlxyXG4gICAgZGVmYXVsdDpcclxuICAgICAgcmV0dXJuIHggPT09IHk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyA3LjIuMTAgU2FtZVZhbHVlWmVybyh4LCB5KVxyXG4gIGZ1bmN0aW9uIFNhbWVWYWx1ZVplcm8oeCwgeSkge1xyXG4gICAgaWYgKHR5cGVvZiB4ICE9PSB0eXBlb2YgeSkgcmV0dXJuIGZhbHNlO1xyXG4gICAgc3dpdGNoICh0eXBlb2YgeCkge1xyXG4gICAgY2FzZSAndW5kZWZpbmVkJzpcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICBjYXNlICdudW1iZXInOlxyXG4gICAgICBpZiAoeCAhPT0geCAmJiB5ICE9PSB5KSByZXR1cm4gdHJ1ZTtcclxuICAgICAgcmV0dXJuIHggPT09IHk7XHJcbiAgICBjYXNlICdib29sZWFuJzpcclxuICAgIGNhc2UgJ3N0cmluZyc6XHJcbiAgICBjYXNlICdvYmplY3QnOlxyXG4gICAgZGVmYXVsdDpcclxuICAgICAgcmV0dXJuIHggPT09IHk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAvLyA3LjMgT3BlcmF0aW9ucyBvbiBPYmplY3RzXHJcbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG4gIC8vIDcuMy4xIEdldCAoTywgUClcclxuICAvLyAtIGp1c3QgdXNlIG8ucCBvciBvW3BdXHJcblxyXG4gIC8vIDcuMy4yIEdldFYgKFYsIFApXHJcbiAgZnVuY3Rpb24gR2V0Vih2LCBwKSB7XHJcbiAgICB2YXIgbyA9IFRvT2JqZWN0KHYpO1xyXG4gICAgcmV0dXJuIG9bcF07XHJcbiAgfVxyXG5cclxuICAvLyA3LjMuMyBTZXQgKE8sIFAsIFYsIFRocm93KVxyXG4gIC8vIC0ganVzdCB1c2Ugby5wID0gdiBvciBvW3BdID0gdlxyXG5cclxuXHJcblxyXG5cclxuICAvLyA3LjMuOSBHZXRNZXRob2QgKE8sIFApXHJcbiAgZnVuY3Rpb24gR2V0TWV0aG9kKG8sIHApIHtcclxuICAgIHZhciBmdW5jID0gR2V0VihvLCBwKTtcclxuICAgIGlmIChmdW5jID09PSB1bmRlZmluZWQgfHwgZnVuYyA9PT0gbnVsbCkgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIGlmICghSXNDYWxsYWJsZShmdW5jKSkgdGhyb3cgVHlwZUVycm9yKCk7XHJcbiAgICByZXR1cm4gZnVuYztcclxuICB9XHJcblxyXG4gIC8vIDcuMy4xMCBIYXNQcm9wZXJ0eSAoTywgUClcclxuICBmdW5jdGlvbiBIYXNQcm9wZXJ0eShvLCBwKSB7XHJcbiAgICB3aGlsZSAobykge1xyXG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG8sIHApKSByZXR1cm4gdHJ1ZTtcclxuICAgICAgaWYgKFR5cGUobykgIT09ICdvYmplY3QnKSByZXR1cm4gZmFsc2U7XHJcbiAgICAgIHZhciBvcCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTtcclxuICAgICAgaWYgKG9wID09PSBvKSByZXR1cm4gZmFsc2U7IC8vIElFOCBoYXMgc2VsZi1yZWZlcmVudGlhbCBwcm90b3R5cGVzXHJcbiAgICAgIG8gPSBvcDtcclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcblxyXG4gIC8vIDcuMy4xMSBIYXNPd25Qcm9wZXJ0eSAoTywgUClcclxuICBmdW5jdGlvbiBIYXNPd25Qcm9wZXJ0eShvLCBwKSB7XHJcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG8sIHApO1xyXG4gIH1cclxuXHJcbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgLy8gNy40IE9wZXJhdGlvbnMgb24gSXRlcmF0b3IgT2JqZWN0c1xyXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cclxuICAvLyA3LjQuMSBHZXRJdGVyYXRvciAoIG9iaiwgbWV0aG9kIClcclxuICBmdW5jdGlvbiBHZXRJdGVyYXRvcihvYmosIG1ldGhvZCkge1xyXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKVxyXG4gICAgICBtZXRob2QgPSBHZXRNZXRob2Qob2JqLCAkJGl0ZXJhdG9yKTtcclxuICAgIHZhciBpdGVyYXRvciA9IG1ldGhvZC5jYWxsKG9iaik7XHJcbiAgICBpZiAoVHlwZShpdGVyYXRvcikgIT09ICdvYmplY3QnKSB0aHJvdyBUeXBlRXJyb3IoKTtcclxuICAgIHJldHVybiBpdGVyYXRvcjtcclxuICB9XHJcblxyXG4gIC8vIDcuNC4yIEl0ZXJhdG9yTmV4dCAoIGl0ZXJhdG9yLCB2YWx1ZSApXHJcbiAgZnVuY3Rpb24gSXRlcmF0b3JOZXh0KGl0ZXJhdG9yLCB2YWx1ZSkge1xyXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKVxyXG4gICAgICB2YXIgcmVzdWx0ID0gaXRlcmF0b3IubmV4dCgpO1xyXG4gICAgZWxzZVxyXG4gICAgICByZXN1bHQgPSBpdGVyYXRvci5uZXh0KHZhbHVlKTtcclxuICAgIGlmIChUeXBlKHJlc3VsdCkgIT09ICdvYmplY3QnKSB0aHJvdyBUeXBlRXJyb3IoKTtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbiAgfVxyXG5cclxuICAvLyA3LjQuMyBJdGVyYXRvckNvbXBsZXRlICggaXRlclJlc3VsdCApXHJcbiAgZnVuY3Rpb24gSXRlcmF0b3JDb21wbGV0ZShpdGVyUmVzdWx0KSB7XHJcbiAgICBjb25zb2xlLmFzc2VydChUeXBlKGl0ZXJSZXN1bHQpID09PSAnb2JqZWN0Jyk7XHJcbiAgICByZXR1cm4gQm9vbGVhbihpdGVyUmVzdWx0LmRvbmUpO1xyXG4gIH1cclxuXHJcbiAgLy8gNy40LjQgSXRlcmF0b3JWYWx1ZSAoIGl0ZXJSZXN1bHQgKVxyXG4gIGZ1bmN0aW9uIEl0ZXJhdG9yVmFsdWUoaXRlclJlc3VsdCkge1xyXG4gICAgY29uc29sZS5hc3NlcnQoVHlwZShpdGVyUmVzdWx0KSA9PT0gJ29iamVjdCcpO1xyXG4gICAgcmV0dXJuIGl0ZXJSZXN1bHQudmFsdWU7XHJcbiAgfVxyXG5cclxuICAvLyA3LjQuNSBJdGVyYXRvclN0ZXAgKCBpdGVyYXRvciApXHJcbiAgZnVuY3Rpb24gSXRlcmF0b3JTdGVwKCBpdGVyYXRvciwgdmFsdWUgKSB7XHJcbiAgICB2YXIgcmVzdWx0ID0gSXRlcmF0b3JOZXh0KGl0ZXJhdG9yLCB2YWx1ZSk7XHJcbiAgICB2YXIgZG9uZSA9IHJlc3VsdFsnZG9uZSddO1xyXG4gICAgaWYgKEJvb2xlYW4oZG9uZSkgPT09IHRydWUpIHJldHVybiBmYWxzZTtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbiAgfVxyXG5cclxuICAvLyA3LjQuNiBJdGVyYXRvckNsb3NlKCBpdGVyYXRvciwgY29tcGxldGlvbiApXHJcbiAgZnVuY3Rpb24gSXRlcmF0b3JDbG9zZSggaXRlcmF0b3IsIGNvbXBsZXRpb24gKSB7XHJcbiAgICBjb25zb2xlLmFzc2VydChUeXBlKGl0ZXJhdG9yKSA9PT0gJ29iamVjdCcpO1xyXG4gICAgdmFyIF9yZXR1cm4gPSBHZXRNZXRob2QoaXRlcmF0b3IsICdyZXR1cm4nKTtcclxuICAgIGlmIChfcmV0dXJuID09PSB1bmRlZmluZWQpIHJldHVybiBjb21wbGV0aW9uO1xyXG4gICAgdHJ5IHtcclxuICAgICAgdmFyIGlubmVyUmVzdWx0ID0gX3JldHVybltpdGVyYXRvcl0oKTtcclxuICAgIH0gY2F0Y2ggKHJlc3VsdCkge1xyXG4gICAgICAvLyBUT0RPOiBJZiBjb21wbGV0aW9uLltbdHlwZV1dIGlzIHRocm93LCByZXR1cm4gY29tcGxldGlvblxyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gICAgaWYgKFR5cGUoaW5uZXJSZXN1bHQpICE9PSAnb2JqZWN0JykgdGhyb3cgVHlwZUVycm9yKCk7XHJcbiAgICByZXR1cm4gY29tcGxldGlvbjtcclxuICB9XHJcblxyXG4gIC8vIDcuNC43IENyZWF0ZUl0ZXJSZXN1bHRPYmplY3QgKHZhbHVlLCBkb25lKVxyXG4gIGZ1bmN0aW9uIENyZWF0ZUl0ZXJSZXN1bHRPYmplY3QodmFsdWUsIGRvbmUpIHtcclxuICAgIGNvbnNvbGUuYXNzZXJ0KFR5cGUoZG9uZSkgPT09ICdib29sZWFuJyk7XHJcbiAgICB2YXIgb2JqID0ge307XHJcbiAgICBvYmpbXCJ2YWx1ZVwiXSA9IHZhbHVlO1xyXG4gICAgb2JqW1wiZG9uZVwiXSA9IGRvbmU7XHJcbiAgICByZXR1cm4gb2JqO1xyXG4gIH1cclxuXHJcbiAgLy8gNy40LjggQ3JlYXRlTGlzdEl0ZXJhdG9yIChsaXN0KVxyXG4gIC8vIDcuNC44LjEgTGlzdEl0ZXJhdG9yIG5leHQoIClcclxuXHJcbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgLy8gOCBFeGVjdXRhYmxlIENvZGUgYW5kIEV4ZWN1dGlvbiBDb250ZXh0c1xyXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cclxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAvLyA4LjQgSm9icyBhbmQgSm9iIFF1ZXVlc1xyXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cclxuICAvLyA4LjQuMSBFbnF1ZXVlSm9iICggcXVldWVOYW1lLCBqb2IsIGFyZ3VtZW50cylcclxuICBmdW5jdGlvbiBFbnF1ZXVlSm9iKHF1ZXVlTmFtZSwgam9iLCBhcmdzKSB7XHJcbiAgICB2YXIgZm4gPSBmdW5jdGlvbigpIHsgam9iLmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7IH07XHJcbiAgICBlbnF1ZXVlKGZuKTtcclxuICB9XHJcblxyXG4gIC8vIDguNC4yIE5leHRKb2IgcmVzdWx0XHJcbiAgZnVuY3Rpb24gTmV4dEpvYihyZXN1bHQpIHtcclxuICAgIC8vIG5vLW9wXHJcbiAgfVxyXG5cclxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAvLyA5IE9yZGluYXJ5IGFuZCBFeG90aWMgT2JqZWN0cyBCZWhhdmlvcnNcclxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcbiAgLy8gOS4xLjExIFtbRW51bWVyYXRlXV0gKClcclxuICBmdW5jdGlvbiBFbnVtZXJhdGUob2JqKSB7XHJcbiAgICB2YXIgZSA9IFtdO1xyXG4gICAgaWYgKE9iamVjdChvYmopICE9PSBvYmopIHJldHVybiBlO1xyXG4gICAgdmFyIHZpc2l0ZWQgPSBuZXcgU2V0O1xyXG4gICAgd2hpbGUgKG9iaiAhPT0gbnVsbCkge1xyXG4gICAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvYmopLmZvckVhY2goZnVuY3Rpb24obmFtZSkge1xyXG4gICAgICAgIGlmICghdmlzaXRlZC5oYXMobmFtZSkpIHtcclxuICAgICAgICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIG5hbWUpO1xyXG4gICAgICAgICAgaWYgKGRlc2MpIHtcclxuICAgICAgICAgICAgdmlzaXRlZC5hZGQobmFtZSk7XHJcbiAgICAgICAgICAgIGlmIChkZXNjLmVudW1lcmFibGUpIGUucHVzaChuYW1lKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgICBvYmogPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqKTtcclxuICAgIH1cclxuICAgIHJldHVybiBlWyQkaXRlcmF0b3JdKCk7XHJcbiAgfVxyXG5cclxuICAvLyA5LjEuMTIgW1tPd25Qcm9wZXJ0eUtleXNdXSAoIClcclxuICBmdW5jdGlvbiBPd25Qcm9wZXJ0eUtleXMobykge1xyXG4gICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG8pO1xyXG4gIH1cclxuXHJcbiAgLy8gOS4xLjEzIE9iamVjdENyZWF0ZShwcm90bywgaW50ZXJuYWxTbG90c0xpc3QpXHJcbiAgZnVuY3Rpb24gT2JqZWN0Q3JlYXRlKHByb3RvLCBpbnRlcm5hbFNsb3RzTGlzdCkge1xyXG4gICAgcmV0dXJuIE9iamVjdC5jcmVhdGUocHJvdG8sIGludGVybmFsU2xvdHNMaXN0KTtcclxuICB9XHJcblxyXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gIC8vIDE5IEZ1bmRhbWVudGFsIE9iamVjdHNcclxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgLy8gMTkuMSBPYmplY3QgT2JqZWN0c1xyXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cclxuICAvLyAxOS4xLjEgVGhlIE9iamVjdCBDb25zdHJ1Y3RvclxyXG4gIC8vIDE5LjEuMS4xIE9iamVjdCAoIFsgdmFsdWUgXSApXHJcbiAgLy8gMTkuMS4yIFByb3BlcnRpZXMgb2YgdGhlIE9iamVjdCBDb25zdHJ1Y3RvclxyXG4gIC8vIDE5LjEuMi4xIE9iamVjdC5hc3NpZ24gKCB0YXJnZXQsIC4uLnNvdXJjZXMgKVxyXG4gIGRlZmluZShcclxuICAgIE9iamVjdCwgJ2Fzc2lnbicsXHJcbiAgICBmdW5jdGlvbiBhc3NpZ24odGFyZ2V0LCAvKi4uLiovc291cmNlcykge1xyXG4gICAgICB2YXIgdG8gPSBUb09iamVjdCh0YXJnZXQpO1xyXG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHJldHVybiB0bztcclxuXHJcbiAgICAgIHZhciBzb3VyY2VzSW5kZXggPSAxO1xyXG4gICAgICB3aGlsZSAoc291cmNlc0luZGV4IDwgYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgIHZhciBuZXh0U291cmNlID0gYXJndW1lbnRzW3NvdXJjZXNJbmRleCsrXTtcclxuICAgICAgICBpZiAobmV4dFNvdXJjZSA9PT0gdW5kZWZpbmVkIHx8IG5leHRTb3VyY2UgPT09IG51bGwpIHtcclxuICAgICAgICAgIHZhciBrZXlzID0gW107XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHZhciBmcm9tID0gVG9PYmplY3QobmV4dFNvdXJjZSk7XHJcbiAgICAgICAgICBrZXlzID0gT3duUHJvcGVydHlLZXlzKGZyb20pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKHZhciBrZXlzSW5kZXggPSAwOyBrZXlzSW5kZXggPCBrZXlzLmxlbmd0aDsgKytrZXlzSW5kZXgpIHtcclxuICAgICAgICAgIHZhciBuZXh0S2V5ID0ga2V5c1trZXlzSW5kZXhdO1xyXG4gICAgICAgICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGZyb20sIG5leHRLZXkpO1xyXG4gICAgICAgICAgaWYgKGRlc2MgIT09IHVuZGVmaW5lZCAmJiBkZXNjLmVudW1lcmFibGUpIHtcclxuICAgICAgICAgICAgdmFyIHByb3BWYWx1ZSA9IGZyb21bbmV4dEtleV07XHJcbiAgICAgICAgICAgIHRvW25leHRLZXldID0gcHJvcFZhbHVlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gdG87XHJcbiAgICB9KTtcclxuXHJcbiAgLy8gMTkuMS4yLjIgT2JqZWN0LmNyZWF0ZSAoIE8gWyAsIFByb3BlcnRpZXMgXSApXHJcbiAgLy8gMTkuMS4yLjMgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMgKCBPLCBQcm9wZXJ0aWVzIClcclxuICAvLyAxOS4xLjIuNCBPYmplY3QuZGVmaW5lUHJvcGVydHkgKCBPLCBQLCBBdHRyaWJ1dGVzIClcclxuICAvLyAxOS4xLjIuNSBPYmplY3QuZnJlZXplICggTyApXHJcbiAgLy8gMTkuMS4yLjYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciAoIE8sIFAgKVxyXG5cclxuICAoZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgbmF0aXZlU3ltYm9scyA9ICh0eXBlb2YgZ2xvYmFsLlN5bWJvbCgpID09PSAnc3ltYm9sJyksXHJcbiAgICAgICAgJGdldE93blByb3BlcnR5TmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyxcclxuICAgICAgICAka2V5cyA9IE9iamVjdC5rZXlzLFxyXG4gICAgICAgICR3aW5kb3dfbmFtZXMgPSAodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcgPyAkZ2V0T3duUHJvcGVydHlOYW1lcyh3aW5kb3cpIDogW10pO1xyXG5cclxuICAgIGZ1bmN0aW9uIGlzU3RyaW5nS2V5KGspIHsgcmV0dXJuICFzeW1ib2xGb3JLZXkoayk7IH1cclxuXHJcbiAgICAvLyAxOS4xLjIuNyBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyAoIE8gKVxyXG4gICAgZGVmaW5lKFxyXG4gICAgICBPYmplY3QsICdnZXRPd25Qcm9wZXJ0eU5hbWVzJyxcclxuICAgICAgZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhvKSB7XHJcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKSA9PT0gJ1tvYmplY3QgV2luZG93XScpIHtcclxuICAgICAgICAgIC8vIFdvcmthcm91bmQgZm9yIGNyb3NzLXJlYWxtIGNhbGxpbmcgYnkgSUUgaXRzZWxmLlxyXG4gICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2luZXhvcmFibGV0YXNoL3BvbHlmaWxsL2lzc3Vlcy85NlxyXG4gICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgcmV0dXJuICRnZXRPd25Qcm9wZXJ0eU5hbWVzKG8pLmZpbHRlcihpc1N0cmluZ0tleSk7XHJcbiAgICAgICAgICB9IGNhdGNoIChfKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAkd2luZG93X25hbWVzLnNsaWNlKCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAkZ2V0T3duUHJvcGVydHlOYW1lcyhvKS5maWx0ZXIoaXNTdHJpbmdLZXkpO1xyXG4gICAgICB9LCAhbmF0aXZlU3ltYm9scyk7XHJcblxyXG4gICAgLy8gMTkuMS4yLjggT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyAoIE8gKVxyXG4gICAgZGVmaW5lKFxyXG4gICAgICBPYmplY3QsICdnZXRPd25Qcm9wZXJ0eVN5bWJvbHMnLFxyXG4gICAgICBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMobykge1xyXG4gICAgICAgIHJldHVybiAkZ2V0T3duUHJvcGVydHlOYW1lcyhvKS5maWx0ZXIoc3ltYm9sRm9yS2V5KS5tYXAoc3ltYm9sRm9yS2V5KTtcclxuICAgICAgfSwgIW5hdGl2ZVN5bWJvbHMpO1xyXG5cclxuICAgIC8vIDE5LjEuMi4xNCBPYmplY3Qua2V5cyAoIE8gKVxyXG4gICAgZGVmaW5lKFxyXG4gICAgICBPYmplY3QsICdrZXlzJyxcclxuICAgICAgZnVuY3Rpb24ga2V5cyhvKSB7XHJcbiAgICAgICAgcmV0dXJuICRrZXlzKG8pLmZpbHRlcihpc1N0cmluZ0tleSk7XHJcbiAgICAgIH0sICFuYXRpdmVTeW1ib2xzKTtcclxuICB9KCkpO1xyXG5cclxuICAvLyAxOS4xLjIuOSBPYmplY3QuZ2V0UHJvdG90eXBlT2YgKCBPIClcclxuICAvLyAxOS4xLjIuMTAgT2JqZWN0LmlzICggdmFsdWUxLCB2YWx1ZTIgKVxyXG4gIGRlZmluZShcclxuICAgIE9iamVjdCwgJ2lzJyxcclxuICAgIGZ1bmN0aW9uIGlzKHZhbHVlMSwgdmFsdWUyKSB7XHJcbiAgICAgIHJldHVybiBTYW1lVmFsdWUodmFsdWUxLCB2YWx1ZTIpO1xyXG4gICAgfSk7XHJcblxyXG4gIC8vIDE5LjEuMi4xMSBPYmplY3QuaXNFeHRlbnNpYmxlICggTyApXHJcbiAgLy8gMTkuMS4yLjEyIE9iamVjdC5pc0Zyb3plbiAoIE8gKVxyXG4gIC8vIDE5LjEuMi4xMyBPYmplY3QuaXNTZWFsZWQgKCBPIClcclxuXHJcbiAgLy8gMTkuMS4yLjE0IE9iamVjdC5rZXlzICggTyApXHJcbiAgLy8gc2VlIGFib3ZlXHJcblxyXG4gIC8vIDE5LjEuMi4xNSBPYmplY3QucHJldmVudEV4dGVuc2lvbnMgKCBPIClcclxuICAvLyAxOS4xLjIuMTYgT2JqZWN0LnByb3RvdHlwZVxyXG4gIC8vIDE5LjEuMi4xNyBPYmplY3Quc2VhbCAoIE8gKVxyXG5cclxuICAvLyAxOS4xLjIuMTggT2JqZWN0LnNldFByb3RvdHlwZU9mICggTywgcHJvdG8gKVxyXG4gIGRlZmluZShcclxuICAgIE9iamVjdCwgJ3NldFByb3RvdHlwZU9mJyxcclxuICAgIGZ1bmN0aW9uIHNldFByb3RvdHlwZU9mKG8sIHByb3RvKSB7XHJcbiAgICAgIGlmIChUeXBlKG8pICE9PSAnb2JqZWN0JykgdGhyb3cgVHlwZUVycm9yKCk7XHJcbiAgICAgIGlmIChUeXBlKHByb3RvKSAhPT0gJ29iamVjdCcgJiYgVHlwZShwcm90bykgIT09ICdudWxsJykgdGhyb3cgVHlwZUVycm9yKCk7XHJcbiAgICAgIG8uX19wcm90b19fID0gcHJvdG87XHJcbiAgICAgIHJldHVybiBvO1xyXG4gICAgfVxyXG4gICk7XHJcblxyXG4gIC8vIDE5LjEuMyBQcm9wZXJ0aWVzIG9mIHRoZSBPYmplY3QgUHJvdG90eXBlIE9iamVjdFxyXG4gIC8vIDE5LjEuMy4xIE9iamVjdC5wcm90b3R5cGUuY29uc3RydWN0b3JcclxuICAvLyAxOS4xLjMuMiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5ICggViApXHJcbiAgLy8gMTkuMS4zLjMgT2JqZWN0LnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mICggViApXHJcbiAgLy8gMTkuMS4zLjQgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZSAoIFYgKVxyXG4gIC8vIDE5LjEuMy41IE9iamVjdC5wcm90b3R5cGUudG9Mb2NhbGVTdHJpbmcgKCBbIHJlc2VydmVkMSBbICwgcmVzZXJ2ZWQyIF0gXSApXHJcbiAgLy8gMTkuMS4zLjYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZyAoIClcclxuICB2YXIgb19wX3RzID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcclxuICBkZWZpbmUoT2JqZWN0LnByb3RvdHlwZSwgJ3RvU3RyaW5nJyxcclxuICAgICAgIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICB2YXIgbyA9IHN0cmljdCh0aGlzKTtcclxuICAgICAgICAgaWYgKG8gPT09IE9iamVjdChvKSAmJiAkJHRvU3RyaW5nVGFnIGluIG8pIHtcclxuICAgICAgICAgICByZXR1cm4gJ1tvYmplY3QgJyArIG9bJCR0b1N0cmluZ1RhZ10gKyAnXSc7XHJcbiAgICAgICAgIH1cclxuICAgICAgICAgcmV0dXJuIG9fcF90cy5hcHBseShvLCBhcmd1bWVudHMpO1xyXG4gICAgICAgfSk7XHJcblxyXG4gIC8vIDE5LjEuMy43IE9iamVjdC5wcm90b3R5cGUudmFsdWVPZiAoIClcclxuICAvLyAxOS4xLjQgUHJvcGVydGllcyBvZiBPYmplY3QgSW5zdGFuY2VzXHJcblxyXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gIC8vIDE5LjIgRnVuY3Rpb24gT2JqZWN0c1xyXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cclxuICAvLyAxOS4yLjEgVGhlIEZ1bmN0aW9uIENvbnN0cnVjdG9yXHJcbiAgLy8gMTkuMi4xLjEgRnVuY3Rpb24gKCBwMSwgcDIsIOKApiAsIHBuLCBib2R5IClcclxuICAvLyAxOS4yLjIgUHJvcGVydGllcyBvZiB0aGUgRnVuY3Rpb24gQ29uc3RydWN0b3JcclxuICAvLyAxOS4yLjIuMSBGdW5jdGlvbi5sZW5ndGhcclxuICAvLyAxOS4yLjIuMiBGdW5jdGlvbi5wcm90b3R5cGVcclxuICAvLyAxOS4yLjMgUHJvcGVydGllcyBvZiB0aGUgRnVuY3Rpb24gUHJvdG90eXBlIE9iamVjdFxyXG4gIC8vIDE5LjIuMy4xIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseSAoIHRoaXNBcmcsIGFyZ0FycmF5IClcclxuICAvLyAxOS4yLjMuMiBGdW5jdGlvbi5wcm90b3R5cGUuYmluZCAoIHRoaXNBcmcgLCAuLi5hcmdzKVxyXG4gIC8vIDE5LjIuMy4zIEZ1bmN0aW9uLnByb3RvdHlwZS5jYWxsICh0aGlzQXJnICwgLi4uYXJncylcclxuICAvLyAxOS4yLjMuNCBGdW5jdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3JcclxuICAvLyAxOS4yLjMuNSBGdW5jdGlvbi5wcm90b3R5cGUudG9TdHJpbmcgKCApXHJcbiAgLy8gMTkuMi4zLjYgRnVuY3Rpb24ucHJvdG90eXBlW0BAaGFzSW5zdGFuY2VdICggViApXHJcbiAgLy8gMTkuMi40IEZ1bmN0aW9uIEluc3RhbmNlc1xyXG4gIC8vIDE5LjIuNC4xIGxlbmd0aFxyXG4gIC8vIDE5LjIuNC4yIG5hbWVcclxuICAvLyAxOS4yLjQuMyBwcm90b3R5cGVcclxuXHJcbiAgLy8gKE5vIHBvbHlmaWxsYWJsZSBjaGFuZ2VzIGZyb20gRVM1KVxyXG5cclxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAvLyAxOS4zIEJvb2xlYW4gT2JqZWN0c1xyXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cclxuICAvLyAxOS4zLjEgVGhlIEJvb2xlYW4gQ29uc3RydWN0b3JcclxuICAvLyAxOS4zLjEuMSBCb29sZWFuICggdmFsdWUgKVxyXG4gIC8vIDE5LjMuMiBQcm9wZXJ0aWVzIG9mIHRoZSBCb29sZWFuIENvbnN0cnVjdG9yXHJcbiAgLy8gMTkuMy4yLjEgQm9vbGVhbi5wcm90b3R5cGVcclxuICAvLyAxOS4zLjMgUHJvcGVydGllcyBvZiB0aGUgQm9vbGVhbiBQcm90b3R5cGUgT2JqZWN0XHJcbiAgLy8gMTkuMy4zLjEgQm9vbGVhbi5wcm90b3R5cGUuY29uc3RydWN0b3JcclxuICAvLyAxOS4zLjMuMiBCb29sZWFuLnByb3RvdHlwZS50b1N0cmluZyAoIClcclxuICAvLyAxOS4zLjMuMyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mICggKVxyXG4gIC8vIDE5LjMuNCBQcm9wZXJ0aWVzIG9mIEJvb2xlYW4gSW5zdGFuY2VzXHJcblxyXG4gIC8vIChObyBwb2x5ZmlsbGFibGUgY2hhbmdlcyBmcm9tIEVTNSlcclxuXHJcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgLy8gMTkuNCBTeW1ib2wgT2JqZWN0c1xyXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cclxuICAvLyBNb3ZlZCBlYXJsaWVyIGluIHRoaXMgc2NyaXB0LCBzbyB0aGF0IG90aGVyIHBvbHlmaWxscyBjYW4gZGVwZW5kIG9uIHRoZW0uXHJcblxyXG4gIC8vIDE5LjQuMy40IFN5bWJvbC5wcm90b3R5cGUgWyBAQHRvU3RyaW5nVGFnIF1cclxuICBkZWZpbmUoZ2xvYmFsLlN5bWJvbC5wcm90b3R5cGUsIGdsb2JhbC5TeW1ib2wudG9TdHJpbmdUYWcsICdTeW1ib2wnKTtcclxuXHJcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgLy8gMTkuNSBFcnJvciBPYmplY3RzXHJcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG4gIC8vIDE5LjUuMSBUaGUgRXJyb3IgQ29uc3RydWN0b3JcclxuICAvLyAxOS41LjEuMSBFcnJvciAoIG1lc3NhZ2UgKVxyXG4gIC8vIDE5LjUuMS4yIG5ldyBFcnJvciggLi4uYXJndW1lbnRzTGlzdCApXHJcbiAgLy8gMTkuNS4yIFByb3BlcnRpZXMgb2YgdGhlIEVycm9yIENvbnN0cnVjdG9yXHJcbiAgLy8gMTkuNS4yLjEgRXJyb3IucHJvdG90eXBlXHJcbiAgLy8gMTkuNS4zIFByb3BlcnRpZXMgb2YgdGhlIEVycm9yIFByb3RvdHlwZSBPYmplY3RcclxuICAvLyAxOS41LjMuMSBFcnJvci5wcm90b3R5cGUuY29uc3RydWN0b3JcclxuICAvLyAxOS41LjMuMiBFcnJvci5wcm90b3R5cGUubWVzc2FnZVxyXG4gIC8vIDE5LjUuMy4zIEVycm9yLnByb3RvdHlwZS5uYW1lXHJcbiAgLy8gMTkuNS4zLjQgRXJyb3IucHJvdG90eXBlLnRvU3RyaW5nICggKVxyXG4gIC8vIDE5LjUuNCBQcm9wZXJ0aWVzIG9mIEVycm9yIEluc3RhbmNlc1xyXG4gIC8vIDE5LjUuNSBOYXRpdmUgRXJyb3IgVHlwZXMgVXNlZCBpbiBUaGlzIFN0YW5kYXJkXHJcbiAgLy8gMTkuNS41LjEgRXZhbEVycm9yXHJcbiAgLy8gMTkuNS41LjIgUmFuZ2VFcnJvclxyXG4gIC8vIDE5LjUuNS4zIFJlZmVyZW5jZUVycm9yXHJcbiAgLy8gMTkuNS41LjQgU3ludGF4RXJyb3JcclxuICAvLyAxOS41LjUuNSBUeXBlRXJyb3JcclxuICAvLyAxOS41LjUuNiBVUklFcnJvclxyXG4gIC8vIDE5LjUuNiBOYXRpdmVFcnJvciBPYmplY3QgU3RydWN0dXJlXHJcbiAgLy8gMTkuNS42LjEgTmF0aXZlRXJyb3IgQ29uc3RydWN0b3JzXHJcbiAgLy8gMTkuNS42LjEuMSBOYXRpdmVFcnJvciAoIG1lc3NhZ2UgKVxyXG4gIC8vIDE5LjUuNi4xLjIgbmV3IE5hdGl2ZUVycm9yICggLi4uYXJndW1lbnRzTGlzdCApXHJcbiAgLy8gMTkuNS42LjIgUHJvcGVydGllcyBvZiB0aGUgTmF0aXZlRXJyb3IgQ29uc3RydWN0b3JzXHJcbiAgLy8gMTkuNS42LjIuMSBOYXRpdmVFcnJvci5wcm90b3R5cGVcclxuICAvLyAxOS41LjYuMyBQcm9wZXJ0aWVzIG9mIHRoZSBOYXRpdmVFcnJvciBQcm90b3R5cGUgT2JqZWN0c1xyXG4gIC8vIDE5LjUuNi40IFByb3BlcnRpZXMgb2YgTmF0aXZlRXJyb3IgSW5zdGFuY2VzXHJcblxyXG4gIC8vIChObyBwb2x5ZmlsbGFibGUgY2hhbmdlcyBmcm9tIEVTNSlcclxuXHJcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgLy8gMjAgTnVtYmVycyBhbmQgRGF0ZXNcclxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgLy8gMjAuMSBOdW1iZXIgT2JqZWN0c1xyXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cclxuICAvLyAyMC4xLjEgVGhlIE51bWJlciBDb25zdHJ1Y3RvclxyXG4gIC8vIDIwLjEuMS4xIE51bWJlciAoIFsgdmFsdWUgXSApXHJcbiAgLy8gMjAuMS4xLjIgbmV3IE51bWJlciAoIC4uLmFyZ3VtZW50c0xpc3QgKVxyXG4gIC8vIDIwLjEuMiBQcm9wZXJ0aWVzIG9mIHRoZSBOdW1iZXIgQ29uc3RydWN0b3JcclxuXHJcbiAgLy8gMjAuMS4yLjEgTnVtYmVyLkVQU0lMT05cclxuICBkZWZpbmUoXHJcbiAgICBOdW1iZXIsICdFUFNJTE9OJyxcclxuICAgIChmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhciBuZXh0LCByZXN1bHQ7XHJcbiAgICAgIGZvciAobmV4dCA9IDE7IDEgKyBuZXh0ICE9PSAxOyBuZXh0ID0gbmV4dCAvIDIpXHJcbiAgICAgICAgcmVzdWx0ID0gbmV4dDtcclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH0oKSkpO1xyXG5cclxuICAvLyAyMC4xLjIuMiBOdW1iZXIuaXNGaW5pdGUgKCBudW1iZXIgKVxyXG4gIGRlZmluZShcclxuICAgIE51bWJlciwgJ2lzRmluaXRlJyxcclxuICAgIGZ1bmN0aW9uIGlzRmluaXRlKG51bWJlcikge1xyXG4gICAgICBpZiAoVHlwZShudW1iZXIpICE9PSAnbnVtYmVyJykgcmV0dXJuIGZhbHNlO1xyXG4gICAgICBpZiAobnVtYmVyICE9PSBudW1iZXIgfHwgbnVtYmVyID09PSArSW5maW5pdHkgfHwgbnVtYmVyID09PSAtSW5maW5pdHkpIHJldHVybiBmYWxzZTtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9KTtcclxuXHJcbiAgLy8gMjAuMS4yLjMgTnVtYmVyLmlzSW50ZWdlciAoIG51bWJlciApXHJcbiAgZGVmaW5lKFxyXG4gICAgTnVtYmVyLCAnaXNJbnRlZ2VyJyxcclxuICAgIGZ1bmN0aW9uIGlzSW50ZWdlcihudW1iZXIpIHtcclxuICAgICAgaWYgKFR5cGUobnVtYmVyKSAhPT0gJ251bWJlcicpIHJldHVybiBmYWxzZTtcclxuICAgICAgaWYgKG51bWJlciAhPT0gbnVtYmVyIHx8IG51bWJlciA9PT0gK0luZmluaXR5IHx8IG51bWJlciA9PT0gLUluZmluaXR5KSByZXR1cm4gZmFsc2U7XHJcbiAgICAgIHZhciBpbnRlZ2VyID0gVG9JbnRlZ2VyKG51bWJlcik7XHJcbiAgICAgIGlmIChpbnRlZ2VyICE9PSBudW1iZXIpIHJldHVybiBmYWxzZTtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9KTtcclxuXHJcbiAgLy8gMjAuMS4yLjQgTnVtYmVyLmlzTmFOICggbnVtYmVyIClcclxuICBkZWZpbmUoXHJcbiAgICBOdW1iZXIsICdpc05hTicsXHJcbiAgICBmdW5jdGlvbiBpc05hTihudW1iZXIpIHtcclxuICAgICAgaWYgKFR5cGUobnVtYmVyKSAhPT0gJ251bWJlcicpIHJldHVybiBmYWxzZTtcclxuICAgICAgaWYgKG51bWJlciAhPT0gbnVtYmVyKSByZXR1cm4gdHJ1ZTtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfSk7XHJcblxyXG4gIC8vIDIwLjEuMi41IE51bWJlci5pc1NhZmVJbnRlZ2VyICggbnVtYmVyIClcclxuICBkZWZpbmUoXHJcbiAgICBOdW1iZXIsICdpc1NhZmVJbnRlZ2VyJyxcclxuICAgIGZ1bmN0aW9uIGlzU2FmZUludGVnZXIobnVtYmVyKSB7XHJcbiAgICAgIGlmIChUeXBlKG51bWJlcikgIT09ICdudW1iZXInKSByZXR1cm4gZmFsc2U7XHJcbiAgICAgIGlmIChudW1iZXIgIT09IG51bWJlciB8fCBudW1iZXIgPT09ICtJbmZpbml0eSB8fCBudW1iZXIgPT09IC1JbmZpbml0eSkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB2YXIgaW50ZWdlciA9IFRvSW50ZWdlcihudW1iZXIpO1xyXG4gICAgICBpZiAoaW50ZWdlciAhPT0gbnVtYmVyKSByZXR1cm4gZmFsc2U7XHJcbiAgICAgIGlmIChhYnMoaW50ZWdlcikgPD0gKDB4MjAwMDAwMDAwMDAwMDAgLSAxKSkgLy8gMl41My0xXHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH0pO1xyXG5cclxuICAvLyAyMC4xLjIuNiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUlxyXG4gIGRlZmluZShcclxuICAgIE51bWJlciwgJ01BWF9TQUZFX0lOVEVHRVInLFxyXG4gICAgOTAwNzE5OTI1NDc0MDk5MSk7IC8vIDJeNTMtMVxyXG5cclxuICAvLyAyMC4xLjIuNyBOdW1iZXIuTUFYX1ZBTFVFXHJcblxyXG4gIC8vIDIwLjEuMi44IE51bWJlci5NSU5fU0FGRV9JTlRFR0VSXHJcbiAgZGVmaW5lKFxyXG4gICAgTnVtYmVyLCAnTUlOX1NBRkVfSU5URUdFUicsXHJcbiAgICAtOTAwNzE5OTI1NDc0MDk5MSk7IC8vIC0yXjUzKzFcclxuXHJcbiAgLy8gMjAuMS4yLjkgTnVtYmVyLk1JTl9WQUxVRVxyXG4gIC8vIDIwLjEuMi4xMCBOdW1iZXIuTmFOXHJcbiAgLy8gMjAuMS4yLjExIE51bWJlci5ORUdBVElWRV9JTkZJTklUWVxyXG5cclxuICAvLyAyMC4xLjIuMTIgTnVtYmVyLnBhcnNlRmxvYXQgKCBzdHJpbmcgKVxyXG4gIGRlZmluZShOdW1iZXIsICdwYXJzZUZsb2F0JywgJHBhcnNlRmxvYXQpO1xyXG5cclxuICAvLyAyMC4xLjIuMTMgTnVtYmVyLnBhcnNlSW50ICggc3RyaW5nLCByYWRpeCApXHJcbiAgZGVmaW5lKE51bWJlciwgJ3BhcnNlSW50JywgJHBhcnNlSW50KTtcclxuXHJcbiAgLy8gMjAuMS4yLjE0IE51bWJlci5QT1NJVElWRV9JTkZJTklUWVxyXG4gIC8vIDIwLjEuMi4xNSBOdW1iZXIucHJvdG90eXBlXHJcblxyXG4gIC8vIDIwLjEuMyBQcm9wZXJ0aWVzIG9mIHRoZSBOdW1iZXIgUHJvdG90eXBlIE9iamVjdFxyXG4gIC8vIDIwLjEuMy4xIE51bWJlci5wcm90b3R5cGUuY29uc3RydWN0b3JcclxuICAvLyAyMC4xLjMuMiBOdW1iZXIucHJvdG90eXBlLnRvRXhwb25lbnRpYWwgKCBmcmFjdGlvbkRpZ2l0cyApXHJcbiAgLy8gMjAuMS4zLjMgTnVtYmVyLnByb3RvdHlwZS50b0ZpeGVkICggZnJhY3Rpb25EaWdpdHMgKVxyXG4gIC8vIDIwLjEuMy40IE51bWJlci5wcm90b3R5cGUudG9Mb2NhbGVTdHJpbmcoIFsgcmVzZXJ2ZWQxIFsgLCByZXNlcnZlZDIgXSBdKVxyXG4gIC8vIDIwLjEuMy41IE51bWJlci5wcm90b3R5cGUudG9QcmVjaXNpb24gKCBwcmVjaXNpb24gKVxyXG4gIC8vIDIwLjEuMy42IE51bWJlci5wcm90b3R5cGUudG9TdHJpbmcgKCBbIHJhZGl4IF0gKVxyXG4gIC8vIDIwLjEuMy43IE51bWJlci5wcm90b3R5cGUudmFsdWVPZiAoIClcclxuICAvLyAyMC4xLjQgUHJvcGVydGllcyBvZiBOdW1iZXIgSW5zdGFuY2VzXHJcblxyXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gIC8vIDIwLjIgVGhlIE1hdGggT2JqZWN0XHJcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG4gIC8vIDIwLjIuMSBWYWx1ZSBQcm9wZXJ0aWVzIG9mIHRoZSBNYXRoIE9iamVjdFxyXG4gIC8vIDIwLjIuMS4xIE1hdGguRVxyXG4gIC8vIDIwLjIuMS4yIE1hdGguTE4xMFxyXG4gIC8vIDIwLjIuMS4zIE1hdGguTE4yXHJcbiAgLy8gMjAuMi4xLjQgTWF0aC5MT0cxMEVcclxuICAvLyAyMC4yLjEuNSBNYXRoLkxPRzJFXHJcbiAgLy8gMjAuMi4xLjYgTWF0aC5QSVxyXG4gIC8vIDIwLjIuMS43IE1hdGguU1FSVDFfMlxyXG4gIC8vIDIwLjIuMS44IE1hdGguU1FSVDJcclxuXHJcbiAgLy8gMjAuMi4xLjkgTWF0aCBbIEBAdG9TdHJpbmdUYWcgXVxyXG4gIGRlZmluZShNYXRoLCAkJHRvU3RyaW5nVGFnLCAnTWF0aCcpO1xyXG5cclxuICAvLyAyMC4yLjIgRnVuY3Rpb24gUHJvcGVydGllcyBvZiB0aGUgTWF0aCBPYmplY3RcclxuICAvLyAyMC4yLjIuMSBNYXRoLmFicyAoIHggKVxyXG4gIC8vIDIwLjIuMi4yIE1hdGguYWNvcyAoIHggKVxyXG5cclxuICAvLyAyMC4yLjIuMyBNYXRoLmFjb3NoKHgpXHJcbiAgZGVmaW5lKFxyXG4gICAgTWF0aCwgJ2Fjb3NoJyxcclxuICAgIGZ1bmN0aW9uIGFjb3NoKHgpIHtcclxuICAgICAgeCA9IE51bWJlcih4KTtcclxuICAgICAgcmV0dXJuIGxvZyh4ICsgc3FydCh4ICogeCAtIDEpKTtcclxuICAgIH0pO1xyXG5cclxuICAvLyAyMC4yLjIuNCBNYXRoLmFzaW4gKCB4IClcclxuXHJcbiAgLy8gMjAuMi4yLjUgTWF0aC5hc2luaCggeCApXHJcbiAgZGVmaW5lKFxyXG4gICAgTWF0aCwgJ2FzaW5oJyxcclxuICAgIGZ1bmN0aW9uIGFzaW5oKHgpIHtcclxuICAgICAgeCA9IE51bWJlcih4KTtcclxuICAgICAgaWYgKFNhbWVWYWx1ZSh4LCAtMCkpIHtcclxuICAgICAgICByZXR1cm4geDtcclxuICAgICAgfVxyXG4gICAgICB2YXIgcyA9IHNxcnQoeCAqIHggKyAxKTtcclxuICAgICAgcmV0dXJuIChzID09PSAteCkgPyBsb2coMCkgOiBsb2coeCArIHMpO1xyXG4gICAgfSk7XHJcblxyXG4gIC8vIDIwLjIuMi42IE1hdGguYXRhbiAoIHggKVxyXG5cclxuICAvLyAyMC4yLjIuNyBNYXRoLmF0YW5oKCB4IClcclxuICBkZWZpbmUoXHJcbiAgICBNYXRoLCAnYXRhbmgnLFxyXG4gICAgZnVuY3Rpb24gYXRhbmgoeCkge1xyXG4gICAgICB4ID0gTnVtYmVyKHgpO1xyXG4gICAgICByZXR1cm4gKHggPT09IDApID8geCA6IGxvZygoMSArIHgpIC8gKDEgLSB4KSkgLyAyO1xyXG4gICAgfSk7XHJcblxyXG4gIC8vIDIwLjIuMi44IE1hdGguYXRhbjIgKCB5LCB4IClcclxuXHJcbiAgLy8gMjAuMi4yLjkgTWF0aC5jYnJ0ICggeCApXHJcbiAgZGVmaW5lKFxyXG4gICAgTWF0aCwgJ2NicnQnLFxyXG4gICAgZnVuY3Rpb24gY2JydCh4KSB7XHJcbiAgICAgIHggPSBOdW1iZXIoeCk7XHJcbiAgICAgIGlmICgkaXNOYU4oeC94KSkge1xyXG4gICAgICAgIHJldHVybiB4O1xyXG4gICAgICB9XHJcbiAgICAgIHZhciByID0gcG93KGFicyh4KSwgMS8zKTtcclxuICAgICAgdmFyIHQgPSB4L3IvcjtcclxuICAgICAgcmV0dXJuIHIgKyAociAqICh0LXIpIC8gKDIqciArIHQpKTtcclxuICAgIH0pO1xyXG5cclxuICAvLyAyMC4yLjIuMTAgTWF0aC5jZWlsICggeCApXHJcblxyXG4gIC8vIDIwLjIuMi4xMSBNYXRoLmNsejMyICggeCApXHJcbiAgZGVmaW5lKFxyXG4gICAgTWF0aCwgJ2NsejMyJyxcclxuICAgIGZ1bmN0aW9uIGNsejMyKHgpIHtcclxuICAgICAgZnVuY3Rpb24gY2x6OCh4KSB7XHJcbiAgICAgICAgcmV0dXJuICh4ICYgMHhmMCkgPyAoeCAmIDB4ODAgPyAwIDogeCAmIDB4NDAgPyAxIDogeCAmIDB4MjAgPyAyIDogMykgOlxyXG4gICAgICAgICh4ICYgMHgwOCA/IDQgOiB4ICYgMHgwNCA/IDUgOiB4ICYgMHgwMiA/IDYgOiB4ICYgMHgwMSA/IDcgOiA4KTtcclxuICAgICAgfVxyXG4gICAgICB4ID0gVG9VaW50MzIoeCk7XHJcbiAgICAgIHJldHVybiB4ICYgMHhmZjAwMDAwMCA/IGNsejgoeCA+PiAyNCkgOlxyXG4gICAgICAgIHggJiAweGZmMDAwMCA/IGNsejgoeCA+PiAxNikgKyA4IDpcclxuICAgICAgICB4ICYgMHhmZjAwID8gY2x6OCh4ID4+IDgpICsgMTYgOiBjbHo4KHgpICsgMjQ7XHJcbiAgICB9KTtcclxuXHJcblxyXG5cclxuICAvLyAyMC4yLjIuMTIgTWF0aC5jb3MgKCB4IClcclxuXHJcbiAgLy8gMjAuMi4yLjEzIE1hdGguY29zaCAoIHggKVxyXG4gIGRlZmluZShcclxuICAgIE1hdGgsICdjb3NoJyxcclxuICAgIGZ1bmN0aW9uIGNvc2goeCkge1xyXG4gICAgICB4ID0gTnVtYmVyKHgpO1xyXG4gICAgICByZXR1cm4gKHBvdyhFLCB4KSArIHBvdyhFLCAteCkpIC8gMjtcclxuICAgIH0pO1xyXG5cclxuICAvLyAyMC4yLjIuMTQgTWF0aC5leHAgKCB4IClcclxuXHJcbiAgLy8gMjAuMi4yLjE1IE1hdGguZXhwbTEgKCB4IClcclxuICBkZWZpbmUoXHJcbiAgICBNYXRoLCAnZXhwbTEnLFxyXG4gICAgZnVuY3Rpb24gZXhwbTEoeCkge1xyXG4gICAgICB4ID0gTnVtYmVyKHgpO1xyXG4gICAgICAvLyBmcm9tOiBodHRwOi8vd3d3LmpvaG5kY29vay5jb20vY3BwX2xvZzFwLmh0bWxcclxuICAgICAgaWYgKFNhbWVWYWx1ZSh4LCAtMCkpIHtcclxuICAgICAgICByZXR1cm4gLTA7XHJcbiAgICAgIH0gZWxzZSBpZiAoYWJzKHgpIDwgMWUtNSkge1xyXG4gICAgICAgIHJldHVybiB4ICsgMC41ICogeCAqIHg7IC8vIHR3byB0ZXJtcyBvZiBUYXlsb3IgZXhwYW5zaW9uXHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIGV4cCh4KSAtIDE7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAvLyAyMC4yLjIuMTYgTWF0aC5mbG9vciAoIHggKVxyXG5cclxuICAvLyAyMC4yLjIuMTcgTWF0aC5mcm91bmQgKCB4IClcclxuICBkZWZpbmUoXHJcbiAgICBNYXRoLCAnZnJvdW5kJyxcclxuICAgIGZ1bmN0aW9uIGZyb3VuZCh4KSB7XHJcbiAgICAgIGlmICgkaXNOYU4oeCkpIHtcclxuICAgICAgICByZXR1cm4gTmFOO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICgxL3ggPT09ICtJbmZpbml0eSB8fCAxL3ggPT09IC1JbmZpbml0eSB8fCB4ID09PSArSW5maW5pdHkgfHwgeCA9PT0gLUluZmluaXR5KSB7XHJcbiAgICAgICAgcmV0dXJuIHg7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIChuZXcgRmxvYXQzMkFycmF5KFt4XSkpWzBdO1xyXG4gICAgfSk7XHJcblxyXG4gIC8vIDIwLjIuMi4xOCBNYXRoLmh5cG90ICggdmFsdWUxIFssIHZhbHVlMiBbIC4uLiBdIF0gKVxyXG4gIGRlZmluZShcclxuICAgIE1hdGgsICdoeXBvdCcsXHJcbiAgICBmdW5jdGlvbiBoeXBvdCgpIHtcclxuICAgICAgdmFyIHZhbHVlcyA9IFtdO1xyXG4gICAgICB2YXIgbSA9IDAsIHNhd05hTiA9IGZhbHNlO1xyXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgIHZhciBuID0gYWJzKE51bWJlcihhcmd1bWVudHNbaV0pKTtcclxuICAgICAgICBpZiAobiA9PT0gSW5maW5pdHkpIHJldHVybiBuO1xyXG4gICAgICAgIGlmIChuICE9PSBuKSBzYXdOYU4gPSB0cnVlO1xyXG4gICAgICAgIGlmIChuID4gbSkgbSA9IG47XHJcbiAgICAgICAgdmFsdWVzW2ldID0gbjtcclxuICAgICAgfVxyXG4gICAgICBpZiAoc2F3TmFOKSByZXR1cm4gTmFOO1xyXG4gICAgICBpZiAobSA9PT0gMCkgcmV0dXJuICswO1xyXG4gICAgICB2YXIgc3VtID0gKzA7XHJcbiAgICAgIGZvciAoaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICB2YXIgciA9IHZhbHVlc1tpXSAvIG07XHJcbiAgICAgICAgc3VtID0gc3VtICsgciAqIHI7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIG0gKiBzcXJ0KHN1bSk7XHJcbiAgICB9KTtcclxuXHJcbiAgLy8gMjAuMi4yLjE5IE1hdGguaW11bCAoIHgsIHkgKVxyXG4gIGRlZmluZShcclxuICAgIE1hdGgsICdpbXVsJyxcclxuICAgIGZ1bmN0aW9uIGltdWwoeCwgeSkge1xyXG4gICAgICB2YXIgYSA9IFRvVWludDMyKHgpO1xyXG4gICAgICB2YXIgYiA9IFRvVWludDMyKHkpO1xyXG4gICAgICAvLyAoc2xvdyBidXQgYWNjdXJhdGUpXHJcbiAgICAgIHZhciBhaCAgPSAoYSA+Pj4gMTYpICYgMHhmZmZmO1xyXG4gICAgICB2YXIgYWwgPSBhICYgMHhmZmZmO1xyXG4gICAgICB2YXIgYmggID0gKGIgPj4+IDE2KSAmIDB4ZmZmZjtcclxuICAgICAgdmFyIGJsID0gYiAmIDB4ZmZmZjtcclxuICAgICAgcmV0dXJuICgoYWwgKiBibCkgKyAoKChhaCAqIGJsICsgYWwgKiBiaCkgPDwgMTYpID4+PiAwKXwwKTtcclxuICAgIH0sICgnaW11bCcgaW4gTWF0aCAmJiBNYXRoLmltdWwoMSwgMHg4MDAwMDAwMCkgPT09IDApIC8vIFNhZmFyaSA3IGJ1Z1xyXG4gICk7XHJcblxyXG4gIC8vIDIwLjIuMi4yMCBNYXRoLmxvZyAoIHggKVxyXG5cclxuICAvLyAyMC4yLjIuMjEgTWF0aC5sb2cxcCAoIHggKVxyXG4gIGRlZmluZShcclxuICAgIE1hdGgsICdsb2cxcCcsXHJcbiAgICBmdW5jdGlvbiBsb2cxcCh4KSB7XHJcbiAgICAgIHggPSBOdW1iZXIoeCk7XHJcbiAgICAgIC8vIGZyb206IGh0dHA6Ly93d3cuam9obmRjb29rLmNvbS9jcHBfZXhwbTEuaHRtbFxyXG4gICAgICBpZiAoeCA8IC0xKSB7XHJcbiAgICAgICAgcmV0dXJuIE5hTjtcclxuICAgICAgfSBlbHNlIGlmIChTYW1lVmFsdWUoeCwgLTApKSB7XHJcbiAgICAgICAgcmV0dXJuIC0wO1xyXG4gICAgICB9IGVsc2UgaWYgKGFicyh4KSA+IDFlLTQpIHtcclxuICAgICAgICByZXR1cm4gbG9nKDEgKyB4KTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gKC0wLjUgKiB4ICsgMSkgKiB4O1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgLy8gMjAuMi4yLjIyIE1hdGgubG9nMTAgKCB4IClcclxuICBkZWZpbmUoXHJcbiAgICBNYXRoLCAnbG9nMTAnLFxyXG4gICAgZnVuY3Rpb24gbG9nMTAoeCkge1xyXG4gICAgICB4ID0gTnVtYmVyKHgpO1xyXG4gICAgICByZXR1cm4gbG9nKHgpICogTE9HMTBFO1xyXG4gICAgfSk7XHJcblxyXG4gIC8vIDIwLjIuMi4yMyBNYXRoLmxvZzIgKCB4IClcclxuICBkZWZpbmUoXHJcbiAgICBNYXRoLCAnbG9nMicsXHJcbiAgICBmdW5jdGlvbiBsb2cyKHgpIHtcclxuICAgICAgeCA9IE51bWJlcih4KTtcclxuICAgICAgcmV0dXJuIGxvZyh4KSAqIExPRzJFO1xyXG4gICAgfSk7XHJcblxyXG4gIC8vIDIwLjIuMi4yNCBNYXRoLm1heCAoIHZhbHVlMSwgdmFsdWUyICwgLi4udmFsdWVzIClcclxuICAvLyAyMC4yLjIuMjUgTWF0aC5taW4gKCB2YWx1ZTEsIHZhbHVlMiAsIC4uLnZhbHVlcyApXHJcbiAgLy8gMjAuMi4yLjI2IE1hdGgucG93ICggeCwgeSApXHJcbiAgLy8gMjAuMi4yLjI3IE1hdGgucmFuZG9tICggKVxyXG4gIC8vIDIwLjIuMi4yOCBNYXRoLnJvdW5kICggeCApXHJcblxyXG4gIC8vIDIwLjIuMi4yOSBNYXRoLnNpZ24oeClcclxuICBkZWZpbmUoXHJcbiAgICBNYXRoLCAnc2lnbicsXHJcbiAgICBmdW5jdGlvbiBzaWduKHgpIHtcclxuICAgICAgeCA9IE51bWJlcih4KTtcclxuICAgICAgcmV0dXJuIHggPCAwID8gLTEgOiB4ID4gMCA/IDEgOiB4O1xyXG4gICAgfSk7XHJcblxyXG4gIC8vIDIwLjIuMi4zMCBNYXRoLnNpbiAoIHggKVxyXG5cclxuICAvLyAyMC4yLjIuMzEgTWF0aC5zaW5oKCB4IClcclxuICBkZWZpbmUoXHJcbiAgICBNYXRoLCAnc2luaCcsXHJcbiAgICBmdW5jdGlvbiBzaW5oKHgpIHtcclxuICAgICAgeCA9IE51bWJlcih4KTtcclxuICAgICAgcmV0dXJuIFNhbWVWYWx1ZSh4LCAtMCkgPyB4IDogKHBvdyhFLCB4KSAtIHBvdyhFLCAteCkpIC8gMjtcclxuICAgIH0pO1xyXG5cclxuICAvLyAyMC4yLjIuMzIgTWF0aC5zcXJ0ICggeCApXHJcbiAgLy8gMjAuMi4yLjMzIE1hdGgudGFuICggeCApXHJcblxyXG4gIC8vIDIwLjIuMi4zNCBNYXRoLnRhbmggKCB4IClcclxuICBkZWZpbmUoXHJcbiAgICBNYXRoLCAndGFuaCcsXHJcbiAgICBmdW5jdGlvbiB0YW5oKHgpIHtcclxuICAgICAgeCA9IE51bWJlcih4KTtcclxuICAgICAgdmFyIG4gPSBwb3coRSwgMiAqIHgpIC0gMSxcclxuICAgICAgICAgIGQgPSBwb3coRSwgMiAqIHgpICsgMTtcclxuICAgICAgaWYgKFNhbWVWYWx1ZSh4LCAtMCkpXHJcbiAgICAgICAgcmV0dXJuIHg7XHJcbiAgICAgIHJldHVybiAobiA9PT0gZCkgPyAxIDogbiAvIGQ7IC8vIEhhbmRsZSBJbmZpbml0eS9JbmZpbml0eVxyXG4gICAgfSk7XHJcblxyXG4gIC8vIDIwLjIuMi4zNSBNYXRoLnRydW5jICggeCApXHJcbiAgZGVmaW5lKFxyXG4gICAgTWF0aCwgJ3RydW5jJyxcclxuICAgIGZ1bmN0aW9uIHRydW5jKHgpIHtcclxuICAgICAgeCA9IE51bWJlcih4KTtcclxuICAgICAgcmV0dXJuICRpc05hTih4KSA/IE5hTiA6XHJcbiAgICAgICAgeCA8IDAgPyBjZWlsKHgpIDogZmxvb3IoeCk7XHJcbiAgICB9KTtcclxuXHJcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgLy8gMjAuMyBEYXRlIE9iamVjdHNcclxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcbiAgLy8gMjAuMy4xIE92ZXJ2aWV3IG9mIERhdGUgT2JqZWN0cyBhbmQgRGVmaW5pdGlvbnMgb2YgQWJzdHJhY3QgT3BlcmF0aW9uc1xyXG4gIC8vIDIwLjMuMS4xIFRpbWUgVmFsdWVzIGFuZCBUaW1lIFJhbmdlXHJcbiAgLy8gMjAuMy4xLjIgRGF5IE51bWJlciBhbmQgVGltZSB3aXRoaW4gRGF5XHJcbiAgLy8gMjAuMy4xLjMgWWVhciBOdW1iZXJcclxuICAvLyAyMC4zLjEuNCBNb250aCBOdW1iZXJcclxuICAvLyAyMC4zLjEuNSBEYXRlIE51bWJlclxyXG4gIC8vIDIwLjMuMS42IFdlZWsgRGF5XHJcbiAgLy8gMjAuMy4xLjcgTG9jYWwgVGltZSBab25lIEFkanVzdG1lbnRcclxuICAvLyAyMC4zLjEuOCBEYXlsaWdodCBTYXZpbmcgVGltZSBBZGp1c3RtZW50XHJcbiAgLy8gMjAuMy4xLjkgTG9jYWwgVGltZVxyXG4gIC8vIDIwLjMuMS4xMCBIb3VycywgTWludXRlcywgU2Vjb25kLCBhbmQgTWlsbGlzZWNvbmRzXHJcbiAgLy8gMjAuMy4xLjExIE1ha2VUaW1lIChob3VyLCBtaW4sIHNlYywgbXMpXHJcbiAgLy8gMjAuMy4xLjEyIE1ha2VEYXkgKHllYXIsIG1vbnRoLCBkYXRlKVxyXG4gIC8vIDIwLjMuMS4xMyBNYWtlRGF0ZSAoZGF5LCB0aW1lKVxyXG4gIC8vIDIwLjMuMS4xNCBUaW1lQ2xpcCAodGltZSlcclxuICAvLyAyMC4zLjEuMTUgRGF0ZSBUaW1lIFN0cmluZyBGb3JtYXRcclxuICAvLyAyMC4zLjEuMTUuMSBFeHRlbmRlZCB5ZWFyc1xyXG4gIC8vIDIwLjMuMiBUaGUgRGF0ZSBDb25zdHJ1Y3RvclxyXG4gIC8vIDIwLjMuMi4xIERhdGUgKCB5ZWFyLCBtb250aCBbLCBkYXRlIFsgLCBob3VycyBbICwgbWludXRlcyBbICwgc2Vjb25kcyBbICwgbXMgXSBdIF0gXSBdIClcclxuICAvLyAyMC4zLjIuMiBEYXRlICggdmFsdWUgKVxyXG4gIC8vIDIwLjMuMi4zIERhdGUgKCApXHJcbiAgLy8gMjAuMy4zIFByb3BlcnRpZXMgb2YgdGhlIERhdGUgQ29uc3RydWN0b3JcclxuICAvLyAyMC4zLjMuMSBEYXRlLm5vdyAoIClcclxuICAvLyAyMC4zLjMuMiBEYXRlLnBhcnNlIChzdHJpbmcpXHJcbiAgLy8gMjAuMy4zLjMgRGF0ZS5wcm90b3R5cGVcclxuICAvLyAyMC4zLjMuNCBEYXRlLlVUQyAoIHllYXIsIG1vbnRoIFsgLCBkYXRlIFsgLCBob3VycyBbICwgbWludXRlcyBbICwgc2Vjb25kcyBbICwgbXMgXSBdIF0gXSBdIClcclxuICAvLyAyMC4zLjQgUHJvcGVydGllcyBvZiB0aGUgRGF0ZSBQcm90b3R5cGUgT2JqZWN0XHJcbiAgLy8gMjAuMy40LjEgRGF0ZS5wcm90b3R5cGUuY29uc3RydWN0b3JcclxuICAvLyAyMC4zLjQuMiBEYXRlLnByb3RvdHlwZS5nZXREYXRlICggKVxyXG4gIC8vIDIwLjMuNC4zIERhdGUucHJvdG90eXBlLmdldERheSAoIClcclxuICAvLyAyMC4zLjQuNCBEYXRlLnByb3RvdHlwZS5nZXRGdWxsWWVhciAoIClcclxuICAvLyAyMC4zLjQuNSBEYXRlLnByb3RvdHlwZS5nZXRIb3VycyAoIClcclxuICAvLyAyMC4zLjQuNiBEYXRlLnByb3RvdHlwZS5nZXRNaWxsaXNlY29uZHMgKCApXHJcbiAgLy8gMjAuMy40LjcgRGF0ZS5wcm90b3R5cGUuZ2V0TWludXRlcyAoIClcclxuICAvLyAyMC4zLjQuOCBEYXRlLnByb3RvdHlwZS5nZXRNb250aCAoIClcclxuICAvLyAyMC4zLjQuOSBEYXRlLnByb3RvdHlwZS5nZXRTZWNvbmRzICggKVxyXG4gIC8vIDIwLjMuNC4xMCBEYXRlLnByb3RvdHlwZS5nZXRUaW1lICggKVxyXG4gIC8vIDIwLjMuNC4xMSBEYXRlLnByb3RvdHlwZS5nZXRUaW1lem9uZU9mZnNldCAoIClcclxuICAvLyAyMC4zLjQuMTIgRGF0ZS5wcm90b3R5cGUuZ2V0VVRDRGF0ZSAoIClcclxuICAvLyAyMC4zLjQuMTMgRGF0ZS5wcm90b3R5cGUuZ2V0VVRDRGF5ICggKVxyXG4gIC8vIDIwLjMuNC4xNCBEYXRlLnByb3RvdHlwZS5nZXRVVENGdWxsWWVhciAoIClcclxuICAvLyAyMC4zLjQuMTUgRGF0ZS5wcm90b3R5cGUuZ2V0VVRDSG91cnMgKCApXHJcbiAgLy8gMjAuMy40LjE2IERhdGUucHJvdG90eXBlLmdldFVUQ01pbGxpc2Vjb25kcyAoIClcclxuICAvLyAyMC4zLjQuMTcgRGF0ZS5wcm90b3R5cGUuZ2V0VVRDTWludXRlcyAoIClcclxuICAvLyAyMC4zLjQuMTggRGF0ZS5wcm90b3R5cGUuZ2V0VVRDTW9udGggKCApXHJcbiAgLy8gMjAuMy40LjE5IERhdGUucHJvdG90eXBlLmdldFVUQ1NlY29uZHMgKCApXHJcbiAgLy8gMjAuMy40LjIwIERhdGUucHJvdG90eXBlLnNldERhdGUgKCBkYXRlIClcclxuICAvLyAyMC4zLjQuMjEgRGF0ZS5wcm90b3R5cGUuc2V0RnVsbFllYXIgKCB5ZWFyIFsgLCBtb250aCBbICwgZGF0ZSBdIF0gKVxyXG4gIC8vIDIwLjMuNC4yMiBEYXRlLnByb3RvdHlwZS5zZXRIb3VycyAoIGhvdXIgWyAsIG1pbiBbICwgc2VjIFsgLCBtcyBdIF0gXSApXHJcbiAgLy8gMjAuMy40LjIzIERhdGUucHJvdG90eXBlLnNldE1pbGxpc2Vjb25kcyAoIG1zIClcclxuICAvLyAyMC4zLjQuMjQgRGF0ZS5wcm90b3R5cGUuc2V0TWludXRlcyAoIG1pbiBbICwgc2VjIFsgLCBtcyBdIF0gKVxyXG4gIC8vIDIwLjMuNC4yNSBEYXRlLnByb3RvdHlwZS5zZXRNb250aCAoIG1vbnRoIFsgLCBkYXRlIF0gKVxyXG4gIC8vIDIwLjMuNC4yNiBEYXRlLnByb3RvdHlwZS5zZXRTZWNvbmRzICggc2VjIFsgLCBtcyBdIClcclxuICAvLyAyMC4zLjQuMjcgRGF0ZS5wcm90b3R5cGUuc2V0VGltZSAoIHRpbWUgKVxyXG4gIC8vIDIwLjMuNC4yOCBEYXRlLnByb3RvdHlwZS5zZXRVVENEYXRlICggZGF0ZSApXHJcbiAgLy8gMjAuMy40LjI5IERhdGUucHJvdG90eXBlLnNldFVUQ0Z1bGxZZWFyICggeWVhciBbICwgbW9udGggWyAsIGRhdGUgXSBdIClcclxuICAvLyAyMC4zLjQuMzAgRGF0ZS5wcm90b3R5cGUuc2V0VVRDSG91cnMgKCBob3VyIFsgLCBtaW4gWyAsIHNlYyBbICwgbXMgXSBdIF0gKVxyXG4gIC8vIDIwLjMuNC4zMSBEYXRlLnByb3RvdHlwZS5zZXRVVENNaWxsaXNlY29uZHMgKCBtcyApXHJcbiAgLy8gMjAuMy40LjMyIERhdGUucHJvdG90eXBlLnNldFVUQ01pbnV0ZXMgKCBtaW4gWyAsIHNlYyBbLCBtcyBdIF0gKVxyXG4gIC8vIDIwLjMuNC4zMyBEYXRlLnByb3RvdHlwZS5zZXRVVENNb250aCAoIG1vbnRoIFsgLCBkYXRlIF0gKVxyXG4gIC8vIDIwLjMuNC4zNCBEYXRlLnByb3RvdHlwZS5zZXRVVENTZWNvbmRzICggc2VjIFsgLCBtcyBdIClcclxuICAvLyAyMC4zLjQuMzUgRGF0ZS5wcm90b3R5cGUudG9EYXRlU3RyaW5nICggKVxyXG4gIC8vIDIwLjMuNC4zNiBEYXRlLnByb3RvdHlwZS50b0lTT1N0cmluZyAoIClcclxuICAvLyAyMC4zLjQuMzcgRGF0ZS5wcm90b3R5cGUudG9KU09OICgga2V5IClcclxuICAvLyAyMC4zLjQuMzggRGF0ZS5wcm90b3R5cGUudG9Mb2NhbGVEYXRlU3RyaW5nICggWyByZXNlcnZlZDEgWyAsIHJlc2VydmVkMiBdIF0gKVxyXG4gIC8vIDIwLjMuNC4zOSBEYXRlLnByb3RvdHlwZS50b0xvY2FsZVN0cmluZyAoIFsgcmVzZXJ2ZWQxIFsgLCByZXNlcnZlZDIgXSBdIClcclxuICAvLyAyMC4zLjQuNDAgRGF0ZS5wcm90b3R5cGUudG9Mb2NhbGVUaW1lU3RyaW5nICggWyByZXNlcnZlZDEgWyAsIHJlc2VydmVkMiBdIF0gKVxyXG4gIC8vIDIwLjMuNC40MSBEYXRlLnByb3RvdHlwZS50b1N0cmluZyAoIClcclxuICAvLyAyMC4zLjQuNDIgRGF0ZS5wcm90b3R5cGUudG9UaW1lU3RyaW5nICggKVxyXG4gIC8vIDIwLjMuNC40MyBEYXRlLnByb3RvdHlwZS50b1VUQ1N0cmluZyAoIClcclxuICAvLyAyMC4zLjQuNDQgRGF0ZS5wcm90b3R5cGUudmFsdWVPZiAoIClcclxuICAvLyAyMC4zLjQuNDUgRGF0ZS5wcm90b3R5cGUgWyBAQHRvUHJpbWl0aXZlIF0gKCBoaW50IClcclxuICAvLyAyMC4zLjUgUHJvcGVydGllcyBvZiBEYXRlIEluc3RhbmNlc1xyXG5cclxuICAvLyAoTm8gcG9seWZpbGxhYmxlIGNoYW5nZXMgZnJvbSBFUzUpXHJcblxyXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gIC8vIDIxIFRleHQgUHJvY2Vzc2luZ1xyXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cclxuICB2YXIgc3RyaW5nX3JlZ2V4cF9kaXNwYXRjaCA9IChmdW5jdGlvbigpIHtcclxuICAgIHZhciBmYXV4ID0ge30sIHNlY3JldCA9IFN5bWJvbCgpO1xyXG4gICAgZmF1eFtTeW1ib2wubWF0Y2hdID0gZnVuY3Rpb24oKSB7IHJldHVybiBzZWNyZXQ7IH07XHJcbiAgICByZXR1cm4gKFwiXCIpLm1hdGNoKGZhdXgpID09PSBzZWNyZXQ7XHJcbiAgfSgpKTtcclxuXHJcbiAgLy8gMjEuMSBTdHJpbmcgT2JqZWN0c1xyXG4gIC8vIDIxLjEuMSBUaGUgU3RyaW5nIENvbnN0cnVjdG9yXHJcbiAgLy8gMjEuMS4xLjEgU3RyaW5nICggdmFsdWUgKVxyXG4gIC8vIDIxLjEuMiBQcm9wZXJ0aWVzIG9mIHRoZSBTdHJpbmcgQ29uc3RydWN0b3JcclxuICAvLyAyMS4xLjIuMSBTdHJpbmcuZnJvbUNoYXJDb2RlICggLi4uY29kZVVuaXRzIClcclxuXHJcbiAgLy8gMjEuMS4yLjIgU3RyaW5nLmZyb21Db2RlUG9pbnQgKCAuLi5jb2RlUG9pbnRzIClcclxuICBkZWZpbmUoXHJcbiAgICBTdHJpbmcsICdmcm9tQ29kZVBvaW50JyxcclxuICAgIGZ1bmN0aW9uIGZyb21Db2RlUG9pbnQoLyouLi5jb2RlUG9pbnRzKi8pIHtcclxuICAgICAgdmFyIGNvZGVQb2ludHMgPSBhcmd1bWVudHMsXHJcbiAgICAgICAgICBsZW5ndGggPSBjb2RlUG9pbnRzLmxlbmd0aCxcclxuICAgICAgICAgIGVsZW1lbnRzID0gW10sXHJcbiAgICAgICAgICBuZXh0SW5kZXggPSAwO1xyXG4gICAgICB3aGlsZSAobmV4dEluZGV4IDwgbGVuZ3RoKSB7XHJcbiAgICAgICAgdmFyIG5leHQgPSBjb2RlUG9pbnRzW25leHRJbmRleF07XHJcbiAgICAgICAgdmFyIG5leHRDUCA9IE51bWJlcihuZXh0KTtcclxuICAgICAgICBpZiAoIVNhbWVWYWx1ZShuZXh0Q1AsIFRvSW50ZWdlcihuZXh0Q1ApKSB8fFxyXG4gICAgICAgICAgICBuZXh0Q1AgPCAwIHx8IG5leHRDUCA+IDB4MTBGRkZGKSB7XHJcbiAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKCdJbnZhbGlkIGNvZGUgcG9pbnQgJyArIG5leHRDUCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChuZXh0Q1AgPCAweDEwMDAwKSB7XHJcbiAgICAgICAgICBlbGVtZW50cy5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUobmV4dENQKSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIG5leHRDUCAtPSAweDEwMDAwO1xyXG4gICAgICAgICAgZWxlbWVudHMucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKChuZXh0Q1AgPj4gMTApICsgMHhEODAwKSk7XHJcbiAgICAgICAgICBlbGVtZW50cy5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoKG5leHRDUCAlIDB4NDAwKSArIDB4REMwMCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBuZXh0SW5kZXggKz0gMTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gZWxlbWVudHMuam9pbignJyk7XHJcbiAgICB9KTtcclxuXHJcbiAgLy8gMjEuMS4yLjMgU3RyaW5nLnByb3RvdHlwZVxyXG5cclxuICAvLyAyMS4xLjIuNCBTdHJpbmcucmF3ICggdGVtcGxhdGUgLCAuLi5zdWJzdGl0dXRpb25zIClcclxuICBkZWZpbmUoXHJcbiAgICBTdHJpbmcsICdyYXcnLFxyXG4gICAgZnVuY3Rpb24gcmF3KHRlbXBsYXRlIC8qLCAuLi5zdWJzdGl0dXRpb25zKi8pIHtcclxuICAgICAgdmFyIHN1YnN0aXR1dGlvbnMgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XHJcblxyXG4gICAgICB2YXIgY29va2VkID0gT2JqZWN0KHRlbXBsYXRlKTtcclxuICAgICAgdmFyIHJhd1ZhbHVlID0gY29va2VkWydyYXcnXTtcclxuICAgICAgdmFyIHJhdyA9IE9iamVjdChyYXdWYWx1ZSk7XHJcbiAgICAgIHZhciBsZW4gPSByYXdbJ2xlbmd0aCddO1xyXG4gICAgICB2YXIgbGl0ZXJhbFNlZ21lbnRzID0gVG9MZW5ndGgobGVuKTtcclxuICAgICAgaWYgKGxpdGVyYWxTZWdtZW50cyA8PSAwKSByZXR1cm4gJyc7XHJcbiAgICAgIHZhciBzdHJpbmdFbGVtZW50cyA9IFtdO1xyXG4gICAgICB2YXIgbmV4dEluZGV4ID0gMDtcclxuICAgICAgd2hpbGUgKHRydWUpIHtcclxuICAgICAgICB2YXIgbmV4dCA9IHJhd1tuZXh0SW5kZXhdO1xyXG4gICAgICAgIHZhciBuZXh0U2VnID0gU3RyaW5nKG5leHQpO1xyXG4gICAgICAgIHN0cmluZ0VsZW1lbnRzLnB1c2gobmV4dFNlZyk7XHJcbiAgICAgICAgaWYgKG5leHRJbmRleCArIDEgPT09IGxpdGVyYWxTZWdtZW50cylcclxuICAgICAgICAgIHJldHVybiBzdHJpbmdFbGVtZW50cy5qb2luKCcnKTtcclxuICAgICAgICBuZXh0ID0gc3Vic3RpdHV0aW9uc1tuZXh0SW5kZXhdO1xyXG4gICAgICAgIHZhciBuZXh0U3ViID0gU3RyaW5nKG5leHQpO1xyXG4gICAgICAgIHN0cmluZ0VsZW1lbnRzLnB1c2gobmV4dFN1Yik7XHJcbiAgICAgICAgbmV4dEluZGV4ID0gbmV4dEluZGV4ICsgMTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gIC8vIFNlZSBodHRwczovL2dpdGhpYi5jb20vaW5leG9yYWJsZXRhc2gvdWF0ZSBmb3IgYSBtb3JlIHVzZWZ1bCB2ZXJzaW9uLlxyXG5cclxuICAvLyAyMS4xLjMgUHJvcGVydGllcyBvZiB0aGUgU3RyaW5nIFByb3RvdHlwZSBPYmplY3RcclxuICAvLyAyMS4xLjMuMSBTdHJpbmcucHJvdG90eXBlLmNoYXJBdCAoIHBvcyApXHJcbiAgLy8gMjEuMS4zLjIgU3RyaW5nLnByb3RvdHlwZS5jaGFyQ29kZUF0ICggcG9zIClcclxuXHJcbiAgLy8gMjEuMS4zLjMgU3RyaW5nLnByb3RvdHlwZS5jb2RlUG9pbnRBdCAoIHBvcyApXHJcbiAgZGVmaW5lKFxyXG4gICAgU3RyaW5nLnByb3RvdHlwZSwgJ2NvZGVQb2ludEF0JyxcclxuICAgIGZ1bmN0aW9uIGNvZGVQb2ludEF0KHBvcykge1xyXG4gICAgICB2YXIgbyA9IHN0cmljdCh0aGlzKTtcclxuICAgICAgdmFyIHMgPSBTdHJpbmcobyk7XHJcbiAgICAgIHZhciBwb3NpdGlvbiA9IFRvSW50ZWdlcihwb3MpO1xyXG4gICAgICB2YXIgc2l6ZSA9IHMubGVuZ3RoO1xyXG4gICAgICBpZiAocG9zaXRpb24gPCAwIHx8IHBvc2l0aW9uID49IHNpemUpIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgIHZhciBmaXJzdCA9IHMuY2hhckNvZGVBdChwb3NpdGlvbik7XHJcbiAgICAgIGlmIChmaXJzdCA8IDB4RDgwMCB8fCBmaXJzdCA+IDB4REJGRiB8fCBwb3NpdGlvbiArIDEgPT09IHNpemUpIHJldHVybiBmaXJzdDtcclxuICAgICAgdmFyIHNlY29uZCA9IHMuY2hhckNvZGVBdChwb3NpdGlvbiArIDEpO1xyXG4gICAgICBpZiAoc2Vjb25kIDwgMHhEQzAwIHx8IHNlY29uZCA+IDB4REZGRikgcmV0dXJuIGZpcnN0O1xyXG4gICAgICByZXR1cm4gKChmaXJzdCAtIDB4RDgwMCkgKiAxMDI0KSArIChzZWNvbmQgLSAweERDMDApICsgMHgxMDAwMDtcclxuICAgIH0pO1xyXG5cclxuICAvLyAyMS4xLjMuNCBTdHJpbmcucHJvdG90eXBlLmNvbmNhdCAoIC4uLmFyZ3MgKVxyXG4gIC8vIDIxLjEuMy41IFN0cmluZy5wcm90b3R5cGUuY29uc3RydWN0b3JcclxuXHJcbiAgLy8gMjEuMS4zLjYgU3RyaW5nLnByb3RvdHlwZS5lbmRzV2l0aCAoIHNlYXJjaFN0cmluZyBbICwgZW5kUG9zaXRpb25dIClcclxuICBkZWZpbmUoXHJcbiAgICBTdHJpbmcucHJvdG90eXBlLCAnZW5kc1dpdGgnLFxyXG4gICAgZnVuY3Rpb24gZW5kc1dpdGgoc2VhcmNoU3RyaW5nKSB7XHJcbiAgICAgIHZhciBlbmRQb3NpdGlvbiA9IGFyZ3VtZW50c1sxXTtcclxuXHJcbiAgICAgIHZhciBvID0gc3RyaWN0KHRoaXMpO1xyXG4gICAgICB2YXIgcyA9IFN0cmluZyhvKTtcclxuICAgICAgdmFyIHNlYXJjaFN0ciA9IFN0cmluZyhzZWFyY2hTdHJpbmcpO1xyXG4gICAgICB2YXIgbGVuID0gcy5sZW5ndGg7XHJcbiAgICAgIHZhciBwb3MgPSAoZW5kUG9zaXRpb24gPT09IHVuZGVmaW5lZCkgPyBsZW4gOiBUb0ludGVnZXIoZW5kUG9zaXRpb24pO1xyXG4gICAgICB2YXIgZW5kID0gbWluKG1heChwb3MsIDApLCBsZW4pO1xyXG4gICAgICB2YXIgc2VhcmNoTGVuZ3RoID0gc2VhcmNoU3RyLmxlbmd0aDtcclxuICAgICAgdmFyIHN0YXJ0ID0gZW5kIC0gc2VhcmNoTGVuZ3RoO1xyXG4gICAgICBpZiAoc3RhcnQgPCAwKSByZXR1cm4gZmFsc2U7XHJcbiAgICAgIGlmIChzLnN1YnN0cmluZyhzdGFydCwgc3RhcnQgKyBzZWFyY2hMZW5ndGgpID09PSBzZWFyY2hTdHIpIHJldHVybiB0cnVlO1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9KTtcclxuXHJcbiAgLy8gMjEuMS4zLjcgU3RyaW5nLnByb3RvdHlwZS5pbmNsdWRlcyAoIHNlYXJjaFN0cmluZyBbICwgcG9zaXRpb24gXSApXHJcbiAgZGVmaW5lKFxyXG4gICAgU3RyaW5nLnByb3RvdHlwZSwgJ2luY2x1ZGVzJyxcclxuICAgIGZ1bmN0aW9uIGluY2x1ZGVzKHNlYXJjaFN0cmluZykge1xyXG4gICAgICB2YXIgcG9zaXRpb24gPSBhcmd1bWVudHNbMV07XHJcblxyXG4gICAgICB2YXIgbyA9IHN0cmljdCh0aGlzKTtcclxuICAgICAgdmFyIHMgPSBTdHJpbmcobyk7XHJcbiAgICAgIHZhciBzZWFyY2hTdHIgPSBTdHJpbmcoc2VhcmNoU3RyaW5nKTtcclxuICAgICAgdmFyIHBvcyA9IFRvSW50ZWdlcihwb3NpdGlvbik7XHJcbiAgICAgIHZhciBsZW4gPSBzLmxlbmd0aDtcclxuICAgICAgdmFyIHN0YXJ0ID0gbWluKG1heChwb3MsIDApLCBsZW4pO1xyXG4gICAgICByZXR1cm4gcy5pbmRleE9mKHNlYXJjaFN0ciwgc3RhcnQpICE9PSAtMTtcclxuICAgIH0pO1xyXG5cclxuICAvLyAyMS4xLjMuOCBTdHJpbmcucHJvdG90eXBlLmluZGV4T2YgKCBzZWFyY2hTdHJpbmcgWyAsIHBvc2l0aW9uIF0gKVxyXG4gIC8vIDIxLjEuMy45IFN0cmluZy5wcm90b3R5cGUubGFzdEluZGV4T2YgKCBzZWFyY2hTdHJpbmcgWyAsIHBvc2l0aW9uIF0gKVxyXG4gIC8vIDIxLjEuMy4xMCBTdHJpbmcucHJvdG90eXBlLmxvY2FsZUNvbXBhcmUgKCB0aGF0IFssIHJlc2VydmVkMSBbICwgcmVzZXJ2ZWQyIF0gXSApXHJcbiAgLy8gMjEuMS4zLjExIFN0cmluZy5wcm90b3R5cGUubWF0Y2ggKCByZWdleHAgKVxyXG4gIGRlZmluZShcclxuICAgIFN0cmluZy5wcm90b3R5cGUsICdtYXRjaCcsXHJcbiAgICBmdW5jdGlvbiBtYXRjaChyZWdleHApIHtcclxuICAgICAgdmFyIG8gPSBzdHJpY3QodGhpcyk7XHJcbiAgICAgIHZhciBzID0gU3RyaW5nKG8pO1xyXG4gICAgICBpZiAoSGFzUHJvcGVydHkocmVnZXhwLCAkJG1hdGNoKSkgdmFyIHJ4ID0gcmVnZXhwO1xyXG4gICAgICBlbHNlIHJ4ID0gbmV3IFJlZ0V4cChyZWdleHApO1xyXG4gICAgICByZXR1cm4gcnhbJCRtYXRjaF0ocyk7XHJcbiAgICB9LCAhc3RyaW5nX3JlZ2V4cF9kaXNwYXRjaCk7XHJcblxyXG4gIC8vIDIxLjEuMy4xMiBTdHJpbmcucHJvdG90eXBlLm5vcm1hbGl6ZSAoIFsgZm9ybSBdIClcclxuXHJcbiAgLy8gTm90IHByYWN0aWNhbCBkdWUgdG8gdGFibGUgc2l6ZXM7IGlmIG5lZWRlZCwgcHVsbCBpbjpcclxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vd2FsbGluZy91bm9ybS9cclxuXHJcbiAgLy8gMjEuMS4zLjEzIFN0cmluZy5wcm90b3R5cGUucmVwZWF0ICggY291bnQgKVxyXG4gIGRlZmluZShcclxuICAgIFN0cmluZy5wcm90b3R5cGUsICdyZXBlYXQnLFxyXG4gICAgZnVuY3Rpb24gcmVwZWF0KGNvdW50KSB7XHJcbiAgICAgIHZhciBvID0gc3RyaWN0KHRoaXMpO1xyXG4gICAgICB2YXIgcyA9IFN0cmluZyhvKTtcclxuICAgICAgdmFyIG4gPSBUb0ludGVnZXIoY291bnQpO1xyXG4gICAgICBpZiAobiA8IDApIHRocm93IFJhbmdlRXJyb3IoKTtcclxuICAgICAgaWYgKG4gPT09IEluZmluaXR5KSB0aHJvdyBSYW5nZUVycm9yKCk7XHJcbiAgICAgIHZhciB0ID0gbmV3IEFycmF5KG4gKyAxKS5qb2luKHMpO1xyXG4gICAgICByZXR1cm4gdDtcclxuICAgIH0pO1xyXG5cclxuICAvLyAyMS4xLjMuMTQgU3RyaW5nLnByb3RvdHlwZS5yZXBsYWNlIChzZWFyY2hWYWx1ZSwgcmVwbGFjZVZhbHVlIClcclxuICBkZWZpbmUoXHJcbiAgICBTdHJpbmcucHJvdG90eXBlLCAncmVwbGFjZScsXHJcbiAgICBmdW5jdGlvbiByZXBsYWNlKHNlYXJjaFZhbHVlLCByZXBsYWNlVmFsdWUpIHtcclxuICAgICAgdmFyIG8gPSBzdHJpY3QodGhpcyk7XHJcbiAgICAgIGlmIChIYXNQcm9wZXJ0eShzZWFyY2hWYWx1ZSwgJCRyZXBsYWNlKSlcclxuICAgICAgICByZXR1cm4gc2VhcmNoVmFsdWVbJCRyZXBsYWNlXShvLCByZXBsYWNlVmFsdWUpO1xyXG4gICAgICByZXR1cm4gb3JpZ19yZXBsYWNlLmNhbGwobywgc2VhcmNoVmFsdWUsIHJlcGxhY2VWYWx1ZSk7XHJcbiAgICB9LCAhc3RyaW5nX3JlZ2V4cF9kaXNwYXRjaCk7XHJcblxyXG4gIC8vIDIxLjEuMy4xNSBTdHJpbmcucHJvdG90eXBlLnNlYXJjaCAoIHJlZ2V4cCApXHJcbiAgZGVmaW5lKFxyXG4gICAgU3RyaW5nLnByb3RvdHlwZSwgJ3NlYXJjaCcsXHJcbiAgICBmdW5jdGlvbiBzZWFyY2gocmVnZXhwKSB7XHJcbiAgICAgIHZhciBvID0gc3RyaWN0KHRoaXMpO1xyXG4gICAgICB2YXIgc3RyaW5nID0gU3RyaW5nKG8pO1xyXG4gICAgICBpZiAoSGFzUHJvcGVydHkocmVnZXhwLCAkJHNlYXJjaCkpIHZhciByeCA9IHJlZ2V4cDtcclxuICAgICAgZWxzZSByeCA9IG5ldyBSZWdFeHAocmVnZXhwKTtcclxuICAgICAgcmV0dXJuIHJ4WyQkc2VhcmNoXShzdHJpbmcpO1xyXG4gICAgfSwgIXN0cmluZ19yZWdleHBfZGlzcGF0Y2gpO1xyXG5cclxuICAvLyAyMS4xLjMuMTYgU3RyaW5nLnByb3RvdHlwZS5zbGljZSAoIHN0YXJ0LCBlbmQgKVxyXG4gIC8vIDIxLjEuMy4xNyBTdHJpbmcucHJvdG90eXBlLnNwbGl0ICggc2VwYXJhdG9yLCBsaW1pdCApXHJcbiAgZGVmaW5lKFxyXG4gICAgU3RyaW5nLnByb3RvdHlwZSwgJ3NwbGl0JyxcclxuICAgIGZ1bmN0aW9uIHNwbGl0KHNlcGFyYXRvciwgbGltaXQpIHtcclxuICAgICAgdmFyIG8gPSBzdHJpY3QodGhpcyk7XHJcbiAgICAgIGlmIChIYXNQcm9wZXJ0eShzZXBhcmF0b3IsICQkc3BsaXQpKVxyXG4gICAgICAgIHJldHVybiBzZXBhcmF0b3JbJCRzcGxpdF0obywgbGltaXQpO1xyXG4gICAgICByZXR1cm4gb3JpZ19zcGxpdC5jYWxsKG8sIHNlcGFyYXRvciwgbGltaXQpO1xyXG4gICAgfSwgIXN0cmluZ19yZWdleHBfZGlzcGF0Y2gpO1xyXG5cclxuICAvLyAyMS4xLjMuMTggU3RyaW5nLnByb3RvdHlwZS5zdGFydHNXaXRoICggc2VhcmNoU3RyaW5nIFssIHBvc2l0aW9uIF0gKVxyXG4gIGRlZmluZShcclxuICAgIFN0cmluZy5wcm90b3R5cGUsICdzdGFydHNXaXRoJyxcclxuICAgIGZ1bmN0aW9uIHN0YXJ0c1dpdGgoc2VhcmNoU3RyaW5nKSB7XHJcbiAgICAgIHZhciBwb3NpdGlvbiA9IGFyZ3VtZW50c1sxXTtcclxuXHJcbiAgICAgIHZhciBvID0gc3RyaWN0KHRoaXMpO1xyXG4gICAgICB2YXIgcyA9IFN0cmluZyhvKTtcclxuICAgICAgdmFyIHNlYXJjaFN0ciA9IFN0cmluZyhzZWFyY2hTdHJpbmcpO1xyXG4gICAgICB2YXIgcG9zID0gVG9JbnRlZ2VyKHBvc2l0aW9uKTtcclxuICAgICAgdmFyIGxlbiA9IHMubGVuZ3RoO1xyXG4gICAgICB2YXIgc3RhcnQgPSBtaW4obWF4KHBvcywgMCksIGxlbik7XHJcbiAgICAgIHZhciBzZWFyY2hMZW5ndGggPSBzZWFyY2hTdHIubGVuZ3RoO1xyXG4gICAgICBpZiAoc2VhcmNoTGVuZ3RoICsgc3RhcnQgPiBsZW4pIHJldHVybiBmYWxzZTtcclxuICAgICAgaWYgKHMuc3Vic3RyaW5nKHN0YXJ0LCBzdGFydCArIHNlYXJjaExlbmd0aCkgPT09IHNlYXJjaFN0cikgcmV0dXJuIHRydWU7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH0pO1xyXG5cclxuICAvLyAyMS4xLjMuMTkgU3RyaW5nLnByb3RvdHlwZS5zdWJzdHJpbmcgKCBzdGFydCwgZW5kIClcclxuICAvLyAyMS4xLjMuMjAgU3RyaW5nLnByb3RvdHlwZS50b0xvY2FsZUxvd2VyQ2FzZSAoIFsgcmVzZXJ2ZWQxIFsgLCByZXNlcnZlZDIgXSBdIClcclxuICAvLyAyMS4xLjMuMjEgU3RyaW5nLnByb3RvdHlwZS50b0xvY2FsZVVwcGVyQ2FzZSAoWyByZXNlcnZlZDEgWyAsIHJlc2VydmVkMiBdIF0gKVxyXG4gIC8vIDIxLjEuMy4yMiBTdHJpbmcucHJvdG90eXBlLnRvTG93ZXJDYXNlICggKVxyXG4gIC8vIDIxLjEuMy4yMyBTdHJpbmcucHJvdG90eXBlLnRvU3RyaW5nICggKVxyXG4gIC8vIDIxLjEuMy4yNCBTdHJpbmcucHJvdG90eXBlLnRvVXBwZXJDYXNlICggKVxyXG4gIC8vIDIxLjEuMy4yNSBTdHJpbmcucHJvdG90eXBlLnRyaW0gKCApXHJcbiAgLy8gMjEuMS4zLjI2IFN0cmluZy5wcm90b3R5cGUudmFsdWVPZiAoIClcclxuXHJcbiAgLy8gMjEuMS4zLjI3IFN0cmluZy5wcm90b3R5cGUgWyBAQGl0ZXJhdG9yIF0oIClcclxuICBkZWZpbmUoXHJcbiAgICBTdHJpbmcucHJvdG90eXBlLCAkJGl0ZXJhdG9yLFxyXG4gICAgZnVuY3Rpb24gZW50cmllcygpIHtcclxuICAgICAgcmV0dXJuIENyZWF0ZVN0cmluZ0l0ZXJhdG9yKHRoaXMsICd2YWx1ZScpO1xyXG4gICAgfSk7XHJcblxyXG4gIC8vIDIxLjEuNCBQcm9wZXJ0aWVzIG9mIFN0cmluZyBJbnN0YW5jZXNcclxuICAvLyAyMS4xLjQuMSBsZW5ndGhcclxuXHJcbiAgLy8gMjEuMS41IFN0cmluZyBJdGVyYXRvciBPYmplY3RzXHJcbiAgLyoqIEBjb25zdHJ1Y3RvciAqL1xyXG4gIGZ1bmN0aW9uIFN0cmluZ0l0ZXJhdG9yKCkge31cclxuXHJcbiAgLy8gMjEuMS41LjEgQ3JlYXRlU3RyaW5nSXRlcmF0b3IgQWJzdHJhY3QgT3BlcmF0aW9uXHJcbiAgZnVuY3Rpb24gQ3JlYXRlU3RyaW5nSXRlcmF0b3Ioc3RyaW5nLCBraW5kKSB7XHJcbiAgICB2YXIgcyA9IFN0cmluZyhzdHJpbmcpO1xyXG4gICAgdmFyIGl0ZXJhdG9yID0gbmV3IFN0cmluZ0l0ZXJhdG9yO1xyXG4gICAgc2V0X2ludGVybmFsKGl0ZXJhdG9yLCAnW1tJdGVyYXRlZFN0cmluZ11dJywgcyk7XHJcbiAgICBzZXRfaW50ZXJuYWwoaXRlcmF0b3IsICdbW1N0cmluZ0l0ZXJhdG9yTmV4dEluZGV4XV0nLCAwKTtcclxuICAgIHNldF9pbnRlcm5hbChpdGVyYXRvciwgJ1tbU3RyaW5nSXRlcmF0aW9uS2luZF1dJywga2luZCk7XHJcbiAgICByZXR1cm4gaXRlcmF0b3I7XHJcbiAgfVxyXG5cclxuICAvLyAyMS4xLjUuMiBUaGUgJVN0cmluZ0l0ZXJhdG9yUHJvdG90eXBlJSBPYmplY3RcclxuICB2YXIgJFN0cmluZ0l0ZXJhdG9yUHJvdG90eXBlJCA9IE9iamVjdC5jcmVhdGUoJEl0ZXJhdG9yUHJvdG90eXBlJCk7XHJcbiAgU3RyaW5nSXRlcmF0b3IucHJvdG90eXBlID0gJFN0cmluZ0l0ZXJhdG9yUHJvdG90eXBlJDtcclxuXHJcbiAgLy8gMjEuMS41LjIuMSAlU3RyaW5nSXRlcmF0b3JQcm90b3R5cGUlLm5leHQgKCApXHJcbiAgZGVmaW5lKFxyXG4gICAgJFN0cmluZ0l0ZXJhdG9yUHJvdG90eXBlJCwgJ25leHQnLFxyXG4gICAgZnVuY3Rpb24gbmV4dCgpIHtcclxuICAgICAgdmFyIG8gPSBUb09iamVjdCh0aGlzKTtcclxuICAgICAgdmFyIHMgPSBTdHJpbmcob1snW1tJdGVyYXRlZFN0cmluZ11dJ10pLFxyXG4gICAgICAgICAgaW5kZXggPSBvWydbW1N0cmluZ0l0ZXJhdG9yTmV4dEluZGV4XV0nXSxcclxuICAgICAgICAgIGxlbiA9IHMubGVuZ3RoO1xyXG4gICAgICBpZiAoaW5kZXggPj0gbGVuKSB7XHJcbiAgICAgICAgc2V0X2ludGVybmFsKG8sICdbW1N0cmluZ0l0ZXJhdG9yTmV4dEluZGV4XV0nLCBJbmZpbml0eSk7XHJcbiAgICAgICAgcmV0dXJuIENyZWF0ZUl0ZXJSZXN1bHRPYmplY3QodW5kZWZpbmVkLCB0cnVlKTtcclxuICAgICAgfVxyXG4gICAgICB2YXIgY3AgPSBzLmNvZGVQb2ludEF0KGluZGV4KTtcclxuICAgICAgc2V0X2ludGVybmFsKG8sICdbW1N0cmluZ0l0ZXJhdG9yTmV4dEluZGV4XV0nLCBpbmRleCArIChjcCA+IDB4RkZGRiA/IDIgOiAxKSk7XHJcbiAgICAgIHJldHVybiBDcmVhdGVJdGVyUmVzdWx0T2JqZWN0KFN0cmluZy5mcm9tQ29kZVBvaW50KGNwKSwgZmFsc2UpO1xyXG4gICAgfSk7XHJcblxyXG4gIC8vIDIxLjEuNS4yLjIgJVN0cmluZ0l0ZXJhdG9yUHJvdG90eXBlJSBbIEBAdG9TdHJpbmdUYWcgXVxyXG4gIGRlZmluZSgkU3RyaW5nSXRlcmF0b3JQcm90b3R5cGUkLCAkJHRvU3RyaW5nVGFnLCAnU3RyaW5nIEl0ZXJhdG9yJyk7XHJcblxyXG4gIC8vIDIxLjEuNS4zIFByb3BlcnRpZXMgb2YgU3RyaW5nIEl0ZXJhdG9yIEluc3RhbmNlc1xyXG5cclxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAvLyAyMS4yIFJlZ0V4cCAoUmVndWxhciBFeHByZXNzaW9uKSBPYmplY3RzXHJcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG4gIC8vIDIxLjIuMSBQYXR0ZXJuc1xyXG4gIC8vIDIxLjIuMiBQYXR0ZXJuIFNlbWFudGljc1xyXG4gIC8vIDIxLjIuMi4xIE5vdGF0aW9uXHJcbiAgLy8gMjEuMi4yLjIgUGF0dGVyblxyXG4gIC8vIDIxLjIuMi4zIERpc2p1bmN0aW9uXHJcbiAgLy8gMjEuMi4yLjQgQWx0ZXJuYXRpdmVcclxuICAvLyAyMS4yLjIuNSBUZXJtXHJcbiAgLy8gMjEuMi4yLjYgQXNzZXJ0aW9uXHJcbiAgLy8gMjEuMi4yLjcgUXVhbnRpZmllclxyXG4gIC8vIDIxLjIuMi44IEF0b21cclxuICAvLyAyMS4yLjIuOSBBdG9tRXNjYXBlXHJcbiAgLy8gMjEuMi4yLjEwIENoYXJhY3RlckVzY2FwZVxyXG4gIC8vIDIxLjIuMi4xMSBEZWNpbWFsRXNjYXBlXHJcbiAgLy8gMjEuMi4yLjEyIENoYXJhY3RlckNsYXNzRXNjYXBlXHJcbiAgLy8gMjEuMi4yLjEzIENoYXJhY3RlckNsYXNzXHJcbiAgLy8gMjEuMi4yLjE0IENsYXNzUmFuZ2VzXHJcbiAgLy8gMjEuMi4yLjE1IE5vbmVtcHR5Q2xhc3NSYW5nZXNcclxuICAvLyAyMS4yLjIuMTYgTm9uZW1wdHlDbGFzc1Jhbmdlc05vRGFzaFxyXG4gIC8vIDIxLjIuMi4xNyBDbGFzc0F0b21cclxuICAvLyAyMS4yLjIuMTggQ2xhc3NBdG9tTm9EYXNoXHJcbiAgLy8gMjEuMi4yLjE5IENsYXNzRXNjYXBlXHJcbiAgLy8gMjEuMi4zIFRoZSBSZWdFeHAgQ29uc3RydWN0b3JcclxuICAvLyAyMS4yLjMuMSBSZWdFeHAgKCBwYXR0ZXJuLCBmbGFncyApXHJcbiAgLy8gMjEuMi4zLjIgbmV3IFJlZ0V4cCggLi4uYXJndW1lbnRzTGlzdCApXHJcbiAgLy8gMjEuMi4zLjMgQWJzdHJhY3QgT3BlcmF0aW9ucyBmb3IgdGhlIFJlZ0V4cCBDb25zdHJ1Y3RvclxyXG4gIC8vIDIxLjIuNCBQcm9wZXJ0aWVzIG9mIHRoZSBSZWdFeHAgQ29uc3RydWN0b3JcclxuICAvLyAyMS4yLjQuMSBSZWdFeHAucHJvdG90eXBlXHJcbiAgLy8gMjEuMi41IFByb3BlcnRpZXMgb2YgdGhlIFJlZ0V4cCBQcm90b3R5cGUgT2JqZWN0XHJcbiAgLy8gMjEuMi41LjEgUmVnRXhwLnByb3RvdHlwZS5jb25zdHJ1Y3RvclxyXG4gIC8vIDIxLjIuNS4yIFJlZ0V4cC5wcm90b3R5cGUuZXhlYyAoIHN0cmluZyApXHJcblxyXG4gIC8vIDIxLjIuNS4zIGdldCBSZWdFeHAucHJvdG90eXBlLmZsYWdzXHJcbiAgaWYgKCEoJ2ZsYWdzJyBpbiBSZWdFeHAucHJvdG90eXBlKSkge1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFxyXG4gICAgICBSZWdFeHAucHJvdG90eXBlLCAnZmxhZ3MnLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgIHZhciBzID0gU3RyaW5nKHRoaXMpO1xyXG4gICAgICAgICAgcmV0dXJuIHMuc3Vic3RyaW5nKHMubGFzdEluZGV4T2YoJy8nKSArIDEpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgfVxyXG5cclxuICAvLyAyMS4yLjUuNCBnZXQgUmVnRXhwLnByb3RvdHlwZS5nbG9iYWxcclxuICAvLyAyMS4yLjUuNSBnZXQgUmVnRXhwLnByb3RvdHlwZS5pZ25vcmVDYXNlXHJcblxyXG4gIC8vIDIxLjIuNS42IFJlZ0V4cC5wcm90b3R5cGUgWyBAQG1hdGNoIF0gKCBzdHJpbmcgKVxyXG4gIGRlZmluZShSZWdFeHAucHJvdG90eXBlLCAkJG1hdGNoLCBmdW5jdGlvbihzdHJpbmcpIHtcclxuICAgIHZhciBvID0gc3RyaWN0KHRoaXMpO1xyXG4gICAgcmV0dXJuIG9yaWdfbWF0Y2guY2FsbChzdHJpbmcsIG8pO1xyXG4gIH0pO1xyXG5cclxuICAvLyAyMS4yLjUuNyBnZXQgUmVnRXhwLnByb3RvdHlwZS5tdWx0aWxpbmVcclxuXHJcbiAgLy8gMjEuMi41LjggUmVnRXhwLnByb3RvdHlwZSBbIEBAcmVwbGFjZSBdICggc3RyaW5nLCByZXBsYWNlVmFsdWUgKVxyXG4gIGRlZmluZShSZWdFeHAucHJvdG90eXBlLCAkJHJlcGxhY2UsIGZ1bmN0aW9uKHN0cmluZywgcmVwbGFjZVZhbHVlKSB7XHJcbiAgICB2YXIgbyA9IHN0cmljdCh0aGlzKTtcclxuICAgIHJldHVybiBvcmlnX3JlcGxhY2UuY2FsbChzdHJpbmcsIG8sIHJlcGxhY2VWYWx1ZSk7XHJcbiAgfSk7XHJcblxyXG4gIC8vIDIxLjIuNS45IFJlZ0V4cC5wcm90b3R5cGUgWyBAQHNlYXJjaCBdICggc3RyaW5nIClcclxuICBkZWZpbmUoUmVnRXhwLnByb3RvdHlwZSwgJCRzZWFyY2gsIGZ1bmN0aW9uKHN0cmluZykge1xyXG4gICAgdmFyIG8gPSBzdHJpY3QodGhpcyk7XHJcbiAgICByZXR1cm4gb3JpZ19zZWFyY2guY2FsbChzdHJpbmcsIG8pO1xyXG4gIH0pO1xyXG5cclxuICAvLyAyMS4yLjUuMTAgZ2V0IFJlZ0V4cC5wcm90b3R5cGUuc291cmNlXHJcblxyXG4gIC8vIDIxLjIuNS4xMSBSZWdFeHAucHJvdG90eXBlIFsgQEBzcGxpdCBdICggc3RyaW5nLCBsaW1pdCApXHJcbiAgZGVmaW5lKFJlZ0V4cC5wcm90b3R5cGUsICQkc3BsaXQsIGZ1bmN0aW9uKHN0cmluZywgbGltaXQpIHtcclxuICAgIHZhciBvID0gc3RyaWN0KHRoaXMpO1xyXG4gICAgcmV0dXJuIG9yaWdfc3BsaXQuY2FsbChzdHJpbmcsIG8sIGxpbWl0KTtcclxuICB9KTtcclxuXHJcbiAgLy8gMjEuMi41LjEyIGdldCBSZWdFeHAucHJvdG90eXBlLnN0aWNreVxyXG4gIC8vIDIxLjIuNS4xMyBSZWdFeHAucHJvdG90eXBlLnRlc3QoIFMgKVxyXG4gIC8vIDIxLjIuNS4xNCBSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nICggKVxyXG4gIC8vIDIxLjIuNS4xNSBnZXQgUmVnRXhwLnByb3RvdHlwZS51bmljb2RlXHJcblxyXG4gIC8vIDIxLjIuNiBQcm9wZXJ0aWVzIG9mIFJlZ0V4cCBJbnN0YW5jZXNcclxuICAvLyAyMS4yLjYuMSBsYXN0SW5kZXhcclxuXHJcbiAgLy8gKE5vIHBvbHlmaWxsYWJsZSBjaGFuZ2VzIGZyb20gRVM1KVxyXG5cclxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAvLyAyMiBJbmRleGVkIENvbGxlY3Rpb25zXHJcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gIC8vIDIyLjEgQXJyYXkgT2JqZWN0c1xyXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cclxuICAvLyAyMi4xLjEgVGhlIEFycmF5IENvbnN0cnVjdG9yXHJcbiAgLy8gMjIuMS4xLjEgQXJyYXkgKCApXHJcbiAgLy8gMjIuMS4xLjIgQXJyYXkgKGxlbilcclxuICAvLyAyMi4xLjEuMyBBcnJheSAoLi4uaXRlbXMgKVxyXG5cclxuICAvLyAyMi4xLjIgUHJvcGVydGllcyBvZiB0aGUgQXJyYXkgQ29uc3RydWN0b3JcclxuXHJcbiAgLy8gMjIuMS4yLjEgQXJyYXkuZnJvbSAoIGl0ZW1zIFsgLCBtYXBmbiBbICwgdGhpc0FyZyBdIF0gKVxyXG4gIGRlZmluZShcclxuICAgIEFycmF5LCAnZnJvbScsXHJcbiAgICBmdW5jdGlvbiBmcm9tKGl0ZW1zKSB7XHJcbiAgICAgIHZhciBtYXBmbiA9IGFyZ3VtZW50c1sxXTtcclxuICAgICAgdmFyIHRoaXNBcmcgPSBhcmd1bWVudHNbMl07XHJcblxyXG4gICAgICB2YXIgYyA9IHN0cmljdCh0aGlzKTtcclxuICAgICAgaWYgKG1hcGZuID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICB2YXIgbWFwcGluZyA9IGZhbHNlO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGlmICghSXNDYWxsYWJsZShtYXBmbikpIHRocm93IFR5cGVFcnJvcigpO1xyXG4gICAgICAgIHZhciB0ID0gdGhpc0FyZztcclxuICAgICAgICBtYXBwaW5nID0gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgICB2YXIgdXNpbmdJdGVyYXRvciA9IEdldE1ldGhvZChpdGVtcywgJCRpdGVyYXRvcik7XHJcbiAgICAgIGlmICh1c2luZ0l0ZXJhdG9yICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgaWYgKElzQ29uc3RydWN0b3IoYykpIHtcclxuICAgICAgICAgIHZhciBhID0gbmV3IGMoKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgYSA9IG5ldyBBcnJheSgwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGl0ZXJhdG9yID0gR2V0SXRlcmF0b3IoaXRlbXMsIHVzaW5nSXRlcmF0b3IpO1xyXG4gICAgICAgIHZhciBrID0gMDtcclxuICAgICAgICB3aGlsZSAodHJ1ZSkge1xyXG4gICAgICAgICAgdmFyIG5leHQgPSBJdGVyYXRvclN0ZXAoaXRlcmF0b3IpO1xyXG4gICAgICAgICAgaWYgKG5leHQgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIGEubGVuZ3RoID0gaztcclxuICAgICAgICAgICAgcmV0dXJuIGE7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICB2YXIgbmV4dFZhbHVlID0gSXRlcmF0b3JWYWx1ZShuZXh0KTtcclxuICAgICAgICAgIGlmIChtYXBwaW5nKVxyXG4gICAgICAgICAgICB2YXIgbWFwcGVkVmFsdWUgPSBtYXBmbi5jYWxsKHQsIG5leHRWYWx1ZSk7XHJcbiAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIG1hcHBlZFZhbHVlID0gbmV4dFZhbHVlO1xyXG4gICAgICAgICAgYVtrXSA9IG1hcHBlZFZhbHVlO1xyXG4gICAgICAgICAgayArPSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICB2YXIgYXJyYXlMaWtlID0gVG9PYmplY3QoaXRlbXMpO1xyXG4gICAgICB2YXIgbGVuVmFsdWUgPSBhcnJheUxpa2UubGVuZ3RoO1xyXG4gICAgICB2YXIgbGVuID0gVG9MZW5ndGgobGVuVmFsdWUpO1xyXG4gICAgICBpZiAoSXNDb25zdHJ1Y3RvcihjKSkge1xyXG4gICAgICAgIGEgPSBuZXcgYyhsZW4pO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGEgPSBuZXcgQXJyYXkobGVuKTtcclxuICAgICAgfVxyXG4gICAgICBrID0gMDtcclxuICAgICAgd2hpbGUgKGsgPCBsZW4pIHtcclxuICAgICAgICB2YXIga1ZhbHVlID0gYXJyYXlMaWtlW2tdO1xyXG4gICAgICAgIGlmIChtYXBwaW5nKVxyXG4gICAgICAgICAgbWFwcGVkVmFsdWUgPSBtYXBmbi5jYWxsKHQsIGtWYWx1ZSwgayk7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgbWFwcGVkVmFsdWUgPSBrVmFsdWU7XHJcbiAgICAgICAgYVtrXSA9IG1hcHBlZFZhbHVlO1xyXG4gICAgICAgIGsgKz0gMTtcclxuICAgICAgfVxyXG4gICAgICBhLmxlbmd0aCA9IGxlbjtcclxuICAgICAgcmV0dXJuIGE7XHJcbiAgICB9KTtcclxuXHJcbiAgLy8gMjIuMS4yLjIgQXJyYXkuaXNBcnJheSAoIGFyZyApXHJcblxyXG4gIC8vIDIyLjEuMi4zIEFycmF5Lm9mICggLi4uaXRlbXMgKVxyXG4gIGRlZmluZShcclxuICAgIEFycmF5LCAnb2YnLFxyXG4gICAgZnVuY3Rpb24gb2YoKSB7XHJcbiAgICAgIHZhciBpdGVtcyA9IGFyZ3VtZW50cztcclxuXHJcbiAgICAgIHZhciBsZW5WYWx1ZSA9IGl0ZW1zLmxlbmd0aDtcclxuICAgICAgdmFyIGxlbiA9IFRvVWludDMyKGxlblZhbHVlKTtcclxuICAgICAgdmFyIGMgPSBzdHJpY3QodGhpcyksIGE7XHJcbiAgICAgIGlmIChJc0NvbnN0cnVjdG9yKGMpKSB7XHJcbiAgICAgICAgYSA9IG5ldyBjKGxlbik7XHJcbiAgICAgICAgYSA9IFRvT2JqZWN0KGEpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGEgPSBuZXcgQXJyYXkobGVuKTtcclxuICAgICAgfVxyXG4gICAgICB2YXIgayA9IDA7XHJcbiAgICAgIHdoaWxlIChrIDwgbGVuKSB7XHJcbiAgICAgICAgYVtrXSA9IGl0ZW1zW2tdO1xyXG4gICAgICAgIGsgKz0gMTtcclxuICAgICAgfVxyXG4gICAgICBhLmxlbmd0aCA9IGxlbjtcclxuICAgICAgcmV0dXJuIGE7XHJcbiAgICB9KTtcclxuXHJcbiAgLy8gMjIuMS4yLjQgQXJyYXkucHJvdG90eXBlXHJcbiAgLy8gMjIuMS4yLjUgZ2V0IEFycmF5IFsgQEBzcGVjaWVzIF1cclxuICAvLyAyMi4xLjMgUHJvcGVydGllcyBvZiB0aGUgQXJyYXkgUHJvdG90eXBlIE9iamVjdFxyXG4gIC8vIDIyLjEuMy4xIEFycmF5LnByb3RvdHlwZS5jb25jYXQgKCAuLi5hcmd1bWVudHMgKVxyXG4gIC8vIDIyLjEuMy4xLjEgUnVudGltZSBTZW1hbnRpY3M6IElzQ29uY2F0U3ByZWFkYWJsZSAoIE8gKVxyXG4gIC8vIDIyLjEuMy4yIEFycmF5LnByb3RvdHlwZS5jb25zdHJ1Y3RvclxyXG4gIC8vIDIyLjEuMy4zIEFycmF5LnByb3RvdHlwZS5jb3B5V2l0aGluICh0YXJnZXQsIHN0YXJ0IFsgLCBlbmQgXSApXHJcbiAgZGVmaW5lKFxyXG4gICAgQXJyYXkucHJvdG90eXBlLCAnY29weVdpdGhpbicsXHJcbiAgICBmdW5jdGlvbiBjb3B5V2l0aGluKHRhcmdldCwgc3RhcnQvKiwgZW5kKi8pIHtcclxuICAgICAgdmFyIGVuZCA9IGFyZ3VtZW50c1syXTtcclxuXHJcbiAgICAgIHZhciBvID0gVG9PYmplY3QodGhpcyk7XHJcbiAgICAgIHZhciBsZW5WYWwgPSBvLmxlbmd0aDtcclxuICAgICAgdmFyIGxlbiA9IFRvTGVuZ3RoKGxlblZhbCk7XHJcbiAgICAgIGxlbiA9IG1heChsZW4sIDApO1xyXG4gICAgICB2YXIgcmVsYXRpdmVUYXJnZXQgPSBUb0ludGVnZXIodGFyZ2V0KTtcclxuICAgICAgdmFyIHRvO1xyXG4gICAgICBpZiAocmVsYXRpdmVUYXJnZXQgPCAwKVxyXG4gICAgICAgIHRvID0gbWF4KGxlbiArIHJlbGF0aXZlVGFyZ2V0LCAwKTtcclxuICAgICAgZWxzZVxyXG4gICAgICAgIHRvID0gbWluKHJlbGF0aXZlVGFyZ2V0LCBsZW4pO1xyXG4gICAgICB2YXIgcmVsYXRpdmVTdGFydCA9IFRvSW50ZWdlcihzdGFydCk7XHJcbiAgICAgIHZhciBmcm9tO1xyXG4gICAgICBpZiAocmVsYXRpdmVTdGFydCA8IDApXHJcbiAgICAgICAgZnJvbSA9IG1heChsZW4gKyByZWxhdGl2ZVN0YXJ0LCAwKTtcclxuICAgICAgZWxzZVxyXG4gICAgICAgIGZyb20gPSBtaW4ocmVsYXRpdmVTdGFydCwgbGVuKTtcclxuICAgICAgdmFyIHJlbGF0aXZlRW5kO1xyXG4gICAgICBpZiAoZW5kID09PSB1bmRlZmluZWQpXHJcbiAgICAgICAgcmVsYXRpdmVFbmQgPSBsZW47XHJcbiAgICAgIGVsc2VcclxuICAgICAgICByZWxhdGl2ZUVuZCA9IFRvSW50ZWdlcihlbmQpO1xyXG4gICAgICB2YXIgZmluYWw7XHJcbiAgICAgIGlmIChyZWxhdGl2ZUVuZCA8IDApXHJcbiAgICAgICAgZmluYWwgPSBtYXgobGVuICsgcmVsYXRpdmVFbmQsIDApO1xyXG4gICAgICBlbHNlXHJcbiAgICAgICAgZmluYWwgPSBtaW4ocmVsYXRpdmVFbmQsIGxlbik7XHJcbiAgICAgIHZhciBjb3VudCA9IG1pbihmaW5hbCAtIGZyb20sIGxlbiAtIHRvKTtcclxuICAgICAgdmFyIGRpcmVjdGlvbjtcclxuICAgICAgaWYgKGZyb20gPCB0byAmJiB0byA8IGZyb20gKyBjb3VudCkge1xyXG4gICAgICAgIGRpcmVjdGlvbiA9IC0xO1xyXG4gICAgICAgIGZyb20gPSBmcm9tICsgY291bnQgLSAxO1xyXG4gICAgICAgIHRvID0gdG8gKyBjb3VudCAtIDE7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZGlyZWN0aW9uID0gMTtcclxuICAgICAgfVxyXG4gICAgICB3aGlsZSAoY291bnQgPiAwKSB7XHJcbiAgICAgICAgdmFyIGZyb21LZXkgPSBTdHJpbmcoZnJvbSk7XHJcbiAgICAgICAgdmFyIHRvS2V5ID0gU3RyaW5nKHRvKTtcclxuICAgICAgICB2YXIgZnJvbVByZXNlbnQgPSBIYXNQcm9wZXJ0eShvLCBmcm9tS2V5KTtcclxuICAgICAgICBpZiAoZnJvbVByZXNlbnQpIHtcclxuICAgICAgICAgIHZhciBmcm9tVmFsID0gb1tmcm9tS2V5XTtcclxuICAgICAgICAgIG9bdG9LZXldID0gZnJvbVZhbDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgZGVsZXRlIG9bdG9LZXldO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmcm9tID0gZnJvbSArIGRpcmVjdGlvbjtcclxuICAgICAgICB0byA9IHRvICsgZGlyZWN0aW9uO1xyXG4gICAgICAgIGNvdW50ID0gY291bnQgLSAxO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBvO1xyXG4gICAgfSk7XHJcblxyXG4gIC8vIDIyLjEuMy40IEFycmF5LnByb3RvdHlwZS5lbnRyaWVzICggKVxyXG4gIHZhciBuYXRpdmVBcnJheUl0ZXJhdG9yTWV0aG9kcyA9XHJcbiAgICAgICAgKCdlbnRyaWVzJyBpbiBBcnJheS5wcm90b3R5cGUgJiYgJ25leHQnIGluIFtdLmVudHJpZXMoKSk7XHJcblxyXG4gIGRlZmluZShcclxuICAgIEFycmF5LnByb3RvdHlwZSwgJ2VudHJpZXMnLFxyXG4gICAgZnVuY3Rpb24gZW50cmllcygpIHtcclxuICAgICAgcmV0dXJuIENyZWF0ZUFycmF5SXRlcmF0b3IodGhpcywgJ2tleSt2YWx1ZScpO1xyXG4gICAgfSwgIW5hdGl2ZUFycmF5SXRlcmF0b3JNZXRob2RzKTtcclxuXHJcbiAgLy8gMjIuMS4zLjUgQXJyYXkucHJvdG90eXBlLmV2ZXJ5ICggY2FsbGJhY2tmbiBbICwgdGhpc0FyZ10gKVxyXG5cclxuICAvLyAyMi4xLjMuNiBBcnJheS5wcm90b3R5cGUuZmlsbCAodmFsdWUgWyAsIHN0YXJ0IFsgLCBlbmQgXSBdIClcclxuICBkZWZpbmUoXHJcbiAgICBBcnJheS5wcm90b3R5cGUsICdmaWxsJyxcclxuICAgIGZ1bmN0aW9uIGZpbGwodmFsdWUvKiwgc3RhcnQsIGVuZCovKSB7XHJcbiAgICAgIHZhciBzdGFydCA9IGFyZ3VtZW50c1sxXSxcclxuICAgICAgICAgIGVuZCA9IGFyZ3VtZW50c1syXTtcclxuXHJcbiAgICAgIHZhciBvID0gVG9PYmplY3QodGhpcyk7XHJcbiAgICAgIHZhciBsZW5WYWwgPSBvLmxlbmd0aDtcclxuICAgICAgdmFyIGxlbiA9IFRvTGVuZ3RoKGxlblZhbCk7XHJcbiAgICAgIGxlbiA9IG1heChsZW4sIDApO1xyXG4gICAgICB2YXIgcmVsYXRpdmVTdGFydCA9IFRvSW50ZWdlcihzdGFydCk7XHJcbiAgICAgIHZhciBrO1xyXG4gICAgICBpZiAocmVsYXRpdmVTdGFydCA8IDApXHJcbiAgICAgICAgayA9IG1heCgobGVuICsgcmVsYXRpdmVTdGFydCksIDApO1xyXG4gICAgICBlbHNlXHJcbiAgICAgICAgayA9IG1pbihyZWxhdGl2ZVN0YXJ0LCBsZW4pO1xyXG4gICAgICB2YXIgcmVsYXRpdmVFbmQ7XHJcbiAgICAgIGlmIChlbmQgPT09IHVuZGVmaW5lZClcclxuICAgICAgICByZWxhdGl2ZUVuZCA9IGxlbjtcclxuICAgICAgZWxzZVxyXG4gICAgICAgIHJlbGF0aXZlRW5kID0gVG9JbnRlZ2VyKGVuZCk7XHJcbiAgICAgIHZhciBmaW5hbDtcclxuICAgICAgaWYgKHJlbGF0aXZlRW5kIDwgMClcclxuICAgICAgICBmaW5hbCA9IG1heCgobGVuICsgcmVsYXRpdmVFbmQpLCAwKTtcclxuICAgICAgZWxzZVxyXG4gICAgICAgIGZpbmFsID0gbWluKHJlbGF0aXZlRW5kLCBsZW4pO1xyXG4gICAgICB3aGlsZSAoayA8IGZpbmFsKSB7XHJcbiAgICAgICAgdmFyIHBrID0gU3RyaW5nKGspO1xyXG4gICAgICAgIG9bcGtdID0gdmFsdWU7XHJcbiAgICAgICAgayArPSAxO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBvO1xyXG4gICAgfSk7XHJcblxyXG4gIC8vIDIyLjEuMy43IEFycmF5LnByb3RvdHlwZS5maWx0ZXIgKCBjYWxsYmFja2ZuIFsgLCB0aGlzQXJnIF0gKVxyXG5cclxuICAvLyAyMi4xLjMuOCBBcnJheS5wcm90b3R5cGUuZmluZCAoIHByZWRpY2F0ZSBbICwgdGhpc0FyZyBdIClcclxuICBkZWZpbmUoXHJcbiAgICBBcnJheS5wcm90b3R5cGUsICdmaW5kJyxcclxuICAgIGZ1bmN0aW9uIGZpbmQocHJlZGljYXRlKSB7XHJcbiAgICAgIHZhciBvID0gVG9PYmplY3QodGhpcyk7XHJcbiAgICAgIHZhciBsZW5WYWx1ZSA9IG8ubGVuZ3RoO1xyXG4gICAgICB2YXIgbGVuID0gVG9JbnRlZ2VyKGxlblZhbHVlKTtcclxuICAgICAgaWYgKCFJc0NhbGxhYmxlKHByZWRpY2F0ZSkpIHRocm93IFR5cGVFcnJvcigpO1xyXG4gICAgICB2YXIgdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkO1xyXG4gICAgICB2YXIgayA9IDA7XHJcbiAgICAgIHdoaWxlIChrIDwgbGVuKSB7XHJcbiAgICAgICAgdmFyIHBrID0gU3RyaW5nKGspO1xyXG4gICAgICAgIHZhciBrUHJlc2VudCA9IEhhc1Byb3BlcnR5KG8sIHBrKTtcclxuICAgICAgICBpZiAoa1ByZXNlbnQpIHtcclxuICAgICAgICAgIHZhciBrVmFsdWUgPSBvW3BrXTtcclxuICAgICAgICAgIHZhciB0ZXN0UmVzdWx0ID0gcHJlZGljYXRlLmNhbGwodCwga1ZhbHVlLCBrLCBvKTtcclxuICAgICAgICAgIGlmIChCb29sZWFuKHRlc3RSZXN1bHQpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBrVmFsdWU7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgICsraztcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgfSk7XHJcblxyXG4gIC8vIDIyLjEuMy45IEFycmF5LnByb3RvdHlwZS5maW5kSW5kZXggKCBwcmVkaWNhdGUgWyAsIHRoaXNBcmcgXSApXHJcbiAgZGVmaW5lKFxyXG4gICAgQXJyYXkucHJvdG90eXBlLCAnZmluZEluZGV4JyxcclxuICAgIGZ1bmN0aW9uIGZpbmRJbmRleChwcmVkaWNhdGUpIHtcclxuICAgICAgdmFyIG8gPSBUb09iamVjdCh0aGlzKTtcclxuICAgICAgdmFyIGxlblZhbHVlID0gby5sZW5ndGg7XHJcbiAgICAgIHZhciBsZW4gPSBUb0xlbmd0aChsZW5WYWx1ZSk7XHJcbiAgICAgIGlmICghSXNDYWxsYWJsZShwcmVkaWNhdGUpKSB0aHJvdyBUeXBlRXJyb3IoKTtcclxuICAgICAgdmFyIHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZDtcclxuICAgICAgdmFyIGsgPSAwO1xyXG4gICAgICB3aGlsZSAoayA8IGxlbikge1xyXG4gICAgICAgIHZhciBwayA9IFN0cmluZyhrKTtcclxuICAgICAgICB2YXIga1ByZXNlbnQgPSBIYXNQcm9wZXJ0eShvLCBwayk7XHJcbiAgICAgICAgaWYgKGtQcmVzZW50KSB7XHJcbiAgICAgICAgICB2YXIga1ZhbHVlID0gb1twa107XHJcbiAgICAgICAgICB2YXIgdGVzdFJlc3VsdCA9IHByZWRpY2F0ZS5jYWxsKHQsIGtWYWx1ZSwgaywgbyk7XHJcbiAgICAgICAgICBpZiAoQm9vbGVhbih0ZXN0UmVzdWx0KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gaztcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgKytrO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiAtMTtcclxuICAgIH0pO1xyXG5cclxuICAvLyAyMi4xLjMuMTAgQXJyYXkucHJvdG90eXBlLmZvckVhY2ggKCBjYWxsYmFja2ZuIFsgLCB0aGlzQXJnIF0gKVxyXG4gIC8vIDIyLjEuMy4xMSBBcnJheS5wcm90b3R5cGUuaW5kZXhPZiAoIHNlYXJjaEVsZW1lbnQgWyAsIGZyb21JbmRleCBdIClcclxuICAvLyAyMi4xLjMuMTIgQXJyYXkucHJvdG90eXBlLmpvaW4gKHNlcGFyYXRvcilcclxuXHJcbiAgLy8gMjIuMS4zLjEzIEFycmF5LnByb3RvdHlwZS5rZXlzICggKVxyXG4gIGRlZmluZShcclxuICAgIEFycmF5LnByb3RvdHlwZSwgJ2tleXMnLFxyXG4gICAgZnVuY3Rpb24ga2V5cygpIHtcclxuICAgICAgcmV0dXJuIENyZWF0ZUFycmF5SXRlcmF0b3IodGhpcywgJ2tleScpO1xyXG4gICAgfSwgIW5hdGl2ZUFycmF5SXRlcmF0b3JNZXRob2RzKTtcclxuXHJcbiAgLy8gMjIuMS4zLjE0IEFycmF5LnByb3RvdHlwZS5sYXN0SW5kZXhPZiAoIHNlYXJjaEVsZW1lbnQgWyAsIGZyb21JbmRleCBdIClcclxuICAvLyAyMi4xLjMuMTUgQXJyYXkucHJvdG90eXBlLm1hcCAoIGNhbGxiYWNrZm4gWyAsIHRoaXNBcmcgXSApXHJcbiAgLy8gMjIuMS4zLjE2IEFycmF5LnByb3RvdHlwZS5wb3AgKCApXHJcbiAgLy8gMjIuMS4zLjE3IEFycmF5LnByb3RvdHlwZS5wdXNoICggLi4uaXRlbXMgKVxyXG4gIC8vIDIyLjEuMy4xOCBBcnJheS5wcm90b3R5cGUucmVkdWNlICggY2FsbGJhY2tmbiBbICwgaW5pdGlhbFZhbHVlIF0gKVxyXG4gIC8vIDIyLjEuMy4xOSBBcnJheS5wcm90b3R5cGUucmVkdWNlUmlnaHQgKCBjYWxsYmFja2ZuIFsgLCBpbml0aWFsVmFsdWUgXSApXHJcbiAgLy8gMjIuMS4zLjIwIEFycmF5LnByb3RvdHlwZS5yZXZlcnNlICggKVxyXG4gIC8vIDIyLjEuMy4yMSBBcnJheS5wcm90b3R5cGUuc2hpZnQgKCApXHJcbiAgLy8gMjIuMS4zLjIyIEFycmF5LnByb3RvdHlwZS5zbGljZSAoc3RhcnQsIGVuZClcclxuICAvLyAyMi4xLjMuMjMgQXJyYXkucHJvdG90eXBlLnNvbWUgKCBjYWxsYmFja2ZuIFsgLCB0aGlzQXJnIF0gKVxyXG4gIC8vIDIyLjEuMy4yNCBBcnJheS5wcm90b3R5cGUuc29ydCAoY29tcGFyZWZuKVxyXG4gIC8vIDIyLjEuMy4yNSBBcnJheS5wcm90b3R5cGUuc3BsaWNlIChzdGFydCwgZGVsZXRlQ291bnQgLCAuLi5pdGVtcyApXHJcbiAgLy8gMjIuMS4zLjI2IEFycmF5LnByb3RvdHlwZS50b0xvY2FsZVN0cmluZyAoIFsgcmVzZXJ2ZWQxIFsgLCByZXNlcnZlZDIgXSBdIClcclxuICAvLyAyMi4xLjMuMjcgQXJyYXkucHJvdG90eXBlLnRvU3RyaW5nICggKVxyXG4gIC8vIDIyLjEuMy4yOCBBcnJheS5wcm90b3R5cGUudW5zaGlmdCAoIC4uLml0ZW1zIClcclxuXHJcbiAgLy8gMjIuMS4zLjI5IEFycmF5LnByb3RvdHlwZS52YWx1ZXMgKCApXHJcbiAgZGVmaW5lKFxyXG4gICAgQXJyYXkucHJvdG90eXBlLCAndmFsdWVzJyxcclxuICAgIGZ1bmN0aW9uIHZhbHVlcygpIHtcclxuICAgICAgcmV0dXJuIENyZWF0ZUFycmF5SXRlcmF0b3IodGhpcywgJ3ZhbHVlJyk7XHJcbiAgICB9LCAhbmF0aXZlQXJyYXlJdGVyYXRvck1ldGhvZHMpO1xyXG5cclxuICAvLyAyMi4xLjMuMzAgQXJyYXkucHJvdG90eXBlIFsgQEBpdGVyYXRvciBdICggKVxyXG4gIGRlZmluZShcclxuICAgIEFycmF5LnByb3RvdHlwZSwgJCRpdGVyYXRvcixcclxuICAgIEFycmF5LnByb3RvdHlwZS52YWx1ZXNcclxuICAgICk7XHJcblxyXG4gIC8vIDIyLjEuMy4zMSBBcnJheS5wcm90b3R5cGUgWyBAQHVuc2NvcGFibGVzIF1cclxuICAvLyAyMi4xLjQgUHJvcGVydGllcyBvZiBBcnJheSBJbnN0YW5jZXNcclxuICAvLyAyMi4xLjQuMSBsZW5ndGhcclxuXHJcbiAgLy8gMjIuMS41IEFycmF5IEl0ZXJhdG9yIE9iamVjdHNcclxuICBmdW5jdGlvbiBBcnJheUl0ZXJhdG9yKCkge31cclxuXHJcbiAgLy8gMjIuMS41LjEgQ3JlYXRlQXJyYXlJdGVyYXRvciBBYnN0cmFjdCBPcGVyYXRpb25cclxuICBmdW5jdGlvbiBDcmVhdGVBcnJheUl0ZXJhdG9yKGFycmF5LCBraW5kKSB7XHJcbiAgICB2YXIgbyA9IFRvT2JqZWN0KGFycmF5KTtcclxuICAgIHZhciBpdGVyYXRvciA9IG5ldyBBcnJheUl0ZXJhdG9yO1xyXG4gICAgc2V0X2ludGVybmFsKGl0ZXJhdG9yLCAnW1tJdGVyYXRlZE9iamVjdF1dJywgbyk7XHJcbiAgICBzZXRfaW50ZXJuYWwoaXRlcmF0b3IsICdbW0FycmF5SXRlcmF0b3JOZXh0SW5kZXhdXScsIDApO1xyXG4gICAgc2V0X2ludGVybmFsKGl0ZXJhdG9yLCAnW1tBcnJheUl0ZXJhdGlvbktpbmRdXScsIGtpbmQpO1xyXG4gICAgcmV0dXJuIGl0ZXJhdG9yO1xyXG4gIH1cclxuXHJcbiAgLy8gMjIuMS41LjIgVGhlICVBcnJheUl0ZXJhdG9yUHJvdG90eXBlJSBPYmplY3RcclxuICB2YXIgJEFycmF5SXRlcmF0b3JQcm90b3R5cGUkID0gT2JqZWN0LmNyZWF0ZSgkSXRlcmF0b3JQcm90b3R5cGUkKTtcclxuICBBcnJheUl0ZXJhdG9yLnByb3RvdHlwZSA9ICRBcnJheUl0ZXJhdG9yUHJvdG90eXBlJDtcclxuXHJcbiAgLy8gMjIuMS41LjIuMSAlQXJyYXlJdGVyYXRvclByb3RvdHlwZSUuIG5leHQoIClcclxuICBkZWZpbmUoXHJcbiAgICAkQXJyYXlJdGVyYXRvclByb3RvdHlwZSQsICduZXh0JyxcclxuICAgIGZ1bmN0aW9uIG5leHQoKSB7XHJcbiAgICAgIHZhciBvID0gc3RyaWN0KHRoaXMpO1xyXG4gICAgICBpZiAoVHlwZShvKSAhPT0gJ29iamVjdCcpIHRocm93IFR5cGVFcnJvcigpO1xyXG4gICAgICB2YXIgYSA9IG9bJ1tbSXRlcmF0ZWRPYmplY3RdXSddLFxyXG4gICAgICAgICAgaW5kZXggPSBvWydbW0FycmF5SXRlcmF0b3JOZXh0SW5kZXhdXSddLFxyXG4gICAgICAgICAgaXRlbUtpbmQgPSBvWydbW0FycmF5SXRlcmF0aW9uS2luZF1dJ10sXHJcbiAgICAgICAgICBsZW5WYWx1ZSA9IGEubGVuZ3RoLFxyXG4gICAgICAgICAgbGVuID0gVG9VaW50MzIobGVuVmFsdWUpLFxyXG4gICAgICAgICAgZWxlbWVudEtleSxcclxuICAgICAgICAgIGVsZW1lbnRWYWx1ZTtcclxuICAgICAgaWYgKGl0ZW1LaW5kLmluZGV4T2YoJ3NwYXJzZScpICE9PSAtMSkge1xyXG4gICAgICAgIHZhciBmb3VuZCA9IGZhbHNlO1xyXG4gICAgICAgIHdoaWxlICghZm91bmQgJiYgaW5kZXggPCBsZW4pIHtcclxuICAgICAgICAgIGVsZW1lbnRLZXkgPSBTdHJpbmcoaW5kZXgpO1xyXG4gICAgICAgICAgZm91bmQgPSBIYXNQcm9wZXJ0eShhLCBlbGVtZW50S2V5KTtcclxuICAgICAgICAgIGlmICghZm91bmQpIHtcclxuICAgICAgICAgICAgaW5kZXggKz0gMTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGluZGV4ID49IGxlbikge1xyXG4gICAgICAgIHNldF9pbnRlcm5hbChvLCAnW1tBcnJheUl0ZXJhdG9yTmV4dEluZGV4XV0nLCBJbmZpbml0eSk7XHJcbiAgICAgICAgcmV0dXJuIENyZWF0ZUl0ZXJSZXN1bHRPYmplY3QodW5kZWZpbmVkLCB0cnVlKTtcclxuICAgICAgfVxyXG4gICAgICBlbGVtZW50S2V5ID0gaW5kZXg7XHJcbiAgICAgIHNldF9pbnRlcm5hbChvLCAnW1tBcnJheUl0ZXJhdG9yTmV4dEluZGV4XV0nLCBpbmRleCArIDEpO1xyXG4gICAgICBpZiAoaXRlbUtpbmQuaW5kZXhPZigndmFsdWUnKSAhPT0gLTEpXHJcbiAgICAgICAgZWxlbWVudFZhbHVlID0gYVtlbGVtZW50S2V5XTtcclxuICAgICAgaWYgKGl0ZW1LaW5kLmluZGV4T2YoJ2tleSt2YWx1ZScpICE9PSAtMSlcclxuICAgICAgICByZXR1cm4gQ3JlYXRlSXRlclJlc3VsdE9iamVjdChbZWxlbWVudEtleSwgZWxlbWVudFZhbHVlXSwgZmFsc2UpO1xyXG4gICAgICBpZiAoaXRlbUtpbmQuaW5kZXhPZigna2V5JykgIT09IC0xKVxyXG4gICAgICAgIHJldHVybiBDcmVhdGVJdGVyUmVzdWx0T2JqZWN0KGVsZW1lbnRLZXksIGZhbHNlKTtcclxuICAgICAgaWYgKGl0ZW1LaW5kID09PSAndmFsdWUnKVxyXG4gICAgICAgIHJldHVybiBDcmVhdGVJdGVyUmVzdWx0T2JqZWN0KGVsZW1lbnRWYWx1ZSwgZmFsc2UpO1xyXG4gICAgICB0aHJvdyBFcnJvcignSW50ZXJuYWwgZXJyb3InKTtcclxuICAgIH0pO1xyXG5cclxuICAvLyAyMi4xLjUuMi4yICVBcnJheUl0ZXJhdG9yUHJvdG90eXBlJSBbIEBAdG9TdHJpbmdUYWcgXVxyXG4gIGRlZmluZSgkQXJyYXlJdGVyYXRvclByb3RvdHlwZSQsICQkdG9TdHJpbmdUYWcsICdBcnJheSBJdGVyYXRvcicpO1xyXG5cclxuICAvLyAyMi4xLjUuMyBQcm9wZXJ0aWVzIG9mIEFycmF5IEl0ZXJhdG9yIEluc3RhbmNlc1xyXG5cclxuXHJcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgLy8gMjIuMiBUeXBlZEFycmF5IE9iamVjdHNcclxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcbiAgLy8gU2VlIHR5cGVkYXJyYXkuanMgZm9yIFR5cGVkQXJyYXkgcG9seWZpbGxcclxuXHJcbiAgWydJbnQ4QXJyYXknLCAnVWludDhBcnJheScsICdVaW50OENsYW1wZWRBcnJheScsXHJcbiAgICdJbnQxNkFycmF5JywgJ1VpbnQxNkFycmF5JyxcclxuICAgJ0ludDMyQXJyYXknLCAnVWludDMyQXJyYXknLFxyXG4gICAnRmxvYXQzMkFycmF5JywgJ0Zsb2F0NjRBcnJheSddLmZvckVhY2goZnVuY3Rpb24gKCRUeXBlZEFycmF5TmFtZSQpIHtcclxuICAgICBpZiAoISgkVHlwZWRBcnJheU5hbWUkIGluIGdsb2JhbCkpXHJcbiAgICAgICByZXR1cm47XHJcbiAgICAgdmFyICRUeXBlZEFycmF5JCA9IGdsb2JhbFskVHlwZWRBcnJheU5hbWUkXTtcclxuXHJcbiAgICAgLy8gMjIuMi4xIFRoZSAlVHlwZWRBcnJheSUgSW50cmluc2ljIE9iamVjdFxyXG4gICAgIC8vIDIyLjIuMS4xICVUeXBlZEFycmF5JSAoIGxlbmd0aCApXHJcbiAgICAgLy8gMjIuMi4xLjIgJVR5cGVkQXJyYXklICggdHlwZWRBcnJheSApXHJcbiAgICAgLy8gMjIuMi4xLjMgJVR5cGVkQXJyYXklICggb2JqZWN0IClcclxuICAgICAvLyAyMi4yLjEuNCAlVHlwZWRBcnJheSUgKCBidWZmZXIgWyAsIGJ5dGVPZmZzZXQgWyAsIGxlbmd0aCBdIF0gKVxyXG4gICAgIC8vIDIyLjIuMS41ICVUeXBlZEFycmF5JSAoIGFsbCBvdGhlciBhcmd1bWVudCBjb21iaW5hdGlvbnMgKVxyXG4gICAgIC8vIDIyLjIuMiBQcm9wZXJ0aWVzIG9mIHRoZSAlVHlwZWRBcnJheSUgSW50cmluc2ljIE9iamVjdFxyXG5cclxuICAgICAvLyAyMi4yLjIuMSAlVHlwZWRBcnJheSUuZnJvbSAoIHNvdXJjZSBbICwgbWFwZm4gWyAsIHRoaXNBcmcgXSBdIClcclxuICAgICBkZWZpbmUoXHJcbiAgICAgICAkVHlwZWRBcnJheSQsICdmcm9tJyxcclxuICAgICAgIGZ1bmN0aW9uIGZyb20oc291cmNlKSB7XHJcbiAgICAgICAgIHZhciBtYXBmbiA9IGFyZ3VtZW50c1sxXTtcclxuICAgICAgICAgdmFyIHRoaXNBcmcgPSBhcmd1bWVudHNbMl07XHJcblxyXG4gICAgICAgICB2YXIgYyA9IHN0cmljdCh0aGlzKTtcclxuICAgICAgICAgaWYgKCFJc0NvbnN0cnVjdG9yKGMpKSB0aHJvdyBUeXBlRXJyb3IoKTtcclxuICAgICAgICAgaWYgKG1hcGZuID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICB2YXIgbWFwcGluZyA9IGZhbHNlO1xyXG4gICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgIGlmIChJc0NhbGxhYmxlKG1hcGZuKSkgdGhyb3cgVHlwZUVycm9yKCk7XHJcbiAgICAgICAgICAgdmFyIHQgPSB0aGlzQXJnO1xyXG4gICAgICAgICAgIG1hcHBpbmcgPSB0cnVlO1xyXG4gICAgICAgICB9XHJcbiAgICAgICAgIHZhciB1c2luZ0l0ZXJhdG9yID0gR2V0TWV0aG9kKHNvdXJjZSwgJCRpdGVyYXRvcik7XHJcbiAgICAgICAgIGlmICh1c2luZ0l0ZXJhdG9yICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICB2YXIgaXRlcmF0b3IgPSBHZXRJdGVyYXRvcihzb3VyY2UsIHVzaW5nSXRlcmF0b3IpO1xyXG4gICAgICAgICAgIHZhciB2YWx1ZXMgPSBbXTtcclxuICAgICAgICAgICB2YXIgbmV4dCA9IHRydWU7XHJcbiAgICAgICAgICAgd2hpbGUgKG5leHQgIT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICBuZXh0ID0gSXRlcmF0b3JTdGVwKGl0ZXJhdG9yKTtcclxuICAgICAgICAgICAgIGlmIChuZXh0ICE9PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICB2YXIgbmV4dFZhbHVlID0gSXRlcmF0b3JWYWx1ZShuZXh0KTtcclxuICAgICAgICAgICAgICAgdmFsdWVzLnB1c2gobmV4dFZhbHVlKTtcclxuICAgICAgICAgICAgIH1cclxuICAgICAgICAgICB9XHJcbiAgICAgICAgICAgdmFyIGxlbiA9IHZhbHVlcy5sZW5ndGg7XHJcbiAgICAgICAgICAgdmFyIG5ld09iaiA9IG5ldyBjKGxlbik7XHJcbiAgICAgICAgICAgdmFyIGsgPSAwO1xyXG4gICAgICAgICAgIHdoaWxlIChrIDwgbGVuKSB7XHJcbiAgICAgICAgICAgICB2YXIga1ZhbHVlID0gdmFsdWVzLnNoaWZ0KCk7XHJcbiAgICAgICAgICAgICBpZiAobWFwcGluZykge1xyXG4gICAgICAgICAgICAgICB2YXIgbWFwcGVkVmFsdWUgPSBtYXBmbi5jYWxsKHQsIGtWYWx1ZSk7XHJcbiAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICBtYXBwZWRWYWx1ZSA9IGtWYWx1ZTtcclxuICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgIG5ld09ialtrXSA9IG1hcHBlZFZhbHVlO1xyXG4gICAgICAgICAgICAgKytrO1xyXG4gICAgICAgICAgIH1cclxuICAgICAgICAgICBjb25zb2xlLmFzc2VydCh2YWx1ZXMubGVuZ3RoID09PSAwKTtcclxuICAgICAgICAgICByZXR1cm4gbmV3T2JqO1xyXG4gICAgICAgICB9XHJcbiAgICAgICAgIHZhciBhcnJheUxpa2UgPSBUb09iamVjdChzb3VyY2UpO1xyXG4gICAgICAgICB2YXIgbGVuVmFsdWUgPSBhcnJheUxpa2UubGVuZ3RoO1xyXG4gICAgICAgICBsZW4gPSBUb0xlbmd0aChsZW5WYWx1ZSk7XHJcbiAgICAgICAgIG5ld09iaiA9IG5ldyBjKGxlbik7XHJcbiAgICAgICAgIGsgPSAwO1xyXG4gICAgICAgICB3aGlsZSAoayA8IGxlbikge1xyXG4gICAgICAgICAgIGtWYWx1ZSA9IGFycmF5TGlrZVtrXTtcclxuICAgICAgICAgICBpZiAobWFwcGluZykge1xyXG4gICAgICAgICAgICAgbWFwcGVkVmFsdWUgPSBtYXBmbi5jYWxsKHQsIGtWYWx1ZSwgayk7XHJcbiAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgIG1hcHBlZFZhbHVlID0ga1ZhbHVlO1xyXG4gICAgICAgICAgIH1cclxuICAgICAgICAgICBuZXdPYmpba10gPSBtYXBwZWRWYWx1ZTtcclxuICAgICAgICAgICArK2s7XHJcbiAgICAgICAgIH1cclxuICAgICAgICAgcmV0dXJuIG5ld09iajtcclxuICAgICAgIH0pO1xyXG5cclxuICAgICAvLyAyMi4yLjIuMiAlVHlwZWRBcnJheSUub2YgKCAuLi5pdGVtcyApXHJcbiAgICAgZGVmaW5lKFxyXG4gICAgICAgJFR5cGVkQXJyYXkkLCAnb2YnLFxyXG4gICAgICAgZnVuY3Rpb24gb2YoKSB7XHJcbiAgICAgICAgIHZhciBpdGVtcyA9IGFyZ3VtZW50cztcclxuXHJcbiAgICAgICAgIHZhciBsZW4gPSBpdGVtcy5sZW5ndGg7XHJcbiAgICAgICAgIHZhciBjID0gc3RyaWN0KHRoaXMpO1xyXG4gICAgICAgICB2YXIgbmV3T2JqID0gbmV3IGMobGVuKTtcclxuICAgICAgICAgdmFyIGsgPSAwO1xyXG4gICAgICAgICB3aGlsZSAoayA8IGxlbikge1xyXG4gICAgICAgICAgIG5ld09ialtrXSA9IGl0ZW1zW2tdO1xyXG4gICAgICAgICAgICsraztcclxuICAgICAgICAgfVxyXG4gICAgICAgICByZXR1cm4gbmV3T2JqO1xyXG4gICAgICAgfSk7XHJcblxyXG4gICAgIC8vIDIyLjIuMi4zICVUeXBlZEFycmF5JS5wcm90b3R5cGVcclxuICAgICAvLyAyMi4yLjIuNCBnZXQgJVR5cGVkQXJyYXklIFsgQEBzcGVjaWVzIF1cclxuICAgICAvLyAyMi4yLjMgUHJvcGVydGllcyBvZiB0aGUgJVR5cGVkQXJyYXlQcm90b3R5cGUlIE9iamVjdFxyXG4gICAgIC8vIDIyLjIuMy4xIGdldCAlVHlwZWRBcnJheSUucHJvdG90eXBlLmJ1ZmZlclxyXG4gICAgIC8vIDIyLjIuMy4yIGdldCAlVHlwZWRBcnJheSUucHJvdG90eXBlLmJ5dGVMZW5ndGhcclxuICAgICAvLyAyMi4yLjMuMyBnZXQgJVR5cGVkQXJyYXklLnByb3RvdHlwZS5ieXRlT2Zmc2V0XHJcbiAgICAgLy8gMjIuMi4zLjQgJVR5cGVkQXJyYXklLnByb3RvdHlwZS5jb25zdHJ1Y3RvclxyXG5cclxuICAgICAvLyAyMi4yLjMuNSAlVHlwZWRBcnJheSUucHJvdG90eXBlLmNvcHlXaXRoaW4gKHRhcmdldCwgc3RhcnQgWywgZW5kIF0gKVxyXG4gICAgIGRlZmluZSgkVHlwZWRBcnJheSQucHJvdG90eXBlLCAnY29weVdpdGhpbicsIEFycmF5LnByb3RvdHlwZS5jb3B5V2l0aGluKTtcclxuXHJcbiAgICAgLy8gMjIuMi4zLjYgJVR5cGVkQXJyYXklLnByb3RvdHlwZS5lbnRyaWVzICggKVxyXG4gICAgIGRlZmluZSgkVHlwZWRBcnJheSQucHJvdG90eXBlLCAnZW50cmllcycsIEFycmF5LnByb3RvdHlwZS5lbnRyaWVzKTtcclxuXHJcbiAgICAgLy8gMjIuMi4zLjcgJVR5cGVkQXJyYXklLnByb3RvdHlwZS5ldmVyeSAoIGNhbGxiYWNrZm4gWyAsIHRoaXNBcmcgXSApXHJcbiAgICAgZGVmaW5lKCRUeXBlZEFycmF5JC5wcm90b3R5cGUsICdldmVyeScsIEFycmF5LnByb3RvdHlwZS5ldmVyeSk7XHJcblxyXG4gICAgIC8vIDIyLjIuMy44ICVUeXBlZEFycmF5JS5wcm90b3R5cGUuZmlsbCAodmFsdWUgWyAsIHN0YXJ0IFsgLCBlbmQgXSBdIClcclxuICAgICBkZWZpbmUoXHJcbiAgICAgICAkVHlwZWRBcnJheSQucHJvdG90eXBlLCAnZmlsbCcsXHJcbiAgICAgICAvL0FycmF5LnByb3RvdHlwZS5maWxsIC8vIERvZXNuJ3Qgd29yayBpbiBTYWZhcmkgN1xyXG4gICAgICAgZnVuY3Rpb24gZmlsbCh2YWx1ZS8qLCBzdGFydCwgZW5kKi8pIHtcclxuICAgICAgICAgdmFyIHN0YXJ0ID0gYXJndW1lbnRzWzFdLFxyXG4gICAgICAgICAgICAgZW5kID0gYXJndW1lbnRzWzJdO1xyXG5cclxuICAgICAgICAgdmFyIG8gPSBUb09iamVjdCh0aGlzKTtcclxuICAgICAgICAgdmFyIGxlblZhbCA9IG8ubGVuZ3RoO1xyXG4gICAgICAgICB2YXIgbGVuID0gVG9MZW5ndGgobGVuVmFsKTtcclxuICAgICAgICAgbGVuID0gbWF4KGxlbiwgMCk7XHJcbiAgICAgICAgIHZhciByZWxhdGl2ZVN0YXJ0ID0gVG9JbnRlZ2VyKHN0YXJ0KTtcclxuICAgICAgICAgdmFyIGs7XHJcbiAgICAgICAgIGlmIChyZWxhdGl2ZVN0YXJ0IDwgMCkgayA9IG1heCgobGVuICsgcmVsYXRpdmVTdGFydCksIDApO1xyXG4gICAgICAgICBlbHNlIGsgPSBtaW4ocmVsYXRpdmVTdGFydCwgbGVuKTtcclxuICAgICAgICAgdmFyIHJlbGF0aXZlRW5kO1xyXG4gICAgICAgICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHJlbGF0aXZlRW5kID0gbGVuO1xyXG4gICAgICAgICBlbHNlIHJlbGF0aXZlRW5kID0gVG9JbnRlZ2VyKGVuZCk7XHJcbiAgICAgICAgIHZhciBmaW5hbDtcclxuICAgICAgICAgaWYgKHJlbGF0aXZlRW5kIDwgMCkgZmluYWwgPSBtYXgoKGxlbiArIHJlbGF0aXZlRW5kKSwgMCk7XHJcbiAgICAgICAgIGVsc2UgZmluYWwgPSBtaW4ocmVsYXRpdmVFbmQsIGxlbik7XHJcbiAgICAgICAgIHdoaWxlIChrIDwgZmluYWwpIHtcclxuICAgICAgICAgICB2YXIgcGsgPSBTdHJpbmcoayk7XHJcbiAgICAgICAgICAgb1twa10gPSB2YWx1ZTtcclxuICAgICAgICAgICBrICs9IDE7XHJcbiAgICAgICAgIH1cclxuICAgICAgICAgcmV0dXJuIG87XHJcbiAgICAgICB9KTtcclxuXHJcbiAgICAgLy8gMjIuMi4zLjkgJVR5cGVkQXJyYXklLnByb3RvdHlwZS5maWx0ZXIgKCBjYWxsYmFja2ZuIFsgLCB0aGlzQXJnIF0gKVxyXG4gICAgIGRlZmluZShcclxuICAgICAgICRUeXBlZEFycmF5JC5wcm90b3R5cGUsICdmaWx0ZXInLFxyXG4gICAgICAgZnVuY3Rpb24gZmlsdGVyKGNhbGxiYWNrZm4pIHtcclxuICAgICAgICAgdmFyIHRoaXNBcmcgPSBhcmd1bWVudHNbMV07XHJcblxyXG4gICAgICAgICB2YXIgbyA9IFRvT2JqZWN0KHRoaXMpO1xyXG4gICAgICAgICB2YXIgbGVuVmFsID0gby5sZW5ndGg7XHJcbiAgICAgICAgIHZhciBsZW4gPSBUb0xlbmd0aChsZW5WYWwpO1xyXG4gICAgICAgICBpZiAoIUlzQ2FsbGFibGUoY2FsbGJhY2tmbikpIHRocm93IFR5cGVFcnJvcigpO1xyXG4gICAgICAgICB2YXIgdCA9IHRoaXNBcmc7XHJcbiAgICAgICAgIHZhciBjID0gby5jb25zdHJ1Y3RvcjtcclxuICAgICAgICAgdmFyIGtlcHQgPSBbXTtcclxuICAgICAgICAgdmFyIGsgPSAwO1xyXG4gICAgICAgICB2YXIgY2FwdHVyZWQgPSAwO1xyXG4gICAgICAgICB3aGlsZSAoayA8IGxlbikge1xyXG4gICAgICAgICAgIHZhciBrVmFsdWUgPSBvW2tdO1xyXG4gICAgICAgICAgIHZhciBzZWxlY3RlZCA9IGNhbGxiYWNrZm4uY2FsbCh0LCBrVmFsdWUsIGssIG8pO1xyXG4gICAgICAgICAgIGlmIChzZWxlY3RlZCkge1xyXG4gICAgICAgICAgICAga2VwdC5wdXNoKGtWYWx1ZSk7XHJcbiAgICAgICAgICAgICArK2NhcHR1cmVkO1xyXG4gICAgICAgICAgIH1cclxuICAgICAgICAgICArK2s7XHJcbiAgICAgICAgIH1cclxuICAgICAgICAgdmFyIGEgPSBuZXcgYyhjYXB0dXJlZCk7XHJcbiAgICAgICAgIHZhciBuID0gMDtcclxuICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXB0Lmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgdmFyIGUgPSBrZXB0W2ldO1xyXG4gICAgICAgICAgIGFbbl0gPSBlO1xyXG4gICAgICAgICAgICsrbjtcclxuICAgICAgICAgfVxyXG4gICAgICAgICByZXR1cm4gYTtcclxuICAgICAgIH0pO1xyXG5cclxuICAgICAvLyAyMi4yLjMuMTAgJVR5cGVkQXJyYXklLnByb3RvdHlwZS5maW5kIChwcmVkaWNhdGUgWyAsIHRoaXNBcmcgXSApXHJcbiAgICAgZGVmaW5lKCRUeXBlZEFycmF5JC5wcm90b3R5cGUsICdmaW5kJywgQXJyYXkucHJvdG90eXBlLmZpbmQpO1xyXG5cclxuICAgICAvLyAyMi4yLjMuMTEgJVR5cGVkQXJyYXklLnByb3RvdHlwZS5maW5kSW5kZXggKCBwcmVkaWNhdGUgWyAsIHRoaXNBcmcgXSApXHJcbiAgICAgZGVmaW5lKCRUeXBlZEFycmF5JC5wcm90b3R5cGUsICdmaW5kSW5kZXgnLCBBcnJheS5wcm90b3R5cGUuZmluZEluZGV4KTtcclxuXHJcbiAgICAgLy8gMjIuMi4zLjEyICVUeXBlZEFycmF5JS5wcm90b3R5cGUuZm9yRWFjaCAoIGNhbGxiYWNrZm4gWyAsIHRoaXNBcmcgXSApXHJcbiAgICAgZGVmaW5lKCRUeXBlZEFycmF5JC5wcm90b3R5cGUsICdmb3JFYWNoJywgQXJyYXkucHJvdG90eXBlLmZvckVhY2gpO1xyXG5cclxuICAgICAvLyAyMi4yLjMuMTMgJVR5cGVkQXJyYXklLnByb3RvdHlwZS5pbmRleE9mIChzZWFyY2hFbGVtZW50IFsgLCBmcm9tSW5kZXggXSApXHJcbiAgICAgZGVmaW5lKCRUeXBlZEFycmF5JC5wcm90b3R5cGUsICdpbmRleE9mJywgQXJyYXkucHJvdG90eXBlLmluZGV4T2YpO1xyXG5cclxuICAgICAvLyAyMi4yLjMuMTQgJVR5cGVkQXJyYXklLnByb3RvdHlwZS5qb2luICggc2VwYXJhdG9yIClcclxuICAgICBkZWZpbmUoJFR5cGVkQXJyYXkkLnByb3RvdHlwZSwgJ2pvaW4nLCBBcnJheS5wcm90b3R5cGUuam9pbik7XHJcblxyXG4gICAgIC8vIDIyLjIuMy4xNSAlVHlwZWRBcnJheSUucHJvdG90eXBlLmtleXMgKCApXHJcbiAgICAgZGVmaW5lKCRUeXBlZEFycmF5JC5wcm90b3R5cGUsICdrZXlzJywgQXJyYXkucHJvdG90eXBlLmtleXMpO1xyXG5cclxuICAgICAvLyAyMi4yLjMuMTYgJVR5cGVkQXJyYXklLnByb3RvdHlwZS5sYXN0SW5kZXhPZiAoIHNlYXJjaEVsZW1lbnQgWyAsIGZyb21JbmRleCBdIClcclxuICAgICBkZWZpbmUoJFR5cGVkQXJyYXkkLnByb3RvdHlwZSwgJ2xhc3RJbmRleE9mJywgQXJyYXkucHJvdG90eXBlLmxhc3RJbmRleE9mKTtcclxuXHJcbiAgICAgLy8gMjIuMi4zLjE3IGdldCAlVHlwZWRBcnJheSUucHJvdG90eXBlLmxlbmd0aFxyXG5cclxuICAgICAvLyAyMi4yLjMuMTggJVR5cGVkQXJyYXklLnByb3RvdHlwZS5tYXAgKCBjYWxsYmFja2ZuIFsgLCB0aGlzQXJnIF0gKVxyXG4gICAgIGRlZmluZShcclxuICAgICAgICRUeXBlZEFycmF5JC5wcm90b3R5cGUsICdtYXAnLFxyXG4gICAgICAgZnVuY3Rpb24gbWFwKGNhbGxiYWNrZm4pIHtcclxuICAgICAgICAgdmFyIHRoaXNBcmcgPSBhcmd1bWVudHNbMV07XHJcblxyXG4gICAgICAgICB2YXIgbyA9IFRvT2JqZWN0KHRoaXMpO1xyXG4gICAgICAgICB2YXIgbGVuVmFsdWUgPSBvLmxlbmd0aDtcclxuICAgICAgICAgdmFyIGxlbiA9IFRvTGVuZ3RoKGxlblZhbHVlKTtcclxuICAgICAgICAgaWYgKCFJc0NhbGxhYmxlKGNhbGxiYWNrZm4pKSB0aHJvdyBUeXBlRXJyb3IoKTtcclxuICAgICAgICAgdmFyIHQgPSB0aGlzQXJnO1xyXG4gICAgICAgICB2YXIgYSA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgdmFyIGMgPSBvLmNvbnN0cnVjdG9yO1xyXG4gICAgICAgICBpZiAoSXNDb25zdHJ1Y3RvcihjKSlcclxuICAgICAgICAgICBhID0gbmV3IGMobGVuKTtcclxuICAgICAgICAgaWYgKGEgPT09IHVuZGVmaW5lZClcclxuICAgICAgICAgICBhID0gbmV3IEFycmF5KGxlbik7XHJcbiAgICAgICAgIHZhciBrID0gMDtcclxuICAgICAgICAgd2hpbGUgKGsgPCBsZW4pIHtcclxuICAgICAgICAgICB2YXIga1ByZXNlbnQgPSBIYXNQcm9wZXJ0eShvLCBrKTtcclxuICAgICAgICAgICBpZiAoa1ByZXNlbnQpIHtcclxuICAgICAgICAgICAgIHZhciBrVmFsdWUgPSBvW2tdO1xyXG4gICAgICAgICAgICAgdmFyIG1hcHBlZFZhbHVlID0gY2FsbGJhY2tmbi5jYWxsKHQsIGtWYWx1ZSwgaywgbyk7XHJcbiAgICAgICAgICAgICBhW2tdID0gbWFwcGVkVmFsdWU7XHJcbiAgICAgICAgICAgfVxyXG4gICAgICAgICAgICsraztcclxuICAgICAgICAgfVxyXG4gICAgICAgICByZXR1cm4gYTtcclxuICAgICAgIH0pO1xyXG5cclxuICAgICAvLyAyMi4yLjMuMTkgJVR5cGVkQXJyYXklLnByb3RvdHlwZS5yZWR1Y2UgKCBjYWxsYmFja2ZuIFssIGluaXRpYWxWYWx1ZV0gKVxyXG4gICAgIGRlZmluZSgkVHlwZWRBcnJheSQucHJvdG90eXBlLCAncmVkdWNlJywgQXJyYXkucHJvdG90eXBlLnJlZHVjZSk7XHJcblxyXG4gICAgIC8vIDIyLjIuMy4yMCAlVHlwZWRBcnJheSUucHJvdG90eXBlLnJlZHVjZVJpZ2h0ICggY2FsbGJhY2tmbiBbLCBpbml0aWFsVmFsdWVdIClcclxuICAgICBkZWZpbmUoJFR5cGVkQXJyYXkkLnByb3RvdHlwZSwgJ3JlZHVjZVJpZ2h0JywgQXJyYXkucHJvdG90eXBlLnJlZHVjZVJpZ2h0KTtcclxuXHJcbiAgICAgLy8gMjIuMi4zLjIxICVUeXBlZEFycmF5JS5wcm90b3R5cGUucmV2ZXJzZSAoIClcclxuICAgICBkZWZpbmUoJFR5cGVkQXJyYXkkLnByb3RvdHlwZSwgJ3JldmVyc2UnLCBBcnJheS5wcm90b3R5cGUucmV2ZXJzZSk7XHJcblxyXG4gICAgIC8vIDIyLjIuMy4yMiAlVHlwZWRBcnJheSUucHJvdG90eXBlLnNldCAoIG92ZXJsb2FkZWQgWyAsIG9mZnNldCBdKVxyXG4gICAgIC8vIDIyLjIuMy4yMi4xICVUeXBlZEFycmF5JS5wcm90b3R5cGUuc2V0IChhcnJheSBbICwgb2Zmc2V0IF0gKVxyXG4gICAgIC8vIDIyLjIuMy4yMi4yICVUeXBlZEFycmF5JS5wcm90b3R5cGUuc2V0KHR5cGVkQXJyYXkgWywgb2Zmc2V0IF0gKVxyXG5cclxuICAgICAvLyAyMi4yLjMuMjMgJVR5cGVkQXJyYXklLnByb3RvdHlwZS5zbGljZSAoIHN0YXJ0LCBlbmQgKVxyXG4gICAgIGRlZmluZShcclxuICAgICAgICRUeXBlZEFycmF5JC5wcm90b3R5cGUsICdzbGljZScsXHJcbiAgICAgICBmdW5jdGlvbiBzbGljZShzdGFydCwgZW5kKSB7XHJcbiAgICAgICAgIHZhciBvID0gVG9PYmplY3QodGhpcyk7XHJcbiAgICAgICAgIHZhciBsZW5WYWwgPSBvLmxlbmd0aDtcclxuICAgICAgICAgdmFyIGxlbiA9IFRvTGVuZ3RoKGxlblZhbCk7XHJcbiAgICAgICAgIHZhciByZWxhdGl2ZVN0YXJ0ID0gVG9JbnRlZ2VyKHN0YXJ0KTtcclxuICAgICAgICAgdmFyIGsgPSAocmVsYXRpdmVTdGFydCA8IDApID8gbWF4KGxlbiArIHJlbGF0aXZlU3RhcnQsIDApIDogbWluKHJlbGF0aXZlU3RhcnQsIGxlbik7XHJcbiAgICAgICAgIHZhciByZWxhdGl2ZUVuZCA9IChlbmQgPT09IHVuZGVmaW5lZCkgPyBsZW4gOiBUb0ludGVnZXIoZW5kKTtcclxuICAgICAgICAgdmFyIGZpbmFsID0gKHJlbGF0aXZlRW5kIDwgMCkgPyBtYXgobGVuICsgcmVsYXRpdmVFbmQsIDApIDogbWluKHJlbGF0aXZlRW5kLCBsZW4pO1xyXG4gICAgICAgICB2YXIgY291bnQgPSBmaW5hbCAtIGs7XHJcbiAgICAgICAgIHZhciBjID0gby5jb25zdHJ1Y3RvcjtcclxuICAgICAgICAgaWYgKElzQ29uc3RydWN0b3IoYykpIHtcclxuICAgICAgICAgICB2YXIgYSA9IG5ldyBjKGNvdW50KTtcclxuICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoKTtcclxuICAgICAgICAgfVxyXG4gICAgICAgICB2YXIgbiA9IDA7XHJcbiAgICAgICAgIHdoaWxlIChrIDwgZmluYWwpIHtcclxuICAgICAgICAgICB2YXIga1ZhbHVlID0gb1trXTtcclxuICAgICAgICAgICBhW25dID0ga1ZhbHVlO1xyXG4gICAgICAgICAgICsraztcclxuICAgICAgICAgICArK247XHJcbiAgICAgICAgIH1cclxuICAgICAgICAgcmV0dXJuIGE7XHJcbiAgICAgICB9KTtcclxuXHJcbiAgICAgLy8gMjIuMi4zLjI0ICVUeXBlZEFycmF5JS5wcm90b3R5cGUuc29tZSAoIGNhbGxiYWNrZm4gWyAsIHRoaXNBcmcgXSApXHJcbiAgICAgZGVmaW5lKCRUeXBlZEFycmF5JC5wcm90b3R5cGUsICdzb21lJywgQXJyYXkucHJvdG90eXBlLnNvbWUpO1xyXG5cclxuICAgICAvLyAyMi4yLjMuMjUgJVR5cGVkQXJyYXklLnByb3RvdHlwZS5zb3J0ICggY29tcGFyZWZuIClcclxuICAgICBkZWZpbmUoXHJcbiAgICAgICAkVHlwZWRBcnJheSQucHJvdG90eXBlLCAnc29ydCcsXHJcbiAgICAgICBmdW5jdGlvbiBzb3J0KCkge1xyXG4gICAgICAgICB2YXIgY29tcGFyZWZuID0gYXJndW1lbnRzWzBdO1xyXG5cclxuICAgICAgICAgZnVuY3Rpb24gc29ydENvbXBhcmUoeCwgeSkge1xyXG4gICAgICAgICAgIGNvbnNvbGUuYXNzZXJ0KFR5cGUoeCkgPT09ICdudW1iZXInICYmIFR5cGUoeSkgPT09ICdudW1iZXInKTtcclxuICAgICAgICAgICBpZiAoeCAhPT0geCAmJiB5ICE9PSB5KSByZXR1cm4gKzA7XHJcbiAgICAgICAgICAgaWYgKHggIT09IHgpIHJldHVybiAxO1xyXG4gICAgICAgICAgIGlmICh5ICE9PSB5KSByZXR1cm4gLTE7XHJcbiAgICAgICAgICAgaWYgKGNvbXBhcmVmbiAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICByZXR1cm4gY29tcGFyZWZuKHgsIHkpO1xyXG4gICAgICAgICAgIH1cclxuICAgICAgICAgICBpZiAoeCA8IHkpIHJldHVybiAtMTtcclxuICAgICAgICAgICBpZiAoeCA+IHkpIHJldHVybiAxO1xyXG4gICAgICAgICAgIHJldHVybiArMDtcclxuICAgICAgICAgfVxyXG4gICAgICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNvcnQuY2FsbCh0aGlzLCBzb3J0Q29tcGFyZSk7XHJcbiAgICAgICB9KTtcclxuXHJcbiAgICAgLy8gMjIuMi4zLjI2ICVUeXBlZEFycmF5JS5wcm90b3R5cGUuc3ViYXJyYXkoIFsgYmVnaW4gWyAsIGVuZCBdIF0gKVxyXG4gICAgIC8vIDIyLjIuMy4yNyAlVHlwZWRBcnJheSUucHJvdG90eXBlLnRvTG9jYWxlU3RyaW5nIChbIHJlc2VydmVkMSBbICwgcmVzZXJ2ZWQyIF0gXSlcclxuICAgICAvLyAyMi4yLjMuMjggJVR5cGVkQXJyYXklLnByb3RvdHlwZS50b1N0cmluZyAoIClcclxuXHJcbiAgICAgLy8gMjIuMi4zLjI5ICVUeXBlZEFycmF5JS5wcm90b3R5cGUudmFsdWVzICggKVxyXG4gICAgIGRlZmluZSgkVHlwZWRBcnJheSQucHJvdG90eXBlLCAndmFsdWVzJywgQXJyYXkucHJvdG90eXBlLnZhbHVlcyk7XHJcblxyXG4gICAgIC8vIDIyLjIuMy4zMCAlVHlwZWRBcnJheSUucHJvdG90eXBlIFsgQEBpdGVyYXRvciBdICggKVxyXG4gICAgIGRlZmluZShcclxuICAgICAgICRUeXBlZEFycmF5JC5wcm90b3R5cGUsICQkaXRlcmF0b3IsXHJcbiAgICAgICAkVHlwZWRBcnJheSQucHJvdG90eXBlLnZhbHVlc1xyXG4gICAgICk7XHJcblxyXG4gICAgIC8vIDIyLjIuMy4zMSBnZXQgJVR5cGVkQXJyYXklLnByb3RvdHlwZSBbIEBAdG9TdHJpbmdUYWcgXVxyXG4gICAgIGRlZmluZSgkVHlwZWRBcnJheSQucHJvdG90eXBlLCAkJHRvU3RyaW5nVGFnLCAkVHlwZWRBcnJheU5hbWUkKTtcclxuXHJcbiAgICAgLy8gMjIuMi40IFRoZSBUeXBlZEFycmF5IENvbnN0cnVjdG9yc1xyXG4gICAgIC8vIDIyLjIuNC4xVHlwZWRBcnJheSggLi4uIGFyZ3VtZW50c0xpc3QpXHJcbiAgICAgLy8gMjIuMi41IFByb3BlcnRpZXMgb2YgdGhlIFR5cGVkQXJyYXkgQ29uc3RydWN0b3JzXHJcbiAgICAgLy8gMjIuMi41LjEgVHlwZWRBcnJheS5CWVRFU19QRVJfRUxFTUVOVFxyXG4gICAgIC8vIDIyLjIuNS4yIFR5cGVkQXJyYXkucHJvdG90eXBlXHJcbiAgICAgLy8gMjIuMi42IFByb3BlcnRpZXMgb2YgVHlwZWRBcnJheSBQcm90b3R5cGUgT2JqZWN0c1xyXG4gICAgIC8vIDIyLjIuNi4xIFR5cGVkQXJyYXkucHJvdG90eXBlLkJZVEVTX1BFUl9FTEVNRU5UXHJcbiAgICAgLy8gMjIuMi42LjIgVHlwZWRBcnJheS5wcm90b3R5cGUuY29uc3RydWN0b3JcclxuICAgICAvLyAyMi4yLjcgUHJvcGVydGllcyBvZiBUeXBlZEFycmF5IEluc3RhbmNlc1xyXG4gICB9KTtcclxuXHJcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgLy8gMjMgS2V5ZWQgQ29sbGVjdGlvblxyXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cclxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAvLyAyMy4xIE1hcCBPYmplY3RzXHJcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG4gIChmdW5jdGlvbigpIHtcclxuICAgIC8vIDIzLjEuMSBUaGUgTWFwIENvbnN0cnVjdG9yXHJcblxyXG4gICAgLy8gMjMuMS4xLjEgTWFwICggWyBpdGVyYWJsZSBdIClcclxuICAgIC8qKiBAY29uc3RydWN0b3IgKi9cclxuICAgIGZ1bmN0aW9uIE1hcCgvKml0ZXJhYmxlKi8pIHtcclxuICAgICAgdmFyIG1hcCA9IHN0cmljdCh0aGlzKTtcclxuICAgICAgdmFyIGl0ZXJhYmxlID0gYXJndW1lbnRzWzBdO1xyXG5cclxuICAgICAgaWYgKFR5cGUobWFwKSAhPT0gJ29iamVjdCcpIHRocm93IFR5cGVFcnJvcigpO1xyXG4gICAgICBpZiAoJ1tbTWFwRGF0YV1dJyBpbiBtYXApIHRocm93IFR5cGVFcnJvcigpO1xyXG5cclxuICAgICAgaWYgKGl0ZXJhYmxlICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICB2YXIgYWRkZXIgPSBtYXBbJ3NldCddO1xyXG4gICAgICAgIGlmICghSXNDYWxsYWJsZShhZGRlcikpIHRocm93IFR5cGVFcnJvcigpO1xyXG4gICAgICAgIHZhciBpdGVyID0gR2V0SXRlcmF0b3IoVG9PYmplY3QoaXRlcmFibGUpKTtcclxuICAgICAgfVxyXG4gICAgICBzZXRfaW50ZXJuYWwobWFwLCAnW1tNYXBEYXRhXV0nLCB7IGtleXM6IFtdLCB2YWx1ZXM6IFtdIH0pO1xyXG4gICAgICBpZiAoaXRlciA9PT0gdW5kZWZpbmVkKSByZXR1cm4gbWFwO1xyXG4gICAgICB3aGlsZSAodHJ1ZSkge1xyXG4gICAgICAgIHZhciBuZXh0ID0gSXRlcmF0b3JTdGVwKGl0ZXIpO1xyXG4gICAgICAgIGlmIChuZXh0ID09PSBmYWxzZSlcclxuICAgICAgICAgIHJldHVybiBtYXA7XHJcbiAgICAgICAgdmFyIG5leHRJdGVtID0gSXRlcmF0b3JWYWx1ZShuZXh0KTtcclxuICAgICAgICBpZiAoVHlwZShuZXh0SXRlbSkgIT09ICdvYmplY3QnKSB0aHJvdyBUeXBlRXJyb3IoKTtcclxuICAgICAgICB2YXIgayA9IG5leHRJdGVtWzBdO1xyXG4gICAgICAgIHZhciB2ID0gbmV4dEl0ZW1bMV07XHJcbiAgICAgICAgYWRkZXIuY2FsbChtYXAsIGssIHYpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gbWFwO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghKCdNYXAnIGluIGdsb2JhbCkgfHwgT1ZFUlJJREVfTkFUSVZFX0ZPUl9URVNUSU5HIHx8XHJcbiAgICAgICAgKGZ1bmN0aW9uKCkgeyB0cnkgeyBuZXcgZ2xvYmFsLk1hcChbXSk7IHJldHVybiBmYWxzZTsgfSBjYXRjaCAoXykgeyByZXR1cm4gdHJ1ZTsgfSB9KCkpIHx8XHJcbiAgICAgICAgKGZ1bmN0aW9uKCkgeyB0cnkgeyByZXR1cm4gIW5ldyBnbG9iYWwuTWFwKCkuZW50cmllcygpLm5leHQ7IH0gY2F0Y2ggKF8pIHsgcmV0dXJuIHRydWU7IH0gfSgpKSB8fFxyXG4gICAgICAgIChuZXcgZ2xvYmFsLk1hcChbWydhJywgMV1dKS5zaXplICE9PSAxKSlcclxuICAgICAgZ2xvYmFsLk1hcCA9IE1hcDtcclxuXHJcblxyXG4gICAgZnVuY3Rpb24gTWFwRGF0YUluZGV4T2YobWFwRGF0YSwga2V5KSB7XHJcbiAgICAgIHZhciBpO1xyXG4gICAgICBpZiAoa2V5ID09PSBrZXkpIHJldHVybiBtYXBEYXRhLmtleXMuaW5kZXhPZihrZXkpO1xyXG4gICAgICAvLyBTbG93IGNhc2UgZm9yIE5hTlxyXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbWFwRGF0YS5rZXlzLmxlbmd0aDsgaSArPSAxKVxyXG4gICAgICAgIGlmIChTYW1lVmFsdWVaZXJvKG1hcERhdGEua2V5c1tpXSwga2V5KSkgcmV0dXJuIGk7XHJcbiAgICAgIHJldHVybiAtMTtcclxuICAgIH1cclxuXHJcbiAgICAvLyAyMy4xLjEuMiBuZXcgTWFwICggLi4uIGFyZ3VtZW50c0xpc3QgKVxyXG4gICAgLy8gMjMuMS4yIFByb3BlcnRpZXMgb2YgdGhlIE1hcCBDb25zdHJ1Y3RvclxyXG4gICAgLy8gMjMuMS4yLjEgTWFwLnByb3RvdHlwZVxyXG4gICAgdmFyICRNYXBQcm90b3R5cGUkID0ge307XHJcbiAgICBNYXAucHJvdG90eXBlID0gJE1hcFByb3RvdHlwZSQ7XHJcblxyXG4gICAgLy8gMjMuMS4yLjIgZ2V0IE1hcCBbIEBAc3BlY2llcyBdXHJcblxyXG4gICAgLy8gMjMuMS4zIFByb3BlcnRpZXMgb2YgdGhlIE1hcCBQcm90b3R5cGUgT2JqZWN0XHJcbiAgICAvLyAyMy4xLjMuMSBNYXAucHJvdG90eXBlLmNsZWFyICgpXHJcbiAgICBkZWZpbmUoXHJcbiAgICAgIE1hcC5wcm90b3R5cGUsICdjbGVhcicsXHJcbiAgICAgIGZ1bmN0aW9uIGNsZWFyKCkge1xyXG4gICAgICAgIHZhciBtID0gc3RyaWN0KHRoaXMpO1xyXG4gICAgICAgIGlmIChUeXBlKG0pICE9PSAnb2JqZWN0JykgdGhyb3cgVHlwZUVycm9yKCk7XHJcbiAgICAgICAgaWYgKCEoJ1tbTWFwRGF0YV1dJyBpbiBtKSkgdGhyb3cgVHlwZUVycm9yKCk7XHJcbiAgICAgICAgaWYgKG1bJ1tbTWFwRGF0YV1dJ10gPT09IHVuZGVmaW5lZCkgdGhyb3cgVHlwZUVycm9yKCk7XHJcbiAgICAgICAgdmFyIGVudHJpZXMgPSBtWydbW01hcERhdGFdXSddO1xyXG4gICAgICAgIGVudHJpZXMua2V5cy5sZW5ndGggPSAwO1xyXG4gICAgICAgIGVudHJpZXMudmFsdWVzLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgfSk7XHJcblxyXG4gICAgLy8gMjMuMS4zLjIgTWFwLnByb3RvdHlwZS5jb25zdHJ1Y3RvclxyXG5cclxuICAgIC8vIDIzLjEuMy4zIE1hcC5wcm90b3R5cGUuZGVsZXRlICgga2V5IClcclxuICAgIGRlZmluZShcclxuICAgICAgTWFwLnByb3RvdHlwZSwgJ2RlbGV0ZScsXHJcbiAgICAgIGZ1bmN0aW9uIGRlbGV0ZV8oa2V5KSB7XHJcbiAgICAgICAgdmFyIG0gPSBzdHJpY3QodGhpcyk7XHJcbiAgICAgICAgaWYgKFR5cGUobSkgIT09ICdvYmplY3QnKSB0aHJvdyBUeXBlRXJyb3IoKTtcclxuICAgICAgICBpZiAoISgnW1tNYXBEYXRhXV0nIGluIG0pKSB0aHJvdyBUeXBlRXJyb3IoKTtcclxuICAgICAgICBpZiAobVsnW1tNYXBEYXRhXV0nXSA9PT0gdW5kZWZpbmVkKSB0aHJvdyBUeXBlRXJyb3IoKTtcclxuICAgICAgICB2YXIgZW50cmllcyA9IG1bJ1tbTWFwRGF0YV1dJ107XHJcbiAgICAgICAgdmFyIGkgPSBNYXBEYXRhSW5kZXhPZihlbnRyaWVzLCBrZXkpO1xyXG4gICAgICAgIGlmIChpIDwgMCkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIGVudHJpZXMua2V5c1tpXSA9IGVtcHR5O1xyXG4gICAgICAgIGVudHJpZXMudmFsdWVzW2ldID0gZW1wdHk7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgIC8vIDIzLjEuMy40IE1hcC5wcm90b3R5cGUuZW50cmllcyAoIClcclxuICAgIGRlZmluZShcclxuICAgICAgTWFwLnByb3RvdHlwZSwgJ2VudHJpZXMnLFxyXG4gICAgICBmdW5jdGlvbiBlbnRyaWVzKCkge1xyXG4gICAgICAgIHZhciBtID0gc3RyaWN0KHRoaXMpO1xyXG4gICAgICAgIGlmIChUeXBlKG0pICE9PSAnb2JqZWN0JykgdGhyb3cgVHlwZUVycm9yKCk7XHJcbiAgICAgICAgcmV0dXJuIENyZWF0ZU1hcEl0ZXJhdG9yKG0sICdrZXkrdmFsdWUnKTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgLy8gMjMuMS4zLjUgTWFwLnByb3RvdHlwZS5mb3JFYWNoICggY2FsbGJhY2tmbiBbICwgdGhpc0FyZyBdIClcclxuICAgIGRlZmluZShcclxuICAgICAgTWFwLnByb3RvdHlwZSwgJ2ZvckVhY2gnLFxyXG4gICAgICBmdW5jdGlvbiBmb3JFYWNoKGNhbGxiYWNrZm4gLyosIHRoaXNBcmcqLykge1xyXG4gICAgICAgIHZhciB0aGlzQXJnID0gYXJndW1lbnRzWzFdO1xyXG5cclxuICAgICAgICB2YXIgbSA9IHN0cmljdCh0aGlzKTtcclxuICAgICAgICBpZiAoVHlwZShtKSAhPT0gJ29iamVjdCcpIHRocm93IFR5cGVFcnJvcigpO1xyXG4gICAgICAgIGlmICghKCdbW01hcERhdGFdXScgaW4gbSkpIHRocm93IFR5cGVFcnJvcigpO1xyXG4gICAgICAgIGlmIChtWydbW01hcERhdGFdXSddID09PSB1bmRlZmluZWQpIHRocm93IFR5cGVFcnJvcigpO1xyXG4gICAgICAgIHZhciBlbnRyaWVzID0gbVsnW1tNYXBEYXRhXV0nXTtcclxuXHJcbiAgICAgICAgaWYgKCFJc0NhbGxhYmxlKGNhbGxiYWNrZm4pKSB7XHJcbiAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IHRvIGZvckVhY2ggaXMgbm90IGNhbGxhYmxlLicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVudHJpZXMua2V5cy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgaWYgKGVudHJpZXMua2V5c1tpXSAhPT0gZW1wdHkpIHtcclxuICAgICAgICAgICAgY2FsbGJhY2tmbi5jYWxsKHRoaXNBcmcsIGVudHJpZXMudmFsdWVzW2ldLCBlbnRyaWVzLmtleXNbaV0sIG0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAvLyAyMy4xLjMuNiBNYXAucHJvdG90eXBlLmdldCAoIGtleSApXHJcbiAgICBkZWZpbmUoXHJcbiAgICAgIE1hcC5wcm90b3R5cGUsICdnZXQnLFxyXG4gICAgICBmdW5jdGlvbiBnZXQoa2V5KSB7XHJcbiAgICAgICAgdmFyIG0gPSBzdHJpY3QodGhpcyk7XHJcbiAgICAgICAgaWYgKFR5cGUobSkgIT09ICdvYmplY3QnKSB0aHJvdyBUeXBlRXJyb3IoKTtcclxuICAgICAgICBpZiAoISgnW1tNYXBEYXRhXV0nIGluIG0pKSB0aHJvdyBUeXBlRXJyb3IoKTtcclxuICAgICAgICBpZiAobVsnW1tNYXBEYXRhXV0nXSA9PT0gdW5kZWZpbmVkKSB0aHJvdyBUeXBlRXJyb3IoKTtcclxuICAgICAgICB2YXIgZW50cmllcyA9IG1bJ1tbTWFwRGF0YV1dJ107XHJcbiAgICAgICAgdmFyIGkgPSBNYXBEYXRhSW5kZXhPZihlbnRyaWVzLCBrZXkpO1xyXG4gICAgICAgIGlmIChpID49IDApIHJldHVybiBlbnRyaWVzLnZhbHVlc1tpXTtcclxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAvLyAyMy4xLjMuNyBNYXAucHJvdG90eXBlLmhhcyAoIGtleSApXHJcbiAgICBkZWZpbmUoXHJcbiAgICAgIE1hcC5wcm90b3R5cGUsICdoYXMnLFxyXG4gICAgICBmdW5jdGlvbiBoYXMoa2V5KSB7XHJcbiAgICAgICAgdmFyIG0gPSBzdHJpY3QodGhpcyk7XHJcbiAgICAgICAgaWYgKFR5cGUobSkgIT09ICdvYmplY3QnKSB0aHJvdyBUeXBlRXJyb3IoKTtcclxuICAgICAgICBpZiAoISgnW1tNYXBEYXRhXV0nIGluIG0pKSB0aHJvdyBUeXBlRXJyb3IoKTtcclxuICAgICAgICBpZiAobVsnW1tNYXBEYXRhXV0nXSA9PT0gdW5kZWZpbmVkKSB0aHJvdyBUeXBlRXJyb3IoKTtcclxuICAgICAgICB2YXIgZW50cmllcyA9IG1bJ1tbTWFwRGF0YV1dJ107XHJcbiAgICAgICAgaWYgKE1hcERhdGFJbmRleE9mKGVudHJpZXMsIGtleSkgPj0gMCkgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAvLyAyMy4xLjMuOCBNYXAucHJvdG90eXBlLmtleXMgKCApXHJcbiAgICBkZWZpbmUoXHJcbiAgICAgIE1hcC5wcm90b3R5cGUsICdrZXlzJyxcclxuICAgICAgZnVuY3Rpb24ga2V5cygpIHtcclxuICAgICAgICB2YXIgbSA9IHN0cmljdCh0aGlzKTtcclxuICAgICAgICBpZiAoVHlwZShtKSAhPT0gJ29iamVjdCcpIHRocm93IFR5cGVFcnJvcigpO1xyXG4gICAgICAgIHJldHVybiBDcmVhdGVNYXBJdGVyYXRvcihtLCAna2V5Jyk7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgIC8vIDIzLjEuMy45IE1hcC5wcm90b3R5cGUuc2V0ICgga2V5ICwgdmFsdWUgKVxyXG4gICAgZGVmaW5lKFxyXG4gICAgICBNYXAucHJvdG90eXBlLCAnc2V0JyxcclxuICAgICAgZnVuY3Rpb24gc2V0KGtleSwgdmFsdWUpIHtcclxuICAgICAgICB2YXIgbSA9IHN0cmljdCh0aGlzKTtcclxuICAgICAgICBpZiAoVHlwZShtKSAhPT0gJ29iamVjdCcpIHRocm93IFR5cGVFcnJvcigpO1xyXG4gICAgICAgIGlmICghKCdbW01hcERhdGFdXScgaW4gbSkpIHRocm93IFR5cGVFcnJvcigpO1xyXG4gICAgICAgIGlmIChtWydbW01hcERhdGFdXSddID09PSB1bmRlZmluZWQpIHRocm93IFR5cGVFcnJvcigpO1xyXG4gICAgICAgIHZhciBlbnRyaWVzID0gbVsnW1tNYXBEYXRhXV0nXTtcclxuICAgICAgICB2YXIgaSA9IE1hcERhdGFJbmRleE9mKGVudHJpZXMsIGtleSk7XHJcbiAgICAgICAgaWYgKGkgPCAwKSBpID0gZW50cmllcy5rZXlzLmxlbmd0aDtcclxuICAgICAgICBpZiAoU2FtZVZhbHVlKGtleSwgLTApKSBrZXkgPSAwO1xyXG4gICAgICAgIGVudHJpZXMua2V5c1tpXSA9IGtleTtcclxuICAgICAgICBlbnRyaWVzLnZhbHVlc1tpXSA9IHZhbHVlO1xyXG4gICAgICAgIHJldHVybiBtO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAvLyAyMy4xLjMuMTAgZ2V0IE1hcC5wcm90b3R5cGUuc2l6ZVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFxyXG4gICAgICBNYXAucHJvdG90eXBlLCAnc2l6ZScsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgdmFyIG0gPSBzdHJpY3QodGhpcyk7XHJcbiAgICAgICAgICBpZiAoVHlwZShtKSAhPT0gJ29iamVjdCcpIHRocm93IFR5cGVFcnJvcigpO1xyXG4gICAgICAgICAgaWYgKCEoJ1tbTWFwRGF0YV1dJyBpbiBtKSkgdGhyb3cgVHlwZUVycm9yKCk7XHJcbiAgICAgICAgICBpZiAobVsnW1tNYXBEYXRhXV0nXSA9PT0gdW5kZWZpbmVkKSB0aHJvdyBUeXBlRXJyb3IoKTtcclxuICAgICAgICAgIHZhciBlbnRyaWVzID0gbVsnW1tNYXBEYXRhXV0nXTtcclxuICAgICAgICAgIHZhciBjb3VudCA9IDA7XHJcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVudHJpZXMua2V5cy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICBpZiAoZW50cmllcy5rZXlzW2ldICE9PSBlbXB0eSlcclxuICAgICAgICAgICAgICBjb3VudCA9IGNvdW50ICsgMTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHJldHVybiBjb3VudDtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG5cclxuICAgIC8vIDIzLjEuMy4xMSBNYXAucHJvdG90eXBlLnZhbHVlcyAoIClcclxuICAgIGRlZmluZShcclxuICAgICAgTWFwLnByb3RvdHlwZSwgJ3ZhbHVlcycsXHJcbiAgICAgIGZ1bmN0aW9uIHZhbHVlcygpIHtcclxuICAgICAgICB2YXIgbSA9IHN0cmljdCh0aGlzKTtcclxuICAgICAgICBpZiAoVHlwZShtKSAhPT0gJ29iamVjdCcpIHRocm93IFR5cGVFcnJvcigpO1xyXG4gICAgICAgIHJldHVybiBDcmVhdGVNYXBJdGVyYXRvcihtLCAndmFsdWUnKTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgLy8gMjMuMS4zLjEyIE1hcC5wcm90b3R5cGUgWyBAQGl0ZXJhdG9yIF0oIClcclxuICAgIGRlZmluZShcclxuICAgICAgTWFwLnByb3RvdHlwZSwgJCRpdGVyYXRvcixcclxuICAgICAgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIG0gPSBzdHJpY3QodGhpcyk7XHJcbiAgICAgICAgaWYgKFR5cGUobSkgIT09ICdvYmplY3QnKSB0aHJvdyBUeXBlRXJyb3IoKTtcclxuICAgICAgICByZXR1cm4gQ3JlYXRlTWFwSXRlcmF0b3IobSwgJ2tleSt2YWx1ZScpO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAvLyAyMy4xLjMuMTMgTWFwLnByb3RvdHlwZSBbIEBAdG9TdHJpbmdUYWcgXVxyXG4gICAgZGVmaW5lKGdsb2JhbC5NYXAucHJvdG90eXBlLCAkJHRvU3RyaW5nVGFnLCAnTWFwJyk7XHJcblxyXG4gICAgLy8gMjMuMS40IFByb3BlcnRpZXMgb2YgTWFwIEluc3RhbmNlc1xyXG4gICAgLy8gMjMuMS41IE1hcCBJdGVyYXRvciBPYmplY3RzXHJcblxyXG4gICAgLyoqIEBjb25zdHJ1Y3RvciAqL1xyXG4gICAgZnVuY3Rpb24gTWFwSXRlcmF0b3IoKSB7fVxyXG5cclxuICAgIC8vIDIzLjEuNS4xIENyZWF0ZU1hcEl0ZXJhdG9yIEFic3RyYWN0IE9wZXJhdGlvblxyXG4gICAgZnVuY3Rpb24gQ3JlYXRlTWFwSXRlcmF0b3IobWFwLCBraW5kKSB7XHJcbiAgICAgIGlmIChUeXBlKG1hcCkgIT09ICdvYmplY3QnKSB0aHJvdyBUeXBlRXJyb3IoKTtcclxuICAgICAgaWYgKCEoJ1tbTWFwRGF0YV1dJyBpbiBtYXApKSB0aHJvdyBUeXBlRXJyb3IoKTtcclxuICAgICAgaWYgKG1hcFsnW1tNYXBEYXRhXV0nXSA9PT0gdW5kZWZpbmVkKSB0aHJvdyBUeXBlRXJyb3IoKTtcclxuICAgICAgdmFyIGl0ZXJhdG9yID0gbmV3IE1hcEl0ZXJhdG9yO1xyXG4gICAgICBzZXRfaW50ZXJuYWwoaXRlcmF0b3IsICdbW01hcF1dJywgbWFwKTtcclxuICAgICAgc2V0X2ludGVybmFsKGl0ZXJhdG9yLCAnW1tNYXBOZXh0SW5kZXhdXScsIDApO1xyXG4gICAgICBzZXRfaW50ZXJuYWwoaXRlcmF0b3IsICdbW01hcEl0ZXJhdGlvbktpbmRdXScsIGtpbmQpO1xyXG4gICAgICByZXR1cm4gaXRlcmF0b3I7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gMjMuMS41LjIgVGhlICVNYXBJdGVyYXRvclByb3RvdHlwZSUgT2JqZWN0XHJcbiAgICB2YXIgJE1hcEl0ZXJhdG9yUHJvdG90eXBlJCA9IE9iamVjdC5jcmVhdGUoJEl0ZXJhdG9yUHJvdG90eXBlJCk7XHJcbiAgICBNYXBJdGVyYXRvci5wcm90b3R5cGUgPSAkTWFwSXRlcmF0b3JQcm90b3R5cGUkO1xyXG5cclxuICAgIC8vIDIzLjEuNS4yLjEgJU1hcEl0ZXJhdG9yUHJvdG90eXBlJS5uZXh0ICggKVxyXG4gICAgZGVmaW5lKFxyXG4gICAgICAkTWFwSXRlcmF0b3JQcm90b3R5cGUkLCAnbmV4dCcsXHJcbiAgICAgIGZ1bmN0aW9uIG5leHQoKSB7XHJcbiAgICAgICAgdmFyIG8gPSBzdHJpY3QodGhpcyk7XHJcbiAgICAgICAgaWYgKFR5cGUobykgIT09ICdvYmplY3QnKSB0aHJvdyBUeXBlRXJyb3IoKTtcclxuICAgICAgICB2YXIgbSA9IG9bJ1tbTWFwXV0nXSxcclxuICAgICAgICAgICAgaW5kZXggPSBvWydbW01hcE5leHRJbmRleF1dJ10sXHJcbiAgICAgICAgICAgIGl0ZW1LaW5kID0gb1snW1tNYXBJdGVyYXRpb25LaW5kXV0nXSxcclxuICAgICAgICAgICAgZW50cmllcyA9IG1bJ1tbTWFwRGF0YV1dJ107XHJcbiAgICAgICAgd2hpbGUgKGluZGV4IDwgZW50cmllcy5rZXlzLmxlbmd0aCkge1xyXG4gICAgICAgICAgdmFyIGUgPSB7a2V5OiBlbnRyaWVzLmtleXNbaW5kZXhdLCB2YWx1ZTogZW50cmllcy52YWx1ZXNbaW5kZXhdfTtcclxuICAgICAgICAgIGluZGV4ID0gaW5kZXggKz0gMTtcclxuICAgICAgICAgIHNldF9pbnRlcm5hbChvLCAnW1tNYXBOZXh0SW5kZXhdXScsIGluZGV4KTtcclxuICAgICAgICAgIGlmIChlLmtleSAhPT0gZW1wdHkpIHtcclxuICAgICAgICAgICAgaWYgKGl0ZW1LaW5kID09PSAna2V5Jykge1xyXG4gICAgICAgICAgICAgIHJldHVybiBDcmVhdGVJdGVyUmVzdWx0T2JqZWN0KGUua2V5LCBmYWxzZSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXRlbUtpbmQgPT09ICd2YWx1ZScpIHtcclxuICAgICAgICAgICAgICByZXR1cm4gQ3JlYXRlSXRlclJlc3VsdE9iamVjdChlLnZhbHVlLCBmYWxzZSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIENyZWF0ZUl0ZXJSZXN1bHRPYmplY3QoW2Uua2V5LCBlLnZhbHVlXSwgZmFsc2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBDcmVhdGVJdGVyUmVzdWx0T2JqZWN0KHVuZGVmaW5lZCwgdHJ1ZSk7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgIC8vIDIzLjEuNS4yLjIgJU1hcEl0ZXJhdG9yUHJvdG90eXBlJSBbIEBAdG9TdHJpbmdUYWcgXVxyXG4gICAgZGVmaW5lKCRNYXBJdGVyYXRvclByb3RvdHlwZSQsICQkdG9TdHJpbmdUYWcsICdNYXAgSXRlcmF0b3InKTtcclxuXHJcbiAgICAvLyAyMy4xLjUuMyBQcm9wZXJ0aWVzIG9mIE1hcCBJdGVyYXRvciBJbnN0YW5jZXNcclxuICB9KCkpO1xyXG5cclxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAvLyAyMy4yIFNldCBPYmplY3RzXHJcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG4gIChmdW5jdGlvbigpIHtcclxuICAgIC8vIDIzLjIuMSBUaGUgU2V0IENvbnN0cnVjdG9yXHJcbiAgICAvLyAyMy4yLjEuMSBTZXQgKCBbIGl0ZXJhYmxlIF0gKVxyXG5cclxuICAgIC8qKiBAY29uc3RydWN0b3IgKi9cclxuICAgIGZ1bmN0aW9uIFNldCgvKml0ZXJhYmxlKi8pIHtcclxuICAgICAgdmFyIHNldCA9IHN0cmljdCh0aGlzKTtcclxuICAgICAgdmFyIGl0ZXJhYmxlID0gYXJndW1lbnRzWzBdO1xyXG5cclxuICAgICAgaWYgKFR5cGUoc2V0KSAhPT0gJ29iamVjdCcpIHRocm93IFR5cGVFcnJvcigpO1xyXG4gICAgICBpZiAoJ1tbU2V0RGF0YV1dJyBpbiBzZXQpIHRocm93IFR5cGVFcnJvcigpO1xyXG5cclxuICAgICAgaWYgKGl0ZXJhYmxlICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICB2YXIgYWRkZXIgPSBzZXRbJ2FkZCddO1xyXG4gICAgICAgIGlmICghSXNDYWxsYWJsZShhZGRlcikpIHRocm93IFR5cGVFcnJvcigpO1xyXG4gICAgICAgIHZhciBpdGVyID0gR2V0SXRlcmF0b3IoVG9PYmplY3QoaXRlcmFibGUpKTtcclxuICAgICAgfVxyXG4gICAgICBzZXRfaW50ZXJuYWwoc2V0LCAnW1tTZXREYXRhXV0nLCBbXSk7XHJcbiAgICAgIGlmIChpdGVyID09PSB1bmRlZmluZWQpIHJldHVybiBzZXQ7XHJcbiAgICAgIHdoaWxlICh0cnVlKSB7XHJcbiAgICAgICAgdmFyIG5leHQgPSBJdGVyYXRvclN0ZXAoaXRlcik7XHJcbiAgICAgICAgaWYgKG5leHQgPT09IGZhbHNlKVxyXG4gICAgICAgICAgcmV0dXJuIHNldDtcclxuICAgICAgICB2YXIgbmV4dFZhbHVlID0gSXRlcmF0b3JWYWx1ZShuZXh0KTtcclxuICAgICAgICBhZGRlci5jYWxsKHNldCwgbmV4dFZhbHVlKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHNldDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoISgnU2V0JyBpbiBnbG9iYWwpIHx8IE9WRVJSSURFX05BVElWRV9GT1JfVEVTVElORyB8fFxyXG4gICAgICAgIChmdW5jdGlvbigpIHsgdHJ5IHsgcmV0dXJuICFuZXcgZ2xvYmFsLlNldCgpLmVudHJpZXMoKS5uZXh0OyB9IGNhdGNoIChfKSB7IHJldHVybiB0cnVlOyB9IH0oKSkgfHxcclxuICAgICAgICAobmV3IGdsb2JhbC5TZXQoWzFdKS5zaXplICE9PSAxKSlcclxuICAgICAgZ2xvYmFsLlNldCA9IFNldDtcclxuXHJcbiAgICBmdW5jdGlvbiBTZXREYXRhSW5kZXhPZihzZXREYXRhLCBrZXkpIHtcclxuICAgICAgdmFyIGk7XHJcbiAgICAgIGlmIChrZXkgPT09IGtleSlcclxuICAgICAgICByZXR1cm4gc2V0RGF0YS5pbmRleE9mKGtleSk7XHJcbiAgICAgIC8vIFNsb3cgY2FzZSBmb3IgTmFOXHJcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBzZXREYXRhLmxlbmd0aDsgaSArPSAxKVxyXG4gICAgICAgIGlmIChTYW1lVmFsdWVaZXJvKHNldERhdGFbaV0sIGtleSkpIHJldHVybiBpO1xyXG4gICAgICByZXR1cm4gLTE7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gMjMuMi4xLjIgbmV3IFNldCAoIC4uLmFyZ3VtZW50c0xpc3QgKVxyXG4gICAgLy8gMjMuMi4yIFByb3BlcnRpZXMgb2YgdGhlIFNldCBDb25zdHJ1Y3RvclxyXG5cclxuICAgIC8vIDIzLjIuMi4xIFNldC5wcm90b3R5cGVcclxuICAgIHZhciAkU2V0UHJvdG90eXBlJCA9ICB7fTtcclxuICAgIFNldC5wcm90b3R5cGUgPSAkU2V0UHJvdG90eXBlJDtcclxuXHJcbiAgICAvLyAyMy4yLjIuMiBnZXQgU2V0IFsgQEBzcGVjaWVzIF1cclxuICAgIC8vIDIzLjIuMyBQcm9wZXJ0aWVzIG9mIHRoZSBTZXQgUHJvdG90eXBlIE9iamVjdFxyXG5cclxuICAgIC8vIDIzLjIuMy4xIFNldC5wcm90b3R5cGUuYWRkICh2YWx1ZSApXHJcbiAgICBkZWZpbmUoXHJcbiAgICAgIFNldC5wcm90b3R5cGUsICdhZGQnLFxyXG4gICAgICBmdW5jdGlvbiBhZGQodmFsdWUpIHtcclxuICAgICAgICB2YXIgcyA9IHN0cmljdCh0aGlzKTtcclxuICAgICAgICBpZiAoVHlwZShzKSAhPT0gJ29iamVjdCcpIHRocm93IFR5cGVFcnJvcigpO1xyXG4gICAgICAgIGlmICghKCdbW1NldERhdGFdXScgaW4gcykpIHRocm93IFR5cGVFcnJvcigpO1xyXG4gICAgICAgIGlmIChzWydbW1NldERhdGFdXSddID09PSB1bmRlZmluZWQpIHRocm93IFR5cGVFcnJvcigpO1xyXG4gICAgICAgIGlmIChTYW1lVmFsdWUodmFsdWUsIC0wKSkgdmFsdWUgPSAwO1xyXG4gICAgICAgIHZhciBlbnRyaWVzID0gc1snW1tTZXREYXRhXV0nXTtcclxuICAgICAgICB2YXIgaSA9IFNldERhdGFJbmRleE9mKGVudHJpZXMsIHZhbHVlKTtcclxuICAgICAgICBpZiAoaSA8IDApIGkgPSBzWydbW1NldERhdGFdXSddLmxlbmd0aDtcclxuICAgICAgICBzWydbW1NldERhdGFdXSddW2ldID0gdmFsdWU7XHJcblxyXG4gICAgICAgIHJldHVybiBzO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAvLyAyMy4yLjMuMiBTZXQucHJvdG90eXBlLmNsZWFyICgpXHJcbiAgICBkZWZpbmUoXHJcbiAgICAgIFNldC5wcm90b3R5cGUsICdjbGVhcicsXHJcbiAgICAgIGZ1bmN0aW9uIGNsZWFyKCkge1xyXG4gICAgICAgIHZhciBzID0gc3RyaWN0KHRoaXMpO1xyXG4gICAgICAgIGlmIChUeXBlKHMpICE9PSAnb2JqZWN0JykgdGhyb3cgVHlwZUVycm9yKCk7XHJcbiAgICAgICAgaWYgKCEoJ1tbU2V0RGF0YV1dJyBpbiBzKSkgdGhyb3cgVHlwZUVycm9yKCk7XHJcbiAgICAgICAgaWYgKHNbJ1tbU2V0RGF0YV1dJ10gPT09IHVuZGVmaW5lZCkgdGhyb3cgVHlwZUVycm9yKCk7XHJcbiAgICAgICAgdmFyIGVudHJpZXMgPSBzWydbW1NldERhdGFdXSddO1xyXG4gICAgICAgIGVudHJpZXMubGVuZ3RoID0gMDtcclxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAvLyAyMy4yLjMuMyBTZXQucHJvdG90eXBlLmNvbnN0cnVjdG9yXHJcbiAgICAvLyAyMy4yLjMuNCBTZXQucHJvdG90eXBlLmRlbGV0ZSAoIHZhbHVlIClcclxuICAgIGRlZmluZShcclxuICAgICAgU2V0LnByb3RvdHlwZSwgJ2RlbGV0ZScsXHJcbiAgICAgIGZ1bmN0aW9uIGRlbGV0ZV8odmFsdWUpIHtcclxuICAgICAgICB2YXIgcyA9IHN0cmljdCh0aGlzKTtcclxuICAgICAgICBpZiAoVHlwZShzKSAhPT0gJ29iamVjdCcpIHRocm93IFR5cGVFcnJvcigpO1xyXG4gICAgICAgIGlmICghKCdbW1NldERhdGFdXScgaW4gcykpIHRocm93IFR5cGVFcnJvcigpO1xyXG4gICAgICAgIGlmIChzWydbW1NldERhdGFdXSddID09PSB1bmRlZmluZWQpIHRocm93IFR5cGVFcnJvcigpO1xyXG4gICAgICAgIHZhciBlbnRyaWVzID0gc1snW1tTZXREYXRhXV0nXTtcclxuICAgICAgICB2YXIgaSA9IFNldERhdGFJbmRleE9mKGVudHJpZXMsIHZhbHVlKTtcclxuICAgICAgICBpZiAoaSA8IDApIHJldHVybiBmYWxzZTtcclxuICAgICAgICBlbnRyaWVzW2ldID0gZW1wdHk7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgIC8vIDIzLjIuMy41IFNldC5wcm90b3R5cGUuZW50cmllcyAoIClcclxuICAgIGRlZmluZShcclxuICAgICAgU2V0LnByb3RvdHlwZSwgJ2VudHJpZXMnLFxyXG4gICAgICBmdW5jdGlvbiBlbnRyaWVzKCkge1xyXG4gICAgICAgIHZhciBzID0gc3RyaWN0KHRoaXMpO1xyXG4gICAgICAgIGlmIChUeXBlKHMpICE9PSAnb2JqZWN0JykgdGhyb3cgVHlwZUVycm9yKCk7XHJcbiAgICAgICAgcmV0dXJuIENyZWF0ZVNldEl0ZXJhdG9yKHMsICdrZXkrdmFsdWUnKTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgLy8gMjMuMi4zLjYgU2V0LnByb3RvdHlwZS5mb3JFYWNoICggY2FsbGJhY2tmbiBbICwgdGhpc0FyZyBdIClcclxuICAgIGRlZmluZShcclxuICAgICAgU2V0LnByb3RvdHlwZSwgJ2ZvckVhY2gnLFxyXG4gICAgICBmdW5jdGlvbiBmb3JFYWNoKGNhbGxiYWNrZm4vKiwgdGhpc0FyZyovKSB7XHJcbiAgICAgICAgdmFyIHRoaXNBcmcgPSBhcmd1bWVudHNbMV07XHJcblxyXG4gICAgICAgIHZhciBzID0gc3RyaWN0KHRoaXMpO1xyXG4gICAgICAgIGlmIChUeXBlKHMpICE9PSAnb2JqZWN0JykgdGhyb3cgVHlwZUVycm9yKCk7XHJcbiAgICAgICAgaWYgKCEoJ1tbU2V0RGF0YV1dJyBpbiBzKSkgdGhyb3cgVHlwZUVycm9yKCk7XHJcbiAgICAgICAgaWYgKHNbJ1tbU2V0RGF0YV1dJ10gPT09IHVuZGVmaW5lZCkgdGhyb3cgVHlwZUVycm9yKCk7XHJcbiAgICAgICAgdmFyIGVudHJpZXMgPSBzWydbW1NldERhdGFdXSddO1xyXG5cclxuICAgICAgICBpZiAoIUlzQ2FsbGFibGUoY2FsbGJhY2tmbikpIHtcclxuICAgICAgICAgIHRocm93IFR5cGVFcnJvcignRmlyc3QgYXJndW1lbnQgdG8gZm9yRWFjaCBpcyBub3QgY2FsbGFibGUuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZW50cmllcy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgaWYgKGVudHJpZXNbaV0gIT09IGVtcHR5KSB7XHJcbiAgICAgICAgICAgIGNhbGxiYWNrZm4uY2FsbCh0aGlzQXJnLCBlbnRyaWVzW2ldLCBlbnRyaWVzW2ldLCBzKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG5cclxuICAgIC8vIDIzLjIuMy43IFNldC5wcm90b3R5cGUuaGFzICggdmFsdWUgKVxyXG4gICAgZGVmaW5lKFxyXG4gICAgICBTZXQucHJvdG90eXBlLCAnaGFzJyxcclxuICAgICAgZnVuY3Rpb24gaGFzKGtleSkge1xyXG4gICAgICAgIHZhciBzID0gc3RyaWN0KHRoaXMpO1xyXG4gICAgICAgIGlmIChUeXBlKHMpICE9PSAnb2JqZWN0JykgdGhyb3cgVHlwZUVycm9yKCk7XHJcbiAgICAgICAgaWYgKCEoJ1tbU2V0RGF0YV1dJyBpbiBzKSkgdGhyb3cgVHlwZUVycm9yKCk7XHJcbiAgICAgICAgaWYgKHNbJ1tbU2V0RGF0YV1dJ10gPT09IHVuZGVmaW5lZCkgdGhyb3cgVHlwZUVycm9yKCk7XHJcbiAgICAgICAgdmFyIGVudHJpZXMgPSBzWydbW1NldERhdGFdXSddO1xyXG4gICAgICAgIHJldHVybiBTZXREYXRhSW5kZXhPZihlbnRyaWVzLCBrZXkpICE9PSAtMTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgLy8gMjMuMi4zLjggU2V0LnByb3RvdHlwZS5rZXlzICggKVxyXG4gICAgLy8gU2VlIFNldC5wcm90b3R5cGUudmFsdWVzXHJcblxyXG4gICAgLy8gMjMuMi4zLjkgZ2V0IFNldC5wcm90b3R5cGUuc2l6ZVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFxyXG4gICAgICBTZXQucHJvdG90eXBlLCAnc2l6ZScsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgdmFyIHMgPSBzdHJpY3QodGhpcyk7XHJcbiAgICAgICAgICBpZiAoVHlwZShzKSAhPT0gJ29iamVjdCcpIHRocm93IFR5cGVFcnJvcigpO1xyXG4gICAgICAgICAgaWYgKCEoJ1tbU2V0RGF0YV1dJyBpbiBzKSkgdGhyb3cgVHlwZUVycm9yKCk7XHJcbiAgICAgICAgICBpZiAoc1snW1tTZXREYXRhXV0nXSA9PT0gdW5kZWZpbmVkKSB0aHJvdyBUeXBlRXJyb3IoKTtcclxuICAgICAgICAgIHZhciBlbnRyaWVzID0gc1snW1tTZXREYXRhXV0nXTtcclxuICAgICAgICAgIHZhciBjb3VudCA9IDA7XHJcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVudHJpZXMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgaWYgKGVudHJpZXNbaV0gIT09IGVtcHR5KVxyXG4gICAgICAgICAgICAgIGNvdW50ID0gY291bnQgKyAxO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgcmV0dXJuIGNvdW50O1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcblxyXG4gICAgLy8gMjMuMi4zLjEwIFNldC5wcm90b3R5cGUudmFsdWVzICggKVxyXG4gICAgZGVmaW5lKFxyXG4gICAgICBTZXQucHJvdG90eXBlLCAndmFsdWVzJyxcclxuICAgICAgZnVuY3Rpb24gdmFsdWVzKCkge1xyXG4gICAgICAgIHZhciBzID0gc3RyaWN0KHRoaXMpO1xyXG4gICAgICAgIGlmIChUeXBlKHMpICE9PSAnb2JqZWN0JykgdGhyb3cgVHlwZUVycm9yKCk7XHJcbiAgICAgICAgcmV0dXJuIENyZWF0ZVNldEl0ZXJhdG9yKHMsICd2YWx1ZScpO1xyXG4gICAgICB9KTtcclxuICAgIC8vIE5PVEU6IGZ1bmN0aW9uIG5hbWUgaXMgc3RpbGwgJ3ZhbHVlcyc6XHJcbiAgICBTZXQucHJvdG90eXBlLmtleXMgPSBTZXQucHJvdG90eXBlLnZhbHVlcztcclxuXHJcbiAgICAvLyAyMy4yLjMuMTEgU2V0LnByb3RvdHlwZSBbQEBpdGVyYXRvciBdICggKVxyXG4gICAgZGVmaW5lKFxyXG4gICAgICBTZXQucHJvdG90eXBlLCAkJGl0ZXJhdG9yLFxyXG4gICAgICBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgcyA9IHN0cmljdCh0aGlzKTtcclxuICAgICAgICBpZiAoVHlwZShzKSAhPT0gJ29iamVjdCcpIHRocm93IFR5cGVFcnJvcigpO1xyXG4gICAgICAgIHJldHVybiBDcmVhdGVTZXRJdGVyYXRvcihzKTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgLy8gMjMuMi4zLjEyIFNldC5wcm90b3R5cGUgWyBAQHRvU3RyaW5nVGFnIF1cclxuICAgIGRlZmluZShnbG9iYWwuU2V0LnByb3RvdHlwZSwgJCR0b1N0cmluZ1RhZywgJ1NldCcpO1xyXG5cclxuICAgIC8vIDIzLjIuNCBQcm9wZXJ0aWVzIG9mIFNldCBJbnN0YW5jZXNcclxuICAgIC8vIDIzLjIuNSBTZXQgSXRlcmF0b3IgT2JqZWN0c1xyXG4gICAgLyoqIEBjb25zdHJ1Y3RvciAqL1xyXG4gICAgZnVuY3Rpb24gU2V0SXRlcmF0b3IoKSB7fVxyXG5cclxuICAgIC8vIDIzLjIuNS4xIENyZWF0ZVNldEl0ZXJhdG9yIEFic3RyYWN0IE9wZXJhdGlvblxyXG4gICAgZnVuY3Rpb24gQ3JlYXRlU2V0SXRlcmF0b3Ioc2V0LCBraW5kKSB7XHJcbiAgICAgIGlmIChUeXBlKHNldCkgIT09ICdvYmplY3QnKSB0aHJvdyBUeXBlRXJyb3IoKTtcclxuICAgICAgaWYgKCEoJ1tbU2V0RGF0YV1dJyBpbiBzZXQpKSB0aHJvdyBUeXBlRXJyb3IoKTtcclxuICAgICAgaWYgKHNldFsnW1tTZXREYXRhXV0nXSA9PT0gdW5kZWZpbmVkKSB0aHJvdyBUeXBlRXJyb3IoKTtcclxuICAgICAgdmFyIGl0ZXJhdG9yID0gbmV3IFNldEl0ZXJhdG9yO1xyXG4gICAgICBzZXRfaW50ZXJuYWwoaXRlcmF0b3IsICdbW0l0ZXJhdGVkU2V0XV0nLCBzZXQpO1xyXG4gICAgICBzZXRfaW50ZXJuYWwoaXRlcmF0b3IsICdbW1NldE5leHRJbmRleF1dJywgMCk7XHJcbiAgICAgIHNldF9pbnRlcm5hbChpdGVyYXRvciwgJ1tbU2V0SXRlcmF0aW9uS2luZF1dJywga2luZCk7XHJcbiAgICAgIHJldHVybiBpdGVyYXRvcjtcclxuICAgIH1cclxuXHJcbiAgICAvLyAyMy4yLjUuMiBUaGUgJVNldEl0ZXJhdG9yUHJvdG90eXBlJSBPYmplY3RcclxuICAgIHZhciAkU2V0SXRlcmF0b3JQcm90b3R5cGUkID0gT2JqZWN0LmNyZWF0ZSgkSXRlcmF0b3JQcm90b3R5cGUkKTtcclxuICAgIFNldEl0ZXJhdG9yLnByb3RvdHlwZSA9ICRTZXRJdGVyYXRvclByb3RvdHlwZSQ7XHJcblxyXG4gICAgLy8gMjMuMi41LjIuMSAlU2V0SXRlcmF0b3JQcm90b3R5cGUlLm5leHQoIClcclxuICAgIGRlZmluZShcclxuICAgICAgJFNldEl0ZXJhdG9yUHJvdG90eXBlJCwgJ25leHQnLFxyXG4gICAgICBmdW5jdGlvbiBuZXh0KCkge1xyXG4gICAgICAgIHZhciBvID0gc3RyaWN0KHRoaXMpO1xyXG4gICAgICAgIGlmIChUeXBlKG8pICE9PSAnb2JqZWN0JykgdGhyb3cgVHlwZUVycm9yKCk7XHJcbiAgICAgICAgdmFyIHMgPSBvWydbW0l0ZXJhdGVkU2V0XV0nXSxcclxuICAgICAgICAgICAgaW5kZXggPSBvWydbW1NldE5leHRJbmRleF1dJ10sXHJcbiAgICAgICAgICAgIGl0ZW1LaW5kID0gb1snW1tTZXRJdGVyYXRpb25LaW5kXV0nXSxcclxuICAgICAgICAgICAgZW50cmllcyA9IHNbJ1tbU2V0RGF0YV1dJ107XHJcbiAgICAgICAgd2hpbGUgKGluZGV4IDwgZW50cmllcy5sZW5ndGgpIHtcclxuICAgICAgICAgIHZhciBlID0gZW50cmllc1tpbmRleF07XHJcbiAgICAgICAgICBpbmRleCA9IGluZGV4ICs9IDE7XHJcbiAgICAgICAgICBzZXRfaW50ZXJuYWwobywgJ1tbU2V0TmV4dEluZGV4XV0nLCBpbmRleCk7XHJcbiAgICAgICAgICBpZiAoZSAhPT0gZW1wdHkpIHtcclxuICAgICAgICAgICAgaWYgKGl0ZW1LaW5kID09PSAna2V5K3ZhbHVlJylcclxuICAgICAgICAgICAgICByZXR1cm4gQ3JlYXRlSXRlclJlc3VsdE9iamVjdChbZSwgZV0sIGZhbHNlKTtcclxuICAgICAgICAgICAgcmV0dXJuIENyZWF0ZUl0ZXJSZXN1bHRPYmplY3QoZSwgZmFsc2UpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gQ3JlYXRlSXRlclJlc3VsdE9iamVjdCh1bmRlZmluZWQsIHRydWUpO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAvLyAyMy4yLjUuMi4yICVTZXRJdGVyYXRvclByb3RvdHlwZSUgWyBAQHRvU3RyaW5nVGFnIF1cclxuICAgIGRlZmluZSgkU2V0SXRlcmF0b3JQcm90b3R5cGUkLCAkJHRvU3RyaW5nVGFnLCAnU2V0IEl0ZXJhdG9yJyk7XHJcblxyXG4gICAgLy8gMjMuMi41LjMgUHJvcGVydGllcyBvZiBTZXQgSXRlcmF0b3IgSW5zdGFuY2VzXHJcblxyXG4gIH0oKSk7XHJcblxyXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gIC8vIDIzLjMgV2Vha01hcCBPYmplY3RzXHJcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG4gIChmdW5jdGlvbigpIHtcclxuICAgIC8vIDIzLjMuMSBUaGUgV2Vha01hcCBDb25zdHJ1Y3RvclxyXG4gICAgLy8gMjMuMy4xLjEgV2Vha01hcCAoIFsgaXRlcmFibGUgXSApXHJcbiAgICAvKiogQGNvbnN0cnVjdG9yICovXHJcbiAgICBmdW5jdGlvbiBXZWFrTWFwKC8qaXRlcmFibGUqLykge1xyXG4gICAgICB2YXIgbWFwID0gc3RyaWN0KHRoaXMpO1xyXG4gICAgICB2YXIgaXRlcmFibGUgPSBhcmd1bWVudHNbMF07XHJcblxyXG4gICAgICBpZiAoVHlwZShtYXApICE9PSAnb2JqZWN0JykgdGhyb3cgVHlwZUVycm9yKCk7XHJcbiAgICAgIGlmICgnW1tXZWFrTWFwRGF0YV1dJyBpbiBtYXApIHRocm93IFR5cGVFcnJvcigpO1xyXG5cclxuICAgICAgaWYgKGl0ZXJhYmxlICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICB2YXIgYWRkZXIgPSBtYXBbJ3NldCddO1xyXG4gICAgICAgIGlmICghSXNDYWxsYWJsZShhZGRlcikpIHRocm93IFR5cGVFcnJvcigpO1xyXG4gICAgICAgIHZhciBpdGVyID0gR2V0SXRlcmF0b3IoVG9PYmplY3QoaXRlcmFibGUpKTtcclxuICAgICAgfVxyXG4gICAgICBzZXRfaW50ZXJuYWwobWFwLCAnW1tXZWFrTWFwRGF0YV1dJywgbmV3IEVwaGVtZXJvblRhYmxlKTtcclxuICAgICAgaWYgKGl0ZXIgPT09IHVuZGVmaW5lZCkgcmV0dXJuIG1hcDtcclxuICAgICAgd2hpbGUgKHRydWUpIHtcclxuICAgICAgICB2YXIgbmV4dCA9IEl0ZXJhdG9yU3RlcChpdGVyKTtcclxuICAgICAgICBpZiAobmV4dCA9PT0gZmFsc2UpXHJcbiAgICAgICAgICByZXR1cm4gbWFwO1xyXG4gICAgICAgIHZhciBuZXh0VmFsdWUgPSBJdGVyYXRvclZhbHVlKG5leHQpO1xyXG4gICAgICAgIGlmIChUeXBlKG5leHRWYWx1ZSkgIT09ICdvYmplY3QnKSB0aHJvdyBUeXBlRXJyb3IoKTtcclxuICAgICAgICB2YXIgayA9IG5leHRWYWx1ZVswXTtcclxuICAgICAgICB2YXIgdiA9IG5leHRWYWx1ZVsxXTtcclxuICAgICAgICBhZGRlci5jYWxsKG1hcCwgaywgdik7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBtYXA7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCEoJ1dlYWtNYXAnIGluIGdsb2JhbCkgfHwgT1ZFUlJJREVfTkFUSVZFX0ZPUl9URVNUSU5HKVxyXG4gICAgICBnbG9iYWwuV2Vha01hcCA9IFdlYWtNYXA7XHJcblxyXG4gICAgLy8gMjMuMy4yIFByb3BlcnRpZXMgb2YgdGhlIFdlYWtNYXAgQ29uc3RydWN0b3JcclxuICAgIC8vIDIzLjMuMi4xIFdlYWtNYXAucHJvdG90eXBlXHJcbiAgICB2YXIgJFdlYWtNYXBQcm90b3R5cGUkID0ge307XHJcbiAgICBXZWFrTWFwLnByb3RvdHlwZSA9ICRXZWFrTWFwUHJvdG90eXBlJDtcclxuXHJcblxyXG5cclxuICAgLy8gMjMuMy4yLjIgV2Vha01hcFsgQEBjcmVhdGUgXSAoIClcclxuICAgIC8vIDIzLjMuMyBQcm9wZXJ0aWVzIG9mIHRoZSBXZWFrTWFwIFByb3RvdHlwZSBPYmplY3RcclxuXHJcbiAgICAvLyAyMy4zLjMuMSBXZWFrTWFwLnByb3RvdHlwZS5jb25zdHJ1Y3RvclxyXG5cclxuICAgIC8vIDIzLjMuMy4yIFdlYWtNYXAucHJvdG90eXBlLmRlbGV0ZSAoIGtleSApXHJcbiAgICBkZWZpbmUoXHJcbiAgICAgIFdlYWtNYXAucHJvdG90eXBlLCAnZGVsZXRlJyxcclxuICAgICAgZnVuY3Rpb24gZGVsZXRlXyhrZXkpIHtcclxuICAgICAgICB2YXIgTSA9IHN0cmljdCh0aGlzKTtcclxuICAgICAgICBpZiAoVHlwZShNKSAhPT0gJ29iamVjdCcpIHRocm93IFR5cGVFcnJvcigpO1xyXG4gICAgICAgIGlmIChNWydbW1dlYWtNYXBEYXRhXV0nXSA9PT0gdW5kZWZpbmVkKSB0aHJvdyBUeXBlRXJyb3IoKTtcclxuICAgICAgICBpZiAoVHlwZShrZXkpICE9PSAnb2JqZWN0JykgdGhyb3cgVHlwZUVycm9yKCdFeHBlY3RlZCBvYmplY3QnKTtcclxuICAgICAgICByZXR1cm4gTVsnW1tXZWFrTWFwRGF0YV1dJ10ucmVtb3ZlKGtleSk7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgIC8vIDIzLjMuMy4zIFdlYWtNYXAucHJvdG90eXBlLmdldCAoIGtleSApXHJcbiAgICBkZWZpbmUoXHJcbiAgICAgIFdlYWtNYXAucHJvdG90eXBlLCAnZ2V0JyxcclxuICAgICAgZnVuY3Rpb24gZ2V0KGtleSwgZGVmYXVsdFZhbHVlKSB7XHJcbiAgICAgICAgdmFyIE0gPSBzdHJpY3QodGhpcyk7XHJcbiAgICAgICAgaWYgKFR5cGUoTSkgIT09ICdvYmplY3QnKSB0aHJvdyBUeXBlRXJyb3IoKTtcclxuICAgICAgICBpZiAoTVsnW1tXZWFrTWFwRGF0YV1dJ10gPT09IHVuZGVmaW5lZCkgdGhyb3cgVHlwZUVycm9yKCk7XHJcbiAgICAgICAgaWYgKFR5cGUoa2V5KSAhPT0gJ29iamVjdCcpIHRocm93IFR5cGVFcnJvcignRXhwZWN0ZWQgb2JqZWN0Jyk7XHJcbiAgICAgICAgcmV0dXJuIE1bJ1tbV2Vha01hcERhdGFdXSddLmdldChrZXksIGRlZmF1bHRWYWx1ZSk7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgIC8vIDIzLjMuMy40IFdlYWtNYXAucHJvdG90eXBlLmhhcyAoIGtleSApXHJcbiAgICBkZWZpbmUoXHJcbiAgICAgIFdlYWtNYXAucHJvdG90eXBlLCAnaGFzJyxcclxuICAgICAgZnVuY3Rpb24gaGFzKGtleSkge1xyXG4gICAgICAgIHZhciBNID0gc3RyaWN0KHRoaXMpO1xyXG4gICAgICAgIGlmIChUeXBlKE0pICE9PSAnb2JqZWN0JykgdGhyb3cgVHlwZUVycm9yKCk7XHJcbiAgICAgICAgaWYgKE1bJ1tbV2Vha01hcERhdGFdXSddID09PSB1bmRlZmluZWQpIHRocm93IFR5cGVFcnJvcigpO1xyXG4gICAgICAgIGlmIChUeXBlKGtleSkgIT09ICdvYmplY3QnKSB0aHJvdyBUeXBlRXJyb3IoJ0V4cGVjdGVkIG9iamVjdCcpO1xyXG4gICAgICAgIHJldHVybiBNWydbW1dlYWtNYXBEYXRhXV0nXS5oYXMoa2V5KTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgLy8gMjMuMy4zLjUgV2Vha01hcC5wcm90b3R5cGUuc2V0ICgga2V5ICwgdmFsdWUgKVxyXG4gICAgZGVmaW5lKFxyXG4gICAgICBXZWFrTWFwLnByb3RvdHlwZSwgJ3NldCcsXHJcbiAgICAgIGZ1bmN0aW9uIHNldChrZXksIHZhbHVlKSB7XHJcbiAgICAgICAgdmFyIE0gPSBzdHJpY3QodGhpcyk7XHJcbiAgICAgICAgaWYgKFR5cGUoTSkgIT09ICdvYmplY3QnKSB0aHJvdyBUeXBlRXJyb3IoKTtcclxuICAgICAgICBpZiAoTVsnW1tXZWFrTWFwRGF0YV1dJ10gPT09IHVuZGVmaW5lZCkgdGhyb3cgVHlwZUVycm9yKCk7XHJcbiAgICAgICAgaWYgKFR5cGUoa2V5KSAhPT0gJ29iamVjdCcpIHRocm93IFR5cGVFcnJvcignRXhwZWN0ZWQgb2JqZWN0Jyk7XHJcbiAgICAgICAgTVsnW1tXZWFrTWFwRGF0YV1dJ10uc2V0KGtleSwgdmFsdWUpO1xyXG4gICAgICAgIHJldHVybiBNO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAvLyAyMy4zLjMuNiBXZWFrTWFwLnByb3RvdHlwZSBbIEBAdG9TdHJpbmdUYWcgXVxyXG4gICAgZGVmaW5lKGdsb2JhbC5XZWFrTWFwLnByb3RvdHlwZSwgJCR0b1N0cmluZ1RhZywgJ1dlYWtNYXAnKTtcclxuXHJcbiAgICAvLyAyMy4zLjQgUHJvcGVydGllcyBvZiBXZWFrTWFwIEluc3RhbmNlc1xyXG5cclxuICAgIC8vIFBvbHlmaWxscyBmb3IgaW5jb21wbGV0ZSBuYXRpdmUgaW1wbGVtZW50YXRpb25zOlxyXG4gICAgKGZ1bmN0aW9uKCkge1xyXG4gICAgICB2YXIgd20gPSBuZXcgZ2xvYmFsLldlYWtNYXAoKTtcclxuICAgICAgdmFyIG9yaWcgPSBnbG9iYWwuV2Vha01hcC5wcm90b3R5cGUuc2V0O1xyXG4gICAgICBkZWZpbmUoZ2xvYmFsLldlYWtNYXAucHJvdG90eXBlLCAnc2V0JywgZnVuY3Rpb24gc2V0KCkge1xyXG4gICAgICAgIG9yaWcuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgfSwgd20uc2V0KHt9LCAwKSAhPT0gd20pO1xyXG4gICAgfSgpKTtcclxuICB9KCkpO1xyXG5cclxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAvLyAyMy40IFdlYWtTZXQgT2JqZWN0c1xyXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cclxuICAoZnVuY3Rpb24oKSB7XHJcbiAgICAvLyAyMy40LjEgVGhlIFdlYWtTZXQgQ29uc3RydWN0b3JcclxuICAgIC8vIDIzLjQuMS4xIFdlYWtTZXQgKCBbIGl0ZXJhYmxlIF0gKVxyXG4gICAgLyoqIEBjb25zdHJ1Y3RvciAqL1xyXG4gICAgZnVuY3Rpb24gV2Vha1NldCgvKml0ZXJhYmxlKi8pIHtcclxuICAgICAgdmFyIHNldCA9IHN0cmljdCh0aGlzKTtcclxuICAgICAgdmFyIGl0ZXJhYmxlID0gYXJndW1lbnRzWzBdO1xyXG5cclxuICAgICAgaWYgKFR5cGUoc2V0KSAhPT0gJ29iamVjdCcpIHRocm93IFR5cGVFcnJvcigpO1xyXG4gICAgICBpZiAoJ1tbV2Vha1NldERhdGFdXScgaW4gc2V0KSB0aHJvdyBUeXBlRXJyb3IoKTtcclxuXHJcbiAgICAgIGlmIChpdGVyYWJsZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgdmFyIGFkZGVyID0gc2V0WydhZGQnXTtcclxuICAgICAgICBpZiAoIUlzQ2FsbGFibGUoYWRkZXIpKSB0aHJvdyBUeXBlRXJyb3IoKTtcclxuICAgICAgICB2YXIgaXRlciA9IEdldEl0ZXJhdG9yKFRvT2JqZWN0KGl0ZXJhYmxlKSk7XHJcbiAgICAgIH1cclxuICAgICAgc2V0X2ludGVybmFsKHNldCwgJ1tbV2Vha1NldERhdGFdXScsIG5ldyBFcGhlbWVyb25UYWJsZSk7XHJcbiAgICAgIGlmIChpdGVyID09PSB1bmRlZmluZWQpIHJldHVybiBzZXQ7XHJcbiAgICAgIHdoaWxlICh0cnVlKSB7XHJcbiAgICAgICAgdmFyIG5leHQgPSBJdGVyYXRvclN0ZXAoaXRlcik7XHJcbiAgICAgICAgaWYgKG5leHQgPT09IGZhbHNlKVxyXG4gICAgICAgICAgcmV0dXJuIHNldDtcclxuICAgICAgICB2YXIgbmV4dFZhbHVlID0gSXRlcmF0b3JWYWx1ZShuZXh0KTtcclxuICAgICAgICBhZGRlci5jYWxsKHNldCwgbmV4dFZhbHVlKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHNldDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoISgnV2Vha1NldCcgaW4gZ2xvYmFsKSB8fCBPVkVSUklERV9OQVRJVkVfRk9SX1RFU1RJTkcpXHJcbiAgICAgIGdsb2JhbC5XZWFrU2V0ID0gV2Vha1NldDtcclxuXHJcbiAgICAvLyAyMy40LjIgUHJvcGVydGllcyBvZiB0aGUgV2Vha1NldCBDb25zdHJ1Y3RvclxyXG4gICAgLy8gMjMuNC4yLjEgV2Vha1NldC5wcm90b3R5cGVcclxuICAgIHZhciAkV2Vha1NldFByb3RvdHlwZSQgPSB7fTtcclxuICAgIFdlYWtTZXQucHJvdG90eXBlID0gJFdlYWtTZXRQcm90b3R5cGUkO1xyXG5cclxuICAgIC8vIDIzLjQuMyBQcm9wZXJ0aWVzIG9mIHRoZSBXZWFrU2V0IFByb3RvdHlwZSBPYmplY3RcclxuICAgIC8vIDIzLjQuMy4xIFdlYWtTZXQucHJvdG90eXBlLmFkZCAodmFsdWUgKVxyXG4gICAgZGVmaW5lKFxyXG4gICAgICBXZWFrU2V0LnByb3RvdHlwZSwgJ2FkZCcsXHJcbiAgICAgIGZ1bmN0aW9uIGFkZCh2YWx1ZSkge1xyXG4gICAgICAgIHZhciBTID0gc3RyaWN0KHRoaXMpO1xyXG4gICAgICAgIGlmIChUeXBlKFMpICE9PSAnb2JqZWN0JykgdGhyb3cgVHlwZUVycm9yKCk7XHJcbiAgICAgICAgaWYgKFNbJ1tbV2Vha1NldERhdGFdXSddID09PSB1bmRlZmluZWQpIHRocm93IFR5cGVFcnJvcigpO1xyXG4gICAgICAgIGlmIChUeXBlKHZhbHVlKSAhPT0gJ29iamVjdCcpIHRocm93IFR5cGVFcnJvcignRXhwZWN0ZWQgb2JqZWN0Jyk7XHJcbiAgICAgICAgU1snW1tXZWFrU2V0RGF0YV1dJ10uc2V0KHZhbHVlLCB0cnVlKTtcclxuICAgICAgICByZXR1cm4gUztcclxuICAgICAgfSk7XHJcblxyXG4gICAgLy8gMjMuNC4zLjIgV2Vha1NldC5wcm90b3R5cGUuY29uc3RydWN0b3JcclxuICAgIC8vIDIzLjQuMy4zIFdlYWtTZXQucHJvdG90eXBlLmRlbGV0ZSAoIHZhbHVlIClcclxuICAgIGRlZmluZShcclxuICAgICAgV2Vha1NldC5wcm90b3R5cGUsICdkZWxldGUnLFxyXG4gICAgICBmdW5jdGlvbiBkZWxldGVfKHZhbHVlKSB7XHJcbiAgICAgICAgdmFyIFMgPSBzdHJpY3QodGhpcyk7XHJcbiAgICAgICAgaWYgKFR5cGUoUykgIT09ICdvYmplY3QnKSB0aHJvdyBUeXBlRXJyb3IoKTtcclxuICAgICAgICBpZiAoU1snW1tXZWFrU2V0RGF0YV1dJ10gPT09IHVuZGVmaW5lZCkgdGhyb3cgVHlwZUVycm9yKCk7XHJcbiAgICAgICAgaWYgKFR5cGUodmFsdWUpICE9PSAnb2JqZWN0JykgdGhyb3cgVHlwZUVycm9yKCdFeHBlY3RlZCBvYmplY3QnKTtcclxuICAgICAgICByZXR1cm4gU1snW1tXZWFrU2V0RGF0YV1dJ10ucmVtb3ZlKHZhbHVlKTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgLy8gMjMuNC4zLjQgV2Vha1NldC5wcm90b3R5cGUuaGFzICggdmFsdWUgKVxyXG4gICAgZGVmaW5lKFxyXG4gICAgICBXZWFrU2V0LnByb3RvdHlwZSwgJ2hhcycsXHJcbiAgICAgIGZ1bmN0aW9uIGhhcyhrZXkpIHtcclxuICAgICAgICB2YXIgUyA9IHN0cmljdCh0aGlzKTtcclxuICAgICAgICBpZiAoVHlwZShTKSAhPT0gJ29iamVjdCcpIHRocm93IFR5cGVFcnJvcigpO1xyXG4gICAgICAgIGlmIChTWydbW1dlYWtTZXREYXRhXV0nXSA9PT0gdW5kZWZpbmVkKSB0aHJvdyBUeXBlRXJyb3IoKTtcclxuICAgICAgICBpZiAoVHlwZShrZXkpICE9PSAnb2JqZWN0JykgdGhyb3cgVHlwZUVycm9yKCdFeHBlY3RlZCBvYmplY3QnKTtcclxuICAgICAgICByZXR1cm4gU1snW1tXZWFrU2V0RGF0YV1dJ10uaGFzKGtleSk7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgIC8vIDIzLjQuMy41IFdlYWtTZXQucHJvdG90eXBlIFsgQEB0b1N0cmluZ1RhZyBdXHJcbiAgICBkZWZpbmUoZ2xvYmFsLldlYWtTZXQucHJvdG90eXBlLCAkJHRvU3RyaW5nVGFnLCAnV2Vha1NldCcpO1xyXG5cclxuICAgIC8vIDIzLjQuNCBQcm9wZXJ0aWVzIG9mIFdlYWtTZXQgSW5zdGFuY2VzXHJcblxyXG4gICAgLy8gUG9seWZpbGxzIGZvciBpbmNvbXBsZXRlIG5hdGl2ZSBpbXBsZW1lbnRhdGlvbnM6XHJcbiAgICAoZnVuY3Rpb24oKSB7XHJcbiAgICAgIHZhciB3cyA9IG5ldyBnbG9iYWwuV2Vha1NldCgpO1xyXG4gICAgICB2YXIgb3JpZyA9IGdsb2JhbC5XZWFrU2V0LnByb3RvdHlwZS5hZGQ7XHJcbiAgICAgIGRlZmluZShnbG9iYWwuV2Vha1NldC5wcm90b3R5cGUsICdhZGQnLCBmdW5jdGlvbiBhZGQoKSB7XHJcbiAgICAgICAgb3JpZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICB9LCB3cy5hZGQoe30pICE9PSB3cyk7XHJcbiAgICB9KCkpO1xyXG4gIH0oKSk7XHJcblxyXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gIC8vIDI0IFN0cnVjdHVyZWQgRGF0YVxyXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cclxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAvLyAyNC4xIEFycmF5QnVmZmVyIE9iamVjdHNcclxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcbiAgLy8gU2VlIHR5cGVkYXJyYXkuanMgZm9yIFR5cGVkQXJyYXkgcG9seWZpbGxcclxuXHJcbiAgKGZ1bmN0aW9uKCkge1xyXG4gICAgaWYgKCEoJ0FycmF5QnVmZmVyJyBpbiBnbG9iYWwpKVxyXG4gICAgICByZXR1cm47XHJcblxyXG4gICAgLy8gMjQuMS4xIEFic3RyYWN0IE9wZXJhdGlvbnMgRm9yIEFycmF5QnVmZmVyIE9iamVjdHNcclxuICAgIC8vIDI0LjEuMS4xIEFsbG9jYXRlQXJyYXlCdWZmZXIoIGNvbnN0cnVjdG9yLCBieXRlTGVuZ3RoIClcclxuICAgIC8vIDI0LjEuMS4yIElzRGV0YWNoZWRCdWZmZXIoIGFycmF5QnVmZmVyIClcclxuICAgIC8vIDI0LjEuMS4zIERldGFjaEFycmF5QnVmZmVyKCBhcnJheUJ1ZmZlciApXHJcbiAgICAvLyAyNC4xLjEuNCBDbG9uZUFycmF5QnVmZmVyKCBzcmNCdWZmZXIsIHNyY0J5dGVPZmZzZXQgWywgY2xvbmVDb25zdHJ1Y3Rvcl0gKVxyXG4gICAgLy8gMjQuMS4xLjUgR2V0VmFsdWVGcm9tQnVmZmVyICggYXJyYXlCdWZmZXIsIGJ5dGVJbmRleCwgdHlwZSwgaXNMaXR0bGVFbmRpYW4gKVxyXG4gICAgLy8gMjQuMS4xLjYgU2V0VmFsdWVJbkJ1ZmZlciAoIGFycmF5QnVmZmVyLCBieXRlSW5kZXgsIHR5cGUsIHZhbHVlLCBpc0xpdHRsZUVuZGlhbiApXHJcbiAgICAvLyAyNC4xLjIgVGhlIEFycmF5QnVmZmVyIENvbnN0cnVjdG9yXHJcbiAgICAvLyAyNC4xLjIuMSBBcnJheUJ1ZmZlciggbGVuZ3RoIClcclxuICAgIC8vIDI0LjEuMyBQcm9wZXJ0aWVzIG9mIHRoZSBBcnJheUJ1ZmZlciBDb25zdHJ1Y3RvclxyXG5cclxuICAgIC8vIDI0LjEuMy4xIEFycmF5QnVmZmVyLmlzVmlldyAoIGFyZyApXHJcbiAgICBkZWZpbmUoXHJcbiAgICAgIEFycmF5QnVmZmVyLCAnaXNWaWV3JyxcclxuICAgICAgZnVuY3Rpb24gaXNWaWV3KGFyZykge1xyXG4gICAgICAgIGlmIChUeXBlKGFyZykgIT09ICdvYmplY3QnKSByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgaWYgKCdidWZmZXInIGluIGFyZyAmJiBhcmcuYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHJldHVybiB0cnVlO1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgLy8gMjQuMS4zLjIgQXJyYXlCdWZmZXIucHJvdG90eXBlXHJcbiAgICAvLyAyNC4xLjMuMyBnZXQgQXJyYXlCdWZmZXIgWyBAQHNwZWNpZXMgXVxyXG4gICAgLy8gMjQuMS40IFByb3BlcnRpZXMgb2YgdGhlIEFycmF5QnVmZmVyIFByb3RvdHlwZSBPYmplY3RcclxuICAgIC8vIDI0LjEuNC4xIGdldCBBcnJheUJ1ZmZlci5wcm90b3R5cGUuYnl0ZUxlbmd0aFxyXG4gICAgLy8gMjQuMS40LjIgQXJyYXlCdWZmZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yXHJcbiAgICAvLyAyNC4xLjQuMyBBcnJheUJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgKCBzdGFydCAsIGVuZClcclxuXHJcbiAgICAvLyAyNC4xLjQuNCBBcnJheUJ1ZmZlci5wcm90b3R5cGUgWyBAQHRvU3RyaW5nVGFnIF1cclxuICAgIGRlZmluZShBcnJheUJ1ZmZlci5wcm90b3R5cGUsICQkdG9TdHJpbmdUYWcsICdBcnJheUJ1ZmZlcicpO1xyXG5cclxuICAgIC8vIDI0LjEuNSBQcm9wZXJ0aWVzIG9mIHRoZSBBcnJheUJ1ZmZlciBJbnN0YW5jZXNcclxuICB9KCkpO1xyXG5cclxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAvLyAyNC4yIERhdGFWaWV3IE9iamVjdHNcclxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcbiAgLy8gU2VlIHR5cGVkYXJyYXkuanMgZm9yIFR5cGVkQXJyYXkgcG9seWZpbGxcclxuXHJcbiAgKGZ1bmN0aW9uKCkge1xyXG4gICAgaWYgKCEoJ0RhdGFWaWV3JyBpbiBnbG9iYWwpKVxyXG4gICAgICByZXR1cm47XHJcblxyXG4gICAgLy8gMjQuMi4xIEFic3RyYWN0IE9wZXJhdGlvbnMgRm9yIERhdGFWaWV3IE9iamVjdHNcclxuICAgIC8vIDI0LjIuMS4xIEdldFZpZXdWYWx1ZSh2aWV3LCByZXF1ZXN0SW5kZXgsIGlzTGl0dGxlRW5kaWFuLCB0eXBlKVxyXG4gICAgLy8gMjQuMi4xLjIgU2V0Vmlld1ZhbHVlKHZpZXcsIHJlcXVlc3RJbmRleCwgaXNMaXR0bGVFbmRpYW4sIHR5cGUsIHZhbHVlKVxyXG4gICAgLy8gMjQuMi4yIFRoZSBEYXRhVmlldyBDb25zdHJ1Y3RvclxyXG4gICAgLy8gMjQuMi4yLjEgRGF0YVZpZXcgKGJ1ZmZlciBbICwgYnl0ZU9mZnNldCBbICwgYnl0ZUxlbmd0aCBdIF0gKVxyXG4gICAgLy8gMjQuMi4zIFByb3BlcnRpZXMgb2YgdGhlIERhdGFWaWV3IENvbnN0cnVjdG9yXHJcbiAgICAvLyAyNC4yLjMuMSBEYXRhVmlldy5wcm90b3R5cGVcclxuICAgIC8vIDI0LjIuNCBQcm9wZXJ0aWVzIG9mIHRoZSBEYXRhVmlldyBQcm90b3R5cGUgT2JqZWN0XHJcbiAgICAvLyAyNC4yLjQuMSBnZXQgRGF0YVZpZXcucHJvdG90eXBlLmJ1ZmZlclxyXG4gICAgLy8gMjQuMi40LjIgZ2V0IERhdGFWaWV3LnByb3RvdHlwZS5ieXRlTGVuZ3RoXHJcbiAgICAvLyAyNC4yLjQuMyBnZXQgRGF0YVZpZXcucHJvdG90eXBlLmJ5dGVPZmZzZXRcclxuICAgIC8vIDI0LjIuNC40IERhdGFWaWV3LnByb3RvdHlwZS5jb25zdHJ1Y3RvclxyXG4gICAgLy8gMjQuMi40LjUgRGF0YVZpZXcucHJvdG90eXBlLmdldEZsb2F0MzIgKCBieXRlT2Zmc2V0IFsgLCBsaXR0bGVFbmRpYW4gXSApXHJcbiAgICAvLyAyNC4yLjQuNiBEYXRhVmlldy5wcm90b3R5cGUuZ2V0RmxvYXQ2NCAoIGJ5dGVPZmZzZXQgWyAsIGxpdHRsZUVuZGlhbiBdIClcclxuICAgIC8vIDI0LjIuNC43IERhdGFWaWV3LnByb3RvdHlwZS5nZXRJbnQ4ICggYnl0ZU9mZnNldCApXHJcbiAgICAvLyAyNC4yLjQuOCBEYXRhVmlldy5wcm90b3R5cGUuZ2V0SW50MTYgKCBieXRlT2Zmc2V0IFsgLCBsaXR0bGVFbmRpYW4gXSApXHJcbiAgICAvLyAyNC4yLjQuOSBEYXRhVmlldy5wcm90b3R5cGUuZ2V0SW50MzIgKCBieXRlT2Zmc2V0IFsgLCBsaXR0bGVFbmRpYW4gXSApXHJcbiAgICAvLyAyNC4yLjQuMTAgRGF0YVZpZXcucHJvdG90eXBlLmdldFVpbnQ4ICggYnl0ZU9mZnNldCApXHJcbiAgICAvLyAyNC4yLjQuMTEgRGF0YVZpZXcucHJvdG90eXBlLmdldFVpbnQxNiAoIGJ5dGVPZmZzZXQgWyAsIGxpdHRsZUVuZGlhbiBdIClcclxuICAgIC8vIDI0LjIuNC4xMiBEYXRhVmlldy5wcm90b3R5cGUuZ2V0VWludDMyICggYnl0ZU9mZnNldCBbICwgbGl0dGxlRW5kaWFuIF0gKVxyXG4gICAgLy8gMjQuMi40LjEzIERhdGFWaWV3LnByb3RvdHlwZS5zZXRGbG9hdDMyICggYnl0ZU9mZnNldCwgdmFsdWUgWyAsIGxpdHRsZUVuZGlhbiBdIClcclxuICAgIC8vIDI0LjIuNC4xNCBEYXRhVmlldy5wcm90b3R5cGUuc2V0RmxvYXQ2NCAoIGJ5dGVPZmZzZXQsIHZhbHVlIFsgLCBsaXR0bGVFbmRpYW4gXSApXHJcbiAgICAvLyAyNC4yLjQuMTUgRGF0YVZpZXcucHJvdG90eXBlLnNldEludDggKCBieXRlT2Zmc2V0LCB2YWx1ZSApXHJcbiAgICAvLyAyNC4yLjQuMTYgRGF0YVZpZXcucHJvdG90eXBlLnNldEludDE2ICggYnl0ZU9mZnNldCwgdmFsdWUgWyAsIGxpdHRsZUVuZGlhbiBdIClcclxuICAgIC8vIDI0LjIuNC4xNyBEYXRhVmlldy5wcm90b3R5cGUuc2V0SW50MzIgKCBieXRlT2Zmc2V0LCB2YWx1ZSBbICwgbGl0dGxlRW5kaWFuIF0gKVxyXG4gICAgLy8gMjQuMi40LjE4IERhdGFWaWV3LnByb3RvdHlwZS5zZXRVaW50OCAoIGJ5dGVPZmZzZXQsIHZhbHVlIClcclxuICAgIC8vIDI0LjIuNC4xOSBEYXRhVmlldy5wcm90b3R5cGUuc2V0VWludDE2ICggYnl0ZU9mZnNldCwgdmFsdWUgWyAsIGxpdHRsZUVuZGlhbiBdIClcclxuICAgIC8vIDI0LjIuNC4yMCBEYXRhVmlldy5wcm90b3R5cGUuc2V0VWludDMyICggYnl0ZU9mZnNldCwgdmFsdWUgWyAsIGxpdHRsZUVuZGlhbiBdIClcclxuXHJcbiAgICAvLyAyNC4yLjQuMjEgRGF0YVZpZXcucHJvdG90eXBlWyBAQHRvU3RyaW5nVGFnIF1cclxuICAgIGRlZmluZShEYXRhVmlldy5wcm90b3R5cGUsICQkdG9TdHJpbmdUYWcsICdEYXRhVmlldycpO1xyXG5cclxuICAgIC8vIDI0LjIuNSBQcm9wZXJ0aWVzIG9mIERhdGFWaWV3IEluc3RhbmNlc1xyXG4gIH0oKSk7XHJcblxyXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gIC8vIDI0LjMgVGhlIEpTT04gT2JqZWN0XHJcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG4gIC8vIDI0LjMuMSBKU09OLnBhcnNlICggdGV4dCBbICwgcmV2aXZlciBdIClcclxuICAvLyAyNC4zLjIgSlNPTi5zdHJpbmdpZnkgKCB2YWx1ZSBbICwgcmVwbGFjZXIgWyAsIHNwYWNlIF0gXSApXHJcbiAgLy8gMjQuMy4zIEpTT04gWyBAQHRvU3RyaW5nVGFnIF1cclxuICBkZWZpbmUoSlNPTiwgJCR0b1N0cmluZ1RhZywgJ0pTT04nKTtcclxuXHJcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgLy8gMjUuMSBJdGVyYXRpb25cclxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcbiAgLy8gMjUuMS4xIENvbW1vbiBJdGVyYXRpb24gSW50ZXJmYWNlc1xyXG4gIC8vIDI1LjEuMS4xIFRoZSBJdGVyYWJsZSBJbnRlcmZhY2VcclxuICAvLyAyNS4xLjEuMiBUaGUgSXRlcmF0b3IgSW50ZXJmYWNlXHJcbiAgLy8gMjUuMS4xLjMgVGhlIEl0ZXJhdG9yUmVzdWx0IEludGVyZmFjZVxyXG5cclxuICAvLyAyNS4xLjIgVGhlICVJdGVyYXRvclByb3RvdHlwZSUgT2JqZWN0XHJcbiAgLy8gRGVmaW5lZCBlYXJsaWVyLCBzbyBvdGhlciBwcm90b3R5cGVzIGNhbiByZWZlcmVuY2UgaXQuXHJcbiAgLy8gMjUuMS4yLjEgJUl0ZXJhdG9yUHJvdG90eXBlJSBbIEBAaXRlcmF0b3IgXSAoIClcclxuICBkZWZpbmUoJEl0ZXJhdG9yUHJvdG90eXBlJCwgJCRpdGVyYXRvciwgZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9KTtcclxuXHJcblxyXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gIC8vIDI1LjQgUHJvbWlzZSBPYmplY3RzXHJcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG4gIChmdW5jdGlvbigpIHtcclxuICAgIC8vIDI1LjQgUHJvbWlzZSBPYmplY3RzXHJcblxyXG4gICAgLy8gMjUuNC4xIFByb21pc2UgQWJzdHJhY3QgT3BlcmF0aW9uc1xyXG5cclxuICAgIC8vIDI1LjQuMS4xIFByb21pc2VDYXBhYmlsaXR5IFJlY29yZHNcclxuICAgIC8vIDI1LjQuMS4xLjEgSWZBYnJ1cHRSZWplY3RQcm9taXNlICggdmFsdWUsIGNhcGFiaWxpdHkgKVxyXG5cclxuICAgIGZ1bmN0aW9uIElmQWJydXB0UmVqZWN0UHJvbWlzZSh2YWx1ZSwgY2FwYWJpbGl0eSkge1xyXG4gICAgICB2YXIgcmVqZWN0UmVzdWx0ID0gY2FwYWJpbGl0eVsnW1tSZWplY3RdXSddLmNhbGwodW5kZWZpbmVkLCB2YWx1ZSk7XHJcbiAgICAgIHJldHVybiBjYXBhYmlsaXR5WydbW1Byb21pc2VdXSddO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIDI1LjQuMS4yIFByb21pc2VSZWFjdGlvbiBSZWNvcmRzXHJcblxyXG4gICAgLy8gMjUuNC4xLjMgQ3JlYXRlUmVzb2x2aW5nRnVuY3Rpb25zICggcHJvbWlzZSApXHJcblxyXG4gICAgZnVuY3Rpb24gQ3JlYXRlUmVzb2x2aW5nRnVuY3Rpb25zKHByb21pc2UpIHtcclxuICAgICAgdmFyIGFscmVhZHlSZXNvbHZlZCA9IHsnW1t2YWx1ZV1dJzogZmFsc2V9O1xyXG4gICAgICB2YXIgcmVzb2x2ZSA9IFByb21pc2VSZXNvbHZlRnVuY3Rpb24oKTtcclxuICAgICAgc2V0X2ludGVybmFsKHJlc29sdmUsICdbW1Byb21pc2VdXScsICBwcm9taXNlKTtcclxuICAgICAgc2V0X2ludGVybmFsKHJlc29sdmUsICdbW0FscmVhZHlSZXNvbHZlZF1dJywgYWxyZWFkeVJlc29sdmVkKTtcclxuICAgICAgdmFyIHJlamVjdCA9IFByb21pc2VSZWplY3RGdW5jdGlvbigpO1xyXG4gICAgICBzZXRfaW50ZXJuYWwocmVqZWN0LCAnW1tQcm9taXNlXV0nLCBwcm9taXNlKTtcclxuICAgICAgc2V0X2ludGVybmFsKHJlamVjdCwgJ1tbQWxyZWFkeVJlc29sdmVkXV0nLCBhbHJlYWR5UmVzb2x2ZWQpO1xyXG4gICAgICByZXR1cm4geyAnW1tSZXNvbHZlXV0nOiByZXNvbHZlLCAnW1tSZWplY3RdXSc6IHJlamVjdH07XHJcbiAgICB9XHJcblxyXG4gICAgLy8gMjUuNC4xLjMuMSBQcm9taXNlIFJlamVjdCBGdW5jdGlvbnNcclxuXHJcbiAgICBmdW5jdGlvbiBQcm9taXNlUmVqZWN0RnVuY3Rpb24oKSB7XHJcbiAgICAgIHZhciBGID0gZnVuY3Rpb24ocmVhc29uKSB7XHJcbiAgICAgICAgY29uc29sZS5hc3NlcnQoVHlwZShGWydbW1Byb21pc2VdXSddKSA9PT0gJ29iamVjdCcpO1xyXG4gICAgICAgIHZhciBwcm9taXNlID0gRlsnW1tQcm9taXNlXV0nXTtcclxuICAgICAgICB2YXIgYWxyZWFkeVJlc29sdmVkID0gRlsnW1tBbHJlYWR5UmVzb2x2ZWRdXSddO1xyXG4gICAgICAgIGlmIChhbHJlYWR5UmVzb2x2ZWRbJ1tbdmFsdWVdXSddKSByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgIHNldF9pbnRlcm5hbChhbHJlYWR5UmVzb2x2ZWQsICdbW3ZhbHVlXV0nLCB0cnVlKTtcclxuICAgICAgICByZXR1cm4gUmVqZWN0UHJvbWlzZShwcm9taXNlLCByZWFzb24pO1xyXG4gICAgICB9O1xyXG4gICAgICByZXR1cm4gRjtcclxuICAgIH1cclxuXHJcbiAgICAvLyAyNS40LjEuMy4yIFByb21pc2UgUmVzb2x2ZSBGdW5jdGlvbnNcclxuXHJcbiAgICBmdW5jdGlvbiBQcm9taXNlUmVzb2x2ZUZ1bmN0aW9uKCkge1xyXG4gICAgICB2YXIgRiA9IGZ1bmN0aW9uKHJlc29sdXRpb24pIHtcclxuICAgICAgICBjb25zb2xlLmFzc2VydChUeXBlKEZbJ1tbUHJvbWlzZV1dJ10pID09PSAnb2JqZWN0Jyk7XHJcbiAgICAgICAgdmFyIHByb21pc2UgPSBGWydbW1Byb21pc2VdXSddO1xyXG4gICAgICAgIHZhciBhbHJlYWR5UmVzb2x2ZWQgPSBGWydbW0FscmVhZHlSZXNvbHZlZF1dJ107XHJcbiAgICAgICAgaWYgKGFscmVhZHlSZXNvbHZlZFsnW1t2YWx1ZV1dJ10pIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgc2V0X2ludGVybmFsKGFscmVhZHlSZXNvbHZlZCwgJ1tbdmFsdWVdXScsIHRydWUpO1xyXG5cclxuICAgICAgICBpZiAoU2FtZVZhbHVlKHJlc29sdXRpb24sIHByb21pc2UpKSAge1xyXG4gICAgICAgICAgdmFyIHNlbGZSZXNvbHV0aW9uRXJyb3IgPSBUeXBlRXJyb3IoKTtcclxuICAgICAgICAgIHJldHVybiBSZWplY3RQcm9taXNlKHByb21pc2UsIHNlbGZSZXNvbHV0aW9uRXJyb3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoVHlwZShyZXNvbHV0aW9uKSAhPT0gJ29iamVjdCcpXHJcbiAgICAgICAgICByZXR1cm4gRnVsZmlsbFByb21pc2UocHJvbWlzZSwgcmVzb2x1dGlvbik7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIHZhciB0aGVuID0gcmVzb2x1dGlvblsndGhlbiddO1xyXG4gICAgICAgIH0gY2F0Y2godGhlbikge1xyXG4gICAgICAgICAgcmV0dXJuIFJlamVjdFByb21pc2UocHJvbWlzZSwgdGhlbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghSXNDYWxsYWJsZSh0aGVuKSlcclxuICAgICAgICAgIHJldHVybiBGdWxmaWxsUHJvbWlzZShwcm9taXNlLCByZXNvbHV0aW9uKTtcclxuICAgICAgICBFbnF1ZXVlSm9iKCdQcm9taXNlSm9icycsIFByb21pc2VSZXNvbHZlVGhlbmFibGVKb2IsIFtwcm9taXNlLCByZXNvbHV0aW9uLCB0aGVuXSk7XHJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgfTtcclxuICAgICAgcmV0dXJuIEY7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gMjUuNC4xLjQgRnVsZmlsbFByb21pc2UgKCBwcm9taXNlLCB2YWx1ZSApXHJcblxyXG4gICAgZnVuY3Rpb24gRnVsZmlsbFByb21pc2UocHJvbWlzZSwgdmFsdWUpIHtcclxuICAgICAgY29uc29sZS5hc3NlcnQocHJvbWlzZVsnW1tQcm9taXNlU3RhdGVdXSddID09PSAncGVuZGluZycpO1xyXG4gICAgICB2YXIgcmVhY3Rpb25zID0gcHJvbWlzZVsnW1tQcm9taXNlRnVsZmlsbFJlYWN0aW9uc11dJ107XHJcbiAgICAgIHNldF9pbnRlcm5hbChwcm9taXNlLCAnW1tQcm9taXNlUmVzdWx0XV0nLCB2YWx1ZSk7XHJcbiAgICAgIHNldF9pbnRlcm5hbChwcm9taXNlLCAnW1tQcm9taXNlRnVsZmlsbFJlYWN0aW9uc11dJywgdW5kZWZpbmVkKTtcclxuICAgICAgc2V0X2ludGVybmFsKHByb21pc2UsICdbW1Byb21pc2VSZWplY3RSZWFjdGlvbnNdXScsIHVuZGVmaW5lZCk7XHJcbiAgICAgIHNldF9pbnRlcm5hbChwcm9taXNlLCAnW1tQcm9taXNlU3RhdGVdXScsICdmdWxmaWxsZWQnKTtcclxuICAgICAgcmV0dXJuIFRyaWdnZXJQcm9taXNlUmVhY3Rpb25zKHJlYWN0aW9ucywgdmFsdWUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIDI1LjQuMS41IE5ld1Byb21pc2VDYXBhYmlsaXR5ICggQyApXHJcblxyXG4gICAgZnVuY3Rpb24gTmV3UHJvbWlzZUNhcGFiaWxpdHkoYykge1xyXG4gICAgICAvLyBUbyBrZWVwIFByb21pc2UgaGVybWV0aWMsIHRoaXMgZG9lc24ndCBsb29rIG11Y2ggbGlrZSB0aGUgc3BlYy5cclxuICAgICAgcmV0dXJuIENyZWF0ZVByb21pc2VDYXBhYmlsaXR5UmVjb3JkKHVuZGVmaW5lZCwgYyk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gMjUuNC4xLjUuMSBDcmVhdGVQcm9taXNlQ2FwYWJpbGl0eVJlY29yZCAoIHByb21pc2UsIGNvbnN0cnVjdG9yIClcclxuXHJcbiAgICBmdW5jdGlvbiBDcmVhdGVQcm9taXNlQ2FwYWJpbGl0eVJlY29yZChwcm9taXNlLCBjb25zdHJ1Y3Rvcikge1xyXG4gICAgICAvLyBUbyBrZWVwIFByb21pc2UgaGVybWV0aWMsIHRoaXMgZG9lc24ndCBsb29rIG11Y2ggbGlrZSB0aGUgc3BlYy5cclxuICAgICAgY29uc29sZS5hc3NlcnQoSXNDb25zdHJ1Y3Rvcihjb25zdHJ1Y3RvcikpO1xyXG4gICAgICB2YXIgcHJvbWlzZUNhcGFiaWxpdHkgPSB7fTtcclxuICAgICAgc2V0X2ludGVybmFsKHByb21pc2VDYXBhYmlsaXR5LCAnW1tQcm9taXNlXV0nLCBwcm9taXNlKTtcclxuICAgICAgc2V0X2ludGVybmFsKHByb21pc2VDYXBhYmlsaXR5LCAnW1tSZXNvbHZlXV0nLCB1bmRlZmluZWQpO1xyXG4gICAgICBzZXRfaW50ZXJuYWwocHJvbWlzZUNhcGFiaWxpdHksICdbW1JlamVjdF1dJywgdW5kZWZpbmVkKTtcclxuICAgICAgdmFyIGV4ZWN1dG9yID0gR2V0Q2FwYWJpbGl0aWVzRXhlY3V0b3IoKTtcclxuICAgICAgc2V0X2ludGVybmFsKGV4ZWN1dG9yLCAnW1tDYXBhYmlsaXR5XV0nLCBwcm9taXNlQ2FwYWJpbGl0eSk7XHJcblxyXG4gICAgICAvLyBOT1RFOiBEaWZmZXJzIGZyb20gc3BlYzsgb2JqZWN0IGlzIGNvbnN0cnVjdGVkIGhlcmVcclxuICAgICAgdmFyIGNvbnN0cnVjdG9yUmVzdWx0ID0gcHJvbWlzZSA9IG5ldyBjb25zdHJ1Y3RvcihleGVjdXRvcik7XHJcbiAgICAgIHNldF9pbnRlcm5hbChwcm9taXNlQ2FwYWJpbGl0eSwgJ1tbUHJvbWlzZV1dJywgcHJvbWlzZSk7XHJcblxyXG4gICAgICBpZiAoIUlzQ2FsbGFibGUocHJvbWlzZUNhcGFiaWxpdHlbJ1tbUmVzb2x2ZV1dJ10pKSB0aHJvdyBUeXBlRXJyb3IoKTtcclxuICAgICAgaWYgKCFJc0NhbGxhYmxlKHByb21pc2VDYXBhYmlsaXR5WydbW1JlamVjdF1dJ10pKSB0aHJvdyBUeXBlRXJyb3IoKTtcclxuICAgICAgaWYgKFR5cGUoY29uc3RydWN0b3JSZXN1bHQpID09PSAnb2JqZWN0JyAmJiAhU2FtZVZhbHVlKHByb21pc2UsIGNvbnN0cnVjdG9yUmVzdWx0KSkgdGhyb3cgVHlwZUVycm9yKCk7XHJcbiAgICAgIHJldHVybiBwcm9taXNlQ2FwYWJpbGl0eTtcclxuICAgIH1cclxuXHJcbiAgICAvLyAyNS40LjEuNS4yIEdldENhcGFiaWxpdGllc0V4ZWN1dG9yIEZ1bmN0aW9uc1xyXG5cclxuICAgIGZ1bmN0aW9uIEdldENhcGFiaWxpdGllc0V4ZWN1dG9yKCkge1xyXG4gICAgICB2YXIgRiA9IGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIGNvbnNvbGUuYXNzZXJ0KEZbJ1tbQ2FwYWJpbGl0eV1dJ10pO1xyXG4gICAgICAgIHZhciBwcm9taXNlQ2FwYWJpbGl0eSA9IEZbJ1tbQ2FwYWJpbGl0eV1dJ107XHJcbiAgICAgICAgaWYgKHByb21pc2VDYXBhYmlsaXR5WydbW1Jlc29sdmVdXSddICE9PSB1bmRlZmluZWQpIHRocm93IFR5cGVFcnJvcigpO1xyXG4gICAgICAgIGlmIChwcm9taXNlQ2FwYWJpbGl0eVsnW1tSZWplY3RdXSddICE9PSB1bmRlZmluZWQpIHRocm93IFR5cGVFcnJvcigpO1xyXG4gICAgICAgIHNldF9pbnRlcm5hbChwcm9taXNlQ2FwYWJpbGl0eSwgJ1tbUmVzb2x2ZV1dJywgcmVzb2x2ZSk7XHJcbiAgICAgICAgc2V0X2ludGVybmFsKHByb21pc2VDYXBhYmlsaXR5LCAnW1tSZWplY3RdXScsIHJlamVjdCk7XHJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgfTtcclxuICAgICAgcmV0dXJuIEY7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gMjUuNC4xLjYgSXNQcm9taXNlICggeCApXHJcblxyXG4gICAgZnVuY3Rpb24gSXNQcm9taXNlKHgpIHtcclxuICAgICAgaWYgKFR5cGUoeCkgIT09ICdvYmplY3QnKSByZXR1cm4gZmFsc2U7XHJcbiAgICAgIGlmICghKCdbW1Byb21pc2VTdGF0ZV1dJyBpbiB4KSkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICBpZiAoeFsnW1tQcm9taXNlU3RhdGVdXSddID09PSB1bmRlZmluZWQpIHJldHVybiBmYWxzZTtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gMjUuNC4xLjcgUmVqZWN0UHJvbWlzZSAoIHByb21pc2UsIHJlYXNvbiApXHJcblxyXG4gICAgZnVuY3Rpb24gUmVqZWN0UHJvbWlzZShwcm9taXNlLCByZWFzb24pIHtcclxuICAgICAgY29uc29sZS5hc3NlcnQocHJvbWlzZVsnW1tQcm9taXNlU3RhdGVdXSddID09PSAncGVuZGluZycpO1xyXG4gICAgICB2YXIgcmVhY3Rpb25zID0gcHJvbWlzZVsnW1tQcm9taXNlUmVqZWN0UmVhY3Rpb25zXV0nXTtcclxuICAgICAgc2V0X2ludGVybmFsKHByb21pc2UsICdbW1Byb21pc2VSZXN1bHRdXScsIHJlYXNvbik7XHJcbiAgICAgIHNldF9pbnRlcm5hbChwcm9taXNlLCAnW1tQcm9taXNlRnVsZmlsbFJlYWN0aW9uc11dJywgdW5kZWZpbmVkKTtcclxuICAgICAgc2V0X2ludGVybmFsKHByb21pc2UsICdbW1Byb21pc2VSZWplY3RSZWFjdGlvbnNdXScsIHVuZGVmaW5lZCk7XHJcbiAgICAgIHNldF9pbnRlcm5hbChwcm9taXNlLCAnW1tQcm9taXNlU3RhdGVdXScsICdyZWplY3RlZCcpO1xyXG4gICAgICByZXR1cm4gVHJpZ2dlclByb21pc2VSZWFjdGlvbnMocmVhY3Rpb25zLCByZWFzb24pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIDI1LjQuMS44IFRyaWdnZXJQcm9taXNlUmVhY3Rpb25zICggcmVhY3Rpb25zLCBhcmd1bWVudCApXHJcblxyXG4gICAgZnVuY3Rpb24gVHJpZ2dlclByb21pc2VSZWFjdGlvbnMocmVhY3Rpb25zLCBhcmd1bWVudCkge1xyXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gcmVhY3Rpb25zLmxlbmd0aDsgaSA8IGxlbjsgKytpKVxyXG4gICAgICAgIEVucXVldWVKb2IoJ1Byb21pc2VKb2JzJywgUHJvbWlzZVJlYWN0aW9uSm9iLCBbcmVhY3Rpb25zW2ldLCBhcmd1bWVudF0pO1xyXG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIDI1LjQuMiBQcm9taXNlIEpvYnNcclxuXHJcbiAgICAvLyAyNS40LjIuMSBQcm9taXNlUmVhY3Rpb25Kb2IgKCByZWFjdGlvbiwgYXJndW1lbnQgKVxyXG5cclxuICAgIGZ1bmN0aW9uIFByb21pc2VSZWFjdGlvbkpvYihyZWFjdGlvbiwgYXJndW1lbnQpIHtcclxuICAgICAgdmFyIHByb21pc2VDYXBhYmlsaXR5ID0gcmVhY3Rpb25bJ1tbQ2FwYWJpbGl0aWVzXV0nXTtcclxuICAgICAgdmFyIGhhbmRsZXIgPSByZWFjdGlvblsnW1tIYW5kbGVyXV0nXTtcclxuICAgICAgdmFyIGhhbmRsZXJSZXN1bHQsIHN0YXR1cztcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBpZiAoaGFuZGxlciA9PT0gJ0lkZW50aXR5JykgaGFuZGxlclJlc3VsdCA9IGFyZ3VtZW50O1xyXG4gICAgICAgIGVsc2UgaWYgKGhhbmRsZXIgPT09ICdUaHJvd2VyJykgdGhyb3cgYXJndW1lbnQ7XHJcbiAgICAgICAgZWxzZSBoYW5kbGVyUmVzdWx0ID0gaGFuZGxlci5jYWxsKHVuZGVmaW5lZCwgYXJndW1lbnQpO1xyXG4gICAgICB9IGNhdGNoIChoYW5kbGVyUmVzdWx0KSB7XHJcbiAgICAgICAgc3RhdHVzID0gcHJvbWlzZUNhcGFiaWxpdHlbJ1tbUmVqZWN0XV0nXS5jYWxsKHVuZGVmaW5lZCwgaGFuZGxlclJlc3VsdCk7XHJcbiAgICAgICAgTmV4dEpvYihzdGF0dXMpOyByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgc3RhdHVzID0gcHJvbWlzZUNhcGFiaWxpdHlbJ1tbUmVzb2x2ZV1dJ10uY2FsbCh1bmRlZmluZWQsIGhhbmRsZXJSZXN1bHQpO1xyXG4gICAgICBOZXh0Sm9iKHN0YXR1cyk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gMjUuNC4yLjIgUHJvbWlzZVJlc29sdmVUaGVuYWJsZUpvYiAoIHByb21pc2VUb1Jlc29sdmUsIHRoZW5hYmxlLCB0aGVuKVxyXG5cclxuICAgIGZ1bmN0aW9uIFByb21pc2VSZXNvbHZlVGhlbmFibGVKb2IocHJvbWlzZVRvUmVzb2x2ZSwgdGhlbmFibGUsIHRoZW4pIHtcclxuICAgICAgLy8gU1BFQyBCVUc6IHByb21pc2UgdnMuIHByb21pc2VUb1Jlc29sdmVcclxuICAgICAgdmFyIHJlc29sdmluZ0Z1bmN0aW9ucyA9IENyZWF0ZVJlc29sdmluZ0Z1bmN0aW9ucyhwcm9taXNlVG9SZXNvbHZlKTtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICB2YXIgdGhlbkNhbGxSZXN1bHQgPSB0aGVuLmNhbGwodGhlbmFibGUsIHJlc29sdmluZ0Z1bmN0aW9uc1snW1tSZXNvbHZlXV0nXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2aW5nRnVuY3Rpb25zWydbW1JlamVjdF1dJ10pO1xyXG4gICAgICB9IGNhdGNoICh0aGVuQ2FsbFJlc3VsdCkge1xyXG4gICAgICAgIHZhciBzdGF0dXMgPSByZXNvbHZpbmdGdW5jdGlvbnNbJ1tbUmVqZWN0XV0nXS5jYWxsKHVuZGVmaW5lZCwgdGhlbkNhbGxSZXN1bHQpO1xyXG4gICAgICAgIE5leHRKb2Ioc3RhdHVzKTsgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIE5leHRKb2IodGhlbkNhbGxSZXN1bHQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIDI1LjQuMyBUaGUgUHJvbWlzZSBDb25zdHJ1Y3RvclxyXG5cclxuICAgIC8vIDI1LjQuMy4xIFByb21pc2UgKCBleGVjdXRvciApXHJcblxyXG4gICAgZnVuY3Rpb24gUHJvbWlzZShleGVjdXRvcikge1xyXG4gICAgICB2YXIgY29uZmlnID0geyBjb25maWd1cmFibGU6IGZhbHNlLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlOiB1bmRlZmluZWQgfTtcclxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdbW1Byb21pc2VTdGF0ZV1dJywgY29uZmlnKTtcclxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdbW1Byb21pc2VDb25zdHJ1Y3Rvcl1dJywgY29uZmlnKTtcclxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdbW1Byb21pc2VSZXN1bHRdXScsIGNvbmZpZyk7XHJcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnW1tQcm9taXNlRnVsZmlsbFJlYWN0aW9uc11dJywgY29uZmlnKTtcclxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdbW1Byb21pc2VSZWplY3RSZWFjdGlvbnNdXScsIGNvbmZpZyk7XHJcblxyXG4gICAgICB2YXIgcHJvbWlzZSA9IHRoaXM7XHJcbiAgICAgIGlmIChUeXBlKHByb21pc2UpICE9PSAnb2JqZWN0JykgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xyXG4gICAgICBpZiAoISgnW1tQcm9taXNlU3RhdGVdXScgaW4gcHJvbWlzZSkpIHRocm93IFR5cGVFcnJvcigpO1xyXG4gICAgICBpZiAocHJvbWlzZVsnW1tQcm9taXNlU3RhdGVdXSddICE9PSB1bmRlZmluZWQpIHRocm93IFR5cGVFcnJvcigpO1xyXG4gICAgICBpZiAoIUlzQ2FsbGFibGUoZXhlY3V0b3IpKSB0aHJvdyBUeXBlRXJyb3IoKTtcclxuXHJcbiAgICAgIHNldF9pbnRlcm5hbChwcm9taXNlLCAnW1tQcm9taXNlQ29uc3RydWN0b3JdXScsIFByb21pc2UpO1xyXG5cclxuICAgICAgcmV0dXJuIEluaXRpYWxpemVQcm9taXNlKHByb21pc2UsIGV4ZWN1dG9yKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyAyNS40LjMuMS4xIEluaXRpYWxpemVQcm9taXNlICggcHJvbWlzZSwgZXhlY3V0b3IgKVxyXG5cclxuICAgIGZ1bmN0aW9uIEluaXRpYWxpemVQcm9taXNlKHByb21pc2UsIGV4ZWN1dG9yKSB7XHJcbiAgICAgIGNvbnNvbGUuYXNzZXJ0KCdbW1Byb21pc2VTdGF0ZV1dJyBpbiBwcm9taXNlKTtcclxuICAgICAgY29uc29sZS5hc3NlcnQoSXNDYWxsYWJsZShleGVjdXRvcikpO1xyXG4gICAgICBzZXRfaW50ZXJuYWwocHJvbWlzZSwgJ1tbUHJvbWlzZVN0YXRlXV0nLCAncGVuZGluZycpO1xyXG4gICAgICBzZXRfaW50ZXJuYWwocHJvbWlzZSwgJ1tbUHJvbWlzZUZ1bGZpbGxSZWFjdGlvbnNdXScsIFtdKTtcclxuICAgICAgc2V0X2ludGVybmFsKHByb21pc2UsICdbW1Byb21pc2VSZWplY3RSZWFjdGlvbnNdXScsIFtdKTtcclxuICAgICAgdmFyIHJlc29sdmluZ0Z1bmN0aW9ucyA9IENyZWF0ZVJlc29sdmluZ0Z1bmN0aW9ucyhwcm9taXNlKTtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICB2YXIgY29tcGxldGlvbiA9IGV4ZWN1dG9yLmNhbGwodW5kZWZpbmVkLCByZXNvbHZpbmdGdW5jdGlvbnNbJ1tbUmVzb2x2ZV1dJ10sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmluZ0Z1bmN0aW9uc1snW1tSZWplY3RdXSddKTtcclxuICAgICAgfSBjYXRjaCAoY29tcGxldGlvbikge1xyXG4gICAgICAgIHZhciBzdGF0dXMgPSByZXNvbHZpbmdGdW5jdGlvbnNbJ1tbUmVqZWN0XV0nXS5jYWxsKHVuZGVmaW5lZCwgY29tcGxldGlvbik7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHByb21pc2U7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gMjUuNC40IFByb3BlcnRpZXMgb2YgdGhlIFByb21pc2UgQ29uc3RydWN0b3JcclxuICAgIC8vIDI1LjQuNC4xIFByb21pc2UuYWxsICggaXRlcmFibGUgKVxyXG5cclxuICAgIGRlZmluZShQcm9taXNlLCAnYWxsJywgZnVuY3Rpb24gYWxsKGl0ZXJhYmxlKSB7XHJcbiAgICAgIHZhciBjID0gc3RyaWN0KHRoaXMpO1xyXG4gICAgICB2YXIgcHJvbWlzZUNhcGFiaWxpdHkgPSBOZXdQcm9taXNlQ2FwYWJpbGl0eShjKTtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICB2YXIgaXRlcmF0b3IgPSBHZXRJdGVyYXRvcihpdGVyYWJsZSk7XHJcbiAgICAgIH0gY2F0Y2ggKHZhbHVlKSB7XHJcbiAgICAgICAgcHJvbWlzZUNhcGFiaWxpdHlbJ1tbUmVqZWN0XV0nXS5jYWxsKHVuZGVmaW5lZCwgdmFsdWUpO1xyXG4gICAgICAgIHJldHVybiBwcm9taXNlQ2FwYWJpbGl0eVsnW1tQcm9taXNlXV0nXTtcclxuICAgICAgfVxyXG4gICAgICB2YXIgdmFsdWVzID0gW107XHJcbiAgICAgIHZhciByZW1haW5pbmdFbGVtZW50c0NvdW50ID0geyB2YWx1ZTogMSB9O1xyXG4gICAgICB2YXIgaW5kZXggPSAwO1xyXG4gICAgICB3aGlsZSAodHJ1ZSkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICB2YXIgbmV4dCA9IEl0ZXJhdG9yU3RlcChpdGVyYXRvcik7XHJcbiAgICAgICAgfSBjYXRjaCAodmFsdWUpIHtcclxuICAgICAgICAgIHByb21pc2VDYXBhYmlsaXR5WydbW1JlamVjdF1dJ10uY2FsbCh1bmRlZmluZWQsIHZhbHVlKTtcclxuICAgICAgICAgIHJldHVybiBwcm9taXNlQ2FwYWJpbGl0eVsnW1tQcm9taXNlXV0nXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFuZXh0KSB7XHJcbiAgICAgICAgICByZW1haW5pbmdFbGVtZW50c0NvdW50LnZhbHVlIC09IDE7XHJcbiAgICAgICAgICBpZiAocmVtYWluaW5nRWxlbWVudHNDb3VudC52YWx1ZSA9PT0gMCkge1xyXG4gICAgICAgICAgICB2YXIgcmVzb2x2ZVJlc3VsdCA9IHByb21pc2VDYXBhYmlsaXR5WydbW1Jlc29sdmVdXSddLmFwcGx5KHVuZGVmaW5lZCwgdmFsdWVzKTtcclxuXHJcblxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgcmV0dXJuIHByb21pc2VDYXBhYmlsaXR5WydbW1Byb21pc2VdXSddO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgdmFyIG5leHRWYWx1ZSA9IEl0ZXJhdG9yVmFsdWUobmV4dCk7XHJcbiAgICAgICAgfSBjYXRjaCAodmFsdWUpIHtcclxuICAgICAgICAgIHByb21pc2VDYXBhYmlsaXR5WydbW1JlamVjdF1dJ10uY2FsbCh1bmRlZmluZWQsIHZhbHVlKTtcclxuICAgICAgICAgIHJldHVybiBwcm9taXNlQ2FwYWJpbGl0eVsnW1tQcm9taXNlXV0nXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIHZhciBuZXh0UHJvbWlzZSA9IGMucmVzb2x2ZShuZXh0VmFsdWUpO1xyXG4gICAgICAgIH0gY2F0Y2ggKHZhbHVlKSB7XHJcbiAgICAgICAgICBwcm9taXNlQ2FwYWJpbGl0eVsnW1tSZWplY3RdXSddLmNhbGwodW5kZWZpbmVkLCB2YWx1ZSk7XHJcbiAgICAgICAgICByZXR1cm4gcHJvbWlzZUNhcGFiaWxpdHlbJ1tbUHJvbWlzZV1dJ107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciByZXNvbHZlRWxlbWVudCA9IFByb21pc2VBbGxSZXNvbHZlRWxlbWVudEZ1bmN0aW9uKCk7XHJcbiAgICAgICAgc2V0X2ludGVybmFsKHJlc29sdmVFbGVtZW50LCAnW1tBbHJlYWR5Q2FsbGVkXV0nLCB7IHZhbHVlOiBmYWxzZSB9KTtcclxuICAgICAgICBzZXRfaW50ZXJuYWwocmVzb2x2ZUVsZW1lbnQsICdbW0luZGV4XV0nLCBpbmRleCk7XHJcbiAgICAgICAgc2V0X2ludGVybmFsKHJlc29sdmVFbGVtZW50LCAnW1tWYWx1ZXNdXScsIHZhbHVlcyk7XHJcbiAgICAgICAgc2V0X2ludGVybmFsKHJlc29sdmVFbGVtZW50LCAnW1tDYXBhYmlsaXRpZXNdXScsIHByb21pc2VDYXBhYmlsaXR5KTtcclxuICAgICAgICBzZXRfaW50ZXJuYWwocmVzb2x2ZUVsZW1lbnQsICdbW1JlbWFpbmluZ0VsZW1lbnRzXV0nLCByZW1haW5pbmdFbGVtZW50c0NvdW50KTtcclxuICAgICAgICByZW1haW5pbmdFbGVtZW50c0NvdW50LnZhbHVlICs9IDE7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIHZhciByZXN1bHQgPSBuZXh0UHJvbWlzZS50aGVuKHJlc29sdmVFbGVtZW50LCBwcm9taXNlQ2FwYWJpbGl0eVsnW1tSZWplY3RdXSddKTtcclxuICAgICAgICB9IGNhdGNoICh2YWx1ZSkge1xyXG4gICAgICAgICAgcHJvbWlzZUNhcGFiaWxpdHlbJ1tbUmVqZWN0XV0nXS5jYWxsKHVuZGVmaW5lZCwgdmFsdWUpO1xyXG4gICAgICAgICAgcmV0dXJuIHByb21pc2VDYXBhYmlsaXR5WydbW1Byb21pc2VdXSddO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpbmRleCArPSAxO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyAyNS40LjQuMS4xIFByb21pc2UuYWxsIFJlc29sdmUgRWxlbWVudCBGdW5jdGlvbnNcclxuXHJcbiAgICBmdW5jdGlvbiBQcm9taXNlQWxsUmVzb2x2ZUVsZW1lbnRGdW5jdGlvbigpIHtcclxuICAgICAgdmFyIEYgPSBmdW5jdGlvbih4KSB7XHJcbiAgICAgICAgdmFyIGFscmVhZHlDYWxsZWQgPSBGWydbW0FscmVhZHlDYWxsZWRdXSddO1xyXG4gICAgICAgIGlmIChhbHJlYWR5Q2FsbGVkLnZhbHVlKSByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgIGFscmVhZHlDYWxsZWQudmFsdWUgPSB0cnVlO1xyXG4gICAgICAgIHZhciBpbmRleCA9IEZbJ1tbSW5kZXhdXSddO1xyXG4gICAgICAgIHZhciB2YWx1ZXMgPSBGWydbW1ZhbHVlc11dJ107XHJcbiAgICAgICAgdmFyIHByb21pc2VDYXBhYmlsaXR5ID0gRlsnW1tDYXBhYmlsaXRpZXNdXSddO1xyXG4gICAgICAgIHZhciByZW1haW5pbmdFbGVtZW50c0NvdW50ID0gRlsnW1tSZW1haW5pbmdFbGVtZW50c11dJ107XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIHZhbHVlc1tpbmRleF0gPSB4O1xyXG4gICAgICAgIH0gY2F0Y2ggKHJlc3VsdCkge1xyXG4gICAgICAgICAgcHJvbWlzZUNhcGFiaWxpdHlbJ1tbUmVqZWN0XV0nXS5jYWxsKHVuZGVmaW5lZCwgcmVzdWx0KTtcclxuICAgICAgICAgIHJldHVybiBwcm9taXNlQ2FwYWJpbGl0eVsnW1tQcm9taXNlXV0nXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVtYWluaW5nRWxlbWVudHNDb3VudC52YWx1ZSAtPSAxO1xyXG4gICAgICAgIGlmIChyZW1haW5pbmdFbGVtZW50c0NvdW50LnZhbHVlID09PSAwKVxyXG4gICAgICAgICAgcmV0dXJuIHByb21pc2VDYXBhYmlsaXR5WydbW1Jlc29sdmVdXSddLmNhbGwodW5kZWZpbmVkLCB2YWx1ZXMpO1xyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgIH07XHJcbiAgICAgIHJldHVybiBGO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIDI1LjQuNC4yIFByb21pc2UucHJvdG90eXBlXHJcblxyXG4gICAgUHJvbWlzZS5wcm90b3R5cGUgPSB7fTtcclxuXHJcbiAgICAvLyAyNS40LjQuMyBQcm9taXNlLnJhY2UgKCBpdGVyYWJsZSApXHJcblxyXG4gICAgZGVmaW5lKFByb21pc2UsICdyYWNlJywgZnVuY3Rpb24gcmFjZShpdGVyYWJsZSkge1xyXG4gICAgICB2YXIgYyA9IHN0cmljdCh0aGlzKTtcclxuICAgICAgdmFyIHByb21pc2VDYXBhYmlsaXR5ID0gTmV3UHJvbWlzZUNhcGFiaWxpdHkoYyk7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgdmFyIGl0ZXJhdG9yID0gR2V0SXRlcmF0b3IoaXRlcmFibGUpO1xyXG4gICAgICB9IGNhdGNoICh2YWx1ZSkge1xyXG4gICAgICAgIHByb21pc2VDYXBhYmlsaXR5WydbW1JlamVjdF1dJ10uY2FsbCh1bmRlZmluZWQsIHZhbHVlKTtcclxuICAgICAgICByZXR1cm4gcHJvbWlzZUNhcGFiaWxpdHlbJ1tbUHJvbWlzZV1dJ107XHJcbiAgICAgIH1cclxuICAgICAgd2hpbGUgKHRydWUpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgdmFyIG5leHQgPSBJdGVyYXRvclN0ZXAoaXRlcmF0b3IpO1xyXG4gICAgICAgIH0gY2F0Y2ggKHZhbHVlKSB7XHJcbiAgICAgICAgICBwcm9taXNlQ2FwYWJpbGl0eVsnW1tSZWplY3RdXSddLmNhbGwodW5kZWZpbmVkLCB2YWx1ZSk7XHJcbiAgICAgICAgICByZXR1cm4gcHJvbWlzZUNhcGFiaWxpdHlbJ1tbUHJvbWlzZV1dJ107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghbmV4dCkgcmV0dXJuIHByb21pc2VDYXBhYmlsaXR5WydbW1Byb21pc2VdXSddO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICB2YXIgbmV4dFZhbHVlID0gSXRlcmF0b3JWYWx1ZShuZXh0KTtcclxuICAgICAgICB9IGNhdGNoICh2YWx1ZSkge1xyXG4gICAgICAgICAgcHJvbWlzZUNhcGFiaWxpdHlbJ1tbUmVqZWN0XV0nXS5jYWxsKHVuZGVmaW5lZCwgdmFsdWUpO1xyXG4gICAgICAgICAgcmV0dXJuIHByb21pc2VDYXBhYmlsaXR5WydbW1Byb21pc2VdXSddO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgdmFyIG5leHRQcm9taXNlID0gYy5yZXNvbHZlKG5leHRWYWx1ZSk7XHJcbiAgICAgICAgfSBjYXRjaCAodmFsdWUpIHtcclxuICAgICAgICAgIHByb21pc2VDYXBhYmlsaXR5WydbW1JlamVjdF1dJ10uY2FsbCh1bmRlZmluZWQsIHZhbHVlKTtcclxuICAgICAgICAgIHJldHVybiBwcm9taXNlQ2FwYWJpbGl0eVsnW1tQcm9taXNlXV0nXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIG5leHRQcm9taXNlLnRoZW4ocHJvbWlzZUNhcGFiaWxpdHlbJ1tbUmVzb2x2ZV1dJ10sIHByb21pc2VDYXBhYmlsaXR5WydbW1JlamVjdF1dJ10pO1xyXG4gICAgICAgIH0gY2F0Y2ggKHZhbHVlKSB7XHJcbiAgICAgICAgICBwcm9taXNlQ2FwYWJpbGl0eVsnW1tSZWplY3RdXSddLmNhbGwodW5kZWZpbmVkLCB2YWx1ZSk7XHJcbiAgICAgICAgICByZXR1cm4gcHJvbWlzZUNhcGFiaWxpdHlbJ1tbUHJvbWlzZV1dJ107XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyAyNS40LjQuNCBQcm9taXNlLnJlamVjdCAoIHIgKVxyXG5cclxuICAgIGRlZmluZShQcm9taXNlLCAncmVqZWN0JywgZnVuY3Rpb24gcmVqZWN0KHIpIHtcclxuICAgICAgdmFyIGMgPSBzdHJpY3QodGhpcyk7XHJcbiAgICAgIHZhciBwcm9taXNlQ2FwYWJpbGl0eSA9IE5ld1Byb21pc2VDYXBhYmlsaXR5KGMpO1xyXG4gICAgICB2YXIgcmVqZWN0UmVzdWx0ID0gcHJvbWlzZUNhcGFiaWxpdHlbJ1tbUmVqZWN0XV0nXS5jYWxsKHVuZGVmaW5lZCwgcik7XHJcbiAgICAgIHJldHVybiBwcm9taXNlQ2FwYWJpbGl0eVsnW1tQcm9taXNlXV0nXTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIDI1LjQuNC41IFByb21pc2UucmVzb2x2ZSAoIHggKVxyXG5cclxuICAgIGRlZmluZShQcm9taXNlLCAncmVzb2x2ZScsIGZ1bmN0aW9uIHJlc29sdmUoeCkge1xyXG4gICAgICB2YXIgYyA9IHN0cmljdCh0aGlzKTtcclxuICAgICAgaWYgKElzUHJvbWlzZSh4KSkge1xyXG4gICAgICAgIHZhciBjb25zdHJ1Y3RvciA9IHhbJ1tbUHJvbWlzZUNvbnN0cnVjdG9yXV0nXTtcclxuICAgICAgICBpZiAoU2FtZVZhbHVlKGNvbnN0cnVjdG9yLCBjKSkgcmV0dXJuIHg7XHJcbiAgICAgIH1cclxuICAgICAgdmFyIHByb21pc2VDYXBhYmlsaXR5ID0gTmV3UHJvbWlzZUNhcGFiaWxpdHkoYyk7XHJcbiAgICAgIHZhciByZXNvbHZlUmVzdWx0ID0gcHJvbWlzZUNhcGFiaWxpdHlbJ1tbUmVzb2x2ZV1dJ10uY2FsbCh1bmRlZmluZWQsIHgpO1xyXG4gICAgICByZXR1cm4gcHJvbWlzZUNhcGFiaWxpdHlbJ1tbUHJvbWlzZV1dJ107XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyAyNS40LjQuNiBQcm9taXNlIFsgQEBjcmVhdGUgXSAoIClcclxuICAgIC8vIDI1LjQuNC42LjEgQWxsb2NhdGVQcm9taXNlICggY29uc3RydWN0b3IgKVxyXG4gICAgLy8gMjUuNC41IFByb3BlcnRpZXMgb2YgdGhlIFByb21pc2UgUHJvdG90eXBlIE9iamVjdFxyXG4gICAgLy8gMjUuNC41LjEgUHJvbWlzZS5wcm90b3R5cGUuY2F0Y2ggKCBvblJlamVjdGVkIClcclxuXHJcbiAgICBkZWZpbmUoUHJvbWlzZS5wcm90b3R5cGUsICdjYXRjaCcsIGZ1bmN0aW9uIGNhdGNoXyhvblJlamVjdGVkKSB7XHJcbiAgICAgIHZhciBwcm9taXNlID0gdGhpcztcclxuICAgICAgcmV0dXJuIHByb21pc2UudGhlbih1bmRlZmluZWQsIG9uUmVqZWN0ZWQpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gMjUuNC41LjIgUHJvbWlzZS5wcm90b3R5cGUuY29uc3RydWN0b3JcclxuXHJcbiAgICBQcm9taXNlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFByb21pc2U7XHJcblxyXG4gICAgLy8gMjUuNC41LjMgUHJvbWlzZS5wcm90b3R5cGUudGhlbiAoIG9uRnVsZmlsbGVkICwgb25SZWplY3RlZCApXHJcblxyXG4gICAgZGVmaW5lKFByb21pc2UucHJvdG90eXBlLCAndGhlbicsIGZ1bmN0aW9uIHRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpIHtcclxuICAgICAgdmFyIHByb21pc2UgPSB0aGlzO1xyXG4gICAgICBpZiAoIUlzUHJvbWlzZShwcm9taXNlKSkgdGhyb3cgVHlwZUVycm9yKCk7XHJcbiAgICAgIGlmICghSXNDYWxsYWJsZShvbkZ1bGZpbGxlZCkpIG9uRnVsZmlsbGVkID0gJ0lkZW50aXR5JztcclxuICAgICAgaWYgKCFJc0NhbGxhYmxlKG9uUmVqZWN0ZWQpKSBvblJlamVjdGVkID0gJ1Rocm93ZXInO1xyXG4gICAgICB2YXIgYyA9IHByb21pc2UuY29uc3RydWN0b3I7XHJcbiAgICAgIHZhciBwcm9taXNlQ2FwYWJpbGl0eSA9IE5ld1Byb21pc2VDYXBhYmlsaXR5KGMpO1xyXG4gICAgICB2YXIgZnVsZmlsbFJlYWN0aW9uID0geyAnW1tDYXBhYmlsaXRpZXNdXSc6IHByb21pc2VDYXBhYmlsaXR5LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnW1tIYW5kbGVyXV0nOiBvbkZ1bGZpbGxlZCB9O1xyXG4gICAgICB2YXIgcmVqZWN0UmVhY3Rpb24gPSB7ICdbW0NhcGFiaWxpdGllc11dJzogcHJvbWlzZUNhcGFiaWxpdHksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1tbSGFuZGxlcl1dJzogb25SZWplY3RlZCB9O1xyXG4gICAgICBpZiAocHJvbWlzZVsnW1tQcm9taXNlU3RhdGVdXSddID09PSAncGVuZGluZycpIHtcclxuICAgICAgICBwcm9taXNlWydbW1Byb21pc2VGdWxmaWxsUmVhY3Rpb25zXV0nXS5wdXNoKGZ1bGZpbGxSZWFjdGlvbik7XHJcbiAgICAgICAgcHJvbWlzZVsnW1tQcm9taXNlUmVqZWN0UmVhY3Rpb25zXV0nXS5wdXNoKHJlamVjdFJlYWN0aW9uKTtcclxuICAgICAgfSBlbHNlIGlmIChwcm9taXNlWydbW1Byb21pc2VTdGF0ZV1dJ10gPT09ICdmdWxmaWxsZWQnKSB7XHJcbiAgICAgICAgdmFyIHZhbHVlID0gcHJvbWlzZVsnW1tQcm9taXNlUmVzdWx0XV0nXTtcclxuICAgICAgICBFbnF1ZXVlSm9iKCdQcm9taXNlSm9icycsIFByb21pc2VSZWFjdGlvbkpvYiwgW2Z1bGZpbGxSZWFjdGlvbiwgdmFsdWVdKTtcclxuICAgICAgfSBlbHNlIGlmIChwcm9taXNlWydbW1Byb21pc2VTdGF0ZV1dJ10gPT09ICdyZWplY3RlZCcpIHtcclxuICAgICAgICB2YXIgcmVhc29uID0gcHJvbWlzZVsnW1tQcm9taXNlUmVzdWx0XV0nXTtcclxuICAgICAgICBFbnF1ZXVlSm9iKCdQcm9taXNlSm9icycsIFByb21pc2VSZWFjdGlvbkpvYiwgW3JlamVjdFJlYWN0aW9uLCByZWFzb25dKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gcHJvbWlzZUNhcGFiaWxpdHlbJ1tbUHJvbWlzZV1dJ107XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyAyNS40LjYgUHJvcGVydGllcyBvZiBQcm9taXNlIEluc3RhbmNlc1xyXG5cclxuICAgIGlmICghKCdQcm9taXNlJyBpbiBnbG9iYWwpIHx8IE9WRVJSSURFX05BVElWRV9GT1JfVEVTVElORylcclxuICAgICAgZ2xvYmFsLlByb21pc2UgPSBQcm9taXNlO1xyXG5cclxuICAgIC8vIFBhdGNoIGVhcmx5IFByb21pc2UuY2FzdCB2cy4gUHJvbWlzZS5yZXNvbHZlIGltcGxlbWVudGF0aW9uc1xyXG4gICAgaWYgKCdjYXN0JyBpbiBnbG9iYWwuUHJvbWlzZSkgZ2xvYmFsLlByb21pc2UucmVzb2x2ZSA9IGdsb2JhbC5Qcm9taXNlLmNhc3Q7XHJcbiAgfSgpKTtcclxuXHJcbiAgLy8gMjUuNC41LjEgUHJvbWlzZS5wcm90b3R5cGUgWyBAQHRvU3RyaW5nVGFnIF1cclxuICBkZWZpbmUoUHJvbWlzZS5wcm90b3R5cGUsICQkdG9TdHJpbmdUYWcsICdQcm9taXNlJyk7XHJcblxyXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gIC8vIDI2IFJlZmxlY3Rpb25cclxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcbiAgKGZ1bmN0aW9uKCkge1xyXG4gICAgLy8gMjYuMSBUaGUgUmVmbGVjdCBPYmplY3RcclxuICAgIGlmICghKCdSZWZsZWN0JyBpbiBnbG9iYWwpIHx8IE9WRVJSSURFX05BVElWRV9GT1JfVEVTVElORylcclxuICAgICAgZ2xvYmFsLlJlZmxlY3QgPSB7fTtcclxuXHJcbiAgICAvLyAyNi4xLjEgUmVmbGVjdC5hcHBseSAoIHRhcmdldCwgdGhpc0FyZ3VtZW50LCBhcmd1bWVudHNMaXN0IClcclxuICAgIGRlZmluZShcclxuICAgICAgUmVmbGVjdCwgJ2FwcGx5JyxcclxuICAgICAgZnVuY3Rpb24gYXBwbHkodGFyZ2V0LCB0aGlzQXJndW1lbnQsIGFyZ3VtZW50c0xpc3QpIHtcclxuICAgICAgICBpZiAoIUlzQ2FsbGFibGUodGFyZ2V0KSkgdGhyb3cgVHlwZUVycm9yKCk7XHJcbiAgICAgICAgcmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKHRhcmdldCwgdGhpc0FyZ3VtZW50LCBhcmd1bWVudHNMaXN0KTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgLy8gMjYuMS4yIFJlZmxlY3QuY29uc3RydWN0ICggdGFyZ2V0LCBhcmd1bWVudHNMaXN0IFssIG5ld1RhcmdldF0gKVxyXG4gICAgZGVmaW5lKFxyXG4gICAgICBSZWZsZWN0LCAnY29uc3RydWN0JyxcclxuICAgICAgZnVuY3Rpb24gY29uc3RydWN0KHRhcmdldCwgYXJndW1lbnRzTGlzdCkge1xyXG4gICAgICAgIHJldHVybiBfX2NvbnModGFyZ2V0LCBhcmd1bWVudHNMaXN0KTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgLy8gMjYuMS4zIFJlZmxlY3QuZGVmaW5lUHJvcGVydHkgKCB0YXJnZXQsIHByb3BlcnR5S2V5LCBhdHRyaWJ1dGVzIClcclxuICAgIGRlZmluZShcclxuICAgICAgUmVmbGVjdCwgJ2RlZmluZVByb3BlcnR5JyxcclxuICAgICAgZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eUtleSwgYXR0cmlidXRlcykge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eUtleSwgYXR0cmlidXRlcyk7XHJcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9IGNhdGNoIChfKSB7XHJcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuXHJcbiAgICAvLyAyNi4xLjQgUmVmbGVjdC5kZWxldGVQcm9wZXJ0eSAoIHRhcmdldCwgcHJvcGVydHlLZXkgKVxyXG4gICAgZGVmaW5lKFxyXG4gICAgICBSZWZsZWN0LCAnZGVsZXRlUHJvcGVydHknLFxyXG4gICAgICBmdW5jdGlvbiBkZWxldGVQcm9wZXJ0eSh0YXJnZXQsbmFtZSkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICBkZWxldGUgdGFyZ2V0W25hbWVdO1xyXG4gICAgICAgICAgcmV0dXJuICFIYXNPd25Qcm9wZXJ0eSh0YXJnZXQsIG5hbWUpO1xyXG4gICAgICAgIH0gY2F0Y2ggKF8pIHtcclxuICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG5cclxuICAgIC8vIDI2LjEuNSBSZWZsZWN0LmVudW1lcmF0ZSAoIHRhcmdldCApXHJcbiAgICBkZWZpbmUoXHJcbiAgICAgIFJlZmxlY3QsICdlbnVtZXJhdGUnLFxyXG4gICAgICBmdW5jdGlvbiBlbnVtZXJhdGUodGFyZ2V0KSB7XHJcbiAgICAgICAgdGFyZ2V0ID0gVG9PYmplY3QodGFyZ2V0KTtcclxuICAgICAgICB2YXIgaXRlcmF0b3IgPSBFbnVtZXJhdGUodGFyZ2V0KTtcclxuICAgICAgICByZXR1cm4gaXRlcmF0b3I7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgIC8vIDI2LjEuNiBSZWZsZWN0LmdldCAoIHRhcmdldCwgcHJvcGVydHlLZXkgWyAsIHJlY2VpdmVyIF0pXHJcbiAgICBkZWZpbmUoXHJcbiAgICAgIFJlZmxlY3QsICdnZXQnLFxyXG4gICAgICBmdW5jdGlvbiBnZXQodGFyZ2V0LCBuYW1lLCByZWNlaXZlcikge1xyXG4gICAgICAgIHRhcmdldCA9IFRvT2JqZWN0KHRhcmdldCk7XHJcbiAgICAgICAgbmFtZSA9IFN0cmluZyhuYW1lKTtcclxuICAgICAgICByZWNlaXZlciA9IChyZWNlaXZlciA9PT0gdW5kZWZpbmVkKSA/IHRhcmdldCA6IFRvT2JqZWN0KHJlY2VpdmVyKTtcclxuICAgICAgICB2YXIgZGVzYyA9IGdldFByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIG5hbWUpO1xyXG4gICAgICAgIGlmIChkZXNjICYmICdnZXQnIGluIGRlc2MpXHJcbiAgICAgICAgICByZXR1cm4gRnVuY3Rpb24ucHJvdG90eXBlLmNhbGwuY2FsbChkZXNjWydnZXQnXSwgcmVjZWl2ZXIpO1xyXG4gICAgICAgIHJldHVybiB0YXJnZXRbbmFtZV07XHJcbiAgICAgIH0pO1xyXG5cclxuICAgIC8vIDI2LjEuNyBSZWZsZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciAoIHRhcmdldCwgcHJvcGVydHlLZXkgKVxyXG4gICAgZGVmaW5lKFxyXG4gICAgICBSZWZsZWN0LCAnZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJyxcclxuICAgICAgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcik7XHJcblxyXG4gICAgLy8gMjYuMS44IFJlZmxlY3QuZ2V0UHJvdG90eXBlT2YgKCB0YXJnZXQgKVxyXG4gICAgZGVmaW5lKFxyXG4gICAgICBSZWZsZWN0LCAnZ2V0UHJvdG90eXBlT2YnLFxyXG4gICAgICBPYmplY3QuZ2V0UHJvdG90eXBlT2YpO1xyXG5cclxuICAgIC8vIDI2LjEuOSBSZWZsZWN0LmhhcyAoIHRhcmdldCwgcHJvcGVydHlLZXkgKVxyXG4gICAgZGVmaW5lKFxyXG4gICAgICBSZWZsZWN0LCAnaGFzJyxcclxuICAgICAgZnVuY3Rpb24gaGFzKHRhcmdldCxuYW1lKSB7XHJcbiAgICAgICAgcmV0dXJuIFN0cmluZyhuYW1lKSBpbiBUb09iamVjdCh0YXJnZXQpO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAvLyAyNi4xLjEwIFJlZmxlY3QuaXNFeHRlbnNpYmxlICh0YXJnZXQpXHJcbiAgICBkZWZpbmUoXHJcbiAgICAgIFJlZmxlY3QsICdpc0V4dGVuc2libGUnLFxyXG4gICAgICBPYmplY3QuaXNFeHRlbnNpYmxlKTtcclxuXHJcbiAgICAvLyAyNi4xLjExIFJlZmxlY3Qub3duS2V5cyAoIHRhcmdldCApXHJcbiAgICBkZWZpbmUoXHJcbiAgICAgIFJlZmxlY3QsICdvd25LZXlzJyxcclxuICAgICAgZnVuY3Rpb24gb3duS2V5cyh0YXJnZXQpIHtcclxuICAgICAgICB2YXIgb2JqID0gVG9PYmplY3QodGFyZ2V0KTtcclxuICAgICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMob2JqKTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgLy8gMjYuMS4xMiBSZWZsZWN0LnByZXZlbnRFeHRlbnNpb25zICggdGFyZ2V0IClcclxuICAgIGRlZmluZShcclxuICAgICAgUmVmbGVjdCwgJ3ByZXZlbnRFeHRlbnNpb25zJyxcclxuICAgICAgZnVuY3Rpb24gcHJldmVudEV4dGVuc2lvbnModGFyZ2V0KSB7XHJcbiAgICAgICAgdHJ5IHsgT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKHRhcmdldCk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChfKSB7IHJldHVybiBmYWxzZTsgfVxyXG4gICAgICB9KTtcclxuXHJcbiAgICAvLyAyNi4xLjEzIFJlZmxlY3Quc2V0ICggdGFyZ2V0LCBwcm9wZXJ0eUtleSwgViBbICwgcmVjZWl2ZXIgXSApXHJcbiAgICBkZWZpbmUoXHJcbiAgICAgIFJlZmxlY3QsICdzZXQnLFxyXG4gICAgICBmdW5jdGlvbiBzZXQodGFyZ2V0LCBuYW1lLCB2YWx1ZSwgcmVjZWl2ZXIpIHtcclxuICAgICAgICB0YXJnZXQgPSBUb09iamVjdCh0YXJnZXQpO1xyXG4gICAgICAgIG5hbWUgPSBTdHJpbmcobmFtZSk7XHJcbiAgICAgICAgcmVjZWl2ZXIgPSAocmVjZWl2ZXIgPT09IHVuZGVmaW5lZCkgPyB0YXJnZXQgOiBUb09iamVjdChyZWNlaXZlcik7XHJcbiAgICAgICAgdmFyIGRlc2MgPSBnZXRQcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBuYW1lKTtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgaWYgKGRlc2MgJiYgJ3NldCcgaW4gZGVzYylcclxuICAgICAgICAgICAgRnVuY3Rpb24ucHJvdG90eXBlLmNhbGwuY2FsbChkZXNjWydzZXQnXSwgcmVjZWl2ZXIsIHZhbHVlKTtcclxuICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgdGFyZ2V0W25hbWVdID0gdmFsdWU7XHJcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9IGNhdGNoIChfKSB7XHJcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuXHJcbiAgICAvLyAyNi4xLjE0IFJlZmxlY3Quc2V0UHJvdG90eXBlT2YgKCB0YXJnZXQsIHByb3RvIClcclxuICAgIGRlZmluZShcclxuICAgICAgUmVmbGVjdCwgJ3NldFByb3RvdHlwZU9mJyxcclxuICAgICAgZnVuY3Rpb24gc2V0UHJvdG90eXBlT2YodGFyZ2V0LCBwcm90bykge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICB0YXJnZXQuX19wcm90b19fID0gcHJvdG87XHJcbiAgICAgICAgICByZXR1cm4gUmVmbGVjdC5nZXRQcm90b3R5cGVPZih0YXJnZXQpID09PSBwcm90bztcclxuICAgICAgICB9IGNhdGNoKF8pIHtcclxuICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG5cclxuICB9KCkpO1xyXG5cclxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAvLyAyNi4yIFByb3h5IE9iamVjdHNcclxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcbiAgLy8gTm90IHBvbHlmaWxsYWJsZS5cclxuXHJcbn0oc2VsZikpO1xyXG5cclxuLy8gVGhpcyBoZWxwZXIgaXMgZGVmaW5lZCBvdXRzaWRlIHRoZSBtYWluIHNjb3BlIHNvIHRoYXQgdGhlIHVzZSBvZlxyXG4vLyAnZXZhbCcgZG9lcyBub3QgdGFpbnQgdGhlIHNjb3BlIGZvciBtaW5pZmllcnMuXHJcbmZ1bmN0aW9uIF9fY29ucyh0LCBhKSB7XHJcbiAgcmV0dXJuIGV2YWwoJ25ldyB0KCcgKyBhLm1hcChmdW5jdGlvbihfLCBpKSB7IHJldHVybiAnYVsnICsgaSArICddJzsgfSkuam9pbignLCcpICsgJyknKTtcclxufVxyXG4iLCIvKipcbiAqIGx1bnIgLSBodHRwOi8vbHVucmpzLmNvbSAtIEEgYml0IGxpa2UgU29sciwgYnV0IG11Y2ggc21hbGxlciBhbmQgbm90IGFzIGJyaWdodCAtIDIuMy44XG4gKiBDb3B5cmlnaHQgKEMpIDIwMTkgT2xpdmVyIE5pZ2h0aW5nYWxlXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuXG47KGZ1bmN0aW9uKCl7XG5cbi8qKlxuICogQSBjb252ZW5pZW5jZSBmdW5jdGlvbiBmb3IgY29uZmlndXJpbmcgYW5kIGNvbnN0cnVjdGluZ1xuICogYSBuZXcgbHVuciBJbmRleC5cbiAqXG4gKiBBIGx1bnIuQnVpbGRlciBpbnN0YW5jZSBpcyBjcmVhdGVkIGFuZCB0aGUgcGlwZWxpbmUgc2V0dXBcbiAqIHdpdGggYSB0cmltbWVyLCBzdG9wIHdvcmQgZmlsdGVyIGFuZCBzdGVtbWVyLlxuICpcbiAqIFRoaXMgYnVpbGRlciBvYmplY3QgaXMgeWllbGRlZCB0byB0aGUgY29uZmlndXJhdGlvbiBmdW5jdGlvblxuICogdGhhdCBpcyBwYXNzZWQgYXMgYSBwYXJhbWV0ZXIsIGFsbG93aW5nIHRoZSBsaXN0IG9mIGZpZWxkc1xuICogYW5kIG90aGVyIGJ1aWxkZXIgcGFyYW1ldGVycyB0byBiZSBjdXN0b21pc2VkLlxuICpcbiAqIEFsbCBkb2N1bWVudHMgX211c3RfIGJlIGFkZGVkIHdpdGhpbiB0aGUgcGFzc2VkIGNvbmZpZyBmdW5jdGlvbi5cbiAqXG4gKiBAZXhhbXBsZVxuICogdmFyIGlkeCA9IGx1bnIoZnVuY3Rpb24gKCkge1xuICogICB0aGlzLmZpZWxkKCd0aXRsZScpXG4gKiAgIHRoaXMuZmllbGQoJ2JvZHknKVxuICogICB0aGlzLnJlZignaWQnKVxuICpcbiAqICAgZG9jdW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKGRvYykge1xuICogICAgIHRoaXMuYWRkKGRvYylcbiAqICAgfSwgdGhpcylcbiAqIH0pXG4gKlxuICogQHNlZSB7QGxpbmsgbHVuci5CdWlsZGVyfVxuICogQHNlZSB7QGxpbmsgbHVuci5QaXBlbGluZX1cbiAqIEBzZWUge0BsaW5rIGx1bnIudHJpbW1lcn1cbiAqIEBzZWUge0BsaW5rIGx1bnIuc3RvcFdvcmRGaWx0ZXJ9XG4gKiBAc2VlIHtAbGluayBsdW5yLnN0ZW1tZXJ9XG4gKiBAbmFtZXNwYWNlIHtmdW5jdGlvbn0gbHVuclxuICovXG52YXIgbHVuciA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgdmFyIGJ1aWxkZXIgPSBuZXcgbHVuci5CdWlsZGVyXG5cbiAgYnVpbGRlci5waXBlbGluZS5hZGQoXG4gICAgbHVuci50cmltbWVyLFxuICAgIGx1bnIuc3RvcFdvcmRGaWx0ZXIsXG4gICAgbHVuci5zdGVtbWVyXG4gIClcblxuICBidWlsZGVyLnNlYXJjaFBpcGVsaW5lLmFkZChcbiAgICBsdW5yLnN0ZW1tZXJcbiAgKVxuXG4gIGNvbmZpZy5jYWxsKGJ1aWxkZXIsIGJ1aWxkZXIpXG4gIHJldHVybiBidWlsZGVyLmJ1aWxkKClcbn1cblxubHVuci52ZXJzaW9uID0gXCIyLjMuOFwiXG4vKiFcbiAqIGx1bnIudXRpbHNcbiAqIENvcHlyaWdodCAoQykgMjAxOSBPbGl2ZXIgTmlnaHRpbmdhbGVcbiAqL1xuXG4vKipcbiAqIEEgbmFtZXNwYWNlIGNvbnRhaW5pbmcgdXRpbHMgZm9yIHRoZSByZXN0IG9mIHRoZSBsdW5yIGxpYnJhcnlcbiAqIEBuYW1lc3BhY2UgbHVuci51dGlsc1xuICovXG5sdW5yLnV0aWxzID0ge31cblxuLyoqXG4gKiBQcmludCBhIHdhcm5pbmcgbWVzc2FnZSB0byB0aGUgY29uc29sZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBiZSBwcmludGVkLlxuICogQG1lbWJlck9mIGx1bnIudXRpbHNcbiAqIEBmdW5jdGlvblxuICovXG5sdW5yLnV0aWxzLndhcm4gPSAoZnVuY3Rpb24gKGdsb2JhbCkge1xuICAvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25zb2xlICovXG4gIHJldHVybiBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgIGlmIChnbG9iYWwuY29uc29sZSAmJiBjb25zb2xlLndhcm4pIHtcbiAgICAgIGNvbnNvbGUud2FybihtZXNzYWdlKVxuICAgIH1cbiAgfVxuICAvKiBlc2xpbnQtZW5hYmxlIG5vLWNvbnNvbGUgKi9cbn0pKHRoaXMpXG5cbi8qKlxuICogQ29udmVydCBhbiBvYmplY3QgdG8gYSBzdHJpbmcuXG4gKlxuICogSW4gdGhlIGNhc2Ugb2YgYG51bGxgIGFuZCBgdW5kZWZpbmVkYCB0aGUgZnVuY3Rpb24gcmV0dXJuc1xuICogdGhlIGVtcHR5IHN0cmluZywgaW4gYWxsIG90aGVyIGNhc2VzIHRoZSByZXN1bHQgb2YgY2FsbGluZ1xuICogYHRvU3RyaW5nYCBvbiB0aGUgcGFzc2VkIG9iamVjdCBpcyByZXR1cm5lZC5cbiAqXG4gKiBAcGFyYW0ge0FueX0gb2JqIFRoZSBvYmplY3QgdG8gY29udmVydCB0byBhIHN0cmluZy5cbiAqIEByZXR1cm4ge1N0cmluZ30gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBwYXNzZWQgb2JqZWN0LlxuICogQG1lbWJlck9mIGx1bnIudXRpbHNcbiAqL1xubHVuci51dGlscy5hc1N0cmluZyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgaWYgKG9iaiA9PT0gdm9pZCAwIHx8IG9iaiA9PT0gbnVsbCkge1xuICAgIHJldHVybiBcIlwiXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG9iai50b1N0cmluZygpXG4gIH1cbn1cblxuLyoqXG4gKiBDbG9uZXMgYW4gb2JqZWN0LlxuICpcbiAqIFdpbGwgY3JlYXRlIGEgY29weSBvZiBhbiBleGlzdGluZyBvYmplY3Qgc3VjaCB0aGF0IGFueSBtdXRhdGlvbnNcbiAqIG9uIHRoZSBjb3B5IGNhbm5vdCBhZmZlY3QgdGhlIG9yaWdpbmFsLlxuICpcbiAqIE9ubHkgc2hhbGxvdyBvYmplY3RzIGFyZSBzdXBwb3J0ZWQsIHBhc3NpbmcgYSBuZXN0ZWQgb2JqZWN0IHRvIHRoaXNcbiAqIGZ1bmN0aW9uIHdpbGwgY2F1c2UgYSBUeXBlRXJyb3IuXG4gKlxuICogT2JqZWN0cyB3aXRoIHByaW1pdGl2ZXMsIGFuZCBhcnJheXMgb2YgcHJpbWl0aXZlcyBhcmUgc3VwcG9ydGVkLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byBjbG9uZS5cbiAqIEByZXR1cm4ge09iamVjdH0gYSBjbG9uZSBvZiB0aGUgcGFzc2VkIG9iamVjdC5cbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gd2hlbiBhIG5lc3RlZCBvYmplY3QgaXMgcGFzc2VkLlxuICogQG1lbWJlck9mIFV0aWxzXG4gKi9cbmx1bnIudXRpbHMuY2xvbmUgPSBmdW5jdGlvbiAob2JqKSB7XG4gIGlmIChvYmogPT09IG51bGwgfHwgb2JqID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gb2JqXG4gIH1cblxuICB2YXIgY2xvbmUgPSBPYmplY3QuY3JlYXRlKG51bGwpLFxuICAgICAga2V5cyA9IE9iamVjdC5rZXlzKG9iailcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIga2V5ID0ga2V5c1tpXSxcbiAgICAgICAgdmFsID0gb2JqW2tleV1cblxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAgIGNsb25lW2tleV0gPSB2YWwuc2xpY2UoKVxuICAgICAgY29udGludWVcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgdHlwZW9mIHZhbCA9PT0gJ251bWJlcicgfHxcbiAgICAgICAgdHlwZW9mIHZhbCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICBjbG9uZVtrZXldID0gdmFsXG4gICAgICBjb250aW51ZVxuICAgIH1cblxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJjbG9uZSBpcyBub3QgZGVlcCBhbmQgZG9lcyBub3Qgc3VwcG9ydCBuZXN0ZWQgb2JqZWN0c1wiKVxuICB9XG5cbiAgcmV0dXJuIGNsb25lXG59XG5sdW5yLkZpZWxkUmVmID0gZnVuY3Rpb24gKGRvY1JlZiwgZmllbGROYW1lLCBzdHJpbmdWYWx1ZSkge1xuICB0aGlzLmRvY1JlZiA9IGRvY1JlZlxuICB0aGlzLmZpZWxkTmFtZSA9IGZpZWxkTmFtZVxuICB0aGlzLl9zdHJpbmdWYWx1ZSA9IHN0cmluZ1ZhbHVlXG59XG5cbmx1bnIuRmllbGRSZWYuam9pbmVyID0gXCIvXCJcblxubHVuci5GaWVsZFJlZi5mcm9tU3RyaW5nID0gZnVuY3Rpb24gKHMpIHtcbiAgdmFyIG4gPSBzLmluZGV4T2YobHVuci5GaWVsZFJlZi5qb2luZXIpXG5cbiAgaWYgKG4gPT09IC0xKSB7XG4gICAgdGhyb3cgXCJtYWxmb3JtZWQgZmllbGQgcmVmIHN0cmluZ1wiXG4gIH1cblxuICB2YXIgZmllbGRSZWYgPSBzLnNsaWNlKDAsIG4pLFxuICAgICAgZG9jUmVmID0gcy5zbGljZShuICsgMSlcblxuICByZXR1cm4gbmV3IGx1bnIuRmllbGRSZWYgKGRvY1JlZiwgZmllbGRSZWYsIHMpXG59XG5cbmx1bnIuRmllbGRSZWYucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5fc3RyaW5nVmFsdWUgPT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpcy5fc3RyaW5nVmFsdWUgPSB0aGlzLmZpZWxkTmFtZSArIGx1bnIuRmllbGRSZWYuam9pbmVyICsgdGhpcy5kb2NSZWZcbiAgfVxuXG4gIHJldHVybiB0aGlzLl9zdHJpbmdWYWx1ZVxufVxuLyohXG4gKiBsdW5yLlNldFxuICogQ29weXJpZ2h0IChDKSAyMDE5IE9saXZlciBOaWdodGluZ2FsZVxuICovXG5cbi8qKlxuICogQSBsdW5yIHNldC5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xubHVuci5TZXQgPSBmdW5jdGlvbiAoZWxlbWVudHMpIHtcbiAgdGhpcy5lbGVtZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbClcblxuICBpZiAoZWxlbWVudHMpIHtcbiAgICB0aGlzLmxlbmd0aCA9IGVsZW1lbnRzLmxlbmd0aFxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLmVsZW1lbnRzW2VsZW1lbnRzW2ldXSA9IHRydWVcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5sZW5ndGggPSAwXG4gIH1cbn1cblxuLyoqXG4gKiBBIGNvbXBsZXRlIHNldCB0aGF0IGNvbnRhaW5zIGFsbCBlbGVtZW50cy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAcmVhZG9ubHlcbiAqIEB0eXBlIHtsdW5yLlNldH1cbiAqL1xubHVuci5TZXQuY29tcGxldGUgPSB7XG4gIGludGVyc2VjdDogZnVuY3Rpb24gKG90aGVyKSB7XG4gICAgcmV0dXJuIG90aGVyXG4gIH0sXG5cbiAgdW5pb246IGZ1bmN0aW9uIChvdGhlcikge1xuICAgIHJldHVybiBvdGhlclxuICB9LFxuXG4gIGNvbnRhaW5zOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxufVxuXG4vKipcbiAqIEFuIGVtcHR5IHNldCB0aGF0IGNvbnRhaW5zIG5vIGVsZW1lbnRzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEByZWFkb25seVxuICogQHR5cGUge2x1bnIuU2V0fVxuICovXG5sdW5yLlNldC5lbXB0eSA9IHtcbiAgaW50ZXJzZWN0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXNcbiAgfSxcblxuICB1bmlvbjogZnVuY3Rpb24gKG90aGVyKSB7XG4gICAgcmV0dXJuIG90aGVyXG4gIH0sXG5cbiAgY29udGFpbnM6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIHNldCBjb250YWlucyB0aGUgc3BlY2lmaWVkIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gb2JqZWN0IC0gT2JqZWN0IHdob3NlIHByZXNlbmNlIGluIHRoaXMgc2V0IGlzIHRvIGJlIHRlc3RlZC5cbiAqIEByZXR1cm5zIHtib29sZWFufSAtIFRydWUgaWYgdGhpcyBzZXQgY29udGFpbnMgdGhlIHNwZWNpZmllZCBvYmplY3QuXG4gKi9cbmx1bnIuU2V0LnByb3RvdHlwZS5jb250YWlucyA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgcmV0dXJuICEhdGhpcy5lbGVtZW50c1tvYmplY3RdXG59XG5cbi8qKlxuICogUmV0dXJucyBhIG5ldyBzZXQgY29udGFpbmluZyBvbmx5IHRoZSBlbGVtZW50cyB0aGF0IGFyZSBwcmVzZW50IGluIGJvdGhcbiAqIHRoaXMgc2V0IGFuZCB0aGUgc3BlY2lmaWVkIHNldC5cbiAqXG4gKiBAcGFyYW0ge2x1bnIuU2V0fSBvdGhlciAtIHNldCB0byBpbnRlcnNlY3Qgd2l0aCB0aGlzIHNldC5cbiAqIEByZXR1cm5zIHtsdW5yLlNldH0gYSBuZXcgc2V0IHRoYXQgaXMgdGhlIGludGVyc2VjdGlvbiBvZiB0aGlzIGFuZCB0aGUgc3BlY2lmaWVkIHNldC5cbiAqL1xuXG5sdW5yLlNldC5wcm90b3R5cGUuaW50ZXJzZWN0ID0gZnVuY3Rpb24gKG90aGVyKSB7XG4gIHZhciBhLCBiLCBlbGVtZW50cywgaW50ZXJzZWN0aW9uID0gW11cblxuICBpZiAob3RoZXIgPT09IGx1bnIuU2V0LmNvbXBsZXRlKSB7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIGlmIChvdGhlciA9PT0gbHVuci5TZXQuZW1wdHkpIHtcbiAgICByZXR1cm4gb3RoZXJcbiAgfVxuXG4gIGlmICh0aGlzLmxlbmd0aCA8IG90aGVyLmxlbmd0aCkge1xuICAgIGEgPSB0aGlzXG4gICAgYiA9IG90aGVyXG4gIH0gZWxzZSB7XG4gICAgYSA9IG90aGVyXG4gICAgYiA9IHRoaXNcbiAgfVxuXG4gIGVsZW1lbnRzID0gT2JqZWN0LmtleXMoYS5lbGVtZW50cylcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGVsZW1lbnQgPSBlbGVtZW50c1tpXVxuICAgIGlmIChlbGVtZW50IGluIGIuZWxlbWVudHMpIHtcbiAgICAgIGludGVyc2VjdGlvbi5wdXNoKGVsZW1lbnQpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ldyBsdW5yLlNldCAoaW50ZXJzZWN0aW9uKVxufVxuXG4vKipcbiAqIFJldHVybnMgYSBuZXcgc2V0IGNvbWJpbmluZyB0aGUgZWxlbWVudHMgb2YgdGhpcyBhbmQgdGhlIHNwZWNpZmllZCBzZXQuXG4gKlxuICogQHBhcmFtIHtsdW5yLlNldH0gb3RoZXIgLSBzZXQgdG8gdW5pb24gd2l0aCB0aGlzIHNldC5cbiAqIEByZXR1cm4ge2x1bnIuU2V0fSBhIG5ldyBzZXQgdGhhdCBpcyB0aGUgdW5pb24gb2YgdGhpcyBhbmQgdGhlIHNwZWNpZmllZCBzZXQuXG4gKi9cblxubHVuci5TZXQucHJvdG90eXBlLnVuaW9uID0gZnVuY3Rpb24gKG90aGVyKSB7XG4gIGlmIChvdGhlciA9PT0gbHVuci5TZXQuY29tcGxldGUpIHtcbiAgICByZXR1cm4gbHVuci5TZXQuY29tcGxldGVcbiAgfVxuXG4gIGlmIChvdGhlciA9PT0gbHVuci5TZXQuZW1wdHkpIHtcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgcmV0dXJuIG5ldyBsdW5yLlNldChPYmplY3Qua2V5cyh0aGlzLmVsZW1lbnRzKS5jb25jYXQoT2JqZWN0LmtleXMob3RoZXIuZWxlbWVudHMpKSlcbn1cbi8qKlxuICogQSBmdW5jdGlvbiB0byBjYWxjdWxhdGUgdGhlIGludmVyc2UgZG9jdW1lbnQgZnJlcXVlbmN5IGZvclxuICogYSBwb3N0aW5nLiBUaGlzIGlzIHNoYXJlZCBiZXR3ZWVuIHRoZSBidWlsZGVyIGFuZCB0aGUgaW5kZXhcbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtvYmplY3R9IHBvc3RpbmcgLSBUaGUgcG9zdGluZyBmb3IgYSBnaXZlbiB0ZXJtXG4gKiBAcGFyYW0ge251bWJlcn0gZG9jdW1lbnRDb3VudCAtIFRoZSB0b3RhbCBudW1iZXIgb2YgZG9jdW1lbnRzLlxuICovXG5sdW5yLmlkZiA9IGZ1bmN0aW9uIChwb3N0aW5nLCBkb2N1bWVudENvdW50KSB7XG4gIHZhciBkb2N1bWVudHNXaXRoVGVybSA9IDBcblxuICBmb3IgKHZhciBmaWVsZE5hbWUgaW4gcG9zdGluZykge1xuICAgIGlmIChmaWVsZE5hbWUgPT0gJ19pbmRleCcpIGNvbnRpbnVlIC8vIElnbm9yZSB0aGUgdGVybSBpbmRleCwgaXRzIG5vdCBhIGZpZWxkXG4gICAgZG9jdW1lbnRzV2l0aFRlcm0gKz0gT2JqZWN0LmtleXMocG9zdGluZ1tmaWVsZE5hbWVdKS5sZW5ndGhcbiAgfVxuXG4gIHZhciB4ID0gKGRvY3VtZW50Q291bnQgLSBkb2N1bWVudHNXaXRoVGVybSArIDAuNSkgLyAoZG9jdW1lbnRzV2l0aFRlcm0gKyAwLjUpXG5cbiAgcmV0dXJuIE1hdGgubG9nKDEgKyBNYXRoLmFicyh4KSlcbn1cblxuLyoqXG4gKiBBIHRva2VuIHdyYXBzIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgdG9rZW5cbiAqIGFzIGl0IGlzIHBhc3NlZCB0aHJvdWdoIHRoZSB0ZXh0IHByb2Nlc3NpbmcgcGlwZWxpbmUuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge3N0cmluZ30gW3N0cj0nJ10gLSBUaGUgc3RyaW5nIHRva2VuIGJlaW5nIHdyYXBwZWQuXG4gKiBAcGFyYW0ge29iamVjdH0gW21ldGFkYXRhPXt9XSAtIE1ldGFkYXRhIGFzc29jaWF0ZWQgd2l0aCB0aGlzIHRva2VuLlxuICovXG5sdW5yLlRva2VuID0gZnVuY3Rpb24gKHN0ciwgbWV0YWRhdGEpIHtcbiAgdGhpcy5zdHIgPSBzdHIgfHwgXCJcIlxuICB0aGlzLm1ldGFkYXRhID0gbWV0YWRhdGEgfHwge31cbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSB0b2tlbiBzdHJpbmcgdGhhdCBpcyBiZWluZyB3cmFwcGVkIGJ5IHRoaXMgb2JqZWN0LlxuICpcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmx1bnIuVG9rZW4ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5zdHJcbn1cblxuLyoqXG4gKiBBIHRva2VuIHVwZGF0ZSBmdW5jdGlvbiBpcyB1c2VkIHdoZW4gdXBkYXRpbmcgb3Igb3B0aW9uYWxseVxuICogd2hlbiBjbG9uaW5nIGEgdG9rZW4uXG4gKlxuICogQGNhbGxiYWNrIGx1bnIuVG9rZW5+dXBkYXRlRnVuY3Rpb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgLSBUaGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB0b2tlbi5cbiAqIEBwYXJhbSB7T2JqZWN0fSBtZXRhZGF0YSAtIEFsbCBtZXRhZGF0YSBhc3NvY2lhdGVkIHdpdGggdGhpcyB0b2tlbi5cbiAqL1xuXG4vKipcbiAqIEFwcGxpZXMgdGhlIGdpdmVuIGZ1bmN0aW9uIHRvIHRoZSB3cmFwcGVkIHN0cmluZyB0b2tlbi5cbiAqXG4gKiBAZXhhbXBsZVxuICogdG9rZW4udXBkYXRlKGZ1bmN0aW9uIChzdHIsIG1ldGFkYXRhKSB7XG4gKiAgIHJldHVybiBzdHIudG9VcHBlckNhc2UoKVxuICogfSlcbiAqXG4gKiBAcGFyYW0ge2x1bnIuVG9rZW5+dXBkYXRlRnVuY3Rpb259IGZuIC0gQSBmdW5jdGlvbiB0byBhcHBseSB0byB0aGUgdG9rZW4gc3RyaW5nLlxuICogQHJldHVybnMge2x1bnIuVG9rZW59XG4gKi9cbmx1bnIuVG9rZW4ucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChmbikge1xuICB0aGlzLnN0ciA9IGZuKHRoaXMuc3RyLCB0aGlzLm1ldGFkYXRhKVxuICByZXR1cm4gdGhpc1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiB0aGlzIHRva2VuLiBPcHRpb25hbGx5IGEgZnVuY3Rpb24gY2FuIGJlXG4gKiBhcHBsaWVkIHRvIHRoZSBjbG9uZWQgdG9rZW4uXG4gKlxuICogQHBhcmFtIHtsdW5yLlRva2VufnVwZGF0ZUZ1bmN0aW9ufSBbZm5dIC0gQW4gb3B0aW9uYWwgZnVuY3Rpb24gdG8gYXBwbHkgdG8gdGhlIGNsb25lZCB0b2tlbi5cbiAqIEByZXR1cm5zIHtsdW5yLlRva2VufVxuICovXG5sdW5yLlRva2VuLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uIChmbikge1xuICBmbiA9IGZuIHx8IGZ1bmN0aW9uIChzKSB7IHJldHVybiBzIH1cbiAgcmV0dXJuIG5ldyBsdW5yLlRva2VuIChmbih0aGlzLnN0ciwgdGhpcy5tZXRhZGF0YSksIHRoaXMubWV0YWRhdGEpXG59XG4vKiFcbiAqIGx1bnIudG9rZW5pemVyXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTkgT2xpdmVyIE5pZ2h0aW5nYWxlXG4gKi9cblxuLyoqXG4gKiBBIGZ1bmN0aW9uIGZvciBzcGxpdHRpbmcgYSBzdHJpbmcgaW50byB0b2tlbnMgcmVhZHkgdG8gYmUgaW5zZXJ0ZWQgaW50b1xuICogdGhlIHNlYXJjaCBpbmRleC4gVXNlcyBgbHVuci50b2tlbml6ZXIuc2VwYXJhdG9yYCB0byBzcGxpdCBzdHJpbmdzLCBjaGFuZ2VcbiAqIHRoZSB2YWx1ZSBvZiB0aGlzIHByb3BlcnR5IHRvIGNoYW5nZSBob3cgc3RyaW5ncyBhcmUgc3BsaXQgaW50byB0b2tlbnMuXG4gKlxuICogVGhpcyB0b2tlbml6ZXIgd2lsbCBjb252ZXJ0IGl0cyBwYXJhbWV0ZXIgdG8gYSBzdHJpbmcgYnkgY2FsbGluZyBgdG9TdHJpbmdgIGFuZFxuICogdGhlbiB3aWxsIHNwbGl0IHRoaXMgc3RyaW5nIG9uIHRoZSBjaGFyYWN0ZXIgaW4gYGx1bnIudG9rZW5pemVyLnNlcGFyYXRvcmAuXG4gKiBBcnJheXMgd2lsbCBoYXZlIHRoZWlyIGVsZW1lbnRzIGNvbnZlcnRlZCB0byBzdHJpbmdzIGFuZCB3cmFwcGVkIGluIGEgbHVuci5Ub2tlbi5cbiAqXG4gKiBPcHRpb25hbCBtZXRhZGF0YSBjYW4gYmUgcGFzc2VkIHRvIHRoZSB0b2tlbml6ZXIsIHRoaXMgbWV0YWRhdGEgd2lsbCBiZSBjbG9uZWQgYW5kXG4gKiBhZGRlZCBhcyBtZXRhZGF0YSB0byBldmVyeSB0b2tlbiB0aGF0IGlzIGNyZWF0ZWQgZnJvbSB0aGUgb2JqZWN0IHRvIGJlIHRva2VuaXplZC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAcGFyYW0gez8oc3RyaW5nfG9iamVjdHxvYmplY3RbXSl9IG9iaiAtIFRoZSBvYmplY3QgdG8gY29udmVydCBpbnRvIHRva2Vuc1xuICogQHBhcmFtIHs/b2JqZWN0fSBtZXRhZGF0YSAtIE9wdGlvbmFsIG1ldGFkYXRhIHRvIGFzc29jaWF0ZSB3aXRoIGV2ZXJ5IHRva2VuXG4gKiBAcmV0dXJucyB7bHVuci5Ub2tlbltdfVxuICogQHNlZSB7QGxpbmsgbHVuci5QaXBlbGluZX1cbiAqL1xubHVuci50b2tlbml6ZXIgPSBmdW5jdGlvbiAob2JqLCBtZXRhZGF0YSkge1xuICBpZiAob2JqID09IG51bGwgfHwgb2JqID09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBbXVxuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkob2JqKSkge1xuICAgIHJldHVybiBvYmoubWFwKGZ1bmN0aW9uICh0KSB7XG4gICAgICByZXR1cm4gbmV3IGx1bnIuVG9rZW4oXG4gICAgICAgIGx1bnIudXRpbHMuYXNTdHJpbmcodCkudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgbHVuci51dGlscy5jbG9uZShtZXRhZGF0YSlcbiAgICAgIClcbiAgICB9KVxuICB9XG5cbiAgdmFyIHN0ciA9IG9iai50b1N0cmluZygpLnRvTG93ZXJDYXNlKCksXG4gICAgICBsZW4gPSBzdHIubGVuZ3RoLFxuICAgICAgdG9rZW5zID0gW11cblxuICBmb3IgKHZhciBzbGljZUVuZCA9IDAsIHNsaWNlU3RhcnQgPSAwOyBzbGljZUVuZCA8PSBsZW47IHNsaWNlRW5kKyspIHtcbiAgICB2YXIgY2hhciA9IHN0ci5jaGFyQXQoc2xpY2VFbmQpLFxuICAgICAgICBzbGljZUxlbmd0aCA9IHNsaWNlRW5kIC0gc2xpY2VTdGFydFxuXG4gICAgaWYgKChjaGFyLm1hdGNoKGx1bnIudG9rZW5pemVyLnNlcGFyYXRvcikgfHwgc2xpY2VFbmQgPT0gbGVuKSkge1xuXG4gICAgICBpZiAoc2xpY2VMZW5ndGggPiAwKSB7XG4gICAgICAgIHZhciB0b2tlbk1ldGFkYXRhID0gbHVuci51dGlscy5jbG9uZShtZXRhZGF0YSkgfHwge31cbiAgICAgICAgdG9rZW5NZXRhZGF0YVtcInBvc2l0aW9uXCJdID0gW3NsaWNlU3RhcnQsIHNsaWNlTGVuZ3RoXVxuICAgICAgICB0b2tlbk1ldGFkYXRhW1wiaW5kZXhcIl0gPSB0b2tlbnMubGVuZ3RoXG5cbiAgICAgICAgdG9rZW5zLnB1c2goXG4gICAgICAgICAgbmV3IGx1bnIuVG9rZW4gKFxuICAgICAgICAgICAgc3RyLnNsaWNlKHNsaWNlU3RhcnQsIHNsaWNlRW5kKSxcbiAgICAgICAgICAgIHRva2VuTWV0YWRhdGFcbiAgICAgICAgICApXG4gICAgICAgIClcbiAgICAgIH1cblxuICAgICAgc2xpY2VTdGFydCA9IHNsaWNlRW5kICsgMVxuICAgIH1cblxuICB9XG5cbiAgcmV0dXJuIHRva2Vuc1xufVxuXG4vKipcbiAqIFRoZSBzZXBhcmF0b3IgdXNlZCB0byBzcGxpdCBhIHN0cmluZyBpbnRvIHRva2Vucy4gT3ZlcnJpZGUgdGhpcyBwcm9wZXJ0eSB0byBjaGFuZ2UgdGhlIGJlaGF2aW91ciBvZlxuICogYGx1bnIudG9rZW5pemVyYCBiZWhhdmlvdXIgd2hlbiB0b2tlbml6aW5nIHN0cmluZ3MuIEJ5IGRlZmF1bHQgdGhpcyBzcGxpdHMgb24gd2hpdGVzcGFjZSBhbmQgaHlwaGVucy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2VlIGx1bnIudG9rZW5pemVyXG4gKi9cbmx1bnIudG9rZW5pemVyLnNlcGFyYXRvciA9IC9bXFxzXFwtXSsvXG4vKiFcbiAqIGx1bnIuUGlwZWxpbmVcbiAqIENvcHlyaWdodCAoQykgMjAxOSBPbGl2ZXIgTmlnaHRpbmdhbGVcbiAqL1xuXG4vKipcbiAqIGx1bnIuUGlwZWxpbmVzIG1haW50YWluIGFuIG9yZGVyZWQgbGlzdCBvZiBmdW5jdGlvbnMgdG8gYmUgYXBwbGllZCB0byBhbGxcbiAqIHRva2VucyBpbiBkb2N1bWVudHMgZW50ZXJpbmcgdGhlIHNlYXJjaCBpbmRleCBhbmQgcXVlcmllcyBiZWluZyByYW4gYWdhaW5zdFxuICogdGhlIGluZGV4LlxuICpcbiAqIEFuIGluc3RhbmNlIG9mIGx1bnIuSW5kZXggY3JlYXRlZCB3aXRoIHRoZSBsdW5yIHNob3J0Y3V0IHdpbGwgY29udGFpbiBhXG4gKiBwaXBlbGluZSB3aXRoIGEgc3RvcCB3b3JkIGZpbHRlciBhbmQgYW4gRW5nbGlzaCBsYW5ndWFnZSBzdGVtbWVyLiBFeHRyYVxuICogZnVuY3Rpb25zIGNhbiBiZSBhZGRlZCBiZWZvcmUgb3IgYWZ0ZXIgZWl0aGVyIG9mIHRoZXNlIGZ1bmN0aW9ucyBvciB0aGVzZVxuICogZGVmYXVsdCBmdW5jdGlvbnMgY2FuIGJlIHJlbW92ZWQuXG4gKlxuICogV2hlbiBydW4gdGhlIHBpcGVsaW5lIHdpbGwgY2FsbCBlYWNoIGZ1bmN0aW9uIGluIHR1cm4sIHBhc3NpbmcgYSB0b2tlbiwgdGhlXG4gKiBpbmRleCBvZiB0aGF0IHRva2VuIGluIHRoZSBvcmlnaW5hbCBsaXN0IG9mIGFsbCB0b2tlbnMgYW5kIGZpbmFsbHkgYSBsaXN0IG9mXG4gKiBhbGwgdGhlIG9yaWdpbmFsIHRva2Vucy5cbiAqXG4gKiBUaGUgb3V0cHV0IG9mIGZ1bmN0aW9ucyBpbiB0aGUgcGlwZWxpbmUgd2lsbCBiZSBwYXNzZWQgdG8gdGhlIG5leHQgZnVuY3Rpb25cbiAqIGluIHRoZSBwaXBlbGluZS4gVG8gZXhjbHVkZSBhIHRva2VuIGZyb20gZW50ZXJpbmcgdGhlIGluZGV4IHRoZSBmdW5jdGlvblxuICogc2hvdWxkIHJldHVybiB1bmRlZmluZWQsIHRoZSByZXN0IG9mIHRoZSBwaXBlbGluZSB3aWxsIG5vdCBiZSBjYWxsZWQgd2l0aFxuICogdGhpcyB0b2tlbi5cbiAqXG4gKiBGb3Igc2VyaWFsaXNhdGlvbiBvZiBwaXBlbGluZXMgdG8gd29yaywgYWxsIGZ1bmN0aW9ucyB1c2VkIGluIGFuIGluc3RhbmNlIG9mXG4gKiBhIHBpcGVsaW5lIHNob3VsZCBiZSByZWdpc3RlcmVkIHdpdGggbHVuci5QaXBlbGluZS4gUmVnaXN0ZXJlZCBmdW5jdGlvbnMgY2FuXG4gKiB0aGVuIGJlIGxvYWRlZC4gSWYgdHJ5aW5nIHRvIGxvYWQgYSBzZXJpYWxpc2VkIHBpcGVsaW5lIHRoYXQgdXNlcyBmdW5jdGlvbnNcbiAqIHRoYXQgYXJlIG5vdCByZWdpc3RlcmVkIGFuIGVycm9yIHdpbGwgYmUgdGhyb3duLlxuICpcbiAqIElmIG5vdCBwbGFubmluZyBvbiBzZXJpYWxpc2luZyB0aGUgcGlwZWxpbmUgdGhlbiByZWdpc3RlcmluZyBwaXBlbGluZSBmdW5jdGlvbnNcbiAqIGlzIG5vdCBuZWNlc3NhcnkuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmx1bnIuUGlwZWxpbmUgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuX3N0YWNrID0gW11cbn1cblxubHVuci5QaXBlbGluZS5yZWdpc3RlcmVkRnVuY3Rpb25zID0gT2JqZWN0LmNyZWF0ZShudWxsKVxuXG4vKipcbiAqIEEgcGlwZWxpbmUgZnVuY3Rpb24gbWFwcyBsdW5yLlRva2VuIHRvIGx1bnIuVG9rZW4uIEEgbHVuci5Ub2tlbiBjb250YWlucyB0aGUgdG9rZW5cbiAqIHN0cmluZyBhcyB3ZWxsIGFzIGFsbCBrbm93biBtZXRhZGF0YS4gQSBwaXBlbGluZSBmdW5jdGlvbiBjYW4gbXV0YXRlIHRoZSB0b2tlbiBzdHJpbmdcbiAqIG9yIG11dGF0ZSAob3IgYWRkKSBtZXRhZGF0YSBmb3IgYSBnaXZlbiB0b2tlbi5cbiAqXG4gKiBBIHBpcGVsaW5lIGZ1bmN0aW9uIGNhbiBpbmRpY2F0ZSB0aGF0IHRoZSBwYXNzZWQgdG9rZW4gc2hvdWxkIGJlIGRpc2NhcmRlZCBieSByZXR1cm5pbmdcbiAqIG51bGwsIHVuZGVmaW5lZCBvciBhbiBlbXB0eSBzdHJpbmcuIFRoaXMgdG9rZW4gd2lsbCBub3QgYmUgcGFzc2VkIHRvIGFueSBkb3duc3RyZWFtIHBpcGVsaW5lXG4gKiBmdW5jdGlvbnMgYW5kIHdpbGwgbm90IGJlIGFkZGVkIHRvIHRoZSBpbmRleC5cbiAqXG4gKiBNdWx0aXBsZSB0b2tlbnMgY2FuIGJlIHJldHVybmVkIGJ5IHJldHVybmluZyBhbiBhcnJheSBvZiB0b2tlbnMuIEVhY2ggdG9rZW4gd2lsbCBiZSBwYXNzZWRcbiAqIHRvIGFueSBkb3duc3RyZWFtIHBpcGVsaW5lIGZ1bmN0aW9ucyBhbmQgYWxsIHdpbGwgcmV0dXJuZWQgdG9rZW5zIHdpbGwgYmUgYWRkZWQgdG8gdGhlIGluZGV4LlxuICpcbiAqIEFueSBudW1iZXIgb2YgcGlwZWxpbmUgZnVuY3Rpb25zIG1heSBiZSBjaGFpbmVkIHRvZ2V0aGVyIHVzaW5nIGEgbHVuci5QaXBlbGluZS5cbiAqXG4gKiBAaW50ZXJmYWNlIGx1bnIuUGlwZWxpbmVGdW5jdGlvblxuICogQHBhcmFtIHtsdW5yLlRva2VufSB0b2tlbiAtIEEgdG9rZW4gZnJvbSB0aGUgZG9jdW1lbnQgYmVpbmcgcHJvY2Vzc2VkLlxuICogQHBhcmFtIHtudW1iZXJ9IGkgLSBUaGUgaW5kZXggb2YgdGhpcyB0b2tlbiBpbiB0aGUgY29tcGxldGUgbGlzdCBvZiB0b2tlbnMgZm9yIHRoaXMgZG9jdW1lbnQvZmllbGQuXG4gKiBAcGFyYW0ge2x1bnIuVG9rZW5bXX0gdG9rZW5zIC0gQWxsIHRva2VucyBmb3IgdGhpcyBkb2N1bWVudC9maWVsZC5cbiAqIEByZXR1cm5zIHsoP2x1bnIuVG9rZW58bHVuci5Ub2tlbltdKX1cbiAqL1xuXG4vKipcbiAqIFJlZ2lzdGVyIGEgZnVuY3Rpb24gd2l0aCB0aGUgcGlwZWxpbmUuXG4gKlxuICogRnVuY3Rpb25zIHRoYXQgYXJlIHVzZWQgaW4gdGhlIHBpcGVsaW5lIHNob3VsZCBiZSByZWdpc3RlcmVkIGlmIHRoZSBwaXBlbGluZVxuICogbmVlZHMgdG8gYmUgc2VyaWFsaXNlZCwgb3IgYSBzZXJpYWxpc2VkIHBpcGVsaW5lIG5lZWRzIHRvIGJlIGxvYWRlZC5cbiAqXG4gKiBSZWdpc3RlcmluZyBhIGZ1bmN0aW9uIGRvZXMgbm90IGFkZCBpdCB0byBhIHBpcGVsaW5lLCBmdW5jdGlvbnMgbXVzdCBzdGlsbCBiZVxuICogYWRkZWQgdG8gaW5zdGFuY2VzIG9mIHRoZSBwaXBlbGluZSBmb3IgdGhlbSB0byBiZSB1c2VkIHdoZW4gcnVubmluZyBhIHBpcGVsaW5lLlxuICpcbiAqIEBwYXJhbSB7bHVuci5QaXBlbGluZUZ1bmN0aW9ufSBmbiAtIFRoZSBmdW5jdGlvbiB0byBjaGVjayBmb3IuXG4gKiBAcGFyYW0ge1N0cmluZ30gbGFiZWwgLSBUaGUgbGFiZWwgdG8gcmVnaXN0ZXIgdGhpcyBmdW5jdGlvbiB3aXRoXG4gKi9cbmx1bnIuUGlwZWxpbmUucmVnaXN0ZXJGdW5jdGlvbiA9IGZ1bmN0aW9uIChmbiwgbGFiZWwpIHtcbiAgaWYgKGxhYmVsIGluIHRoaXMucmVnaXN0ZXJlZEZ1bmN0aW9ucykge1xuICAgIGx1bnIudXRpbHMud2FybignT3ZlcndyaXRpbmcgZXhpc3RpbmcgcmVnaXN0ZXJlZCBmdW5jdGlvbjogJyArIGxhYmVsKVxuICB9XG5cbiAgZm4ubGFiZWwgPSBsYWJlbFxuICBsdW5yLlBpcGVsaW5lLnJlZ2lzdGVyZWRGdW5jdGlvbnNbZm4ubGFiZWxdID0gZm5cbn1cblxuLyoqXG4gKiBXYXJucyBpZiB0aGUgZnVuY3Rpb24gaXMgbm90IHJlZ2lzdGVyZWQgYXMgYSBQaXBlbGluZSBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0ge2x1bnIuUGlwZWxpbmVGdW5jdGlvbn0gZm4gLSBUaGUgZnVuY3Rpb24gdG8gY2hlY2sgZm9yLlxuICogQHByaXZhdGVcbiAqL1xubHVuci5QaXBlbGluZS53YXJuSWZGdW5jdGlvbk5vdFJlZ2lzdGVyZWQgPSBmdW5jdGlvbiAoZm4pIHtcbiAgdmFyIGlzUmVnaXN0ZXJlZCA9IGZuLmxhYmVsICYmIChmbi5sYWJlbCBpbiB0aGlzLnJlZ2lzdGVyZWRGdW5jdGlvbnMpXG5cbiAgaWYgKCFpc1JlZ2lzdGVyZWQpIHtcbiAgICBsdW5yLnV0aWxzLndhcm4oJ0Z1bmN0aW9uIGlzIG5vdCByZWdpc3RlcmVkIHdpdGggcGlwZWxpbmUuIFRoaXMgbWF5IGNhdXNlIHByb2JsZW1zIHdoZW4gc2VyaWFsaXNpbmcgdGhlIGluZGV4LlxcbicsIGZuKVxuICB9XG59XG5cbi8qKlxuICogTG9hZHMgYSBwcmV2aW91c2x5IHNlcmlhbGlzZWQgcGlwZWxpbmUuXG4gKlxuICogQWxsIGZ1bmN0aW9ucyB0byBiZSBsb2FkZWQgbXVzdCBhbHJlYWR5IGJlIHJlZ2lzdGVyZWQgd2l0aCBsdW5yLlBpcGVsaW5lLlxuICogSWYgYW55IGZ1bmN0aW9uIGZyb20gdGhlIHNlcmlhbGlzZWQgZGF0YSBoYXMgbm90IGJlZW4gcmVnaXN0ZXJlZCB0aGVuIGFuXG4gKiBlcnJvciB3aWxsIGJlIHRocm93bi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gc2VyaWFsaXNlZCAtIFRoZSBzZXJpYWxpc2VkIHBpcGVsaW5lIHRvIGxvYWQuXG4gKiBAcmV0dXJucyB7bHVuci5QaXBlbGluZX1cbiAqL1xubHVuci5QaXBlbGluZS5sb2FkID0gZnVuY3Rpb24gKHNlcmlhbGlzZWQpIHtcbiAgdmFyIHBpcGVsaW5lID0gbmV3IGx1bnIuUGlwZWxpbmVcblxuICBzZXJpYWxpc2VkLmZvckVhY2goZnVuY3Rpb24gKGZuTmFtZSkge1xuICAgIHZhciBmbiA9IGx1bnIuUGlwZWxpbmUucmVnaXN0ZXJlZEZ1bmN0aW9uc1tmbk5hbWVdXG5cbiAgICBpZiAoZm4pIHtcbiAgICAgIHBpcGVsaW5lLmFkZChmbilcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgbG9hZCB1bnJlZ2lzdGVyZWQgZnVuY3Rpb246ICcgKyBmbk5hbWUpXG4gICAgfVxuICB9KVxuXG4gIHJldHVybiBwaXBlbGluZVxufVxuXG4vKipcbiAqIEFkZHMgbmV3IGZ1bmN0aW9ucyB0byB0aGUgZW5kIG9mIHRoZSBwaXBlbGluZS5cbiAqXG4gKiBMb2dzIGEgd2FybmluZyBpZiB0aGUgZnVuY3Rpb24gaGFzIG5vdCBiZWVuIHJlZ2lzdGVyZWQuXG4gKlxuICogQHBhcmFtIHtsdW5yLlBpcGVsaW5lRnVuY3Rpb25bXX0gZnVuY3Rpb25zIC0gQW55IG51bWJlciBvZiBmdW5jdGlvbnMgdG8gYWRkIHRvIHRoZSBwaXBlbGluZS5cbiAqL1xubHVuci5QaXBlbGluZS5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZm5zID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKVxuXG4gIGZucy5mb3JFYWNoKGZ1bmN0aW9uIChmbikge1xuICAgIGx1bnIuUGlwZWxpbmUud2FybklmRnVuY3Rpb25Ob3RSZWdpc3RlcmVkKGZuKVxuICAgIHRoaXMuX3N0YWNrLnB1c2goZm4pXG4gIH0sIHRoaXMpXG59XG5cbi8qKlxuICogQWRkcyBhIHNpbmdsZSBmdW5jdGlvbiBhZnRlciBhIGZ1bmN0aW9uIHRoYXQgYWxyZWFkeSBleGlzdHMgaW4gdGhlXG4gKiBwaXBlbGluZS5cbiAqXG4gKiBMb2dzIGEgd2FybmluZyBpZiB0aGUgZnVuY3Rpb24gaGFzIG5vdCBiZWVuIHJlZ2lzdGVyZWQuXG4gKlxuICogQHBhcmFtIHtsdW5yLlBpcGVsaW5lRnVuY3Rpb259IGV4aXN0aW5nRm4gLSBBIGZ1bmN0aW9uIHRoYXQgYWxyZWFkeSBleGlzdHMgaW4gdGhlIHBpcGVsaW5lLlxuICogQHBhcmFtIHtsdW5yLlBpcGVsaW5lRnVuY3Rpb259IG5ld0ZuIC0gVGhlIG5ldyBmdW5jdGlvbiB0byBhZGQgdG8gdGhlIHBpcGVsaW5lLlxuICovXG5sdW5yLlBpcGVsaW5lLnByb3RvdHlwZS5hZnRlciA9IGZ1bmN0aW9uIChleGlzdGluZ0ZuLCBuZXdGbikge1xuICBsdW5yLlBpcGVsaW5lLndhcm5JZkZ1bmN0aW9uTm90UmVnaXN0ZXJlZChuZXdGbilcblxuICB2YXIgcG9zID0gdGhpcy5fc3RhY2suaW5kZXhPZihleGlzdGluZ0ZuKVxuICBpZiAocG9zID09IC0xKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZmluZCBleGlzdGluZ0ZuJylcbiAgfVxuXG4gIHBvcyA9IHBvcyArIDFcbiAgdGhpcy5fc3RhY2suc3BsaWNlKHBvcywgMCwgbmV3Rm4pXG59XG5cbi8qKlxuICogQWRkcyBhIHNpbmdsZSBmdW5jdGlvbiBiZWZvcmUgYSBmdW5jdGlvbiB0aGF0IGFscmVhZHkgZXhpc3RzIGluIHRoZVxuICogcGlwZWxpbmUuXG4gKlxuICogTG9ncyBhIHdhcm5pbmcgaWYgdGhlIGZ1bmN0aW9uIGhhcyBub3QgYmVlbiByZWdpc3RlcmVkLlxuICpcbiAqIEBwYXJhbSB7bHVuci5QaXBlbGluZUZ1bmN0aW9ufSBleGlzdGluZ0ZuIC0gQSBmdW5jdGlvbiB0aGF0IGFscmVhZHkgZXhpc3RzIGluIHRoZSBwaXBlbGluZS5cbiAqIEBwYXJhbSB7bHVuci5QaXBlbGluZUZ1bmN0aW9ufSBuZXdGbiAtIFRoZSBuZXcgZnVuY3Rpb24gdG8gYWRkIHRvIHRoZSBwaXBlbGluZS5cbiAqL1xubHVuci5QaXBlbGluZS5wcm90b3R5cGUuYmVmb3JlID0gZnVuY3Rpb24gKGV4aXN0aW5nRm4sIG5ld0ZuKSB7XG4gIGx1bnIuUGlwZWxpbmUud2FybklmRnVuY3Rpb25Ob3RSZWdpc3RlcmVkKG5ld0ZuKVxuXG4gIHZhciBwb3MgPSB0aGlzLl9zdGFjay5pbmRleE9mKGV4aXN0aW5nRm4pXG4gIGlmIChwb3MgPT0gLTEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBmaW5kIGV4aXN0aW5nRm4nKVxuICB9XG5cbiAgdGhpcy5fc3RhY2suc3BsaWNlKHBvcywgMCwgbmV3Rm4pXG59XG5cbi8qKlxuICogUmVtb3ZlcyBhIGZ1bmN0aW9uIGZyb20gdGhlIHBpcGVsaW5lLlxuICpcbiAqIEBwYXJhbSB7bHVuci5QaXBlbGluZUZ1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gcmVtb3ZlIGZyb20gdGhlIHBpcGVsaW5lLlxuICovXG5sdW5yLlBpcGVsaW5lLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoZm4pIHtcbiAgdmFyIHBvcyA9IHRoaXMuX3N0YWNrLmluZGV4T2YoZm4pXG4gIGlmIChwb3MgPT0gLTEpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHRoaXMuX3N0YWNrLnNwbGljZShwb3MsIDEpXG59XG5cbi8qKlxuICogUnVucyB0aGUgY3VycmVudCBsaXN0IG9mIGZ1bmN0aW9ucyB0aGF0IG1ha2UgdXAgdGhlIHBpcGVsaW5lIGFnYWluc3QgdGhlXG4gKiBwYXNzZWQgdG9rZW5zLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHRva2VucyBUaGUgdG9rZW5zIHRvIHJ1biB0aHJvdWdoIHRoZSBwaXBlbGluZS5cbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqL1xubHVuci5QaXBlbGluZS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKHRva2Vucykge1xuICB2YXIgc3RhY2tMZW5ndGggPSB0aGlzLl9zdGFjay5sZW5ndGhcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0YWNrTGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZm4gPSB0aGlzLl9zdGFja1tpXVxuICAgIHZhciBtZW1vID0gW11cblxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgdG9rZW5zLmxlbmd0aDsgaisrKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gZm4odG9rZW5zW2pdLCBqLCB0b2tlbnMpXG5cbiAgICAgIGlmIChyZXN1bHQgPT09IG51bGwgfHwgcmVzdWx0ID09PSB2b2lkIDAgfHwgcmVzdWx0ID09PSAnJykgY29udGludWVcblxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVzdWx0KSkge1xuICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IHJlc3VsdC5sZW5ndGg7IGsrKykge1xuICAgICAgICAgIG1lbW8ucHVzaChyZXN1bHRba10pXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1lbW8ucHVzaChyZXN1bHQpXG4gICAgICB9XG4gICAgfVxuXG4gICAgdG9rZW5zID0gbWVtb1xuICB9XG5cbiAgcmV0dXJuIHRva2Vuc1xufVxuXG4vKipcbiAqIENvbnZlbmllbmNlIG1ldGhvZCBmb3IgcGFzc2luZyBhIHN0cmluZyB0aHJvdWdoIGEgcGlwZWxpbmUgYW5kIGdldHRpbmdcbiAqIHN0cmluZ3Mgb3V0LiBUaGlzIG1ldGhvZCB0YWtlcyBjYXJlIG9mIHdyYXBwaW5nIHRoZSBwYXNzZWQgc3RyaW5nIGluIGFcbiAqIHRva2VuIGFuZCBtYXBwaW5nIHRoZSByZXN1bHRpbmcgdG9rZW5zIGJhY2sgdG8gc3RyaW5ncy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyIC0gVGhlIHN0cmluZyB0byBwYXNzIHRocm91Z2ggdGhlIHBpcGVsaW5lLlxuICogQHBhcmFtIHs/b2JqZWN0fSBtZXRhZGF0YSAtIE9wdGlvbmFsIG1ldGFkYXRhIHRvIGFzc29jaWF0ZSB3aXRoIHRoZSB0b2tlblxuICogcGFzc2VkIHRvIHRoZSBwaXBlbGluZS5cbiAqIEByZXR1cm5zIHtzdHJpbmdbXX1cbiAqL1xubHVuci5QaXBlbGluZS5wcm90b3R5cGUucnVuU3RyaW5nID0gZnVuY3Rpb24gKHN0ciwgbWV0YWRhdGEpIHtcbiAgdmFyIHRva2VuID0gbmV3IGx1bnIuVG9rZW4gKHN0ciwgbWV0YWRhdGEpXG5cbiAgcmV0dXJuIHRoaXMucnVuKFt0b2tlbl0pLm1hcChmdW5jdGlvbiAodCkge1xuICAgIHJldHVybiB0LnRvU3RyaW5nKClcbiAgfSlcbn1cblxuLyoqXG4gKiBSZXNldHMgdGhlIHBpcGVsaW5lIGJ5IHJlbW92aW5nIGFueSBleGlzdGluZyBwcm9jZXNzb3JzLlxuICpcbiAqL1xubHVuci5QaXBlbGluZS5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuX3N0YWNrID0gW11cbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgcmVwcmVzZW50YXRpb24gb2YgdGhlIHBpcGVsaW5lIHJlYWR5IGZvciBzZXJpYWxpc2F0aW9uLlxuICpcbiAqIExvZ3MgYSB3YXJuaW5nIGlmIHRoZSBmdW5jdGlvbiBoYXMgbm90IGJlZW4gcmVnaXN0ZXJlZC5cbiAqXG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKi9cbmx1bnIuUGlwZWxpbmUucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX3N0YWNrLm1hcChmdW5jdGlvbiAoZm4pIHtcbiAgICBsdW5yLlBpcGVsaW5lLndhcm5JZkZ1bmN0aW9uTm90UmVnaXN0ZXJlZChmbilcblxuICAgIHJldHVybiBmbi5sYWJlbFxuICB9KVxufVxuLyohXG4gKiBsdW5yLlZlY3RvclxuICogQ29weXJpZ2h0IChDKSAyMDE5IE9saXZlciBOaWdodGluZ2FsZVxuICovXG5cbi8qKlxuICogQSB2ZWN0b3IgaXMgdXNlZCB0byBjb25zdHJ1Y3QgdGhlIHZlY3RvciBzcGFjZSBvZiBkb2N1bWVudHMgYW5kIHF1ZXJpZXMuIFRoZXNlXG4gKiB2ZWN0b3JzIHN1cHBvcnQgb3BlcmF0aW9ucyB0byBkZXRlcm1pbmUgdGhlIHNpbWlsYXJpdHkgYmV0d2VlbiB0d28gZG9jdW1lbnRzIG9yXG4gKiBhIGRvY3VtZW50IGFuZCBhIHF1ZXJ5LlxuICpcbiAqIE5vcm1hbGx5IG5vIHBhcmFtZXRlcnMgYXJlIHJlcXVpcmVkIGZvciBpbml0aWFsaXppbmcgYSB2ZWN0b3IsIGJ1dCBpbiB0aGUgY2FzZSBvZlxuICogbG9hZGluZyBhIHByZXZpb3VzbHkgZHVtcGVkIHZlY3RvciB0aGUgcmF3IGVsZW1lbnRzIGNhbiBiZSBwcm92aWRlZCB0byB0aGUgY29uc3RydWN0b3IuXG4gKlxuICogRm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMgdmVjdG9ycyBhcmUgaW1wbGVtZW50ZWQgd2l0aCBhIGZsYXQgYXJyYXksIHdoZXJlIGFuIGVsZW1lbnRzXG4gKiBpbmRleCBpcyBpbW1lZGlhdGVseSBmb2xsb3dlZCBieSBpdHMgdmFsdWUuIEUuZy4gW2luZGV4LCB2YWx1ZSwgaW5kZXgsIHZhbHVlXS4gVGhpc1xuICogYWxsb3dzIHRoZSB1bmRlcmx5aW5nIGFycmF5IHRvIGJlIGFzIHNwYXJzZSBhcyBwb3NzaWJsZSBhbmQgc3RpbGwgb2ZmZXIgZGVjZW50XG4gKiBwZXJmb3JtYW5jZSB3aGVuIGJlaW5nIHVzZWQgZm9yIHZlY3RvciBjYWxjdWxhdGlvbnMuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge051bWJlcltdfSBbZWxlbWVudHNdIC0gVGhlIGZsYXQgbGlzdCBvZiBlbGVtZW50IGluZGV4IGFuZCBlbGVtZW50IHZhbHVlIHBhaXJzLlxuICovXG5sdW5yLlZlY3RvciA9IGZ1bmN0aW9uIChlbGVtZW50cykge1xuICB0aGlzLl9tYWduaXR1ZGUgPSAwXG4gIHRoaXMuZWxlbWVudHMgPSBlbGVtZW50cyB8fCBbXVxufVxuXG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgcG9zaXRpb24gd2l0aGluIHRoZSB2ZWN0b3IgdG8gaW5zZXJ0IGEgZ2l2ZW4gaW5kZXguXG4gKlxuICogVGhpcyBpcyB1c2VkIGludGVybmFsbHkgYnkgaW5zZXJ0IGFuZCB1cHNlcnQuIElmIHRoZXJlIGFyZSBkdXBsaWNhdGUgaW5kZXhlcyB0aGVuXG4gKiB0aGUgcG9zaXRpb24gaXMgcmV0dXJuZWQgYXMgaWYgdGhlIHZhbHVlIGZvciB0aGF0IGluZGV4IHdlcmUgdG8gYmUgdXBkYXRlZCwgYnV0IGl0XG4gKiBpcyB0aGUgY2FsbGVycyByZXNwb25zaWJpbGl0eSB0byBjaGVjayB3aGV0aGVyIHRoZXJlIGlzIGEgZHVwbGljYXRlIGF0IHRoYXQgaW5kZXhcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gaW5zZXJ0SWR4IC0gVGhlIGluZGV4IGF0IHdoaWNoIHRoZSBlbGVtZW50IHNob3VsZCBiZSBpbnNlcnRlZC5cbiAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gKi9cbmx1bnIuVmVjdG9yLnByb3RvdHlwZS5wb3NpdGlvbkZvckluZGV4ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gIC8vIEZvciBhbiBlbXB0eSB2ZWN0b3IgdGhlIHR1cGxlIGNhbiBiZSBpbnNlcnRlZCBhdCB0aGUgYmVnaW5uaW5nXG4gIGlmICh0aGlzLmVsZW1lbnRzLmxlbmd0aCA9PSAwKSB7XG4gICAgcmV0dXJuIDBcbiAgfVxuXG4gIHZhciBzdGFydCA9IDAsXG4gICAgICBlbmQgPSB0aGlzLmVsZW1lbnRzLmxlbmd0aCAvIDIsXG4gICAgICBzbGljZUxlbmd0aCA9IGVuZCAtIHN0YXJ0LFxuICAgICAgcGl2b3RQb2ludCA9IE1hdGguZmxvb3Ioc2xpY2VMZW5ndGggLyAyKSxcbiAgICAgIHBpdm90SW5kZXggPSB0aGlzLmVsZW1lbnRzW3Bpdm90UG9pbnQgKiAyXVxuXG4gIHdoaWxlIChzbGljZUxlbmd0aCA+IDEpIHtcbiAgICBpZiAocGl2b3RJbmRleCA8IGluZGV4KSB7XG4gICAgICBzdGFydCA9IHBpdm90UG9pbnRcbiAgICB9XG5cbiAgICBpZiAocGl2b3RJbmRleCA+IGluZGV4KSB7XG4gICAgICBlbmQgPSBwaXZvdFBvaW50XG4gICAgfVxuXG4gICAgaWYgKHBpdm90SW5kZXggPT0gaW5kZXgpIHtcbiAgICAgIGJyZWFrXG4gICAgfVxuXG4gICAgc2xpY2VMZW5ndGggPSBlbmQgLSBzdGFydFxuICAgIHBpdm90UG9pbnQgPSBzdGFydCArIE1hdGguZmxvb3Ioc2xpY2VMZW5ndGggLyAyKVxuICAgIHBpdm90SW5kZXggPSB0aGlzLmVsZW1lbnRzW3Bpdm90UG9pbnQgKiAyXVxuICB9XG5cbiAgaWYgKHBpdm90SW5kZXggPT0gaW5kZXgpIHtcbiAgICByZXR1cm4gcGl2b3RQb2ludCAqIDJcbiAgfVxuXG4gIGlmIChwaXZvdEluZGV4ID4gaW5kZXgpIHtcbiAgICByZXR1cm4gcGl2b3RQb2ludCAqIDJcbiAgfVxuXG4gIGlmIChwaXZvdEluZGV4IDwgaW5kZXgpIHtcbiAgICByZXR1cm4gKHBpdm90UG9pbnQgKyAxKSAqIDJcbiAgfVxufVxuXG4vKipcbiAqIEluc2VydHMgYW4gZWxlbWVudCBhdCBhbiBpbmRleCB3aXRoaW4gdGhlIHZlY3Rvci5cbiAqXG4gKiBEb2VzIG5vdCBhbGxvdyBkdXBsaWNhdGVzLCB3aWxsIHRocm93IGFuIGVycm9yIGlmIHRoZXJlIGlzIGFscmVhZHkgYW4gZW50cnlcbiAqIGZvciB0aGlzIGluZGV4LlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBpbnNlcnRJZHggLSBUaGUgaW5kZXggYXQgd2hpY2ggdGhlIGVsZW1lbnQgc2hvdWxkIGJlIGluc2VydGVkLlxuICogQHBhcmFtIHtOdW1iZXJ9IHZhbCAtIFRoZSB2YWx1ZSB0byBiZSBpbnNlcnRlZCBpbnRvIHRoZSB2ZWN0b3IuXG4gKi9cbmx1bnIuVmVjdG9yLnByb3RvdHlwZS5pbnNlcnQgPSBmdW5jdGlvbiAoaW5zZXJ0SWR4LCB2YWwpIHtcbiAgdGhpcy51cHNlcnQoaW5zZXJ0SWR4LCB2YWwsIGZ1bmN0aW9uICgpIHtcbiAgICB0aHJvdyBcImR1cGxpY2F0ZSBpbmRleFwiXG4gIH0pXG59XG5cbi8qKlxuICogSW5zZXJ0cyBvciB1cGRhdGVzIGFuIGV4aXN0aW5nIGluZGV4IHdpdGhpbiB0aGUgdmVjdG9yLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBpbnNlcnRJZHggLSBUaGUgaW5kZXggYXQgd2hpY2ggdGhlIGVsZW1lbnQgc2hvdWxkIGJlIGluc2VydGVkLlxuICogQHBhcmFtIHtOdW1iZXJ9IHZhbCAtIFRoZSB2YWx1ZSB0byBiZSBpbnNlcnRlZCBpbnRvIHRoZSB2ZWN0b3IuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBmbiAtIEEgZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgZm9yIHVwZGF0ZXMsIHRoZSBleGlzdGluZyB2YWx1ZSBhbmQgdGhlXG4gKiByZXF1ZXN0ZWQgdmFsdWUgYXJlIHBhc3NlZCBhcyBhcmd1bWVudHNcbiAqL1xubHVuci5WZWN0b3IucHJvdG90eXBlLnVwc2VydCA9IGZ1bmN0aW9uIChpbnNlcnRJZHgsIHZhbCwgZm4pIHtcbiAgdGhpcy5fbWFnbml0dWRlID0gMFxuICB2YXIgcG9zaXRpb24gPSB0aGlzLnBvc2l0aW9uRm9ySW5kZXgoaW5zZXJ0SWR4KVxuXG4gIGlmICh0aGlzLmVsZW1lbnRzW3Bvc2l0aW9uXSA9PSBpbnNlcnRJZHgpIHtcbiAgICB0aGlzLmVsZW1lbnRzW3Bvc2l0aW9uICsgMV0gPSBmbih0aGlzLmVsZW1lbnRzW3Bvc2l0aW9uICsgMV0sIHZhbClcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmVsZW1lbnRzLnNwbGljZShwb3NpdGlvbiwgMCwgaW5zZXJ0SWR4LCB2YWwpXG4gIH1cbn1cblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBtYWduaXR1ZGUgb2YgdGhpcyB2ZWN0b3IuXG4gKlxuICogQHJldHVybnMge051bWJlcn1cbiAqL1xubHVuci5WZWN0b3IucHJvdG90eXBlLm1hZ25pdHVkZSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuX21hZ25pdHVkZSkgcmV0dXJuIHRoaXMuX21hZ25pdHVkZVxuXG4gIHZhciBzdW1PZlNxdWFyZXMgPSAwLFxuICAgICAgZWxlbWVudHNMZW5ndGggPSB0aGlzLmVsZW1lbnRzLmxlbmd0aFxuXG4gIGZvciAodmFyIGkgPSAxOyBpIDwgZWxlbWVudHNMZW5ndGg7IGkgKz0gMikge1xuICAgIHZhciB2YWwgPSB0aGlzLmVsZW1lbnRzW2ldXG4gICAgc3VtT2ZTcXVhcmVzICs9IHZhbCAqIHZhbFxuICB9XG5cbiAgcmV0dXJuIHRoaXMuX21hZ25pdHVkZSA9IE1hdGguc3FydChzdW1PZlNxdWFyZXMpXG59XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZG90IHByb2R1Y3Qgb2YgdGhpcyB2ZWN0b3IgYW5kIGFub3RoZXIgdmVjdG9yLlxuICpcbiAqIEBwYXJhbSB7bHVuci5WZWN0b3J9IG90aGVyVmVjdG9yIC0gVGhlIHZlY3RvciB0byBjb21wdXRlIHRoZSBkb3QgcHJvZHVjdCB3aXRoLlxuICogQHJldHVybnMge051bWJlcn1cbiAqL1xubHVuci5WZWN0b3IucHJvdG90eXBlLmRvdCA9IGZ1bmN0aW9uIChvdGhlclZlY3Rvcikge1xuICB2YXIgZG90UHJvZHVjdCA9IDAsXG4gICAgICBhID0gdGhpcy5lbGVtZW50cywgYiA9IG90aGVyVmVjdG9yLmVsZW1lbnRzLFxuICAgICAgYUxlbiA9IGEubGVuZ3RoLCBiTGVuID0gYi5sZW5ndGgsXG4gICAgICBhVmFsID0gMCwgYlZhbCA9IDAsXG4gICAgICBpID0gMCwgaiA9IDBcblxuICB3aGlsZSAoaSA8IGFMZW4gJiYgaiA8IGJMZW4pIHtcbiAgICBhVmFsID0gYVtpXSwgYlZhbCA9IGJbal1cbiAgICBpZiAoYVZhbCA8IGJWYWwpIHtcbiAgICAgIGkgKz0gMlxuICAgIH0gZWxzZSBpZiAoYVZhbCA+IGJWYWwpIHtcbiAgICAgIGogKz0gMlxuICAgIH0gZWxzZSBpZiAoYVZhbCA9PSBiVmFsKSB7XG4gICAgICBkb3RQcm9kdWN0ICs9IGFbaSArIDFdICogYltqICsgMV1cbiAgICAgIGkgKz0gMlxuICAgICAgaiArPSAyXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRvdFByb2R1Y3Rcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBzaW1pbGFyaXR5IGJldHdlZW4gdGhpcyB2ZWN0b3IgYW5kIGFub3RoZXIgdmVjdG9yLlxuICpcbiAqIEBwYXJhbSB7bHVuci5WZWN0b3J9IG90aGVyVmVjdG9yIC0gVGhlIG90aGVyIHZlY3RvciB0byBjYWxjdWxhdGUgdGhlXG4gKiBzaW1pbGFyaXR5IHdpdGguXG4gKiBAcmV0dXJucyB7TnVtYmVyfVxuICovXG5sdW5yLlZlY3Rvci5wcm90b3R5cGUuc2ltaWxhcml0eSA9IGZ1bmN0aW9uIChvdGhlclZlY3Rvcikge1xuICByZXR1cm4gdGhpcy5kb3Qob3RoZXJWZWN0b3IpIC8gdGhpcy5tYWduaXR1ZGUoKSB8fCAwXG59XG5cbi8qKlxuICogQ29udmVydHMgdGhlIHZlY3RvciB0byBhbiBhcnJheSBvZiB0aGUgZWxlbWVudHMgd2l0aGluIHRoZSB2ZWN0b3IuXG4gKlxuICogQHJldHVybnMge051bWJlcltdfVxuICovXG5sdW5yLlZlY3Rvci5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG91dHB1dCA9IG5ldyBBcnJheSAodGhpcy5lbGVtZW50cy5sZW5ndGggLyAyKVxuXG4gIGZvciAodmFyIGkgPSAxLCBqID0gMDsgaSA8IHRoaXMuZWxlbWVudHMubGVuZ3RoOyBpICs9IDIsIGorKykge1xuICAgIG91dHB1dFtqXSA9IHRoaXMuZWxlbWVudHNbaV1cbiAgfVxuXG4gIHJldHVybiBvdXRwdXRcbn1cblxuLyoqXG4gKiBBIEpTT04gc2VyaWFsaXphYmxlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB2ZWN0b3IuXG4gKlxuICogQHJldHVybnMge051bWJlcltdfVxuICovXG5sdW5yLlZlY3Rvci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5lbGVtZW50c1xufVxuLyogZXNsaW50LWRpc2FibGUgKi9cbi8qIVxuICogbHVuci5zdGVtbWVyXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTkgT2xpdmVyIE5pZ2h0aW5nYWxlXG4gKiBJbmNsdWRlcyBjb2RlIGZyb20gLSBodHRwOi8vdGFydGFydXMub3JnL35tYXJ0aW4vUG9ydGVyU3RlbW1lci9qcy50eHRcbiAqL1xuXG4vKipcbiAqIGx1bnIuc3RlbW1lciBpcyBhbiBlbmdsaXNoIGxhbmd1YWdlIHN0ZW1tZXIsIHRoaXMgaXMgYSBKYXZhU2NyaXB0XG4gKiBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgUG9ydGVyU3RlbW1lciB0YWtlbiBmcm9tIGh0dHA6Ly90YXJ0YXJ1cy5vcmcvfm1hcnRpblxuICpcbiAqIEBzdGF0aWNcbiAqIEBpbXBsZW1lbnRzIHtsdW5yLlBpcGVsaW5lRnVuY3Rpb259XG4gKiBAcGFyYW0ge2x1bnIuVG9rZW59IHRva2VuIC0gVGhlIHN0cmluZyB0byBzdGVtXG4gKiBAcmV0dXJucyB7bHVuci5Ub2tlbn1cbiAqIEBzZWUge0BsaW5rIGx1bnIuUGlwZWxpbmV9XG4gKiBAZnVuY3Rpb25cbiAqL1xubHVuci5zdGVtbWVyID0gKGZ1bmN0aW9uKCl7XG4gIHZhciBzdGVwMmxpc3QgPSB7XG4gICAgICBcImF0aW9uYWxcIiA6IFwiYXRlXCIsXG4gICAgICBcInRpb25hbFwiIDogXCJ0aW9uXCIsXG4gICAgICBcImVuY2lcIiA6IFwiZW5jZVwiLFxuICAgICAgXCJhbmNpXCIgOiBcImFuY2VcIixcbiAgICAgIFwiaXplclwiIDogXCJpemVcIixcbiAgICAgIFwiYmxpXCIgOiBcImJsZVwiLFxuICAgICAgXCJhbGxpXCIgOiBcImFsXCIsXG4gICAgICBcImVudGxpXCIgOiBcImVudFwiLFxuICAgICAgXCJlbGlcIiA6IFwiZVwiLFxuICAgICAgXCJvdXNsaVwiIDogXCJvdXNcIixcbiAgICAgIFwiaXphdGlvblwiIDogXCJpemVcIixcbiAgICAgIFwiYXRpb25cIiA6IFwiYXRlXCIsXG4gICAgICBcImF0b3JcIiA6IFwiYXRlXCIsXG4gICAgICBcImFsaXNtXCIgOiBcImFsXCIsXG4gICAgICBcIml2ZW5lc3NcIiA6IFwiaXZlXCIsXG4gICAgICBcImZ1bG5lc3NcIiA6IFwiZnVsXCIsXG4gICAgICBcIm91c25lc3NcIiA6IFwib3VzXCIsXG4gICAgICBcImFsaXRpXCIgOiBcImFsXCIsXG4gICAgICBcIml2aXRpXCIgOiBcIml2ZVwiLFxuICAgICAgXCJiaWxpdGlcIiA6IFwiYmxlXCIsXG4gICAgICBcImxvZ2lcIiA6IFwibG9nXCJcbiAgICB9LFxuXG4gICAgc3RlcDNsaXN0ID0ge1xuICAgICAgXCJpY2F0ZVwiIDogXCJpY1wiLFxuICAgICAgXCJhdGl2ZVwiIDogXCJcIixcbiAgICAgIFwiYWxpemVcIiA6IFwiYWxcIixcbiAgICAgIFwiaWNpdGlcIiA6IFwiaWNcIixcbiAgICAgIFwiaWNhbFwiIDogXCJpY1wiLFxuICAgICAgXCJmdWxcIiA6IFwiXCIsXG4gICAgICBcIm5lc3NcIiA6IFwiXCJcbiAgICB9LFxuXG4gICAgYyA9IFwiW15hZWlvdV1cIiwgICAgICAgICAgLy8gY29uc29uYW50XG4gICAgdiA9IFwiW2FlaW91eV1cIiwgICAgICAgICAgLy8gdm93ZWxcbiAgICBDID0gYyArIFwiW15hZWlvdXldKlwiLCAgICAvLyBjb25zb25hbnQgc2VxdWVuY2VcbiAgICBWID0gdiArIFwiW2FlaW91XSpcIiwgICAgICAvLyB2b3dlbCBzZXF1ZW5jZVxuXG4gICAgbWdyMCA9IFwiXihcIiArIEMgKyBcIik/XCIgKyBWICsgQywgICAgICAgICAgICAgICAvLyBbQ11WQy4uLiBpcyBtPjBcbiAgICBtZXExID0gXCJeKFwiICsgQyArIFwiKT9cIiArIFYgKyBDICsgXCIoXCIgKyBWICsgXCIpPyRcIiwgIC8vIFtDXVZDW1ZdIGlzIG09MVxuICAgIG1ncjEgPSBcIl4oXCIgKyBDICsgXCIpP1wiICsgViArIEMgKyBWICsgQywgICAgICAgLy8gW0NdVkNWQy4uLiBpcyBtPjFcbiAgICBzX3YgPSBcIl4oXCIgKyBDICsgXCIpP1wiICsgdjsgICAgICAgICAgICAgICAgICAgLy8gdm93ZWwgaW4gc3RlbVxuXG4gIHZhciByZV9tZ3IwID0gbmV3IFJlZ0V4cChtZ3IwKTtcbiAgdmFyIHJlX21ncjEgPSBuZXcgUmVnRXhwKG1ncjEpO1xuICB2YXIgcmVfbWVxMSA9IG5ldyBSZWdFeHAobWVxMSk7XG4gIHZhciByZV9zX3YgPSBuZXcgUmVnRXhwKHNfdik7XG5cbiAgdmFyIHJlXzFhID0gL14oLis/KShzc3xpKWVzJC87XG4gIHZhciByZTJfMWEgPSAvXiguKz8pKFtec10pcyQvO1xuICB2YXIgcmVfMWIgPSAvXiguKz8pZWVkJC87XG4gIHZhciByZTJfMWIgPSAvXiguKz8pKGVkfGluZykkLztcbiAgdmFyIHJlXzFiXzIgPSAvLiQvO1xuICB2YXIgcmUyXzFiXzIgPSAvKGF0fGJsfGl6KSQvO1xuICB2YXIgcmUzXzFiXzIgPSBuZXcgUmVnRXhwKFwiKFteYWVpb3V5bHN6XSlcXFxcMSRcIik7XG4gIHZhciByZTRfMWJfMiA9IG5ldyBSZWdFeHAoXCJeXCIgKyBDICsgdiArIFwiW15hZWlvdXd4eV0kXCIpO1xuXG4gIHZhciByZV8xYyA9IC9eKC4rP1teYWVpb3VdKXkkLztcbiAgdmFyIHJlXzIgPSAvXiguKz8pKGF0aW9uYWx8dGlvbmFsfGVuY2l8YW5jaXxpemVyfGJsaXxhbGxpfGVudGxpfGVsaXxvdXNsaXxpemF0aW9ufGF0aW9ufGF0b3J8YWxpc218aXZlbmVzc3xmdWxuZXNzfG91c25lc3N8YWxpdGl8aXZpdGl8YmlsaXRpfGxvZ2kpJC87XG5cbiAgdmFyIHJlXzMgPSAvXiguKz8pKGljYXRlfGF0aXZlfGFsaXplfGljaXRpfGljYWx8ZnVsfG5lc3MpJC87XG5cbiAgdmFyIHJlXzQgPSAvXiguKz8pKGFsfGFuY2V8ZW5jZXxlcnxpY3xhYmxlfGlibGV8YW50fGVtZW50fG1lbnR8ZW50fG91fGlzbXxhdGV8aXRpfG91c3xpdmV8aXplKSQvO1xuICB2YXIgcmUyXzQgPSAvXiguKz8pKHN8dCkoaW9uKSQvO1xuXG4gIHZhciByZV81ID0gL14oLis/KWUkLztcbiAgdmFyIHJlXzVfMSA9IC9sbCQvO1xuICB2YXIgcmUzXzUgPSBuZXcgUmVnRXhwKFwiXlwiICsgQyArIHYgKyBcIlteYWVpb3V3eHldJFwiKTtcblxuICB2YXIgcG9ydGVyU3RlbW1lciA9IGZ1bmN0aW9uIHBvcnRlclN0ZW1tZXIodykge1xuICAgIHZhciBzdGVtLFxuICAgICAgc3VmZml4LFxuICAgICAgZmlyc3RjaCxcbiAgICAgIHJlLFxuICAgICAgcmUyLFxuICAgICAgcmUzLFxuICAgICAgcmU0O1xuXG4gICAgaWYgKHcubGVuZ3RoIDwgMykgeyByZXR1cm4gdzsgfVxuXG4gICAgZmlyc3RjaCA9IHcuc3Vic3RyKDAsMSk7XG4gICAgaWYgKGZpcnN0Y2ggPT0gXCJ5XCIpIHtcbiAgICAgIHcgPSBmaXJzdGNoLnRvVXBwZXJDYXNlKCkgKyB3LnN1YnN0cigxKTtcbiAgICB9XG5cbiAgICAvLyBTdGVwIDFhXG4gICAgcmUgPSByZV8xYVxuICAgIHJlMiA9IHJlMl8xYTtcblxuICAgIGlmIChyZS50ZXN0KHcpKSB7IHcgPSB3LnJlcGxhY2UocmUsXCIkMSQyXCIpOyB9XG4gICAgZWxzZSBpZiAocmUyLnRlc3QodykpIHsgdyA9IHcucmVwbGFjZShyZTIsXCIkMSQyXCIpOyB9XG5cbiAgICAvLyBTdGVwIDFiXG4gICAgcmUgPSByZV8xYjtcbiAgICByZTIgPSByZTJfMWI7XG4gICAgaWYgKHJlLnRlc3QodykpIHtcbiAgICAgIHZhciBmcCA9IHJlLmV4ZWModyk7XG4gICAgICByZSA9IHJlX21ncjA7XG4gICAgICBpZiAocmUudGVzdChmcFsxXSkpIHtcbiAgICAgICAgcmUgPSByZV8xYl8yO1xuICAgICAgICB3ID0gdy5yZXBsYWNlKHJlLFwiXCIpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocmUyLnRlc3QodykpIHtcbiAgICAgIHZhciBmcCA9IHJlMi5leGVjKHcpO1xuICAgICAgc3RlbSA9IGZwWzFdO1xuICAgICAgcmUyID0gcmVfc192O1xuICAgICAgaWYgKHJlMi50ZXN0KHN0ZW0pKSB7XG4gICAgICAgIHcgPSBzdGVtO1xuICAgICAgICByZTIgPSByZTJfMWJfMjtcbiAgICAgICAgcmUzID0gcmUzXzFiXzI7XG4gICAgICAgIHJlNCA9IHJlNF8xYl8yO1xuICAgICAgICBpZiAocmUyLnRlc3QodykpIHsgdyA9IHcgKyBcImVcIjsgfVxuICAgICAgICBlbHNlIGlmIChyZTMudGVzdCh3KSkgeyByZSA9IHJlXzFiXzI7IHcgPSB3LnJlcGxhY2UocmUsXCJcIik7IH1cbiAgICAgICAgZWxzZSBpZiAocmU0LnRlc3QodykpIHsgdyA9IHcgKyBcImVcIjsgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFN0ZXAgMWMgLSByZXBsYWNlIHN1ZmZpeCB5IG9yIFkgYnkgaSBpZiBwcmVjZWRlZCBieSBhIG5vbi12b3dlbCB3aGljaCBpcyBub3QgdGhlIGZpcnN0IGxldHRlciBvZiB0aGUgd29yZCAoc28gY3J5IC0+IGNyaSwgYnkgLT4gYnksIHNheSAtPiBzYXkpXG4gICAgcmUgPSByZV8xYztcbiAgICBpZiAocmUudGVzdCh3KSkge1xuICAgICAgdmFyIGZwID0gcmUuZXhlYyh3KTtcbiAgICAgIHN0ZW0gPSBmcFsxXTtcbiAgICAgIHcgPSBzdGVtICsgXCJpXCI7XG4gICAgfVxuXG4gICAgLy8gU3RlcCAyXG4gICAgcmUgPSByZV8yO1xuICAgIGlmIChyZS50ZXN0KHcpKSB7XG4gICAgICB2YXIgZnAgPSByZS5leGVjKHcpO1xuICAgICAgc3RlbSA9IGZwWzFdO1xuICAgICAgc3VmZml4ID0gZnBbMl07XG4gICAgICByZSA9IHJlX21ncjA7XG4gICAgICBpZiAocmUudGVzdChzdGVtKSkge1xuICAgICAgICB3ID0gc3RlbSArIHN0ZXAybGlzdFtzdWZmaXhdO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFN0ZXAgM1xuICAgIHJlID0gcmVfMztcbiAgICBpZiAocmUudGVzdCh3KSkge1xuICAgICAgdmFyIGZwID0gcmUuZXhlYyh3KTtcbiAgICAgIHN0ZW0gPSBmcFsxXTtcbiAgICAgIHN1ZmZpeCA9IGZwWzJdO1xuICAgICAgcmUgPSByZV9tZ3IwO1xuICAgICAgaWYgKHJlLnRlc3Qoc3RlbSkpIHtcbiAgICAgICAgdyA9IHN0ZW0gKyBzdGVwM2xpc3Rbc3VmZml4XTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBTdGVwIDRcbiAgICByZSA9IHJlXzQ7XG4gICAgcmUyID0gcmUyXzQ7XG4gICAgaWYgKHJlLnRlc3QodykpIHtcbiAgICAgIHZhciBmcCA9IHJlLmV4ZWModyk7XG4gICAgICBzdGVtID0gZnBbMV07XG4gICAgICByZSA9IHJlX21ncjE7XG4gICAgICBpZiAocmUudGVzdChzdGVtKSkge1xuICAgICAgICB3ID0gc3RlbTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHJlMi50ZXN0KHcpKSB7XG4gICAgICB2YXIgZnAgPSByZTIuZXhlYyh3KTtcbiAgICAgIHN0ZW0gPSBmcFsxXSArIGZwWzJdO1xuICAgICAgcmUyID0gcmVfbWdyMTtcbiAgICAgIGlmIChyZTIudGVzdChzdGVtKSkge1xuICAgICAgICB3ID0gc3RlbTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBTdGVwIDVcbiAgICByZSA9IHJlXzU7XG4gICAgaWYgKHJlLnRlc3QodykpIHtcbiAgICAgIHZhciBmcCA9IHJlLmV4ZWModyk7XG4gICAgICBzdGVtID0gZnBbMV07XG4gICAgICByZSA9IHJlX21ncjE7XG4gICAgICByZTIgPSByZV9tZXExO1xuICAgICAgcmUzID0gcmUzXzU7XG4gICAgICBpZiAocmUudGVzdChzdGVtKSB8fCAocmUyLnRlc3Qoc3RlbSkgJiYgIShyZTMudGVzdChzdGVtKSkpKSB7XG4gICAgICAgIHcgPSBzdGVtO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJlID0gcmVfNV8xO1xuICAgIHJlMiA9IHJlX21ncjE7XG4gICAgaWYgKHJlLnRlc3QodykgJiYgcmUyLnRlc3QodykpIHtcbiAgICAgIHJlID0gcmVfMWJfMjtcbiAgICAgIHcgPSB3LnJlcGxhY2UocmUsXCJcIik7XG4gICAgfVxuXG4gICAgLy8gYW5kIHR1cm4gaW5pdGlhbCBZIGJhY2sgdG8geVxuXG4gICAgaWYgKGZpcnN0Y2ggPT0gXCJ5XCIpIHtcbiAgICAgIHcgPSBmaXJzdGNoLnRvTG93ZXJDYXNlKCkgKyB3LnN1YnN0cigxKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdztcbiAgfTtcblxuICByZXR1cm4gZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgcmV0dXJuIHRva2VuLnVwZGF0ZShwb3J0ZXJTdGVtbWVyKTtcbiAgfVxufSkoKTtcblxubHVuci5QaXBlbGluZS5yZWdpc3RlckZ1bmN0aW9uKGx1bnIuc3RlbW1lciwgJ3N0ZW1tZXInKVxuLyohXG4gKiBsdW5yLnN0b3BXb3JkRmlsdGVyXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTkgT2xpdmVyIE5pZ2h0aW5nYWxlXG4gKi9cblxuLyoqXG4gKiBsdW5yLmdlbmVyYXRlU3RvcFdvcmRGaWx0ZXIgYnVpbGRzIGEgc3RvcFdvcmRGaWx0ZXIgZnVuY3Rpb24gZnJvbSB0aGUgcHJvdmlkZWRcbiAqIGxpc3Qgb2Ygc3RvcCB3b3Jkcy5cbiAqXG4gKiBUaGUgYnVpbHQgaW4gbHVuci5zdG9wV29yZEZpbHRlciBpcyBidWlsdCB1c2luZyB0aGlzIGdlbmVyYXRvciBhbmQgY2FuIGJlIHVzZWRcbiAqIHRvIGdlbmVyYXRlIGN1c3RvbSBzdG9wV29yZEZpbHRlcnMgZm9yIGFwcGxpY2F0aW9ucyBvciBub24gRW5nbGlzaCBsYW5ndWFnZXMuXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0FycmF5fSB0b2tlbiBUaGUgdG9rZW4gdG8gcGFzcyB0aHJvdWdoIHRoZSBmaWx0ZXJcbiAqIEByZXR1cm5zIHtsdW5yLlBpcGVsaW5lRnVuY3Rpb259XG4gKiBAc2VlIGx1bnIuUGlwZWxpbmVcbiAqIEBzZWUgbHVuci5zdG9wV29yZEZpbHRlclxuICovXG5sdW5yLmdlbmVyYXRlU3RvcFdvcmRGaWx0ZXIgPSBmdW5jdGlvbiAoc3RvcFdvcmRzKSB7XG4gIHZhciB3b3JkcyA9IHN0b3BXb3Jkcy5yZWR1Y2UoZnVuY3Rpb24gKG1lbW8sIHN0b3BXb3JkKSB7XG4gICAgbWVtb1tzdG9wV29yZF0gPSBzdG9wV29yZFxuICAgIHJldHVybiBtZW1vXG4gIH0sIHt9KVxuXG4gIHJldHVybiBmdW5jdGlvbiAodG9rZW4pIHtcbiAgICBpZiAodG9rZW4gJiYgd29yZHNbdG9rZW4udG9TdHJpbmcoKV0gIT09IHRva2VuLnRvU3RyaW5nKCkpIHJldHVybiB0b2tlblxuICB9XG59XG5cbi8qKlxuICogbHVuci5zdG9wV29yZEZpbHRlciBpcyBhbiBFbmdsaXNoIGxhbmd1YWdlIHN0b3Agd29yZCBsaXN0IGZpbHRlciwgYW55IHdvcmRzXG4gKiBjb250YWluZWQgaW4gdGhlIGxpc3Qgd2lsbCBub3QgYmUgcGFzc2VkIHRocm91Z2ggdGhlIGZpbHRlci5cbiAqXG4gKiBUaGlzIGlzIGludGVuZGVkIHRvIGJlIHVzZWQgaW4gdGhlIFBpcGVsaW5lLiBJZiB0aGUgdG9rZW4gZG9lcyBub3QgcGFzcyB0aGVcbiAqIGZpbHRlciB0aGVuIHVuZGVmaW5lZCB3aWxsIGJlIHJldHVybmVkLlxuICpcbiAqIEBmdW5jdGlvblxuICogQGltcGxlbWVudHMge2x1bnIuUGlwZWxpbmVGdW5jdGlvbn1cbiAqIEBwYXJhbXMge2x1bnIuVG9rZW59IHRva2VuIC0gQSB0b2tlbiB0byBjaGVjayBmb3IgYmVpbmcgYSBzdG9wIHdvcmQuXG4gKiBAcmV0dXJucyB7bHVuci5Ub2tlbn1cbiAqIEBzZWUge0BsaW5rIGx1bnIuUGlwZWxpbmV9XG4gKi9cbmx1bnIuc3RvcFdvcmRGaWx0ZXIgPSBsdW5yLmdlbmVyYXRlU3RvcFdvcmRGaWx0ZXIoW1xuICAnYScsXG4gICdhYmxlJyxcbiAgJ2Fib3V0JyxcbiAgJ2Fjcm9zcycsXG4gICdhZnRlcicsXG4gICdhbGwnLFxuICAnYWxtb3N0JyxcbiAgJ2Fsc28nLFxuICAnYW0nLFxuICAnYW1vbmcnLFxuICAnYW4nLFxuICAnYW5kJyxcbiAgJ2FueScsXG4gICdhcmUnLFxuICAnYXMnLFxuICAnYXQnLFxuICAnYmUnLFxuICAnYmVjYXVzZScsXG4gICdiZWVuJyxcbiAgJ2J1dCcsXG4gICdieScsXG4gICdjYW4nLFxuICAnY2Fubm90JyxcbiAgJ2NvdWxkJyxcbiAgJ2RlYXInLFxuICAnZGlkJyxcbiAgJ2RvJyxcbiAgJ2RvZXMnLFxuICAnZWl0aGVyJyxcbiAgJ2Vsc2UnLFxuICAnZXZlcicsXG4gICdldmVyeScsXG4gICdmb3InLFxuICAnZnJvbScsXG4gICdnZXQnLFxuICAnZ290JyxcbiAgJ2hhZCcsXG4gICdoYXMnLFxuICAnaGF2ZScsXG4gICdoZScsXG4gICdoZXInLFxuICAnaGVycycsXG4gICdoaW0nLFxuICAnaGlzJyxcbiAgJ2hvdycsXG4gICdob3dldmVyJyxcbiAgJ2knLFxuICAnaWYnLFxuICAnaW4nLFxuICAnaW50bycsXG4gICdpcycsXG4gICdpdCcsXG4gICdpdHMnLFxuICAnanVzdCcsXG4gICdsZWFzdCcsXG4gICdsZXQnLFxuICAnbGlrZScsXG4gICdsaWtlbHknLFxuICAnbWF5JyxcbiAgJ21lJyxcbiAgJ21pZ2h0JyxcbiAgJ21vc3QnLFxuICAnbXVzdCcsXG4gICdteScsXG4gICduZWl0aGVyJyxcbiAgJ25vJyxcbiAgJ25vcicsXG4gICdub3QnLFxuICAnb2YnLFxuICAnb2ZmJyxcbiAgJ29mdGVuJyxcbiAgJ29uJyxcbiAgJ29ubHknLFxuICAnb3InLFxuICAnb3RoZXInLFxuICAnb3VyJyxcbiAgJ293bicsXG4gICdyYXRoZXInLFxuICAnc2FpZCcsXG4gICdzYXknLFxuICAnc2F5cycsXG4gICdzaGUnLFxuICAnc2hvdWxkJyxcbiAgJ3NpbmNlJyxcbiAgJ3NvJyxcbiAgJ3NvbWUnLFxuICAndGhhbicsXG4gICd0aGF0JyxcbiAgJ3RoZScsXG4gICd0aGVpcicsXG4gICd0aGVtJyxcbiAgJ3RoZW4nLFxuICAndGhlcmUnLFxuICAndGhlc2UnLFxuICAndGhleScsXG4gICd0aGlzJyxcbiAgJ3RpcycsXG4gICd0bycsXG4gICd0b28nLFxuICAndHdhcycsXG4gICd1cycsXG4gICd3YW50cycsXG4gICd3YXMnLFxuICAnd2UnLFxuICAnd2VyZScsXG4gICd3aGF0JyxcbiAgJ3doZW4nLFxuICAnd2hlcmUnLFxuICAnd2hpY2gnLFxuICAnd2hpbGUnLFxuICAnd2hvJyxcbiAgJ3dob20nLFxuICAnd2h5JyxcbiAgJ3dpbGwnLFxuICAnd2l0aCcsXG4gICd3b3VsZCcsXG4gICd5ZXQnLFxuICAneW91JyxcbiAgJ3lvdXInXG5dKVxuXG5sdW5yLlBpcGVsaW5lLnJlZ2lzdGVyRnVuY3Rpb24obHVuci5zdG9wV29yZEZpbHRlciwgJ3N0b3BXb3JkRmlsdGVyJylcbi8qIVxuICogbHVuci50cmltbWVyXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTkgT2xpdmVyIE5pZ2h0aW5nYWxlXG4gKi9cblxuLyoqXG4gKiBsdW5yLnRyaW1tZXIgaXMgYSBwaXBlbGluZSBmdW5jdGlvbiBmb3IgdHJpbW1pbmcgbm9uIHdvcmRcbiAqIGNoYXJhY3RlcnMgZnJvbSB0aGUgYmVnaW5uaW5nIGFuZCBlbmQgb2YgdG9rZW5zIGJlZm9yZSB0aGV5XG4gKiBlbnRlciB0aGUgaW5kZXguXG4gKlxuICogVGhpcyBpbXBsZW1lbnRhdGlvbiBtYXkgbm90IHdvcmsgY29ycmVjdGx5IGZvciBub24gbGF0aW5cbiAqIGNoYXJhY3RlcnMgYW5kIHNob3VsZCBlaXRoZXIgYmUgcmVtb3ZlZCBvciBhZGFwdGVkIGZvciB1c2VcbiAqIHdpdGggbGFuZ3VhZ2VzIHdpdGggbm9uLWxhdGluIGNoYXJhY3RlcnMuXG4gKlxuICogQHN0YXRpY1xuICogQGltcGxlbWVudHMge2x1bnIuUGlwZWxpbmVGdW5jdGlvbn1cbiAqIEBwYXJhbSB7bHVuci5Ub2tlbn0gdG9rZW4gVGhlIHRva2VuIHRvIHBhc3MgdGhyb3VnaCB0aGUgZmlsdGVyXG4gKiBAcmV0dXJucyB7bHVuci5Ub2tlbn1cbiAqIEBzZWUgbHVuci5QaXBlbGluZVxuICovXG5sdW5yLnRyaW1tZXIgPSBmdW5jdGlvbiAodG9rZW4pIHtcbiAgcmV0dXJuIHRva2VuLnVwZGF0ZShmdW5jdGlvbiAocykge1xuICAgIHJldHVybiBzLnJlcGxhY2UoL15cXFcrLywgJycpLnJlcGxhY2UoL1xcVyskLywgJycpXG4gIH0pXG59XG5cbmx1bnIuUGlwZWxpbmUucmVnaXN0ZXJGdW5jdGlvbihsdW5yLnRyaW1tZXIsICd0cmltbWVyJylcbi8qIVxuICogbHVuci5Ub2tlblNldFxuICogQ29weXJpZ2h0IChDKSAyMDE5IE9saXZlciBOaWdodGluZ2FsZVxuICovXG5cbi8qKlxuICogQSB0b2tlbiBzZXQgaXMgdXNlZCB0byBzdG9yZSB0aGUgdW5pcXVlIGxpc3Qgb2YgYWxsIHRva2Vuc1xuICogd2l0aGluIGFuIGluZGV4LiBUb2tlbiBzZXRzIGFyZSBhbHNvIHVzZWQgdG8gcmVwcmVzZW50IGFuXG4gKiBpbmNvbWluZyBxdWVyeSB0byB0aGUgaW5kZXgsIHRoaXMgcXVlcnkgdG9rZW4gc2V0IGFuZCBpbmRleFxuICogdG9rZW4gc2V0IGFyZSB0aGVuIGludGVyc2VjdGVkIHRvIGZpbmQgd2hpY2ggdG9rZW5zIHRvIGxvb2tcbiAqIHVwIGluIHRoZSBpbnZlcnRlZCBpbmRleC5cbiAqXG4gKiBBIHRva2VuIHNldCBjYW4gaG9sZCBtdWx0aXBsZSB0b2tlbnMsIGFzIGluIHRoZSBjYXNlIG9mIHRoZVxuICogaW5kZXggdG9rZW4gc2V0LCBvciBpdCBjYW4gaG9sZCBhIHNpbmdsZSB0b2tlbiBhcyBpbiB0aGVcbiAqIGNhc2Ugb2YgYSBzaW1wbGUgcXVlcnkgdG9rZW4gc2V0LlxuICpcbiAqIEFkZGl0aW9uYWxseSB0b2tlbiBzZXRzIGFyZSB1c2VkIHRvIHBlcmZvcm0gd2lsZGNhcmQgbWF0Y2hpbmcuXG4gKiBMZWFkaW5nLCBjb250YWluZWQgYW5kIHRyYWlsaW5nIHdpbGRjYXJkcyBhcmUgc3VwcG9ydGVkLCBhbmRcbiAqIGZyb20gdGhpcyBlZGl0IGRpc3RhbmNlIG1hdGNoaW5nIGNhbiBhbHNvIGJlIHByb3ZpZGVkLlxuICpcbiAqIFRva2VuIHNldHMgYXJlIGltcGxlbWVudGVkIGFzIGEgbWluaW1hbCBmaW5pdGUgc3RhdGUgYXV0b21hdGEsXG4gKiB3aGVyZSBib3RoIGNvbW1vbiBwcmVmaXhlcyBhbmQgc3VmZml4ZXMgYXJlIHNoYXJlZCBiZXR3ZWVuIHRva2Vucy5cbiAqIFRoaXMgaGVscHMgdG8gcmVkdWNlIHRoZSBzcGFjZSB1c2VkIGZvciBzdG9yaW5nIHRoZSB0b2tlbiBzZXQuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmx1bnIuVG9rZW5TZXQgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuZmluYWwgPSBmYWxzZVxuICB0aGlzLmVkZ2VzID0ge31cbiAgdGhpcy5pZCA9IGx1bnIuVG9rZW5TZXQuX25leHRJZFxuICBsdW5yLlRva2VuU2V0Ll9uZXh0SWQgKz0gMVxufVxuXG4vKipcbiAqIEtlZXBzIHRyYWNrIG9mIHRoZSBuZXh0LCBhdXRvIGluY3JlbWVudCwgaWRlbnRpZmllciB0byBhc3NpZ25cbiAqIHRvIGEgbmV3IHRva2VuU2V0LlxuICpcbiAqIFRva2VuU2V0cyByZXF1aXJlIGEgdW5pcXVlIGlkZW50aWZpZXIgdG8gYmUgY29ycmVjdGx5IG1pbmltaXNlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5sdW5yLlRva2VuU2V0Ll9uZXh0SWQgPSAxXG5cbi8qKlxuICogQ3JlYXRlcyBhIFRva2VuU2V0IGluc3RhbmNlIGZyb20gdGhlIGdpdmVuIHNvcnRlZCBhcnJheSBvZiB3b3Jkcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ1tdfSBhcnIgLSBBIHNvcnRlZCBhcnJheSBvZiBzdHJpbmdzIHRvIGNyZWF0ZSB0aGUgc2V0IGZyb20uXG4gKiBAcmV0dXJucyB7bHVuci5Ub2tlblNldH1cbiAqIEB0aHJvd3MgV2lsbCB0aHJvdyBhbiBlcnJvciBpZiB0aGUgaW5wdXQgYXJyYXkgaXMgbm90IHNvcnRlZC5cbiAqL1xubHVuci5Ub2tlblNldC5mcm9tQXJyYXkgPSBmdW5jdGlvbiAoYXJyKSB7XG4gIHZhciBidWlsZGVyID0gbmV3IGx1bnIuVG9rZW5TZXQuQnVpbGRlclxuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBhcnIubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBidWlsZGVyLmluc2VydChhcnJbaV0pXG4gIH1cblxuICBidWlsZGVyLmZpbmlzaCgpXG4gIHJldHVybiBidWlsZGVyLnJvb3Rcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgdG9rZW4gc2V0IGZyb20gYSBxdWVyeSBjbGF1c2UuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBjbGF1c2UgLSBBIHNpbmdsZSBjbGF1c2UgZnJvbSBsdW5yLlF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGNsYXVzZS50ZXJtIC0gVGhlIHF1ZXJ5IGNsYXVzZSB0ZXJtLlxuICogQHBhcmFtIHtudW1iZXJ9IFtjbGF1c2UuZWRpdERpc3RhbmNlXSAtIFRoZSBvcHRpb25hbCBlZGl0IGRpc3RhbmNlIGZvciB0aGUgdGVybS5cbiAqIEByZXR1cm5zIHtsdW5yLlRva2VuU2V0fVxuICovXG5sdW5yLlRva2VuU2V0LmZyb21DbGF1c2UgPSBmdW5jdGlvbiAoY2xhdXNlKSB7XG4gIGlmICgnZWRpdERpc3RhbmNlJyBpbiBjbGF1c2UpIHtcbiAgICByZXR1cm4gbHVuci5Ub2tlblNldC5mcm9tRnV6enlTdHJpbmcoY2xhdXNlLnRlcm0sIGNsYXVzZS5lZGl0RGlzdGFuY2UpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGx1bnIuVG9rZW5TZXQuZnJvbVN0cmluZyhjbGF1c2UudGVybSlcbiAgfVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSB0b2tlbiBzZXQgcmVwcmVzZW50aW5nIGEgc2luZ2xlIHN0cmluZyB3aXRoIGEgc3BlY2lmaWVkXG4gKiBlZGl0IGRpc3RhbmNlLlxuICpcbiAqIEluc2VydGlvbnMsIGRlbGV0aW9ucywgc3Vic3RpdHV0aW9ucyBhbmQgdHJhbnNwb3NpdGlvbnMgYXJlIGVhY2hcbiAqIHRyZWF0ZWQgYXMgYW4gZWRpdCBkaXN0YW5jZSBvZiAxLlxuICpcbiAqIEluY3JlYXNpbmcgdGhlIGFsbG93ZWQgZWRpdCBkaXN0YW5jZSB3aWxsIGhhdmUgYSBkcmFtYXRpYyBpbXBhY3RcbiAqIG9uIHRoZSBwZXJmb3JtYW5jZSBvZiBib3RoIGNyZWF0aW5nIGFuZCBpbnRlcnNlY3RpbmcgdGhlc2UgVG9rZW5TZXRzLlxuICogSXQgaXMgYWR2aXNlZCB0byBrZWVwIHRoZSBlZGl0IGRpc3RhbmNlIGxlc3MgdGhhbiAzLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgLSBUaGUgc3RyaW5nIHRvIGNyZWF0ZSB0aGUgdG9rZW4gc2V0IGZyb20uXG4gKiBAcGFyYW0ge251bWJlcn0gZWRpdERpc3RhbmNlIC0gVGhlIGFsbG93ZWQgZWRpdCBkaXN0YW5jZSB0byBtYXRjaC5cbiAqIEByZXR1cm5zIHtsdW5yLlZlY3Rvcn1cbiAqL1xubHVuci5Ub2tlblNldC5mcm9tRnV6enlTdHJpbmcgPSBmdW5jdGlvbiAoc3RyLCBlZGl0RGlzdGFuY2UpIHtcbiAgdmFyIHJvb3QgPSBuZXcgbHVuci5Ub2tlblNldFxuXG4gIHZhciBzdGFjayA9IFt7XG4gICAgbm9kZTogcm9vdCxcbiAgICBlZGl0c1JlbWFpbmluZzogZWRpdERpc3RhbmNlLFxuICAgIHN0cjogc3RyXG4gIH1dXG5cbiAgd2hpbGUgKHN0YWNrLmxlbmd0aCkge1xuICAgIHZhciBmcmFtZSA9IHN0YWNrLnBvcCgpXG5cbiAgICAvLyBubyBlZGl0XG4gICAgaWYgKGZyYW1lLnN0ci5sZW5ndGggPiAwKSB7XG4gICAgICB2YXIgY2hhciA9IGZyYW1lLnN0ci5jaGFyQXQoMCksXG4gICAgICAgICAgbm9FZGl0Tm9kZVxuXG4gICAgICBpZiAoY2hhciBpbiBmcmFtZS5ub2RlLmVkZ2VzKSB7XG4gICAgICAgIG5vRWRpdE5vZGUgPSBmcmFtZS5ub2RlLmVkZ2VzW2NoYXJdXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub0VkaXROb2RlID0gbmV3IGx1bnIuVG9rZW5TZXRcbiAgICAgICAgZnJhbWUubm9kZS5lZGdlc1tjaGFyXSA9IG5vRWRpdE5vZGVcbiAgICAgIH1cblxuICAgICAgaWYgKGZyYW1lLnN0ci5sZW5ndGggPT0gMSkge1xuICAgICAgICBub0VkaXROb2RlLmZpbmFsID0gdHJ1ZVxuICAgICAgfVxuXG4gICAgICBzdGFjay5wdXNoKHtcbiAgICAgICAgbm9kZTogbm9FZGl0Tm9kZSxcbiAgICAgICAgZWRpdHNSZW1haW5pbmc6IGZyYW1lLmVkaXRzUmVtYWluaW5nLFxuICAgICAgICBzdHI6IGZyYW1lLnN0ci5zbGljZSgxKVxuICAgICAgfSlcbiAgICB9XG5cbiAgICBpZiAoZnJhbWUuZWRpdHNSZW1haW5pbmcgPT0gMCkge1xuICAgICAgY29udGludWVcbiAgICB9XG5cbiAgICAvLyBpbnNlcnRpb25cbiAgICBpZiAoXCIqXCIgaW4gZnJhbWUubm9kZS5lZGdlcykge1xuICAgICAgdmFyIGluc2VydGlvbk5vZGUgPSBmcmFtZS5ub2RlLmVkZ2VzW1wiKlwiXVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgaW5zZXJ0aW9uTm9kZSA9IG5ldyBsdW5yLlRva2VuU2V0XG4gICAgICBmcmFtZS5ub2RlLmVkZ2VzW1wiKlwiXSA9IGluc2VydGlvbk5vZGVcbiAgICB9XG5cbiAgICBpZiAoZnJhbWUuc3RyLmxlbmd0aCA9PSAwKSB7XG4gICAgICBpbnNlcnRpb25Ob2RlLmZpbmFsID0gdHJ1ZVxuICAgIH1cblxuICAgIHN0YWNrLnB1c2goe1xuICAgICAgbm9kZTogaW5zZXJ0aW9uTm9kZSxcbiAgICAgIGVkaXRzUmVtYWluaW5nOiBmcmFtZS5lZGl0c1JlbWFpbmluZyAtIDEsXG4gICAgICBzdHI6IGZyYW1lLnN0clxuICAgIH0pXG5cbiAgICAvLyBkZWxldGlvblxuICAgIC8vIGNhbiBvbmx5IGRvIGEgZGVsZXRpb24gaWYgd2UgaGF2ZSBlbm91Z2ggZWRpdHMgcmVtYWluaW5nXG4gICAgLy8gYW5kIGlmIHRoZXJlIGFyZSBjaGFyYWN0ZXJzIGxlZnQgdG8gZGVsZXRlIGluIHRoZSBzdHJpbmdcbiAgICBpZiAoZnJhbWUuc3RyLmxlbmd0aCA+IDEpIHtcbiAgICAgIHN0YWNrLnB1c2goe1xuICAgICAgICBub2RlOiBmcmFtZS5ub2RlLFxuICAgICAgICBlZGl0c1JlbWFpbmluZzogZnJhbWUuZWRpdHNSZW1haW5pbmcgLSAxLFxuICAgICAgICBzdHI6IGZyYW1lLnN0ci5zbGljZSgxKVxuICAgICAgfSlcbiAgICB9XG5cbiAgICAvLyBkZWxldGlvblxuICAgIC8vIGp1c3QgcmVtb3ZpbmcgdGhlIGxhc3QgY2hhcmFjdGVyIGZyb20gdGhlIHN0clxuICAgIGlmIChmcmFtZS5zdHIubGVuZ3RoID09IDEpIHtcbiAgICAgIGZyYW1lLm5vZGUuZmluYWwgPSB0cnVlXG4gICAgfVxuXG4gICAgLy8gc3Vic3RpdHV0aW9uXG4gICAgLy8gY2FuIG9ubHkgZG8gYSBzdWJzdGl0dXRpb24gaWYgd2UgaGF2ZSBlbm91Z2ggZWRpdHMgcmVtYWluaW5nXG4gICAgLy8gYW5kIGlmIHRoZXJlIGFyZSBjaGFyYWN0ZXJzIGxlZnQgdG8gc3Vic3RpdHV0ZVxuICAgIGlmIChmcmFtZS5zdHIubGVuZ3RoID49IDEpIHtcbiAgICAgIGlmIChcIipcIiBpbiBmcmFtZS5ub2RlLmVkZ2VzKSB7XG4gICAgICAgIHZhciBzdWJzdGl0dXRpb25Ob2RlID0gZnJhbWUubm9kZS5lZGdlc1tcIipcIl1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBzdWJzdGl0dXRpb25Ob2RlID0gbmV3IGx1bnIuVG9rZW5TZXRcbiAgICAgICAgZnJhbWUubm9kZS5lZGdlc1tcIipcIl0gPSBzdWJzdGl0dXRpb25Ob2RlXG4gICAgICB9XG5cbiAgICAgIGlmIChmcmFtZS5zdHIubGVuZ3RoID09IDEpIHtcbiAgICAgICAgc3Vic3RpdHV0aW9uTm9kZS5maW5hbCA9IHRydWVcbiAgICAgIH1cblxuICAgICAgc3RhY2sucHVzaCh7XG4gICAgICAgIG5vZGU6IHN1YnN0aXR1dGlvbk5vZGUsXG4gICAgICAgIGVkaXRzUmVtYWluaW5nOiBmcmFtZS5lZGl0c1JlbWFpbmluZyAtIDEsXG4gICAgICAgIHN0cjogZnJhbWUuc3RyLnNsaWNlKDEpXG4gICAgICB9KVxuICAgIH1cblxuICAgIC8vIHRyYW5zcG9zaXRpb25cbiAgICAvLyBjYW4gb25seSBkbyBhIHRyYW5zcG9zaXRpb24gaWYgdGhlcmUgYXJlIGVkaXRzIHJlbWFpbmluZ1xuICAgIC8vIGFuZCB0aGVyZSBhcmUgZW5vdWdoIGNoYXJhY3RlcnMgdG8gdHJhbnNwb3NlXG4gICAgaWYgKGZyYW1lLnN0ci5sZW5ndGggPiAxKSB7XG4gICAgICB2YXIgY2hhckEgPSBmcmFtZS5zdHIuY2hhckF0KDApLFxuICAgICAgICAgIGNoYXJCID0gZnJhbWUuc3RyLmNoYXJBdCgxKSxcbiAgICAgICAgICB0cmFuc3Bvc2VOb2RlXG5cbiAgICAgIGlmIChjaGFyQiBpbiBmcmFtZS5ub2RlLmVkZ2VzKSB7XG4gICAgICAgIHRyYW5zcG9zZU5vZGUgPSBmcmFtZS5ub2RlLmVkZ2VzW2NoYXJCXVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJhbnNwb3NlTm9kZSA9IG5ldyBsdW5yLlRva2VuU2V0XG4gICAgICAgIGZyYW1lLm5vZGUuZWRnZXNbY2hhckJdID0gdHJhbnNwb3NlTm9kZVxuICAgICAgfVxuXG4gICAgICBpZiAoZnJhbWUuc3RyLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgIHRyYW5zcG9zZU5vZGUuZmluYWwgPSB0cnVlXG4gICAgICB9XG5cbiAgICAgIHN0YWNrLnB1c2goe1xuICAgICAgICBub2RlOiB0cmFuc3Bvc2VOb2RlLFxuICAgICAgICBlZGl0c1JlbWFpbmluZzogZnJhbWUuZWRpdHNSZW1haW5pbmcgLSAxLFxuICAgICAgICBzdHI6IGNoYXJBICsgZnJhbWUuc3RyLnNsaWNlKDIpXG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByb290XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIFRva2VuU2V0IGZyb20gYSBzdHJpbmcuXG4gKlxuICogVGhlIHN0cmluZyBtYXkgY29udGFpbiBvbmUgb3IgbW9yZSB3aWxkY2FyZCBjaGFyYWN0ZXJzICgqKVxuICogdGhhdCB3aWxsIGFsbG93IHdpbGRjYXJkIG1hdGNoaW5nIHdoZW4gaW50ZXJzZWN0aW5nIHdpdGhcbiAqIGFub3RoZXIgVG9rZW5TZXQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0ciAtIFRoZSBzdHJpbmcgdG8gY3JlYXRlIGEgVG9rZW5TZXQgZnJvbS5cbiAqIEByZXR1cm5zIHtsdW5yLlRva2VuU2V0fVxuICovXG5sdW5yLlRva2VuU2V0LmZyb21TdHJpbmcgPSBmdW5jdGlvbiAoc3RyKSB7XG4gIHZhciBub2RlID0gbmV3IGx1bnIuVG9rZW5TZXQsXG4gICAgICByb290ID0gbm9kZVxuXG4gIC8qXG4gICAqIEl0ZXJhdGVzIHRocm91Z2ggYWxsIGNoYXJhY3RlcnMgd2l0aGluIHRoZSBwYXNzZWQgc3RyaW5nXG4gICAqIGFwcGVuZGluZyBhIG5vZGUgZm9yIGVhY2ggY2hhcmFjdGVyLlxuICAgKlxuICAgKiBXaGVuIGEgd2lsZGNhcmQgY2hhcmFjdGVyIGlzIGZvdW5kIHRoZW4gYSBzZWxmXG4gICAqIHJlZmVyZW5jaW5nIGVkZ2UgaXMgaW50cm9kdWNlZCB0byBjb250aW51YWxseSBtYXRjaFxuICAgKiBhbnkgbnVtYmVyIG9mIGFueSBjaGFyYWN0ZXJzLlxuICAgKi9cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHN0ci5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIHZhciBjaGFyID0gc3RyW2ldLFxuICAgICAgICBmaW5hbCA9IChpID09IGxlbiAtIDEpXG5cbiAgICBpZiAoY2hhciA9PSBcIipcIikge1xuICAgICAgbm9kZS5lZGdlc1tjaGFyXSA9IG5vZGVcbiAgICAgIG5vZGUuZmluYWwgPSBmaW5hbFxuXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBuZXh0ID0gbmV3IGx1bnIuVG9rZW5TZXRcbiAgICAgIG5leHQuZmluYWwgPSBmaW5hbFxuXG4gICAgICBub2RlLmVkZ2VzW2NoYXJdID0gbmV4dFxuICAgICAgbm9kZSA9IG5leHRcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcm9vdFxufVxuXG4vKipcbiAqIENvbnZlcnRzIHRoaXMgVG9rZW5TZXQgaW50byBhbiBhcnJheSBvZiBzdHJpbmdzXG4gKiBjb250YWluZWQgd2l0aGluIHRoZSBUb2tlblNldC5cbiAqXG4gKiBUaGlzIGlzIG5vdCBpbnRlbmRlZCB0byBiZSB1c2VkIG9uIGEgVG9rZW5TZXQgdGhhdFxuICogY29udGFpbnMgd2lsZGNhcmRzLCBpbiB0aGVzZSBjYXNlcyB0aGUgcmVzdWx0cyBhcmVcbiAqIHVuZGVmaW5lZCBhbmQgYXJlIGxpa2VseSB0byBjYXVzZSBhbiBpbmZpbml0ZSBsb29wLlxuICpcbiAqIEByZXR1cm5zIHtzdHJpbmdbXX1cbiAqL1xubHVuci5Ub2tlblNldC5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHdvcmRzID0gW11cblxuICB2YXIgc3RhY2sgPSBbe1xuICAgIHByZWZpeDogXCJcIixcbiAgICBub2RlOiB0aGlzXG4gIH1dXG5cbiAgd2hpbGUgKHN0YWNrLmxlbmd0aCkge1xuICAgIHZhciBmcmFtZSA9IHN0YWNrLnBvcCgpLFxuICAgICAgICBlZGdlcyA9IE9iamVjdC5rZXlzKGZyYW1lLm5vZGUuZWRnZXMpLFxuICAgICAgICBsZW4gPSBlZGdlcy5sZW5ndGhcblxuICAgIGlmIChmcmFtZS5ub2RlLmZpbmFsKSB7XG4gICAgICAvKiBJbiBTYWZhcmksIGF0IHRoaXMgcG9pbnQgdGhlIHByZWZpeCBpcyBzb21ldGltZXMgY29ycnVwdGVkLCBzZWU6XG4gICAgICAgKiBodHRwczovL2dpdGh1Yi5jb20vb2xpdmVybm4vbHVuci5qcy9pc3N1ZXMvMjc5IENhbGxpbmcgYW55XG4gICAgICAgKiBTdHJpbmcucHJvdG90eXBlIG1ldGhvZCBmb3JjZXMgU2FmYXJpIHRvIFwiY2FzdFwiIHRoaXMgc3RyaW5nIHRvIHdoYXRcbiAgICAgICAqIGl0J3Mgc3VwcG9zZWQgdG8gYmUsIGZpeGluZyB0aGUgYnVnLiAqL1xuICAgICAgZnJhbWUucHJlZml4LmNoYXJBdCgwKVxuICAgICAgd29yZHMucHVzaChmcmFtZS5wcmVmaXgpXG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgdmFyIGVkZ2UgPSBlZGdlc1tpXVxuXG4gICAgICBzdGFjay5wdXNoKHtcbiAgICAgICAgcHJlZml4OiBmcmFtZS5wcmVmaXguY29uY2F0KGVkZ2UpLFxuICAgICAgICBub2RlOiBmcmFtZS5ub2RlLmVkZ2VzW2VkZ2VdXG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB3b3Jkc1xufVxuXG4vKipcbiAqIEdlbmVyYXRlcyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIFRva2VuU2V0LlxuICpcbiAqIFRoaXMgaXMgaW50ZW5kZWQgdG8gYWxsb3cgVG9rZW5TZXRzIHRvIGJlIHVzZWQgYXMga2V5c1xuICogaW4gb2JqZWN0cywgbGFyZ2VseSB0byBhaWQgdGhlIGNvbnN0cnVjdGlvbiBhbmQgbWluaW1pc2F0aW9uXG4gKiBvZiBhIFRva2VuU2V0LiBBcyBzdWNoIGl0IGlzIG5vdCBkZXNpZ25lZCB0byBiZSBhIGh1bWFuXG4gKiBmcmllbmRseSByZXByZXNlbnRhdGlvbiBvZiB0aGUgVG9rZW5TZXQuXG4gKlxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xubHVuci5Ub2tlblNldC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIE5PVEU6IFVzaW5nIE9iamVjdC5rZXlzIGhlcmUgYXMgdGhpcy5lZGdlcyBpcyB2ZXJ5IGxpa2VseVxuICAvLyB0byBlbnRlciAnaGFzaC1tb2RlJyB3aXRoIG1hbnkga2V5cyBiZWluZyBhZGRlZFxuICAvL1xuICAvLyBhdm9pZGluZyBhIGZvci1pbiBsb29wIGhlcmUgYXMgaXQgbGVhZHMgdG8gdGhlIGZ1bmN0aW9uXG4gIC8vIGJlaW5nIGRlLW9wdGltaXNlZCAoYXQgbGVhc3QgaW4gVjgpLiBGcm9tIHNvbWUgc2ltcGxlXG4gIC8vIGJlbmNobWFya3MgdGhlIHBlcmZvcm1hbmNlIGlzIGNvbXBhcmFibGUsIGJ1dCBhbGxvd2luZ1xuICAvLyBWOCB0byBvcHRpbWl6ZSBtYXkgbWVhbiBlYXN5IHBlcmZvcm1hbmNlIHdpbnMgaW4gdGhlIGZ1dHVyZS5cblxuICBpZiAodGhpcy5fc3RyKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0clxuICB9XG5cbiAgdmFyIHN0ciA9IHRoaXMuZmluYWwgPyAnMScgOiAnMCcsXG4gICAgICBsYWJlbHMgPSBPYmplY3Qua2V5cyh0aGlzLmVkZ2VzKS5zb3J0KCksXG4gICAgICBsZW4gPSBsYWJlbHMubGVuZ3RoXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIHZhciBsYWJlbCA9IGxhYmVsc1tpXSxcbiAgICAgICAgbm9kZSA9IHRoaXMuZWRnZXNbbGFiZWxdXG5cbiAgICBzdHIgPSBzdHIgKyBsYWJlbCArIG5vZGUuaWRcbiAgfVxuXG4gIHJldHVybiBzdHJcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgbmV3IFRva2VuU2V0IHRoYXQgaXMgdGhlIGludGVyc2VjdGlvbiBvZlxuICogdGhpcyBUb2tlblNldCBhbmQgdGhlIHBhc3NlZCBUb2tlblNldC5cbiAqXG4gKiBUaGlzIGludGVyc2VjdGlvbiB3aWxsIHRha2UgaW50byBhY2NvdW50IGFueSB3aWxkY2FyZHNcbiAqIGNvbnRhaW5lZCB3aXRoaW4gdGhlIFRva2VuU2V0LlxuICpcbiAqIEBwYXJhbSB7bHVuci5Ub2tlblNldH0gYiAtIEFuIG90aGVyIFRva2VuU2V0IHRvIGludGVyc2VjdCB3aXRoLlxuICogQHJldHVybnMge2x1bnIuVG9rZW5TZXR9XG4gKi9cbmx1bnIuVG9rZW5TZXQucHJvdG90eXBlLmludGVyc2VjdCA9IGZ1bmN0aW9uIChiKSB7XG4gIHZhciBvdXRwdXQgPSBuZXcgbHVuci5Ub2tlblNldCxcbiAgICAgIGZyYW1lID0gdW5kZWZpbmVkXG5cbiAgdmFyIHN0YWNrID0gW3tcbiAgICBxTm9kZTogYixcbiAgICBvdXRwdXQ6IG91dHB1dCxcbiAgICBub2RlOiB0aGlzXG4gIH1dXG5cbiAgd2hpbGUgKHN0YWNrLmxlbmd0aCkge1xuICAgIGZyYW1lID0gc3RhY2sucG9wKClcblxuICAgIC8vIE5PVEU6IEFzIHdpdGggdGhlICN0b1N0cmluZyBtZXRob2QsIHdlIGFyZSB1c2luZ1xuICAgIC8vIE9iamVjdC5rZXlzIGFuZCBhIGZvciBsb29wIGluc3RlYWQgb2YgYSBmb3ItaW4gbG9vcFxuICAgIC8vIGFzIGJvdGggb2YgdGhlc2Ugb2JqZWN0cyBlbnRlciAnaGFzaCcgbW9kZSwgY2F1c2luZ1xuICAgIC8vIHRoZSBmdW5jdGlvbiB0byBiZSBkZS1vcHRpbWlzZWQgaW4gVjhcbiAgICB2YXIgcUVkZ2VzID0gT2JqZWN0LmtleXMoZnJhbWUucU5vZGUuZWRnZXMpLFxuICAgICAgICBxTGVuID0gcUVkZ2VzLmxlbmd0aCxcbiAgICAgICAgbkVkZ2VzID0gT2JqZWN0LmtleXMoZnJhbWUubm9kZS5lZGdlcyksXG4gICAgICAgIG5MZW4gPSBuRWRnZXMubGVuZ3RoXG5cbiAgICBmb3IgKHZhciBxID0gMDsgcSA8IHFMZW47IHErKykge1xuICAgICAgdmFyIHFFZGdlID0gcUVkZ2VzW3FdXG5cbiAgICAgIGZvciAodmFyIG4gPSAwOyBuIDwgbkxlbjsgbisrKSB7XG4gICAgICAgIHZhciBuRWRnZSA9IG5FZGdlc1tuXVxuXG4gICAgICAgIGlmIChuRWRnZSA9PSBxRWRnZSB8fCBxRWRnZSA9PSAnKicpIHtcbiAgICAgICAgICB2YXIgbm9kZSA9IGZyYW1lLm5vZGUuZWRnZXNbbkVkZ2VdLFxuICAgICAgICAgICAgICBxTm9kZSA9IGZyYW1lLnFOb2RlLmVkZ2VzW3FFZGdlXSxcbiAgICAgICAgICAgICAgZmluYWwgPSBub2RlLmZpbmFsICYmIHFOb2RlLmZpbmFsLFxuICAgICAgICAgICAgICBuZXh0ID0gdW5kZWZpbmVkXG5cbiAgICAgICAgICBpZiAobkVkZ2UgaW4gZnJhbWUub3V0cHV0LmVkZ2VzKSB7XG4gICAgICAgICAgICAvLyBhbiBlZGdlIGFscmVhZHkgZXhpc3RzIGZvciB0aGlzIGNoYXJhY3RlclxuICAgICAgICAgICAgLy8gbm8gbmVlZCB0byBjcmVhdGUgYSBuZXcgbm9kZSwganVzdCBzZXQgdGhlIGZpbmFsaXR5XG4gICAgICAgICAgICAvLyBiaXQgdW5sZXNzIHRoaXMgbm9kZSBpcyBhbHJlYWR5IGZpbmFsXG4gICAgICAgICAgICBuZXh0ID0gZnJhbWUub3V0cHV0LmVkZ2VzW25FZGdlXVxuICAgICAgICAgICAgbmV4dC5maW5hbCA9IG5leHQuZmluYWwgfHwgZmluYWxcblxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBubyBlZGdlIGV4aXN0cyB5ZXQsIG11c3QgY3JlYXRlIG9uZVxuICAgICAgICAgICAgLy8gc2V0IHRoZSBmaW5hbGl0eSBiaXQgYW5kIGluc2VydCBpdFxuICAgICAgICAgICAgLy8gaW50byB0aGUgb3V0cHV0XG4gICAgICAgICAgICBuZXh0ID0gbmV3IGx1bnIuVG9rZW5TZXRcbiAgICAgICAgICAgIG5leHQuZmluYWwgPSBmaW5hbFxuICAgICAgICAgICAgZnJhbWUub3V0cHV0LmVkZ2VzW25FZGdlXSA9IG5leHRcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzdGFjay5wdXNoKHtcbiAgICAgICAgICAgIHFOb2RlOiBxTm9kZSxcbiAgICAgICAgICAgIG91dHB1dDogbmV4dCxcbiAgICAgICAgICAgIG5vZGU6IG5vZGVcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG91dHB1dFxufVxubHVuci5Ub2tlblNldC5CdWlsZGVyID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLnByZXZpb3VzV29yZCA9IFwiXCJcbiAgdGhpcy5yb290ID0gbmV3IGx1bnIuVG9rZW5TZXRcbiAgdGhpcy51bmNoZWNrZWROb2RlcyA9IFtdXG4gIHRoaXMubWluaW1pemVkTm9kZXMgPSB7fVxufVxuXG5sdW5yLlRva2VuU2V0LkJ1aWxkZXIucHJvdG90eXBlLmluc2VydCA9IGZ1bmN0aW9uICh3b3JkKSB7XG4gIHZhciBub2RlLFxuICAgICAgY29tbW9uUHJlZml4ID0gMFxuXG4gIGlmICh3b3JkIDwgdGhpcy5wcmV2aW91c1dvcmQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IgKFwiT3V0IG9mIG9yZGVyIHdvcmQgaW5zZXJ0aW9uXCIpXG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHdvcmQubGVuZ3RoICYmIGkgPCB0aGlzLnByZXZpb3VzV29yZC5sZW5ndGg7IGkrKykge1xuICAgIGlmICh3b3JkW2ldICE9IHRoaXMucHJldmlvdXNXb3JkW2ldKSBicmVha1xuICAgIGNvbW1vblByZWZpeCsrXG4gIH1cblxuICB0aGlzLm1pbmltaXplKGNvbW1vblByZWZpeClcblxuICBpZiAodGhpcy51bmNoZWNrZWROb2Rlcy5sZW5ndGggPT0gMCkge1xuICAgIG5vZGUgPSB0aGlzLnJvb3RcbiAgfSBlbHNlIHtcbiAgICBub2RlID0gdGhpcy51bmNoZWNrZWROb2Rlc1t0aGlzLnVuY2hlY2tlZE5vZGVzLmxlbmd0aCAtIDFdLmNoaWxkXG4gIH1cblxuICBmb3IgKHZhciBpID0gY29tbW9uUHJlZml4OyBpIDwgd29yZC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBuZXh0Tm9kZSA9IG5ldyBsdW5yLlRva2VuU2V0LFxuICAgICAgICBjaGFyID0gd29yZFtpXVxuXG4gICAgbm9kZS5lZGdlc1tjaGFyXSA9IG5leHROb2RlXG5cbiAgICB0aGlzLnVuY2hlY2tlZE5vZGVzLnB1c2goe1xuICAgICAgcGFyZW50OiBub2RlLFxuICAgICAgY2hhcjogY2hhcixcbiAgICAgIGNoaWxkOiBuZXh0Tm9kZVxuICAgIH0pXG5cbiAgICBub2RlID0gbmV4dE5vZGVcbiAgfVxuXG4gIG5vZGUuZmluYWwgPSB0cnVlXG4gIHRoaXMucHJldmlvdXNXb3JkID0gd29yZFxufVxuXG5sdW5yLlRva2VuU2V0LkJ1aWxkZXIucHJvdG90eXBlLmZpbmlzaCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5taW5pbWl6ZSgwKVxufVxuXG5sdW5yLlRva2VuU2V0LkJ1aWxkZXIucHJvdG90eXBlLm1pbmltaXplID0gZnVuY3Rpb24gKGRvd25Ubykge1xuICBmb3IgKHZhciBpID0gdGhpcy51bmNoZWNrZWROb2Rlcy5sZW5ndGggLSAxOyBpID49IGRvd25UbzsgaS0tKSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLnVuY2hlY2tlZE5vZGVzW2ldLFxuICAgICAgICBjaGlsZEtleSA9IG5vZGUuY2hpbGQudG9TdHJpbmcoKVxuXG4gICAgaWYgKGNoaWxkS2V5IGluIHRoaXMubWluaW1pemVkTm9kZXMpIHtcbiAgICAgIG5vZGUucGFyZW50LmVkZ2VzW25vZGUuY2hhcl0gPSB0aGlzLm1pbmltaXplZE5vZGVzW2NoaWxkS2V5XVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBDYWNoZSB0aGUga2V5IGZvciB0aGlzIG5vZGUgc2luY2VcbiAgICAgIC8vIHdlIGtub3cgaXQgY2FuJ3QgY2hhbmdlIGFueW1vcmVcbiAgICAgIG5vZGUuY2hpbGQuX3N0ciA9IGNoaWxkS2V5XG5cbiAgICAgIHRoaXMubWluaW1pemVkTm9kZXNbY2hpbGRLZXldID0gbm9kZS5jaGlsZFxuICAgIH1cblxuICAgIHRoaXMudW5jaGVja2VkTm9kZXMucG9wKClcbiAgfVxufVxuLyohXG4gKiBsdW5yLkluZGV4XG4gKiBDb3B5cmlnaHQgKEMpIDIwMTkgT2xpdmVyIE5pZ2h0aW5nYWxlXG4gKi9cblxuLyoqXG4gKiBBbiBpbmRleCBjb250YWlucyB0aGUgYnVpbHQgaW5kZXggb2YgYWxsIGRvY3VtZW50cyBhbmQgcHJvdmlkZXMgYSBxdWVyeSBpbnRlcmZhY2VcbiAqIHRvIHRoZSBpbmRleC5cbiAqXG4gKiBVc3VhbGx5IGluc3RhbmNlcyBvZiBsdW5yLkluZGV4IHdpbGwgbm90IGJlIGNyZWF0ZWQgdXNpbmcgdGhpcyBjb25zdHJ1Y3RvciwgaW5zdGVhZFxuICogbHVuci5CdWlsZGVyIHNob3VsZCBiZSB1c2VkIHRvIGNvbnN0cnVjdCBuZXcgaW5kZXhlcywgb3IgbHVuci5JbmRleC5sb2FkIHNob3VsZCBiZVxuICogdXNlZCB0byBsb2FkIHByZXZpb3VzbHkgYnVpbHQgYW5kIHNlcmlhbGl6ZWQgaW5kZXhlcy5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBhdHRycyAtIFRoZSBhdHRyaWJ1dGVzIG9mIHRoZSBidWlsdCBzZWFyY2ggaW5kZXguXG4gKiBAcGFyYW0ge09iamVjdH0gYXR0cnMuaW52ZXJ0ZWRJbmRleCAtIEFuIGluZGV4IG9mIHRlcm0vZmllbGQgdG8gZG9jdW1lbnQgcmVmZXJlbmNlLlxuICogQHBhcmFtIHtPYmplY3Q8c3RyaW5nLCBsdW5yLlZlY3Rvcj59IGF0dHJzLmZpZWxkVmVjdG9ycyAtIEZpZWxkIHZlY3RvcnNcbiAqIEBwYXJhbSB7bHVuci5Ub2tlblNldH0gYXR0cnMudG9rZW5TZXQgLSBBbiBzZXQgb2YgYWxsIGNvcnB1cyB0b2tlbnMuXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBhdHRycy5maWVsZHMgLSBUaGUgbmFtZXMgb2YgaW5kZXhlZCBkb2N1bWVudCBmaWVsZHMuXG4gKiBAcGFyYW0ge2x1bnIuUGlwZWxpbmV9IGF0dHJzLnBpcGVsaW5lIC0gVGhlIHBpcGVsaW5lIHRvIHVzZSBmb3Igc2VhcmNoIHRlcm1zLlxuICovXG5sdW5yLkluZGV4ID0gZnVuY3Rpb24gKGF0dHJzKSB7XG4gIHRoaXMuaW52ZXJ0ZWRJbmRleCA9IGF0dHJzLmludmVydGVkSW5kZXhcbiAgdGhpcy5maWVsZFZlY3RvcnMgPSBhdHRycy5maWVsZFZlY3RvcnNcbiAgdGhpcy50b2tlblNldCA9IGF0dHJzLnRva2VuU2V0XG4gIHRoaXMuZmllbGRzID0gYXR0cnMuZmllbGRzXG4gIHRoaXMucGlwZWxpbmUgPSBhdHRycy5waXBlbGluZVxufVxuXG4vKipcbiAqIEEgcmVzdWx0IGNvbnRhaW5zIGRldGFpbHMgb2YgYSBkb2N1bWVudCBtYXRjaGluZyBhIHNlYXJjaCBxdWVyeS5cbiAqIEB0eXBlZGVmIHtPYmplY3R9IGx1bnIuSW5kZXh+UmVzdWx0XG4gKiBAcHJvcGVydHkge3N0cmluZ30gcmVmIC0gVGhlIHJlZmVyZW5jZSBvZiB0aGUgZG9jdW1lbnQgdGhpcyByZXN1bHQgcmVwcmVzZW50cy5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzY29yZSAtIEEgbnVtYmVyIGJldHdlZW4gMCBhbmQgMSByZXByZXNlbnRpbmcgaG93IHNpbWlsYXIgdGhpcyBkb2N1bWVudCBpcyB0byB0aGUgcXVlcnkuXG4gKiBAcHJvcGVydHkge2x1bnIuTWF0Y2hEYXRhfSBtYXRjaERhdGEgLSBDb250YWlucyBtZXRhZGF0YSBhYm91dCB0aGlzIG1hdGNoIGluY2x1ZGluZyB3aGljaCB0ZXJtKHMpIGNhdXNlZCB0aGUgbWF0Y2guXG4gKi9cblxuLyoqXG4gKiBBbHRob3VnaCBsdW5yIHByb3ZpZGVzIHRoZSBhYmlsaXR5IHRvIGNyZWF0ZSBxdWVyaWVzIHVzaW5nIGx1bnIuUXVlcnksIGl0IGFsc28gcHJvdmlkZXMgYSBzaW1wbGVcbiAqIHF1ZXJ5IGxhbmd1YWdlIHdoaWNoIGl0c2VsZiBpcyBwYXJzZWQgaW50byBhbiBpbnN0YW5jZSBvZiBsdW5yLlF1ZXJ5LlxuICpcbiAqIEZvciBwcm9ncmFtbWF0aWNhbGx5IGJ1aWxkaW5nIHF1ZXJpZXMgaXQgaXMgYWR2aXNlZCB0byBkaXJlY3RseSB1c2UgbHVuci5RdWVyeSwgdGhlIHF1ZXJ5IGxhbmd1YWdlXG4gKiBpcyBiZXN0IHVzZWQgZm9yIGh1bWFuIGVudGVyZWQgdGV4dCByYXRoZXIgdGhhbiBwcm9ncmFtIGdlbmVyYXRlZCB0ZXh0LlxuICpcbiAqIEF0IGl0cyBzaW1wbGVzdCBxdWVyaWVzIGNhbiBqdXN0IGJlIGEgc2luZ2xlIHRlcm0sIGUuZy4gYGhlbGxvYCwgbXVsdGlwbGUgdGVybXMgYXJlIGFsc28gc3VwcG9ydGVkXG4gKiBhbmQgd2lsbCBiZSBjb21iaW5lZCB3aXRoIE9SLCBlLmcgYGhlbGxvIHdvcmxkYCB3aWxsIG1hdGNoIGRvY3VtZW50cyB0aGF0IGNvbnRhaW4gZWl0aGVyICdoZWxsbydcbiAqIG9yICd3b3JsZCcsIHRob3VnaCB0aG9zZSB0aGF0IGNvbnRhaW4gYm90aCB3aWxsIHJhbmsgaGlnaGVyIGluIHRoZSByZXN1bHRzLlxuICpcbiAqIFdpbGRjYXJkcyBjYW4gYmUgaW5jbHVkZWQgaW4gdGVybXMgdG8gbWF0Y2ggb25lIG9yIG1vcmUgdW5zcGVjaWZpZWQgY2hhcmFjdGVycywgdGhlc2Ugd2lsZGNhcmRzIGNhblxuICogYmUgaW5zZXJ0ZWQgYW55d2hlcmUgd2l0aGluIHRoZSB0ZXJtLCBhbmQgbW9yZSB0aGFuIG9uZSB3aWxkY2FyZCBjYW4gZXhpc3QgaW4gYSBzaW5nbGUgdGVybS4gQWRkaW5nXG4gKiB3aWxkY2FyZHMgd2lsbCBpbmNyZWFzZSB0aGUgbnVtYmVyIG9mIGRvY3VtZW50cyB0aGF0IHdpbGwgYmUgZm91bmQgYnV0IGNhbiBhbHNvIGhhdmUgYSBuZWdhdGl2ZVxuICogaW1wYWN0IG9uIHF1ZXJ5IHBlcmZvcm1hbmNlLCBlc3BlY2lhbGx5IHdpdGggd2lsZGNhcmRzIGF0IHRoZSBiZWdpbm5pbmcgb2YgYSB0ZXJtLlxuICpcbiAqIFRlcm1zIGNhbiBiZSByZXN0cmljdGVkIHRvIHNwZWNpZmljIGZpZWxkcywgZS5nLiBgdGl0bGU6aGVsbG9gLCBvbmx5IGRvY3VtZW50cyB3aXRoIHRoZSB0ZXJtXG4gKiBoZWxsbyBpbiB0aGUgdGl0bGUgZmllbGQgd2lsbCBtYXRjaCB0aGlzIHF1ZXJ5LiBVc2luZyBhIGZpZWxkIG5vdCBwcmVzZW50IGluIHRoZSBpbmRleCB3aWxsIGxlYWRcbiAqIHRvIGFuIGVycm9yIGJlaW5nIHRocm93bi5cbiAqXG4gKiBNb2RpZmllcnMgY2FuIGFsc28gYmUgYWRkZWQgdG8gdGVybXMsIGx1bnIgc3VwcG9ydHMgZWRpdCBkaXN0YW5jZSBhbmQgYm9vc3QgbW9kaWZpZXJzIG9uIHRlcm1zLiBBIHRlcm1cbiAqIGJvb3N0IHdpbGwgbWFrZSBkb2N1bWVudHMgbWF0Y2hpbmcgdGhhdCB0ZXJtIHNjb3JlIGhpZ2hlciwgZS5nLiBgZm9vXjVgLiBFZGl0IGRpc3RhbmNlIGlzIGFsc28gc3VwcG9ydGVkXG4gKiB0byBwcm92aWRlIGZ1enp5IG1hdGNoaW5nLCBlLmcuICdoZWxsb34yJyB3aWxsIG1hdGNoIGRvY3VtZW50cyB3aXRoIGhlbGxvIHdpdGggYW4gZWRpdCBkaXN0YW5jZSBvZiAyLlxuICogQXZvaWQgbGFyZ2UgdmFsdWVzIGZvciBlZGl0IGRpc3RhbmNlIHRvIGltcHJvdmUgcXVlcnkgcGVyZm9ybWFuY2UuXG4gKlxuICogRWFjaCB0ZXJtIGFsc28gc3VwcG9ydHMgYSBwcmVzZW5jZSBtb2RpZmllci4gQnkgZGVmYXVsdCBhIHRlcm0ncyBwcmVzZW5jZSBpbiBkb2N1bWVudCBpcyBvcHRpb25hbCwgaG93ZXZlclxuICogdGhpcyBjYW4gYmUgY2hhbmdlZCB0byBlaXRoZXIgcmVxdWlyZWQgb3IgcHJvaGliaXRlZC4gRm9yIGEgdGVybSdzIHByZXNlbmNlIHRvIGJlIHJlcXVpcmVkIGluIGEgZG9jdW1lbnQgdGhlXG4gKiB0ZXJtIHNob3VsZCBiZSBwcmVmaXhlZCB3aXRoIGEgJysnLCBlLmcuIGArZm9vIGJhcmAgaXMgYSBzZWFyY2ggZm9yIGRvY3VtZW50cyB0aGF0IG11c3QgY29udGFpbiAnZm9vJyBhbmRcbiAqIG9wdGlvbmFsbHkgY29udGFpbiAnYmFyJy4gQ29udmVyc2VseSBhIGxlYWRpbmcgJy0nIHNldHMgdGhlIHRlcm1zIHByZXNlbmNlIHRvIHByb2hpYml0ZWQsIGkuZS4gaXQgbXVzdCBub3RcbiAqIGFwcGVhciBpbiBhIGRvY3VtZW50LCBlLmcuIGAtZm9vIGJhcmAgaXMgYSBzZWFyY2ggZm9yIGRvY3VtZW50cyB0aGF0IGRvIG5vdCBjb250YWluICdmb28nIGJ1dCBtYXkgY29udGFpbiAnYmFyJy5cbiAqXG4gKiBUbyBlc2NhcGUgc3BlY2lhbCBjaGFyYWN0ZXJzIHRoZSBiYWNrc2xhc2ggY2hhcmFjdGVyICdcXCcgY2FuIGJlIHVzZWQsIHRoaXMgYWxsb3dzIHNlYXJjaGVzIHRvIGluY2x1ZGVcbiAqIGNoYXJhY3RlcnMgdGhhdCB3b3VsZCBub3JtYWxseSBiZSBjb25zaWRlcmVkIG1vZGlmaWVycywgZS5nLiBgZm9vXFx+MmAgd2lsbCBzZWFyY2ggZm9yIGEgdGVybSBcImZvb34yXCIgaW5zdGVhZFxuICogb2YgYXR0ZW1wdGluZyB0byBhcHBseSBhIGJvb3N0IG9mIDIgdG8gdGhlIHNlYXJjaCB0ZXJtIFwiZm9vXCIuXG4gKlxuICogQHR5cGVkZWYge3N0cmluZ30gbHVuci5JbmRleH5RdWVyeVN0cmluZ1xuICogQGV4YW1wbGUgPGNhcHRpb24+U2ltcGxlIHNpbmdsZSB0ZXJtIHF1ZXJ5PC9jYXB0aW9uPlxuICogaGVsbG9cbiAqIEBleGFtcGxlIDxjYXB0aW9uPk11bHRpcGxlIHRlcm0gcXVlcnk8L2NhcHRpb24+XG4gKiBoZWxsbyB3b3JsZFxuICogQGV4YW1wbGUgPGNhcHRpb24+dGVybSBzY29wZWQgdG8gYSBmaWVsZDwvY2FwdGlvbj5cbiAqIHRpdGxlOmhlbGxvXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj50ZXJtIHdpdGggYSBib29zdCBvZiAxMDwvY2FwdGlvbj5cbiAqIGhlbGxvXjEwXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj50ZXJtIHdpdGggYW4gZWRpdCBkaXN0YW5jZSBvZiAyPC9jYXB0aW9uPlxuICogaGVsbG9+MlxuICogQGV4YW1wbGUgPGNhcHRpb24+dGVybXMgd2l0aCBwcmVzZW5jZSBtb2RpZmllcnM8L2NhcHRpb24+XG4gKiAtZm9vICtiYXIgYmF6XG4gKi9cblxuLyoqXG4gKiBQZXJmb3JtcyBhIHNlYXJjaCBhZ2FpbnN0IHRoZSBpbmRleCB1c2luZyBsdW5yIHF1ZXJ5IHN5bnRheC5cbiAqXG4gKiBSZXN1bHRzIHdpbGwgYmUgcmV0dXJuZWQgc29ydGVkIGJ5IHRoZWlyIHNjb3JlLCB0aGUgbW9zdCByZWxldmFudCByZXN1bHRzXG4gKiB3aWxsIGJlIHJldHVybmVkIGZpcnN0LiAgRm9yIGRldGFpbHMgb24gaG93IHRoZSBzY29yZSBpcyBjYWxjdWxhdGVkLCBwbGVhc2Ugc2VlXG4gKiB0aGUge0BsaW5rIGh0dHBzOi8vbHVucmpzLmNvbS9ndWlkZXMvc2VhcmNoaW5nLmh0bWwjc2NvcmluZ3xndWlkZX0uXG4gKlxuICogRm9yIG1vcmUgcHJvZ3JhbW1hdGljIHF1ZXJ5aW5nIHVzZSBsdW5yLkluZGV4I3F1ZXJ5LlxuICpcbiAqIEBwYXJhbSB7bHVuci5JbmRleH5RdWVyeVN0cmluZ30gcXVlcnlTdHJpbmcgLSBBIHN0cmluZyBjb250YWluaW5nIGEgbHVuciBxdWVyeS5cbiAqIEB0aHJvd3Mge2x1bnIuUXVlcnlQYXJzZUVycm9yfSBJZiB0aGUgcGFzc2VkIHF1ZXJ5IHN0cmluZyBjYW5ub3QgYmUgcGFyc2VkLlxuICogQHJldHVybnMge2x1bnIuSW5kZXh+UmVzdWx0W119XG4gKi9cbmx1bnIuSW5kZXgucHJvdG90eXBlLnNlYXJjaCA9IGZ1bmN0aW9uIChxdWVyeVN0cmluZykge1xuICByZXR1cm4gdGhpcy5xdWVyeShmdW5jdGlvbiAocXVlcnkpIHtcbiAgICB2YXIgcGFyc2VyID0gbmV3IGx1bnIuUXVlcnlQYXJzZXIocXVlcnlTdHJpbmcsIHF1ZXJ5KVxuICAgIHBhcnNlci5wYXJzZSgpXG4gIH0pXG59XG5cbi8qKlxuICogQSBxdWVyeSBidWlsZGVyIGNhbGxiYWNrIHByb3ZpZGVzIGEgcXVlcnkgb2JqZWN0IHRvIGJlIHVzZWQgdG8gZXhwcmVzc1xuICogdGhlIHF1ZXJ5IHRvIHBlcmZvcm0gb24gdGhlIGluZGV4LlxuICpcbiAqIEBjYWxsYmFjayBsdW5yLkluZGV4fnF1ZXJ5QnVpbGRlclxuICogQHBhcmFtIHtsdW5yLlF1ZXJ5fSBxdWVyeSAtIFRoZSBxdWVyeSBvYmplY3QgdG8gYnVpbGQgdXAuXG4gKiBAdGhpcyBsdW5yLlF1ZXJ5XG4gKi9cblxuLyoqXG4gKiBQZXJmb3JtcyBhIHF1ZXJ5IGFnYWluc3QgdGhlIGluZGV4IHVzaW5nIHRoZSB5aWVsZGVkIGx1bnIuUXVlcnkgb2JqZWN0LlxuICpcbiAqIElmIHBlcmZvcm1pbmcgcHJvZ3JhbW1hdGljIHF1ZXJpZXMgYWdhaW5zdCB0aGUgaW5kZXgsIHRoaXMgbWV0aG9kIGlzIHByZWZlcnJlZFxuICogb3ZlciBsdW5yLkluZGV4I3NlYXJjaCBzbyBhcyB0byBhdm9pZCB0aGUgYWRkaXRpb25hbCBxdWVyeSBwYXJzaW5nIG92ZXJoZWFkLlxuICpcbiAqIEEgcXVlcnkgb2JqZWN0IGlzIHlpZWxkZWQgdG8gdGhlIHN1cHBsaWVkIGZ1bmN0aW9uIHdoaWNoIHNob3VsZCBiZSB1c2VkIHRvXG4gKiBleHByZXNzIHRoZSBxdWVyeSB0byBiZSBydW4gYWdhaW5zdCB0aGUgaW5kZXguXG4gKlxuICogTm90ZSB0aGF0IGFsdGhvdWdoIHRoaXMgZnVuY3Rpb24gdGFrZXMgYSBjYWxsYmFjayBwYXJhbWV0ZXIgaXQgaXMgX25vdF8gYW5cbiAqIGFzeW5jaHJvbm91cyBvcGVyYXRpb24sIHRoZSBjYWxsYmFjayBpcyBqdXN0IHlpZWxkZWQgYSBxdWVyeSBvYmplY3QgdG8gYmVcbiAqIGN1c3RvbWl6ZWQuXG4gKlxuICogQHBhcmFtIHtsdW5yLkluZGV4fnF1ZXJ5QnVpbGRlcn0gZm4gLSBBIGZ1bmN0aW9uIHRoYXQgaXMgdXNlZCB0byBidWlsZCB0aGUgcXVlcnkuXG4gKiBAcmV0dXJucyB7bHVuci5JbmRleH5SZXN1bHRbXX1cbiAqL1xubHVuci5JbmRleC5wcm90b3R5cGUucXVlcnkgPSBmdW5jdGlvbiAoZm4pIHtcbiAgLy8gZm9yIGVhY2ggcXVlcnkgY2xhdXNlXG4gIC8vICogcHJvY2VzcyB0ZXJtc1xuICAvLyAqIGV4cGFuZCB0ZXJtcyBmcm9tIHRva2VuIHNldFxuICAvLyAqIGZpbmQgbWF0Y2hpbmcgZG9jdW1lbnRzIGFuZCBtZXRhZGF0YVxuICAvLyAqIGdldCBkb2N1bWVudCB2ZWN0b3JzXG4gIC8vICogc2NvcmUgZG9jdW1lbnRzXG5cbiAgdmFyIHF1ZXJ5ID0gbmV3IGx1bnIuUXVlcnkodGhpcy5maWVsZHMpLFxuICAgICAgbWF0Y2hpbmdGaWVsZHMgPSBPYmplY3QuY3JlYXRlKG51bGwpLFxuICAgICAgcXVlcnlWZWN0b3JzID0gT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICAgIHRlcm1GaWVsZENhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICAgIHJlcXVpcmVkTWF0Y2hlcyA9IE9iamVjdC5jcmVhdGUobnVsbCksXG4gICAgICBwcm9oaWJpdGVkTWF0Y2hlcyA9IE9iamVjdC5jcmVhdGUobnVsbClcblxuICAvKlxuICAgKiBUbyBzdXBwb3J0IGZpZWxkIGxldmVsIGJvb3N0cyBhIHF1ZXJ5IHZlY3RvciBpcyBjcmVhdGVkIHBlclxuICAgKiBmaWVsZC4gQW4gZW1wdHkgdmVjdG9yIGlzIGVhZ2VybHkgY3JlYXRlZCB0byBzdXBwb3J0IG5lZ2F0ZWRcbiAgICogcXVlcmllcy5cbiAgICovXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5maWVsZHMubGVuZ3RoOyBpKyspIHtcbiAgICBxdWVyeVZlY3RvcnNbdGhpcy5maWVsZHNbaV1dID0gbmV3IGx1bnIuVmVjdG9yXG4gIH1cblxuICBmbi5jYWxsKHF1ZXJ5LCBxdWVyeSlcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHF1ZXJ5LmNsYXVzZXMubGVuZ3RoOyBpKyspIHtcbiAgICAvKlxuICAgICAqIFVubGVzcyB0aGUgcGlwZWxpbmUgaGFzIGJlZW4gZGlzYWJsZWQgZm9yIHRoaXMgdGVybSwgd2hpY2ggaXNcbiAgICAgKiB0aGUgY2FzZSBmb3IgdGVybXMgd2l0aCB3aWxkY2FyZHMsIHdlIG5lZWQgdG8gcGFzcyB0aGUgY2xhdXNlXG4gICAgICogdGVybSB0aHJvdWdoIHRoZSBzZWFyY2ggcGlwZWxpbmUuIEEgcGlwZWxpbmUgcmV0dXJucyBhbiBhcnJheVxuICAgICAqIG9mIHByb2Nlc3NlZCB0ZXJtcy4gUGlwZWxpbmUgZnVuY3Rpb25zIG1heSBleHBhbmQgdGhlIHBhc3NlZFxuICAgICAqIHRlcm0sIHdoaWNoIG1lYW5zIHdlIG1heSBlbmQgdXAgcGVyZm9ybWluZyBtdWx0aXBsZSBpbmRleCBsb29rdXBzXG4gICAgICogZm9yIGEgc2luZ2xlIHF1ZXJ5IHRlcm0uXG4gICAgICovXG4gICAgdmFyIGNsYXVzZSA9IHF1ZXJ5LmNsYXVzZXNbaV0sXG4gICAgICAgIHRlcm1zID0gbnVsbCxcbiAgICAgICAgY2xhdXNlTWF0Y2hlcyA9IGx1bnIuU2V0LmNvbXBsZXRlXG5cbiAgICBpZiAoY2xhdXNlLnVzZVBpcGVsaW5lKSB7XG4gICAgICB0ZXJtcyA9IHRoaXMucGlwZWxpbmUucnVuU3RyaW5nKGNsYXVzZS50ZXJtLCB7XG4gICAgICAgIGZpZWxkczogY2xhdXNlLmZpZWxkc1xuICAgICAgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgdGVybXMgPSBbY2xhdXNlLnRlcm1dXG4gICAgfVxuXG4gICAgZm9yICh2YXIgbSA9IDA7IG0gPCB0ZXJtcy5sZW5ndGg7IG0rKykge1xuICAgICAgdmFyIHRlcm0gPSB0ZXJtc1ttXVxuXG4gICAgICAvKlxuICAgICAgICogRWFjaCB0ZXJtIHJldHVybmVkIGZyb20gdGhlIHBpcGVsaW5lIG5lZWRzIHRvIHVzZSB0aGUgc2FtZSBxdWVyeVxuICAgICAgICogY2xhdXNlIG9iamVjdCwgZS5nLiB0aGUgc2FtZSBib29zdCBhbmQgb3IgZWRpdCBkaXN0YW5jZS4gVGhlXG4gICAgICAgKiBzaW1wbGVzdCB3YXkgdG8gZG8gdGhpcyBpcyB0byByZS11c2UgdGhlIGNsYXVzZSBvYmplY3QgYnV0IG11dGF0ZVxuICAgICAgICogaXRzIHRlcm0gcHJvcGVydHkuXG4gICAgICAgKi9cbiAgICAgIGNsYXVzZS50ZXJtID0gdGVybVxuXG4gICAgICAvKlxuICAgICAgICogRnJvbSB0aGUgdGVybSBpbiB0aGUgY2xhdXNlIHdlIGNyZWF0ZSBhIHRva2VuIHNldCB3aGljaCB3aWxsIHRoZW5cbiAgICAgICAqIGJlIHVzZWQgdG8gaW50ZXJzZWN0IHRoZSBpbmRleGVzIHRva2VuIHNldCB0byBnZXQgYSBsaXN0IG9mIHRlcm1zXG4gICAgICAgKiB0byBsb29rdXAgaW4gdGhlIGludmVydGVkIGluZGV4XG4gICAgICAgKi9cbiAgICAgIHZhciB0ZXJtVG9rZW5TZXQgPSBsdW5yLlRva2VuU2V0LmZyb21DbGF1c2UoY2xhdXNlKSxcbiAgICAgICAgICBleHBhbmRlZFRlcm1zID0gdGhpcy50b2tlblNldC5pbnRlcnNlY3QodGVybVRva2VuU2V0KS50b0FycmF5KClcblxuICAgICAgLypcbiAgICAgICAqIElmIGEgdGVybSBtYXJrZWQgYXMgcmVxdWlyZWQgZG9lcyBub3QgZXhpc3QgaW4gdGhlIHRva2VuU2V0IGl0IGlzXG4gICAgICAgKiBpbXBvc3NpYmxlIGZvciB0aGUgc2VhcmNoIHRvIHJldHVybiBhbnkgbWF0Y2hlcy4gV2Ugc2V0IGFsbCB0aGUgZmllbGRcbiAgICAgICAqIHNjb3BlZCByZXF1aXJlZCBtYXRjaGVzIHNldCB0byBlbXB0eSBhbmQgc3RvcCBleGFtaW5pbmcgYW55IGZ1cnRoZXJcbiAgICAgICAqIGNsYXVzZXMuXG4gICAgICAgKi9cbiAgICAgIGlmIChleHBhbmRlZFRlcm1zLmxlbmd0aCA9PT0gMCAmJiBjbGF1c2UucHJlc2VuY2UgPT09IGx1bnIuUXVlcnkucHJlc2VuY2UuUkVRVUlSRUQpIHtcbiAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBjbGF1c2UuZmllbGRzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgdmFyIGZpZWxkID0gY2xhdXNlLmZpZWxkc1trXVxuICAgICAgICAgIHJlcXVpcmVkTWF0Y2hlc1tmaWVsZF0gPSBsdW5yLlNldC5lbXB0eVxuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBleHBhbmRlZFRlcm1zLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIC8qXG4gICAgICAgICAqIEZvciBlYWNoIHRlcm0gZ2V0IHRoZSBwb3N0aW5nIGFuZCB0ZXJtSW5kZXgsIHRoaXMgaXMgcmVxdWlyZWQgZm9yXG4gICAgICAgICAqIGJ1aWxkaW5nIHRoZSBxdWVyeSB2ZWN0b3IuXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgZXhwYW5kZWRUZXJtID0gZXhwYW5kZWRUZXJtc1tqXSxcbiAgICAgICAgICAgIHBvc3RpbmcgPSB0aGlzLmludmVydGVkSW5kZXhbZXhwYW5kZWRUZXJtXSxcbiAgICAgICAgICAgIHRlcm1JbmRleCA9IHBvc3RpbmcuX2luZGV4XG5cbiAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBjbGF1c2UuZmllbGRzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgLypcbiAgICAgICAgICAgKiBGb3IgZWFjaCBmaWVsZCB0aGF0IHRoaXMgcXVlcnkgdGVybSBpcyBzY29wZWQgYnkgKGJ5IGRlZmF1bHRcbiAgICAgICAgICAgKiBhbGwgZmllbGRzIGFyZSBpbiBzY29wZSkgd2UgbmVlZCB0byBnZXQgYWxsIHRoZSBkb2N1bWVudCByZWZzXG4gICAgICAgICAgICogdGhhdCBoYXZlIHRoaXMgdGVybSBpbiB0aGF0IGZpZWxkLlxuICAgICAgICAgICAqXG4gICAgICAgICAgICogVGhlIHBvc3RpbmcgaXMgdGhlIGVudHJ5IGluIHRoZSBpbnZlcnRlZEluZGV4IGZvciB0aGUgbWF0Y2hpbmdcbiAgICAgICAgICAgKiB0ZXJtIGZyb20gYWJvdmUuXG4gICAgICAgICAgICovXG4gICAgICAgICAgdmFyIGZpZWxkID0gY2xhdXNlLmZpZWxkc1trXSxcbiAgICAgICAgICAgICAgZmllbGRQb3N0aW5nID0gcG9zdGluZ1tmaWVsZF0sXG4gICAgICAgICAgICAgIG1hdGNoaW5nRG9jdW1lbnRSZWZzID0gT2JqZWN0LmtleXMoZmllbGRQb3N0aW5nKSxcbiAgICAgICAgICAgICAgdGVybUZpZWxkID0gZXhwYW5kZWRUZXJtICsgXCIvXCIgKyBmaWVsZCxcbiAgICAgICAgICAgICAgbWF0Y2hpbmdEb2N1bWVudHNTZXQgPSBuZXcgbHVuci5TZXQobWF0Y2hpbmdEb2N1bWVudFJlZnMpXG5cbiAgICAgICAgICAvKlxuICAgICAgICAgICAqIGlmIHRoZSBwcmVzZW5jZSBvZiB0aGlzIHRlcm0gaXMgcmVxdWlyZWQgZW5zdXJlIHRoYXQgdGhlIG1hdGNoaW5nXG4gICAgICAgICAgICogZG9jdW1lbnRzIGFyZSBhZGRlZCB0byB0aGUgc2V0IG9mIHJlcXVpcmVkIG1hdGNoZXMgZm9yIHRoaXMgY2xhdXNlLlxuICAgICAgICAgICAqXG4gICAgICAgICAgICovXG4gICAgICAgICAgaWYgKGNsYXVzZS5wcmVzZW5jZSA9PSBsdW5yLlF1ZXJ5LnByZXNlbmNlLlJFUVVJUkVEKSB7XG4gICAgICAgICAgICBjbGF1c2VNYXRjaGVzID0gY2xhdXNlTWF0Y2hlcy51bmlvbihtYXRjaGluZ0RvY3VtZW50c1NldClcblxuICAgICAgICAgICAgaWYgKHJlcXVpcmVkTWF0Y2hlc1tmaWVsZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICByZXF1aXJlZE1hdGNoZXNbZmllbGRdID0gbHVuci5TZXQuY29tcGxldGVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvKlxuICAgICAgICAgICAqIGlmIHRoZSBwcmVzZW5jZSBvZiB0aGlzIHRlcm0gaXMgcHJvaGliaXRlZCBlbnN1cmUgdGhhdCB0aGUgbWF0Y2hpbmdcbiAgICAgICAgICAgKiBkb2N1bWVudHMgYXJlIGFkZGVkIHRvIHRoZSBzZXQgb2YgcHJvaGliaXRlZCBtYXRjaGVzIGZvciB0aGlzIGZpZWxkLFxuICAgICAgICAgICAqIGNyZWF0aW5nIHRoYXQgc2V0IGlmIGl0IGRvZXMgbm90IHlldCBleGlzdC5cbiAgICAgICAgICAgKi9cbiAgICAgICAgICBpZiAoY2xhdXNlLnByZXNlbmNlID09IGx1bnIuUXVlcnkucHJlc2VuY2UuUFJPSElCSVRFRCkge1xuICAgICAgICAgICAgaWYgKHByb2hpYml0ZWRNYXRjaGVzW2ZpZWxkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIHByb2hpYml0ZWRNYXRjaGVzW2ZpZWxkXSA9IGx1bnIuU2V0LmVtcHR5XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHByb2hpYml0ZWRNYXRjaGVzW2ZpZWxkXSA9IHByb2hpYml0ZWRNYXRjaGVzW2ZpZWxkXS51bmlvbihtYXRjaGluZ0RvY3VtZW50c1NldClcblxuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAqIFByb2hpYml0ZWQgbWF0Y2hlcyBzaG91bGQgbm90IGJlIHBhcnQgb2YgdGhlIHF1ZXJ5IHZlY3RvciB1c2VkIGZvclxuICAgICAgICAgICAgICogc2ltaWxhcml0eSBzY29yaW5nIGFuZCBubyBtZXRhZGF0YSBzaG91bGQgYmUgZXh0cmFjdGVkIHNvIHdlIGNvbnRpbnVlXG4gICAgICAgICAgICAgKiB0byB0aGUgbmV4dCBmaWVsZFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8qXG4gICAgICAgICAgICogVGhlIHF1ZXJ5IGZpZWxkIHZlY3RvciBpcyBwb3B1bGF0ZWQgdXNpbmcgdGhlIHRlcm1JbmRleCBmb3VuZCBmb3JcbiAgICAgICAgICAgKiB0aGUgdGVybSBhbmQgYSB1bml0IHZhbHVlIHdpdGggdGhlIGFwcHJvcHJpYXRlIGJvb3N0IGFwcGxpZWQuXG4gICAgICAgICAgICogVXNpbmcgdXBzZXJ0IGJlY2F1c2UgdGhlcmUgY291bGQgYWxyZWFkeSBiZSBhbiBlbnRyeSBpbiB0aGUgdmVjdG9yXG4gICAgICAgICAgICogZm9yIHRoZSB0ZXJtIHdlIGFyZSB3b3JraW5nIHdpdGguIEluIHRoYXQgY2FzZSB3ZSBqdXN0IGFkZCB0aGUgc2NvcmVzXG4gICAgICAgICAgICogdG9nZXRoZXIuXG4gICAgICAgICAgICovXG4gICAgICAgICAgcXVlcnlWZWN0b3JzW2ZpZWxkXS51cHNlcnQodGVybUluZGV4LCBjbGF1c2UuYm9vc3QsIGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhICsgYiB9KVxuXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogSWYgd2UndmUgYWxyZWFkeSBzZWVuIHRoaXMgdGVybSwgZmllbGQgY29tYm8gdGhlbiB3ZSd2ZSBhbHJlYWR5IGNvbGxlY3RlZFxuICAgICAgICAgICAqIHRoZSBtYXRjaGluZyBkb2N1bWVudHMgYW5kIG1ldGFkYXRhLCBubyBuZWVkIHRvIGdvIHRocm91Z2ggYWxsIHRoYXQgYWdhaW5cbiAgICAgICAgICAgKi9cbiAgICAgICAgICBpZiAodGVybUZpZWxkQ2FjaGVbdGVybUZpZWxkXSkge1xuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmb3IgKHZhciBsID0gMDsgbCA8IG1hdGNoaW5nRG9jdW1lbnRSZWZzLmxlbmd0aDsgbCsrKSB7XG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICogQWxsIG1ldGFkYXRhIGZvciB0aGlzIHRlcm0vZmllbGQvZG9jdW1lbnQgdHJpcGxlXG4gICAgICAgICAgICAgKiBhcmUgdGhlbiBleHRyYWN0ZWQgYW5kIGNvbGxlY3RlZCBpbnRvIGFuIGluc3RhbmNlXG4gICAgICAgICAgICAgKiBvZiBsdW5yLk1hdGNoRGF0YSByZWFkeSB0byBiZSByZXR1cm5lZCBpbiB0aGUgcXVlcnlcbiAgICAgICAgICAgICAqIHJlc3VsdHNcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdmFyIG1hdGNoaW5nRG9jdW1lbnRSZWYgPSBtYXRjaGluZ0RvY3VtZW50UmVmc1tsXSxcbiAgICAgICAgICAgICAgICBtYXRjaGluZ0ZpZWxkUmVmID0gbmV3IGx1bnIuRmllbGRSZWYgKG1hdGNoaW5nRG9jdW1lbnRSZWYsIGZpZWxkKSxcbiAgICAgICAgICAgICAgICBtZXRhZGF0YSA9IGZpZWxkUG9zdGluZ1ttYXRjaGluZ0RvY3VtZW50UmVmXSxcbiAgICAgICAgICAgICAgICBmaWVsZE1hdGNoXG5cbiAgICAgICAgICAgIGlmICgoZmllbGRNYXRjaCA9IG1hdGNoaW5nRmllbGRzW21hdGNoaW5nRmllbGRSZWZdKSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIG1hdGNoaW5nRmllbGRzW21hdGNoaW5nRmllbGRSZWZdID0gbmV3IGx1bnIuTWF0Y2hEYXRhIChleHBhbmRlZFRlcm0sIGZpZWxkLCBtZXRhZGF0YSlcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGZpZWxkTWF0Y2guYWRkKGV4cGFuZGVkVGVybSwgZmllbGQsIG1ldGFkYXRhKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGVybUZpZWxkQ2FjaGVbdGVybUZpZWxkXSA9IHRydWVcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIElmIHRoZSBwcmVzZW5jZSB3YXMgcmVxdWlyZWQgd2UgbmVlZCB0byB1cGRhdGUgdGhlIHJlcXVpcmVkTWF0Y2hlcyBmaWVsZCBzZXRzLlxuICAgICAqIFdlIGRvIHRoaXMgYWZ0ZXIgYWxsIGZpZWxkcyBmb3IgdGhlIHRlcm0gaGF2ZSBjb2xsZWN0ZWQgdGhlaXIgbWF0Y2hlcyBiZWNhdXNlXG4gICAgICogdGhlIGNsYXVzZSB0ZXJtcyBwcmVzZW5jZSBpcyByZXF1aXJlZCBpbiBfYW55XyBvZiB0aGUgZmllbGRzIG5vdCBfYWxsXyBvZiB0aGVcbiAgICAgKiBmaWVsZHMuXG4gICAgICovXG4gICAgaWYgKGNsYXVzZS5wcmVzZW5jZSA9PT0gbHVuci5RdWVyeS5wcmVzZW5jZS5SRVFVSVJFRCkge1xuICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBjbGF1c2UuZmllbGRzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgIHZhciBmaWVsZCA9IGNsYXVzZS5maWVsZHNba11cbiAgICAgICAgcmVxdWlyZWRNYXRjaGVzW2ZpZWxkXSA9IHJlcXVpcmVkTWF0Y2hlc1tmaWVsZF0uaW50ZXJzZWN0KGNsYXVzZU1hdGNoZXMpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE5lZWQgdG8gY29tYmluZSB0aGUgZmllbGQgc2NvcGVkIHJlcXVpcmVkIGFuZCBwcm9oaWJpdGVkXG4gICAqIG1hdGNoaW5nIGRvY3VtZW50cyBpbnRvIGEgZ2xvYmFsIHNldCBvZiByZXF1aXJlZCBhbmQgcHJvaGliaXRlZFxuICAgKiBtYXRjaGVzXG4gICAqL1xuICB2YXIgYWxsUmVxdWlyZWRNYXRjaGVzID0gbHVuci5TZXQuY29tcGxldGUsXG4gICAgICBhbGxQcm9oaWJpdGVkTWF0Y2hlcyA9IGx1bnIuU2V0LmVtcHR5XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmZpZWxkcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBmaWVsZCA9IHRoaXMuZmllbGRzW2ldXG5cbiAgICBpZiAocmVxdWlyZWRNYXRjaGVzW2ZpZWxkXSkge1xuICAgICAgYWxsUmVxdWlyZWRNYXRjaGVzID0gYWxsUmVxdWlyZWRNYXRjaGVzLmludGVyc2VjdChyZXF1aXJlZE1hdGNoZXNbZmllbGRdKVxuICAgIH1cblxuICAgIGlmIChwcm9oaWJpdGVkTWF0Y2hlc1tmaWVsZF0pIHtcbiAgICAgIGFsbFByb2hpYml0ZWRNYXRjaGVzID0gYWxsUHJvaGliaXRlZE1hdGNoZXMudW5pb24ocHJvaGliaXRlZE1hdGNoZXNbZmllbGRdKVxuICAgIH1cbiAgfVxuXG4gIHZhciBtYXRjaGluZ0ZpZWxkUmVmcyA9IE9iamVjdC5rZXlzKG1hdGNoaW5nRmllbGRzKSxcbiAgICAgIHJlc3VsdHMgPSBbXSxcbiAgICAgIG1hdGNoZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpXG5cbiAgLypcbiAgICogSWYgdGhlIHF1ZXJ5IGlzIG5lZ2F0ZWQgKGNvbnRhaW5zIG9ubHkgcHJvaGliaXRlZCB0ZXJtcylcbiAgICogd2UgbmVlZCB0byBnZXQgX2FsbF8gZmllbGRSZWZzIGN1cnJlbnRseSBleGlzdGluZyBpbiB0aGVcbiAgICogaW5kZXguIFRoaXMgaXMgb25seSBkb25lIHdoZW4gd2Uga25vdyB0aGF0IHRoZSBxdWVyeSBpc1xuICAgKiBlbnRpcmVseSBwcm9oaWJpdGVkIHRlcm1zIHRvIGF2b2lkIGFueSBjb3N0IG9mIGdldHRpbmcgYWxsXG4gICAqIGZpZWxkUmVmcyB1bm5lY2Vzc2FyaWx5LlxuICAgKlxuICAgKiBBZGRpdGlvbmFsbHksIGJsYW5rIE1hdGNoRGF0YSBtdXN0IGJlIGNyZWF0ZWQgdG8gY29ycmVjdGx5XG4gICAqIHBvcHVsYXRlIHRoZSByZXN1bHRzLlxuICAgKi9cbiAgaWYgKHF1ZXJ5LmlzTmVnYXRlZCgpKSB7XG4gICAgbWF0Y2hpbmdGaWVsZFJlZnMgPSBPYmplY3Qua2V5cyh0aGlzLmZpZWxkVmVjdG9ycylcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWF0Y2hpbmdGaWVsZFJlZnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBtYXRjaGluZ0ZpZWxkUmVmID0gbWF0Y2hpbmdGaWVsZFJlZnNbaV1cbiAgICAgIHZhciBmaWVsZFJlZiA9IGx1bnIuRmllbGRSZWYuZnJvbVN0cmluZyhtYXRjaGluZ0ZpZWxkUmVmKVxuICAgICAgbWF0Y2hpbmdGaWVsZHNbbWF0Y2hpbmdGaWVsZFJlZl0gPSBuZXcgbHVuci5NYXRjaERhdGFcbiAgICB9XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG1hdGNoaW5nRmllbGRSZWZzLmxlbmd0aDsgaSsrKSB7XG4gICAgLypcbiAgICAgKiBDdXJyZW50bHkgd2UgaGF2ZSBkb2N1bWVudCBmaWVsZHMgdGhhdCBtYXRjaCB0aGUgcXVlcnksIGJ1dCB3ZVxuICAgICAqIG5lZWQgdG8gcmV0dXJuIGRvY3VtZW50cy4gVGhlIG1hdGNoRGF0YSBhbmQgc2NvcmVzIGFyZSBjb21iaW5lZFxuICAgICAqIGZyb20gbXVsdGlwbGUgZmllbGRzIGJlbG9uZ2luZyB0byB0aGUgc2FtZSBkb2N1bWVudC5cbiAgICAgKlxuICAgICAqIFNjb3JlcyBhcmUgY2FsY3VsYXRlZCBieSBmaWVsZCwgdXNpbmcgdGhlIHF1ZXJ5IHZlY3RvcnMgY3JlYXRlZFxuICAgICAqIGFib3ZlLCBhbmQgY29tYmluZWQgaW50byBhIGZpbmFsIGRvY3VtZW50IHNjb3JlIHVzaW5nIGFkZGl0aW9uLlxuICAgICAqL1xuICAgIHZhciBmaWVsZFJlZiA9IGx1bnIuRmllbGRSZWYuZnJvbVN0cmluZyhtYXRjaGluZ0ZpZWxkUmVmc1tpXSksXG4gICAgICAgIGRvY1JlZiA9IGZpZWxkUmVmLmRvY1JlZlxuXG4gICAgaWYgKCFhbGxSZXF1aXJlZE1hdGNoZXMuY29udGFpbnMoZG9jUmVmKSkge1xuICAgICAgY29udGludWVcbiAgICB9XG5cbiAgICBpZiAoYWxsUHJvaGliaXRlZE1hdGNoZXMuY29udGFpbnMoZG9jUmVmKSkge1xuICAgICAgY29udGludWVcbiAgICB9XG5cbiAgICB2YXIgZmllbGRWZWN0b3IgPSB0aGlzLmZpZWxkVmVjdG9yc1tmaWVsZFJlZl0sXG4gICAgICAgIHNjb3JlID0gcXVlcnlWZWN0b3JzW2ZpZWxkUmVmLmZpZWxkTmFtZV0uc2ltaWxhcml0eShmaWVsZFZlY3RvciksXG4gICAgICAgIGRvY01hdGNoXG5cbiAgICBpZiAoKGRvY01hdGNoID0gbWF0Y2hlc1tkb2NSZWZdKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBkb2NNYXRjaC5zY29yZSArPSBzY29yZVxuICAgICAgZG9jTWF0Y2gubWF0Y2hEYXRhLmNvbWJpbmUobWF0Y2hpbmdGaWVsZHNbZmllbGRSZWZdKVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbWF0Y2ggPSB7XG4gICAgICAgIHJlZjogZG9jUmVmLFxuICAgICAgICBzY29yZTogc2NvcmUsXG4gICAgICAgIG1hdGNoRGF0YTogbWF0Y2hpbmdGaWVsZHNbZmllbGRSZWZdXG4gICAgICB9XG4gICAgICBtYXRjaGVzW2RvY1JlZl0gPSBtYXRjaFxuICAgICAgcmVzdWx0cy5wdXNoKG1hdGNoKVxuICAgIH1cbiAgfVxuXG4gIC8qXG4gICAqIFNvcnQgdGhlIHJlc3VsdHMgb2JqZWN0cyBieSBzY29yZSwgaGlnaGVzdCBmaXJzdC5cbiAgICovXG4gIHJldHVybiByZXN1bHRzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gYi5zY29yZSAtIGEuc2NvcmVcbiAgfSlcbn1cblxuLyoqXG4gKiBQcmVwYXJlcyB0aGUgaW5kZXggZm9yIEpTT04gc2VyaWFsaXphdGlvbi5cbiAqXG4gKiBUaGUgc2NoZW1hIGZvciB0aGlzIEpTT04gYmxvYiB3aWxsIGJlIGRlc2NyaWJlZCBpbiBhXG4gKiBzZXBhcmF0ZSBKU09OIHNjaGVtYSBmaWxlLlxuICpcbiAqIEByZXR1cm5zIHtPYmplY3R9XG4gKi9cbmx1bnIuSW5kZXgucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGludmVydGVkSW5kZXggPSBPYmplY3Qua2V5cyh0aGlzLmludmVydGVkSW5kZXgpXG4gICAgLnNvcnQoKVxuICAgIC5tYXAoZnVuY3Rpb24gKHRlcm0pIHtcbiAgICAgIHJldHVybiBbdGVybSwgdGhpcy5pbnZlcnRlZEluZGV4W3Rlcm1dXVxuICAgIH0sIHRoaXMpXG5cbiAgdmFyIGZpZWxkVmVjdG9ycyA9IE9iamVjdC5rZXlzKHRoaXMuZmllbGRWZWN0b3JzKVxuICAgIC5tYXAoZnVuY3Rpb24gKHJlZikge1xuICAgICAgcmV0dXJuIFtyZWYsIHRoaXMuZmllbGRWZWN0b3JzW3JlZl0udG9KU09OKCldXG4gICAgfSwgdGhpcylcblxuICByZXR1cm4ge1xuICAgIHZlcnNpb246IGx1bnIudmVyc2lvbixcbiAgICBmaWVsZHM6IHRoaXMuZmllbGRzLFxuICAgIGZpZWxkVmVjdG9yczogZmllbGRWZWN0b3JzLFxuICAgIGludmVydGVkSW5kZXg6IGludmVydGVkSW5kZXgsXG4gICAgcGlwZWxpbmU6IHRoaXMucGlwZWxpbmUudG9KU09OKClcbiAgfVxufVxuXG4vKipcbiAqIExvYWRzIGEgcHJldmlvdXNseSBzZXJpYWxpemVkIGx1bnIuSW5kZXhcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gc2VyaWFsaXplZEluZGV4IC0gQSBwcmV2aW91c2x5IHNlcmlhbGl6ZWQgbHVuci5JbmRleFxuICogQHJldHVybnMge2x1bnIuSW5kZXh9XG4gKi9cbmx1bnIuSW5kZXgubG9hZCA9IGZ1bmN0aW9uIChzZXJpYWxpemVkSW5kZXgpIHtcbiAgdmFyIGF0dHJzID0ge30sXG4gICAgICBmaWVsZFZlY3RvcnMgPSB7fSxcbiAgICAgIHNlcmlhbGl6ZWRWZWN0b3JzID0gc2VyaWFsaXplZEluZGV4LmZpZWxkVmVjdG9ycyxcbiAgICAgIGludmVydGVkSW5kZXggPSBPYmplY3QuY3JlYXRlKG51bGwpLFxuICAgICAgc2VyaWFsaXplZEludmVydGVkSW5kZXggPSBzZXJpYWxpemVkSW5kZXguaW52ZXJ0ZWRJbmRleCxcbiAgICAgIHRva2VuU2V0QnVpbGRlciA9IG5ldyBsdW5yLlRva2VuU2V0LkJ1aWxkZXIsXG4gICAgICBwaXBlbGluZSA9IGx1bnIuUGlwZWxpbmUubG9hZChzZXJpYWxpemVkSW5kZXgucGlwZWxpbmUpXG5cbiAgaWYgKHNlcmlhbGl6ZWRJbmRleC52ZXJzaW9uICE9IGx1bnIudmVyc2lvbikge1xuICAgIGx1bnIudXRpbHMud2FybihcIlZlcnNpb24gbWlzbWF0Y2ggd2hlbiBsb2FkaW5nIHNlcmlhbGlzZWQgaW5kZXguIEN1cnJlbnQgdmVyc2lvbiBvZiBsdW5yICdcIiArIGx1bnIudmVyc2lvbiArIFwiJyBkb2VzIG5vdCBtYXRjaCBzZXJpYWxpemVkIGluZGV4ICdcIiArIHNlcmlhbGl6ZWRJbmRleC52ZXJzaW9uICsgXCInXCIpXG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHNlcmlhbGl6ZWRWZWN0b3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHR1cGxlID0gc2VyaWFsaXplZFZlY3RvcnNbaV0sXG4gICAgICAgIHJlZiA9IHR1cGxlWzBdLFxuICAgICAgICBlbGVtZW50cyA9IHR1cGxlWzFdXG5cbiAgICBmaWVsZFZlY3RvcnNbcmVmXSA9IG5ldyBsdW5yLlZlY3RvcihlbGVtZW50cylcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc2VyaWFsaXplZEludmVydGVkSW5kZXgubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgdHVwbGUgPSBzZXJpYWxpemVkSW52ZXJ0ZWRJbmRleFtpXSxcbiAgICAgICAgdGVybSA9IHR1cGxlWzBdLFxuICAgICAgICBwb3N0aW5nID0gdHVwbGVbMV1cblxuICAgIHRva2VuU2V0QnVpbGRlci5pbnNlcnQodGVybSlcbiAgICBpbnZlcnRlZEluZGV4W3Rlcm1dID0gcG9zdGluZ1xuICB9XG5cbiAgdG9rZW5TZXRCdWlsZGVyLmZpbmlzaCgpXG5cbiAgYXR0cnMuZmllbGRzID0gc2VyaWFsaXplZEluZGV4LmZpZWxkc1xuXG4gIGF0dHJzLmZpZWxkVmVjdG9ycyA9IGZpZWxkVmVjdG9yc1xuICBhdHRycy5pbnZlcnRlZEluZGV4ID0gaW52ZXJ0ZWRJbmRleFxuICBhdHRycy50b2tlblNldCA9IHRva2VuU2V0QnVpbGRlci5yb290XG4gIGF0dHJzLnBpcGVsaW5lID0gcGlwZWxpbmVcblxuICByZXR1cm4gbmV3IGx1bnIuSW5kZXgoYXR0cnMpXG59XG4vKiFcbiAqIGx1bnIuQnVpbGRlclxuICogQ29weXJpZ2h0IChDKSAyMDE5IE9saXZlciBOaWdodGluZ2FsZVxuICovXG5cbi8qKlxuICogbHVuci5CdWlsZGVyIHBlcmZvcm1zIGluZGV4aW5nIG9uIGEgc2V0IG9mIGRvY3VtZW50cyBhbmRcbiAqIHJldHVybnMgaW5zdGFuY2VzIG9mIGx1bnIuSW5kZXggcmVhZHkgZm9yIHF1ZXJ5aW5nLlxuICpcbiAqIEFsbCBjb25maWd1cmF0aW9uIG9mIHRoZSBpbmRleCBpcyBkb25lIHZpYSB0aGUgYnVpbGRlciwgdGhlXG4gKiBmaWVsZHMgdG8gaW5kZXgsIHRoZSBkb2N1bWVudCByZWZlcmVuY2UsIHRoZSB0ZXh0IHByb2Nlc3NpbmdcbiAqIHBpcGVsaW5lIGFuZCBkb2N1bWVudCBzY29yaW5nIHBhcmFtZXRlcnMgYXJlIGFsbCBzZXQgb24gdGhlXG4gKiBidWlsZGVyIGJlZm9yZSBpbmRleGluZy5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBfcmVmIC0gSW50ZXJuYWwgcmVmZXJlbmNlIHRvIHRoZSBkb2N1bWVudCByZWZlcmVuY2UgZmllbGQuXG4gKiBAcHJvcGVydHkge3N0cmluZ1tdfSBfZmllbGRzIC0gSW50ZXJuYWwgcmVmZXJlbmNlIHRvIHRoZSBkb2N1bWVudCBmaWVsZHMgdG8gaW5kZXguXG4gKiBAcHJvcGVydHkge29iamVjdH0gaW52ZXJ0ZWRJbmRleCAtIFRoZSBpbnZlcnRlZCBpbmRleCBtYXBzIHRlcm1zIHRvIGRvY3VtZW50IGZpZWxkcy5cbiAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBkb2N1bWVudFRlcm1GcmVxdWVuY2llcyAtIEtlZXBzIHRyYWNrIG9mIGRvY3VtZW50IHRlcm0gZnJlcXVlbmNpZXMuXG4gKiBAcHJvcGVydHkge29iamVjdH0gZG9jdW1lbnRMZW5ndGhzIC0gS2VlcHMgdHJhY2sgb2YgdGhlIGxlbmd0aCBvZiBkb2N1bWVudHMgYWRkZWQgdG8gdGhlIGluZGV4LlxuICogQHByb3BlcnR5IHtsdW5yLnRva2VuaXplcn0gdG9rZW5pemVyIC0gRnVuY3Rpb24gZm9yIHNwbGl0dGluZyBzdHJpbmdzIGludG8gdG9rZW5zIGZvciBpbmRleGluZy5cbiAqIEBwcm9wZXJ0eSB7bHVuci5QaXBlbGluZX0gcGlwZWxpbmUgLSBUaGUgcGlwZWxpbmUgcGVyZm9ybXMgdGV4dCBwcm9jZXNzaW5nIG9uIHRva2VucyBiZWZvcmUgaW5kZXhpbmcuXG4gKiBAcHJvcGVydHkge2x1bnIuUGlwZWxpbmV9IHNlYXJjaFBpcGVsaW5lIC0gQSBwaXBlbGluZSBmb3IgcHJvY2Vzc2luZyBzZWFyY2ggdGVybXMgYmVmb3JlIHF1ZXJ5aW5nIHRoZSBpbmRleC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkb2N1bWVudENvdW50IC0gS2VlcHMgdHJhY2sgb2YgdGhlIHRvdGFsIG51bWJlciBvZiBkb2N1bWVudHMgaW5kZXhlZC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBfYiAtIEEgcGFyYW1ldGVyIHRvIGNvbnRyb2wgZmllbGQgbGVuZ3RoIG5vcm1hbGl6YXRpb24sIHNldHRpbmcgdGhpcyB0byAwIGRpc2FibGVkIG5vcm1hbGl6YXRpb24sIDEgZnVsbHkgbm9ybWFsaXplcyBmaWVsZCBsZW5ndGhzLCB0aGUgZGVmYXVsdCB2YWx1ZSBpcyAwLjc1LlxuICogQHByb3BlcnR5IHtudW1iZXJ9IF9rMSAtIEEgcGFyYW1ldGVyIHRvIGNvbnRyb2wgaG93IHF1aWNrbHkgYW4gaW5jcmVhc2UgaW4gdGVybSBmcmVxdWVuY3kgcmVzdWx0cyBpbiB0ZXJtIGZyZXF1ZW5jeSBzYXR1cmF0aW9uLCB0aGUgZGVmYXVsdCB2YWx1ZSBpcyAxLjIuXG4gKiBAcHJvcGVydHkge251bWJlcn0gdGVybUluZGV4IC0gQSBjb3VudGVyIGluY3JlbWVudGVkIGZvciBlYWNoIHVuaXF1ZSB0ZXJtLCB1c2VkIHRvIGlkZW50aWZ5IGEgdGVybXMgcG9zaXRpb24gaW4gdGhlIHZlY3RvciBzcGFjZS5cbiAqIEBwcm9wZXJ0eSB7YXJyYXl9IG1ldGFkYXRhV2hpdGVsaXN0IC0gQSBsaXN0IG9mIG1ldGFkYXRhIGtleXMgdGhhdCBoYXZlIGJlZW4gd2hpdGVsaXN0ZWQgZm9yIGVudHJ5IGluIHRoZSBpbmRleC5cbiAqL1xubHVuci5CdWlsZGVyID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLl9yZWYgPSBcImlkXCJcbiAgdGhpcy5fZmllbGRzID0gT2JqZWN0LmNyZWF0ZShudWxsKVxuICB0aGlzLl9kb2N1bWVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpXG4gIHRoaXMuaW52ZXJ0ZWRJbmRleCA9IE9iamVjdC5jcmVhdGUobnVsbClcbiAgdGhpcy5maWVsZFRlcm1GcmVxdWVuY2llcyA9IHt9XG4gIHRoaXMuZmllbGRMZW5ndGhzID0ge31cbiAgdGhpcy50b2tlbml6ZXIgPSBsdW5yLnRva2VuaXplclxuICB0aGlzLnBpcGVsaW5lID0gbmV3IGx1bnIuUGlwZWxpbmVcbiAgdGhpcy5zZWFyY2hQaXBlbGluZSA9IG5ldyBsdW5yLlBpcGVsaW5lXG4gIHRoaXMuZG9jdW1lbnRDb3VudCA9IDBcbiAgdGhpcy5fYiA9IDAuNzVcbiAgdGhpcy5fazEgPSAxLjJcbiAgdGhpcy50ZXJtSW5kZXggPSAwXG4gIHRoaXMubWV0YWRhdGFXaGl0ZWxpc3QgPSBbXVxufVxuXG4vKipcbiAqIFNldHMgdGhlIGRvY3VtZW50IGZpZWxkIHVzZWQgYXMgdGhlIGRvY3VtZW50IHJlZmVyZW5jZS4gRXZlcnkgZG9jdW1lbnQgbXVzdCBoYXZlIHRoaXMgZmllbGQuXG4gKiBUaGUgdHlwZSBvZiB0aGlzIGZpZWxkIGluIHRoZSBkb2N1bWVudCBzaG91bGQgYmUgYSBzdHJpbmcsIGlmIGl0IGlzIG5vdCBhIHN0cmluZyBpdCB3aWxsIGJlXG4gKiBjb2VyY2VkIGludG8gYSBzdHJpbmcgYnkgY2FsbGluZyB0b1N0cmluZy5cbiAqXG4gKiBUaGUgZGVmYXVsdCByZWYgaXMgJ2lkJy5cbiAqXG4gKiBUaGUgcmVmIHNob3VsZCBfbm90XyBiZSBjaGFuZ2VkIGR1cmluZyBpbmRleGluZywgaXQgc2hvdWxkIGJlIHNldCBiZWZvcmUgYW55IGRvY3VtZW50cyBhcmVcbiAqIGFkZGVkIHRvIHRoZSBpbmRleC4gQ2hhbmdpbmcgaXQgZHVyaW5nIGluZGV4aW5nIGNhbiBsZWFkIHRvIGluY29uc2lzdGVudCByZXN1bHRzLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSByZWYgLSBUaGUgbmFtZSBvZiB0aGUgcmVmZXJlbmNlIGZpZWxkIGluIHRoZSBkb2N1bWVudC5cbiAqL1xubHVuci5CdWlsZGVyLnByb3RvdHlwZS5yZWYgPSBmdW5jdGlvbiAocmVmKSB7XG4gIHRoaXMuX3JlZiA9IHJlZlxufVxuXG4vKipcbiAqIEEgZnVuY3Rpb24gdGhhdCBpcyB1c2VkIHRvIGV4dHJhY3QgYSBmaWVsZCBmcm9tIGEgZG9jdW1lbnQuXG4gKlxuICogTHVuciBleHBlY3RzIGEgZmllbGQgdG8gYmUgYXQgdGhlIHRvcCBsZXZlbCBvZiBhIGRvY3VtZW50LCBpZiBob3dldmVyIHRoZSBmaWVsZFxuICogaXMgZGVlcGx5IG5lc3RlZCB3aXRoaW4gYSBkb2N1bWVudCBhbiBleHRyYWN0b3IgZnVuY3Rpb24gY2FuIGJlIHVzZWQgdG8gZXh0cmFjdFxuICogdGhlIHJpZ2h0IGZpZWxkIGZvciBpbmRleGluZy5cbiAqXG4gKiBAY2FsbGJhY2sgZmllbGRFeHRyYWN0b3JcbiAqIEBwYXJhbSB7b2JqZWN0fSBkb2MgLSBUaGUgZG9jdW1lbnQgYmVpbmcgYWRkZWQgdG8gdGhlIGluZGV4LlxuICogQHJldHVybnMgez8oc3RyaW5nfG9iamVjdHxvYmplY3RbXSl9IG9iaiAtIFRoZSBvYmplY3QgdGhhdCB3aWxsIGJlIGluZGV4ZWQgZm9yIHRoaXMgZmllbGQuXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5FeHRyYWN0aW5nIGEgbmVzdGVkIGZpZWxkPC9jYXB0aW9uPlxuICogZnVuY3Rpb24gKGRvYykgeyByZXR1cm4gZG9jLm5lc3RlZC5maWVsZCB9XG4gKi9cblxuLyoqXG4gKiBBZGRzIGEgZmllbGQgdG8gdGhlIGxpc3Qgb2YgZG9jdW1lbnQgZmllbGRzIHRoYXQgd2lsbCBiZSBpbmRleGVkLiBFdmVyeSBkb2N1bWVudCBiZWluZ1xuICogaW5kZXhlZCBzaG91bGQgaGF2ZSB0aGlzIGZpZWxkLiBOdWxsIHZhbHVlcyBmb3IgdGhpcyBmaWVsZCBpbiBpbmRleGVkIGRvY3VtZW50cyB3aWxsXG4gKiBub3QgY2F1c2UgZXJyb3JzIGJ1dCB3aWxsIGxpbWl0IHRoZSBjaGFuY2Ugb2YgdGhhdCBkb2N1bWVudCBiZWluZyByZXRyaWV2ZWQgYnkgc2VhcmNoZXMuXG4gKlxuICogQWxsIGZpZWxkcyBzaG91bGQgYmUgYWRkZWQgYmVmb3JlIGFkZGluZyBkb2N1bWVudHMgdG8gdGhlIGluZGV4LiBBZGRpbmcgZmllbGRzIGFmdGVyXG4gKiBhIGRvY3VtZW50IGhhcyBiZWVuIGluZGV4ZWQgd2lsbCBoYXZlIG5vIGVmZmVjdCBvbiBhbHJlYWR5IGluZGV4ZWQgZG9jdW1lbnRzLlxuICpcbiAqIEZpZWxkcyBjYW4gYmUgYm9vc3RlZCBhdCBidWlsZCB0aW1lLiBUaGlzIGFsbG93cyB0ZXJtcyB3aXRoaW4gdGhhdCBmaWVsZCB0byBoYXZlIG1vcmVcbiAqIGltcG9ydGFuY2Ugd2hlbiByYW5raW5nIHNlYXJjaCByZXN1bHRzLiBVc2UgYSBmaWVsZCBib29zdCB0byBzcGVjaWZ5IHRoYXQgbWF0Y2hlcyB3aXRoaW5cbiAqIG9uZSBmaWVsZCBhcmUgbW9yZSBpbXBvcnRhbnQgdGhhbiBvdGhlciBmaWVsZHMuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkTmFtZSAtIFRoZSBuYW1lIG9mIGEgZmllbGQgdG8gaW5kZXggaW4gYWxsIGRvY3VtZW50cy5cbiAqIEBwYXJhbSB7b2JqZWN0fSBhdHRyaWJ1dGVzIC0gT3B0aW9uYWwgYXR0cmlidXRlcyBhc3NvY2lhdGVkIHdpdGggdGhpcyBmaWVsZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbYXR0cmlidXRlcy5ib29zdD0xXSAtIEJvb3N0IGFwcGxpZWQgdG8gYWxsIHRlcm1zIHdpdGhpbiB0aGlzIGZpZWxkLlxuICogQHBhcmFtIHtmaWVsZEV4dHJhY3Rvcn0gW2F0dHJpYnV0ZXMuZXh0cmFjdG9yXSAtIEZ1bmN0aW9uIHRvIGV4dHJhY3QgYSBmaWVsZCBmcm9tIGEgZG9jdW1lbnQuXG4gKiBAdGhyb3dzIHtSYW5nZUVycm9yfSBmaWVsZE5hbWUgY2Fubm90IGNvbnRhaW4gdW5zdXBwb3J0ZWQgY2hhcmFjdGVycyAnLydcbiAqL1xubHVuci5CdWlsZGVyLnByb3RvdHlwZS5maWVsZCA9IGZ1bmN0aW9uIChmaWVsZE5hbWUsIGF0dHJpYnV0ZXMpIHtcbiAgaWYgKC9cXC8vLnRlc3QoZmllbGROYW1lKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yIChcIkZpZWxkICdcIiArIGZpZWxkTmFtZSArIFwiJyBjb250YWlucyBpbGxlZ2FsIGNoYXJhY3RlciAnLydcIilcbiAgfVxuXG4gIHRoaXMuX2ZpZWxkc1tmaWVsZE5hbWVdID0gYXR0cmlidXRlcyB8fCB7fVxufVxuXG4vKipcbiAqIEEgcGFyYW1ldGVyIHRvIHR1bmUgdGhlIGFtb3VudCBvZiBmaWVsZCBsZW5ndGggbm9ybWFsaXNhdGlvbiB0aGF0IGlzIGFwcGxpZWQgd2hlblxuICogY2FsY3VsYXRpbmcgcmVsZXZhbmNlIHNjb3Jlcy4gQSB2YWx1ZSBvZiAwIHdpbGwgY29tcGxldGVseSBkaXNhYmxlIGFueSBub3JtYWxpc2F0aW9uXG4gKiBhbmQgYSB2YWx1ZSBvZiAxIHdpbGwgZnVsbHkgbm9ybWFsaXNlIGZpZWxkIGxlbmd0aHMuIFRoZSBkZWZhdWx0IGlzIDAuNzUuIFZhbHVlcyBvZiBiXG4gKiB3aWxsIGJlIGNsYW1wZWQgdG8gdGhlIHJhbmdlIDAgLSAxLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBudW1iZXIgLSBUaGUgdmFsdWUgdG8gc2V0IGZvciB0aGlzIHR1bmluZyBwYXJhbWV0ZXIuXG4gKi9cbmx1bnIuQnVpbGRlci5wcm90b3R5cGUuYiA9IGZ1bmN0aW9uIChudW1iZXIpIHtcbiAgaWYgKG51bWJlciA8IDApIHtcbiAgICB0aGlzLl9iID0gMFxuICB9IGVsc2UgaWYgKG51bWJlciA+IDEpIHtcbiAgICB0aGlzLl9iID0gMVxuICB9IGVsc2Uge1xuICAgIHRoaXMuX2IgPSBudW1iZXJcbiAgfVxufVxuXG4vKipcbiAqIEEgcGFyYW1ldGVyIHRoYXQgY29udHJvbHMgdGhlIHNwZWVkIGF0IHdoaWNoIGEgcmlzZSBpbiB0ZXJtIGZyZXF1ZW5jeSByZXN1bHRzIGluIHRlcm1cbiAqIGZyZXF1ZW5jeSBzYXR1cmF0aW9uLiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyAxLjIuIFNldHRpbmcgdGhpcyB0byBhIGhpZ2hlciB2YWx1ZSB3aWxsIGdpdmVcbiAqIHNsb3dlciBzYXR1cmF0aW9uIGxldmVscywgYSBsb3dlciB2YWx1ZSB3aWxsIHJlc3VsdCBpbiBxdWlja2VyIHNhdHVyYXRpb24uXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IG51bWJlciAtIFRoZSB2YWx1ZSB0byBzZXQgZm9yIHRoaXMgdHVuaW5nIHBhcmFtZXRlci5cbiAqL1xubHVuci5CdWlsZGVyLnByb3RvdHlwZS5rMSA9IGZ1bmN0aW9uIChudW1iZXIpIHtcbiAgdGhpcy5fazEgPSBudW1iZXJcbn1cblxuLyoqXG4gKiBBZGRzIGEgZG9jdW1lbnQgdG8gdGhlIGluZGV4LlxuICpcbiAqIEJlZm9yZSBhZGRpbmcgZmllbGRzIHRvIHRoZSBpbmRleCB0aGUgaW5kZXggc2hvdWxkIGhhdmUgYmVlbiBmdWxseSBzZXR1cCwgd2l0aCB0aGUgZG9jdW1lbnRcbiAqIHJlZiBhbmQgYWxsIGZpZWxkcyB0byBpbmRleCBhbHJlYWR5IGhhdmluZyBiZWVuIHNwZWNpZmllZC5cbiAqXG4gKiBUaGUgZG9jdW1lbnQgbXVzdCBoYXZlIGEgZmllbGQgbmFtZSBhcyBzcGVjaWZpZWQgYnkgdGhlIHJlZiAoYnkgZGVmYXVsdCB0aGlzIGlzICdpZCcpIGFuZFxuICogaXQgc2hvdWxkIGhhdmUgYWxsIGZpZWxkcyBkZWZpbmVkIGZvciBpbmRleGluZywgdGhvdWdoIG51bGwgb3IgdW5kZWZpbmVkIHZhbHVlcyB3aWxsIG5vdFxuICogY2F1c2UgZXJyb3JzLlxuICpcbiAqIEVudGlyZSBkb2N1bWVudHMgY2FuIGJlIGJvb3N0ZWQgYXQgYnVpbGQgdGltZS4gQXBwbHlpbmcgYSBib29zdCB0byBhIGRvY3VtZW50IGluZGljYXRlcyB0aGF0XG4gKiB0aGlzIGRvY3VtZW50IHNob3VsZCByYW5rIGhpZ2hlciBpbiBzZWFyY2ggcmVzdWx0cyB0aGFuIG90aGVyIGRvY3VtZW50cy5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gZG9jIC0gVGhlIGRvY3VtZW50IHRvIGFkZCB0byB0aGUgaW5kZXguXG4gKiBAcGFyYW0ge29iamVjdH0gYXR0cmlidXRlcyAtIE9wdGlvbmFsIGF0dHJpYnV0ZXMgYXNzb2NpYXRlZCB3aXRoIHRoaXMgZG9jdW1lbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gW2F0dHJpYnV0ZXMuYm9vc3Q9MV0gLSBCb29zdCBhcHBsaWVkIHRvIGFsbCB0ZXJtcyB3aXRoaW4gdGhpcyBkb2N1bWVudC5cbiAqL1xubHVuci5CdWlsZGVyLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAoZG9jLCBhdHRyaWJ1dGVzKSB7XG4gIHZhciBkb2NSZWYgPSBkb2NbdGhpcy5fcmVmXSxcbiAgICAgIGZpZWxkcyA9IE9iamVjdC5rZXlzKHRoaXMuX2ZpZWxkcylcblxuICB0aGlzLl9kb2N1bWVudHNbZG9jUmVmXSA9IGF0dHJpYnV0ZXMgfHwge31cbiAgdGhpcy5kb2N1bWVudENvdW50ICs9IDFcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGZpZWxkcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBmaWVsZE5hbWUgPSBmaWVsZHNbaV0sXG4gICAgICAgIGV4dHJhY3RvciA9IHRoaXMuX2ZpZWxkc1tmaWVsZE5hbWVdLmV4dHJhY3RvcixcbiAgICAgICAgZmllbGQgPSBleHRyYWN0b3IgPyBleHRyYWN0b3IoZG9jKSA6IGRvY1tmaWVsZE5hbWVdLFxuICAgICAgICB0b2tlbnMgPSB0aGlzLnRva2VuaXplcihmaWVsZCwge1xuICAgICAgICAgIGZpZWxkczogW2ZpZWxkTmFtZV1cbiAgICAgICAgfSksXG4gICAgICAgIHRlcm1zID0gdGhpcy5waXBlbGluZS5ydW4odG9rZW5zKSxcbiAgICAgICAgZmllbGRSZWYgPSBuZXcgbHVuci5GaWVsZFJlZiAoZG9jUmVmLCBmaWVsZE5hbWUpLFxuICAgICAgICBmaWVsZFRlcm1zID0gT2JqZWN0LmNyZWF0ZShudWxsKVxuXG4gICAgdGhpcy5maWVsZFRlcm1GcmVxdWVuY2llc1tmaWVsZFJlZl0gPSBmaWVsZFRlcm1zXG4gICAgdGhpcy5maWVsZExlbmd0aHNbZmllbGRSZWZdID0gMFxuXG4gICAgLy8gc3RvcmUgdGhlIGxlbmd0aCBvZiB0aGlzIGZpZWxkIGZvciB0aGlzIGRvY3VtZW50XG4gICAgdGhpcy5maWVsZExlbmd0aHNbZmllbGRSZWZdICs9IHRlcm1zLmxlbmd0aFxuXG4gICAgLy8gY2FsY3VsYXRlIHRlcm0gZnJlcXVlbmNpZXMgZm9yIHRoaXMgZmllbGRcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRlcm1zLmxlbmd0aDsgaisrKSB7XG4gICAgICB2YXIgdGVybSA9IHRlcm1zW2pdXG5cbiAgICAgIGlmIChmaWVsZFRlcm1zW3Rlcm1dID09IHVuZGVmaW5lZCkge1xuICAgICAgICBmaWVsZFRlcm1zW3Rlcm1dID0gMFxuICAgICAgfVxuXG4gICAgICBmaWVsZFRlcm1zW3Rlcm1dICs9IDFcblxuICAgICAgLy8gYWRkIHRvIGludmVydGVkIGluZGV4XG4gICAgICAvLyBjcmVhdGUgYW4gaW5pdGlhbCBwb3N0aW5nIGlmIG9uZSBkb2Vzbid0IGV4aXN0XG4gICAgICBpZiAodGhpcy5pbnZlcnRlZEluZGV4W3Rlcm1dID09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgcG9zdGluZyA9IE9iamVjdC5jcmVhdGUobnVsbClcbiAgICAgICAgcG9zdGluZ1tcIl9pbmRleFwiXSA9IHRoaXMudGVybUluZGV4XG4gICAgICAgIHRoaXMudGVybUluZGV4ICs9IDFcblxuICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IGZpZWxkcy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgIHBvc3RpbmdbZmllbGRzW2tdXSA9IE9iamVjdC5jcmVhdGUobnVsbClcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuaW52ZXJ0ZWRJbmRleFt0ZXJtXSA9IHBvc3RpbmdcbiAgICAgIH1cblxuICAgICAgLy8gYWRkIGFuIGVudHJ5IGZvciB0aGlzIHRlcm0vZmllbGROYW1lL2RvY1JlZiB0byB0aGUgaW52ZXJ0ZWRJbmRleFxuICAgICAgaWYgKHRoaXMuaW52ZXJ0ZWRJbmRleFt0ZXJtXVtmaWVsZE5hbWVdW2RvY1JlZl0gPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuaW52ZXJ0ZWRJbmRleFt0ZXJtXVtmaWVsZE5hbWVdW2RvY1JlZl0gPSBPYmplY3QuY3JlYXRlKG51bGwpXG4gICAgICB9XG5cbiAgICAgIC8vIHN0b3JlIGFsbCB3aGl0ZWxpc3RlZCBtZXRhZGF0YSBhYm91dCB0aGlzIHRva2VuIGluIHRoZVxuICAgICAgLy8gaW52ZXJ0ZWQgaW5kZXhcbiAgICAgIGZvciAodmFyIGwgPSAwOyBsIDwgdGhpcy5tZXRhZGF0YVdoaXRlbGlzdC5sZW5ndGg7IGwrKykge1xuICAgICAgICB2YXIgbWV0YWRhdGFLZXkgPSB0aGlzLm1ldGFkYXRhV2hpdGVsaXN0W2xdLFxuICAgICAgICAgICAgbWV0YWRhdGEgPSB0ZXJtLm1ldGFkYXRhW21ldGFkYXRhS2V5XVxuXG4gICAgICAgIGlmICh0aGlzLmludmVydGVkSW5kZXhbdGVybV1bZmllbGROYW1lXVtkb2NSZWZdW21ldGFkYXRhS2V5XSA9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLmludmVydGVkSW5kZXhbdGVybV1bZmllbGROYW1lXVtkb2NSZWZdW21ldGFkYXRhS2V5XSA9IFtdXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmludmVydGVkSW5kZXhbdGVybV1bZmllbGROYW1lXVtkb2NSZWZdW21ldGFkYXRhS2V5XS5wdXNoKG1ldGFkYXRhKVxuICAgICAgfVxuICAgIH1cblxuICB9XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgYXZlcmFnZSBkb2N1bWVudCBsZW5ndGggZm9yIHRoaXMgaW5kZXhcbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5sdW5yLkJ1aWxkZXIucHJvdG90eXBlLmNhbGN1bGF0ZUF2ZXJhZ2VGaWVsZExlbmd0aHMgPSBmdW5jdGlvbiAoKSB7XG5cbiAgdmFyIGZpZWxkUmVmcyA9IE9iamVjdC5rZXlzKHRoaXMuZmllbGRMZW5ndGhzKSxcbiAgICAgIG51bWJlck9mRmllbGRzID0gZmllbGRSZWZzLmxlbmd0aCxcbiAgICAgIGFjY3VtdWxhdG9yID0ge30sXG4gICAgICBkb2N1bWVudHNXaXRoRmllbGQgPSB7fVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtYmVyT2ZGaWVsZHM7IGkrKykge1xuICAgIHZhciBmaWVsZFJlZiA9IGx1bnIuRmllbGRSZWYuZnJvbVN0cmluZyhmaWVsZFJlZnNbaV0pLFxuICAgICAgICBmaWVsZCA9IGZpZWxkUmVmLmZpZWxkTmFtZVxuXG4gICAgZG9jdW1lbnRzV2l0aEZpZWxkW2ZpZWxkXSB8fCAoZG9jdW1lbnRzV2l0aEZpZWxkW2ZpZWxkXSA9IDApXG4gICAgZG9jdW1lbnRzV2l0aEZpZWxkW2ZpZWxkXSArPSAxXG5cbiAgICBhY2N1bXVsYXRvcltmaWVsZF0gfHwgKGFjY3VtdWxhdG9yW2ZpZWxkXSA9IDApXG4gICAgYWNjdW11bGF0b3JbZmllbGRdICs9IHRoaXMuZmllbGRMZW5ndGhzW2ZpZWxkUmVmXVxuICB9XG5cbiAgdmFyIGZpZWxkcyA9IE9iamVjdC5rZXlzKHRoaXMuX2ZpZWxkcylcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGZpZWxkcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBmaWVsZE5hbWUgPSBmaWVsZHNbaV1cbiAgICBhY2N1bXVsYXRvcltmaWVsZE5hbWVdID0gYWNjdW11bGF0b3JbZmllbGROYW1lXSAvIGRvY3VtZW50c1dpdGhGaWVsZFtmaWVsZE5hbWVdXG4gIH1cblxuICB0aGlzLmF2ZXJhZ2VGaWVsZExlbmd0aCA9IGFjY3VtdWxhdG9yXG59XG5cbi8qKlxuICogQnVpbGRzIGEgdmVjdG9yIHNwYWNlIG1vZGVsIG9mIGV2ZXJ5IGRvY3VtZW50IHVzaW5nIGx1bnIuVmVjdG9yXG4gKlxuICogQHByaXZhdGVcbiAqL1xubHVuci5CdWlsZGVyLnByb3RvdHlwZS5jcmVhdGVGaWVsZFZlY3RvcnMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBmaWVsZFZlY3RvcnMgPSB7fSxcbiAgICAgIGZpZWxkUmVmcyA9IE9iamVjdC5rZXlzKHRoaXMuZmllbGRUZXJtRnJlcXVlbmNpZXMpLFxuICAgICAgZmllbGRSZWZzTGVuZ3RoID0gZmllbGRSZWZzLmxlbmd0aCxcbiAgICAgIHRlcm1JZGZDYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbClcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGZpZWxkUmVmc0xlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGZpZWxkUmVmID0gbHVuci5GaWVsZFJlZi5mcm9tU3RyaW5nKGZpZWxkUmVmc1tpXSksXG4gICAgICAgIGZpZWxkTmFtZSA9IGZpZWxkUmVmLmZpZWxkTmFtZSxcbiAgICAgICAgZmllbGRMZW5ndGggPSB0aGlzLmZpZWxkTGVuZ3Roc1tmaWVsZFJlZl0sXG4gICAgICAgIGZpZWxkVmVjdG9yID0gbmV3IGx1bnIuVmVjdG9yLFxuICAgICAgICB0ZXJtRnJlcXVlbmNpZXMgPSB0aGlzLmZpZWxkVGVybUZyZXF1ZW5jaWVzW2ZpZWxkUmVmXSxcbiAgICAgICAgdGVybXMgPSBPYmplY3Qua2V5cyh0ZXJtRnJlcXVlbmNpZXMpLFxuICAgICAgICB0ZXJtc0xlbmd0aCA9IHRlcm1zLmxlbmd0aFxuXG5cbiAgICB2YXIgZmllbGRCb29zdCA9IHRoaXMuX2ZpZWxkc1tmaWVsZE5hbWVdLmJvb3N0IHx8IDEsXG4gICAgICAgIGRvY0Jvb3N0ID0gdGhpcy5fZG9jdW1lbnRzW2ZpZWxkUmVmLmRvY1JlZl0uYm9vc3QgfHwgMVxuXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCB0ZXJtc0xlbmd0aDsgaisrKSB7XG4gICAgICB2YXIgdGVybSA9IHRlcm1zW2pdLFxuICAgICAgICAgIHRmID0gdGVybUZyZXF1ZW5jaWVzW3Rlcm1dLFxuICAgICAgICAgIHRlcm1JbmRleCA9IHRoaXMuaW52ZXJ0ZWRJbmRleFt0ZXJtXS5faW5kZXgsXG4gICAgICAgICAgaWRmLCBzY29yZSwgc2NvcmVXaXRoUHJlY2lzaW9uXG5cbiAgICAgIGlmICh0ZXJtSWRmQ2FjaGVbdGVybV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZGYgPSBsdW5yLmlkZih0aGlzLmludmVydGVkSW5kZXhbdGVybV0sIHRoaXMuZG9jdW1lbnRDb3VudClcbiAgICAgICAgdGVybUlkZkNhY2hlW3Rlcm1dID0gaWRmXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZGYgPSB0ZXJtSWRmQ2FjaGVbdGVybV1cbiAgICAgIH1cblxuICAgICAgc2NvcmUgPSBpZGYgKiAoKHRoaXMuX2sxICsgMSkgKiB0ZikgLyAodGhpcy5fazEgKiAoMSAtIHRoaXMuX2IgKyB0aGlzLl9iICogKGZpZWxkTGVuZ3RoIC8gdGhpcy5hdmVyYWdlRmllbGRMZW5ndGhbZmllbGROYW1lXSkpICsgdGYpXG4gICAgICBzY29yZSAqPSBmaWVsZEJvb3N0XG4gICAgICBzY29yZSAqPSBkb2NCb29zdFxuICAgICAgc2NvcmVXaXRoUHJlY2lzaW9uID0gTWF0aC5yb3VuZChzY29yZSAqIDEwMDApIC8gMTAwMFxuICAgICAgLy8gQ29udmVydHMgMS4yMzQ1Njc4OSB0byAxLjIzNC5cbiAgICAgIC8vIFJlZHVjaW5nIHRoZSBwcmVjaXNpb24gc28gdGhhdCB0aGUgdmVjdG9ycyB0YWtlIHVwIGxlc3NcbiAgICAgIC8vIHNwYWNlIHdoZW4gc2VyaWFsaXNlZC4gRG9pbmcgaXQgbm93IHNvIHRoYXQgdGhleSBiZWhhdmVcbiAgICAgIC8vIHRoZSBzYW1lIGJlZm9yZSBhbmQgYWZ0ZXIgc2VyaWFsaXNhdGlvbi4gQWxzbywgdGhpcyBpc1xuICAgICAgLy8gdGhlIGZhc3Rlc3QgYXBwcm9hY2ggdG8gcmVkdWNpbmcgYSBudW1iZXIncyBwcmVjaXNpb24gaW5cbiAgICAgIC8vIEphdmFTY3JpcHQuXG5cbiAgICAgIGZpZWxkVmVjdG9yLmluc2VydCh0ZXJtSW5kZXgsIHNjb3JlV2l0aFByZWNpc2lvbilcbiAgICB9XG5cbiAgICBmaWVsZFZlY3RvcnNbZmllbGRSZWZdID0gZmllbGRWZWN0b3JcbiAgfVxuXG4gIHRoaXMuZmllbGRWZWN0b3JzID0gZmllbGRWZWN0b3JzXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIHRva2VuIHNldCBvZiBhbGwgdG9rZW5zIGluIHRoZSBpbmRleCB1c2luZyBsdW5yLlRva2VuU2V0XG4gKlxuICogQHByaXZhdGVcbiAqL1xubHVuci5CdWlsZGVyLnByb3RvdHlwZS5jcmVhdGVUb2tlblNldCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy50b2tlblNldCA9IGx1bnIuVG9rZW5TZXQuZnJvbUFycmF5KFxuICAgIE9iamVjdC5rZXlzKHRoaXMuaW52ZXJ0ZWRJbmRleCkuc29ydCgpXG4gIClcbn1cblxuLyoqXG4gKiBCdWlsZHMgdGhlIGluZGV4LCBjcmVhdGluZyBhbiBpbnN0YW5jZSBvZiBsdW5yLkluZGV4LlxuICpcbiAqIFRoaXMgY29tcGxldGVzIHRoZSBpbmRleGluZyBwcm9jZXNzIGFuZCBzaG91bGQgb25seSBiZSBjYWxsZWRcbiAqIG9uY2UgYWxsIGRvY3VtZW50cyBoYXZlIGJlZW4gYWRkZWQgdG8gdGhlIGluZGV4LlxuICpcbiAqIEByZXR1cm5zIHtsdW5yLkluZGV4fVxuICovXG5sdW5yLkJ1aWxkZXIucHJvdG90eXBlLmJ1aWxkID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmNhbGN1bGF0ZUF2ZXJhZ2VGaWVsZExlbmd0aHMoKVxuICB0aGlzLmNyZWF0ZUZpZWxkVmVjdG9ycygpXG4gIHRoaXMuY3JlYXRlVG9rZW5TZXQoKVxuXG4gIHJldHVybiBuZXcgbHVuci5JbmRleCh7XG4gICAgaW52ZXJ0ZWRJbmRleDogdGhpcy5pbnZlcnRlZEluZGV4LFxuICAgIGZpZWxkVmVjdG9yczogdGhpcy5maWVsZFZlY3RvcnMsXG4gICAgdG9rZW5TZXQ6IHRoaXMudG9rZW5TZXQsXG4gICAgZmllbGRzOiBPYmplY3Qua2V5cyh0aGlzLl9maWVsZHMpLFxuICAgIHBpcGVsaW5lOiB0aGlzLnNlYXJjaFBpcGVsaW5lXG4gIH0pXG59XG5cbi8qKlxuICogQXBwbGllcyBhIHBsdWdpbiB0byB0aGUgaW5kZXggYnVpbGRlci5cbiAqXG4gKiBBIHBsdWdpbiBpcyBhIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdpdGggdGhlIGluZGV4IGJ1aWxkZXIgYXMgaXRzIGNvbnRleHQuXG4gKiBQbHVnaW5zIGNhbiBiZSB1c2VkIHRvIGN1c3RvbWlzZSBvciBleHRlbmQgdGhlIGJlaGF2aW91ciBvZiB0aGUgaW5kZXhcbiAqIGluIHNvbWUgd2F5LiBBIHBsdWdpbiBpcyBqdXN0IGEgZnVuY3Rpb24sIHRoYXQgZW5jYXBzdWxhdGVkIHRoZSBjdXN0b21cbiAqIGJlaGF2aW91ciB0aGF0IHNob3VsZCBiZSBhcHBsaWVkIHdoZW4gYnVpbGRpbmcgdGhlIGluZGV4LlxuICpcbiAqIFRoZSBwbHVnaW4gZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgd2l0aCB0aGUgaW5kZXggYnVpbGRlciBhcyBpdHMgYXJndW1lbnQsIGFkZGl0aW9uYWxcbiAqIGFyZ3VtZW50cyBjYW4gYWxzbyBiZSBwYXNzZWQgd2hlbiBjYWxsaW5nIHVzZS4gVGhlIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkXG4gKiB3aXRoIHRoZSBpbmRleCBidWlsZGVyIGFzIGl0cyBjb250ZXh0LlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHBsdWdpbiBUaGUgcGx1Z2luIHRvIGFwcGx5LlxuICovXG5sdW5yLkJ1aWxkZXIucHJvdG90eXBlLnVzZSA9IGZ1bmN0aW9uIChmbikge1xuICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSlcbiAgYXJncy51bnNoaWZ0KHRoaXMpXG4gIGZuLmFwcGx5KHRoaXMsIGFyZ3MpXG59XG4vKipcbiAqIENvbnRhaW5zIGFuZCBjb2xsZWN0cyBtZXRhZGF0YSBhYm91dCBhIG1hdGNoaW5nIGRvY3VtZW50LlxuICogQSBzaW5nbGUgaW5zdGFuY2Ugb2YgbHVuci5NYXRjaERhdGEgaXMgcmV0dXJuZWQgYXMgcGFydCBvZiBldmVyeVxuICogbHVuci5JbmRleH5SZXN1bHQuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge3N0cmluZ30gdGVybSAtIFRoZSB0ZXJtIHRoaXMgbWF0Y2ggZGF0YSBpcyBhc3NvY2lhdGVkIHdpdGhcbiAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCAtIFRoZSBmaWVsZCBpbiB3aGljaCB0aGUgdGVybSB3YXMgZm91bmRcbiAqIEBwYXJhbSB7b2JqZWN0fSBtZXRhZGF0YSAtIFRoZSBtZXRhZGF0YSByZWNvcmRlZCBhYm91dCB0aGlzIHRlcm0gaW4gdGhpcyBmaWVsZFxuICogQHByb3BlcnR5IHtvYmplY3R9IG1ldGFkYXRhIC0gQSBjbG9uZWQgY29sbGVjdGlvbiBvZiBtZXRhZGF0YSBhc3NvY2lhdGVkIHdpdGggdGhpcyBkb2N1bWVudC5cbiAqIEBzZWUge0BsaW5rIGx1bnIuSW5kZXh+UmVzdWx0fVxuICovXG5sdW5yLk1hdGNoRGF0YSA9IGZ1bmN0aW9uICh0ZXJtLCBmaWVsZCwgbWV0YWRhdGEpIHtcbiAgdmFyIGNsb25lZE1ldGFkYXRhID0gT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICAgIG1ldGFkYXRhS2V5cyA9IE9iamVjdC5rZXlzKG1ldGFkYXRhIHx8IHt9KVxuXG4gIC8vIENsb25pbmcgdGhlIG1ldGFkYXRhIHRvIHByZXZlbnQgdGhlIG9yaWdpbmFsXG4gIC8vIGJlaW5nIG11dGF0ZWQgZHVyaW5nIG1hdGNoIGRhdGEgY29tYmluYXRpb24uXG4gIC8vIE1ldGFkYXRhIGlzIGtlcHQgaW4gYW4gYXJyYXkgd2l0aGluIHRoZSBpbnZlcnRlZFxuICAvLyBpbmRleCBzbyBjbG9uaW5nIHRoZSBkYXRhIGNhbiBiZSBkb25lIHdpdGhcbiAgLy8gQXJyYXkjc2xpY2VcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXRhZGF0YUtleXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIga2V5ID0gbWV0YWRhdGFLZXlzW2ldXG4gICAgY2xvbmVkTWV0YWRhdGFba2V5XSA9IG1ldGFkYXRhW2tleV0uc2xpY2UoKVxuICB9XG5cbiAgdGhpcy5tZXRhZGF0YSA9IE9iamVjdC5jcmVhdGUobnVsbClcblxuICBpZiAodGVybSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpcy5tZXRhZGF0YVt0ZXJtXSA9IE9iamVjdC5jcmVhdGUobnVsbClcbiAgICB0aGlzLm1ldGFkYXRhW3Rlcm1dW2ZpZWxkXSA9IGNsb25lZE1ldGFkYXRhXG4gIH1cbn1cblxuLyoqXG4gKiBBbiBpbnN0YW5jZSBvZiBsdW5yLk1hdGNoRGF0YSB3aWxsIGJlIGNyZWF0ZWQgZm9yIGV2ZXJ5IHRlcm0gdGhhdCBtYXRjaGVzIGFcbiAqIGRvY3VtZW50LiBIb3dldmVyIG9ubHkgb25lIGluc3RhbmNlIGlzIHJlcXVpcmVkIGluIGEgbHVuci5JbmRleH5SZXN1bHQuIFRoaXNcbiAqIG1ldGhvZCBjb21iaW5lcyBtZXRhZGF0YSBmcm9tIGFub3RoZXIgaW5zdGFuY2Ugb2YgbHVuci5NYXRjaERhdGEgd2l0aCB0aGlzXG4gKiBvYmplY3RzIG1ldGFkYXRhLlxuICpcbiAqIEBwYXJhbSB7bHVuci5NYXRjaERhdGF9IG90aGVyTWF0Y2hEYXRhIC0gQW5vdGhlciBpbnN0YW5jZSBvZiBtYXRjaCBkYXRhIHRvIG1lcmdlIHdpdGggdGhpcyBvbmUuXG4gKiBAc2VlIHtAbGluayBsdW5yLkluZGV4flJlc3VsdH1cbiAqL1xubHVuci5NYXRjaERhdGEucHJvdG90eXBlLmNvbWJpbmUgPSBmdW5jdGlvbiAob3RoZXJNYXRjaERhdGEpIHtcbiAgdmFyIHRlcm1zID0gT2JqZWN0LmtleXMob3RoZXJNYXRjaERhdGEubWV0YWRhdGEpXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ZXJtcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciB0ZXJtID0gdGVybXNbaV0sXG4gICAgICAgIGZpZWxkcyA9IE9iamVjdC5rZXlzKG90aGVyTWF0Y2hEYXRhLm1ldGFkYXRhW3Rlcm1dKVxuXG4gICAgaWYgKHRoaXMubWV0YWRhdGFbdGVybV0gPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLm1ldGFkYXRhW3Rlcm1dID0gT2JqZWN0LmNyZWF0ZShudWxsKVxuICAgIH1cblxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgZmllbGRzLmxlbmd0aDsgaisrKSB7XG4gICAgICB2YXIgZmllbGQgPSBmaWVsZHNbal0sXG4gICAgICAgICAga2V5cyA9IE9iamVjdC5rZXlzKG90aGVyTWF0Y2hEYXRhLm1ldGFkYXRhW3Rlcm1dW2ZpZWxkXSlcblxuICAgICAgaWYgKHRoaXMubWV0YWRhdGFbdGVybV1bZmllbGRdID09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLm1ldGFkYXRhW3Rlcm1dW2ZpZWxkXSA9IE9iamVjdC5jcmVhdGUobnVsbClcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBrZXlzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzW2tdXG5cbiAgICAgICAgaWYgKHRoaXMubWV0YWRhdGFbdGVybV1bZmllbGRdW2tleV0gPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy5tZXRhZGF0YVt0ZXJtXVtmaWVsZF1ba2V5XSA9IG90aGVyTWF0Y2hEYXRhLm1ldGFkYXRhW3Rlcm1dW2ZpZWxkXVtrZXldXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5tZXRhZGF0YVt0ZXJtXVtmaWVsZF1ba2V5XSA9IHRoaXMubWV0YWRhdGFbdGVybV1bZmllbGRdW2tleV0uY29uY2F0KG90aGVyTWF0Y2hEYXRhLm1ldGFkYXRhW3Rlcm1dW2ZpZWxkXVtrZXldKVxuICAgICAgICB9XG5cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBBZGQgbWV0YWRhdGEgZm9yIGEgdGVybS9maWVsZCBwYWlyIHRvIHRoaXMgaW5zdGFuY2Ugb2YgbWF0Y2ggZGF0YS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdGVybSAtIFRoZSB0ZXJtIHRoaXMgbWF0Y2ggZGF0YSBpcyBhc3NvY2lhdGVkIHdpdGhcbiAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCAtIFRoZSBmaWVsZCBpbiB3aGljaCB0aGUgdGVybSB3YXMgZm91bmRcbiAqIEBwYXJhbSB7b2JqZWN0fSBtZXRhZGF0YSAtIFRoZSBtZXRhZGF0YSByZWNvcmRlZCBhYm91dCB0aGlzIHRlcm0gaW4gdGhpcyBmaWVsZFxuICovXG5sdW5yLk1hdGNoRGF0YS5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKHRlcm0sIGZpZWxkLCBtZXRhZGF0YSkge1xuICBpZiAoISh0ZXJtIGluIHRoaXMubWV0YWRhdGEpKSB7XG4gICAgdGhpcy5tZXRhZGF0YVt0ZXJtXSA9IE9iamVjdC5jcmVhdGUobnVsbClcbiAgICB0aGlzLm1ldGFkYXRhW3Rlcm1dW2ZpZWxkXSA9IG1ldGFkYXRhXG4gICAgcmV0dXJuXG4gIH1cblxuICBpZiAoIShmaWVsZCBpbiB0aGlzLm1ldGFkYXRhW3Rlcm1dKSkge1xuICAgIHRoaXMubWV0YWRhdGFbdGVybV1bZmllbGRdID0gbWV0YWRhdGFcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBtZXRhZGF0YUtleXMgPSBPYmplY3Qua2V5cyhtZXRhZGF0YSlcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG1ldGFkYXRhS2V5cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBrZXkgPSBtZXRhZGF0YUtleXNbaV1cblxuICAgIGlmIChrZXkgaW4gdGhpcy5tZXRhZGF0YVt0ZXJtXVtmaWVsZF0pIHtcbiAgICAgIHRoaXMubWV0YWRhdGFbdGVybV1bZmllbGRdW2tleV0gPSB0aGlzLm1ldGFkYXRhW3Rlcm1dW2ZpZWxkXVtrZXldLmNvbmNhdChtZXRhZGF0YVtrZXldKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm1ldGFkYXRhW3Rlcm1dW2ZpZWxkXVtrZXldID0gbWV0YWRhdGFba2V5XVxuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBBIGx1bnIuUXVlcnkgcHJvdmlkZXMgYSBwcm9ncmFtbWF0aWMgd2F5IG9mIGRlZmluaW5nIHF1ZXJpZXMgdG8gYmUgcGVyZm9ybWVkXG4gKiBhZ2FpbnN0IGEge0BsaW5rIGx1bnIuSW5kZXh9LlxuICpcbiAqIFByZWZlciBjb25zdHJ1Y3RpbmcgYSBsdW5yLlF1ZXJ5IHVzaW5nIHRoZSB7QGxpbmsgbHVuci5JbmRleCNxdWVyeX0gbWV0aG9kXG4gKiBzbyB0aGUgcXVlcnkgb2JqZWN0IGlzIHByZS1pbml0aWFsaXplZCB3aXRoIHRoZSByaWdodCBpbmRleCBmaWVsZHMuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcHJvcGVydHkge2x1bnIuUXVlcnl+Q2xhdXNlW119IGNsYXVzZXMgLSBBbiBhcnJheSBvZiBxdWVyeSBjbGF1c2VzLlxuICogQHByb3BlcnR5IHtzdHJpbmdbXX0gYWxsRmllbGRzIC0gQW4gYXJyYXkgb2YgYWxsIGF2YWlsYWJsZSBmaWVsZHMgaW4gYSBsdW5yLkluZGV4LlxuICovXG5sdW5yLlF1ZXJ5ID0gZnVuY3Rpb24gKGFsbEZpZWxkcykge1xuICB0aGlzLmNsYXVzZXMgPSBbXVxuICB0aGlzLmFsbEZpZWxkcyA9IGFsbEZpZWxkc1xufVxuXG4vKipcbiAqIENvbnN0YW50cyBmb3IgaW5kaWNhdGluZyB3aGF0IGtpbmQgb2YgYXV0b21hdGljIHdpbGRjYXJkIGluc2VydGlvbiB3aWxsIGJlIHVzZWQgd2hlbiBjb25zdHJ1Y3RpbmcgYSBxdWVyeSBjbGF1c2UuXG4gKlxuICogVGhpcyBhbGxvd3Mgd2lsZGNhcmRzIHRvIGJlIGFkZGVkIHRvIHRoZSBiZWdpbm5pbmcgYW5kIGVuZCBvZiBhIHRlcm0gd2l0aG91dCBoYXZpbmcgdG8gbWFudWFsbHkgZG8gYW55IHN0cmluZ1xuICogY29uY2F0ZW5hdGlvbi5cbiAqXG4gKiBUaGUgd2lsZGNhcmQgY29uc3RhbnRzIGNhbiBiZSBiaXR3aXNlIGNvbWJpbmVkIHRvIHNlbGVjdCBib3RoIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHdpbGRjYXJkcy5cbiAqXG4gKiBAY29uc3RhbnRcbiAqIEBkZWZhdWx0XG4gKiBAcHJvcGVydHkge251bWJlcn0gd2lsZGNhcmQuTk9ORSAtIFRoZSB0ZXJtIHdpbGwgaGF2ZSBubyB3aWxkY2FyZHMgaW5zZXJ0ZWQsIHRoaXMgaXMgdGhlIGRlZmF1bHQgYmVoYXZpb3VyXG4gKiBAcHJvcGVydHkge251bWJlcn0gd2lsZGNhcmQuTEVBRElORyAtIFByZXBlbmQgdGhlIHRlcm0gd2l0aCBhIHdpbGRjYXJkLCB1bmxlc3MgYSBsZWFkaW5nIHdpbGRjYXJkIGFscmVhZHkgZXhpc3RzXG4gKiBAcHJvcGVydHkge251bWJlcn0gd2lsZGNhcmQuVFJBSUxJTkcgLSBBcHBlbmQgYSB3aWxkY2FyZCB0byB0aGUgdGVybSwgdW5sZXNzIGEgdHJhaWxpbmcgd2lsZGNhcmQgYWxyZWFkeSBleGlzdHNcbiAqIEBzZWUgbHVuci5RdWVyeX5DbGF1c2VcbiAqIEBzZWUgbHVuci5RdWVyeSNjbGF1c2VcbiAqIEBzZWUgbHVuci5RdWVyeSN0ZXJtXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5xdWVyeSB0ZXJtIHdpdGggdHJhaWxpbmcgd2lsZGNhcmQ8L2NhcHRpb24+XG4gKiBxdWVyeS50ZXJtKCdmb28nLCB7IHdpbGRjYXJkOiBsdW5yLlF1ZXJ5LndpbGRjYXJkLlRSQUlMSU5HIH0pXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5xdWVyeSB0ZXJtIHdpdGggbGVhZGluZyBhbmQgdHJhaWxpbmcgd2lsZGNhcmQ8L2NhcHRpb24+XG4gKiBxdWVyeS50ZXJtKCdmb28nLCB7XG4gKiAgIHdpbGRjYXJkOiBsdW5yLlF1ZXJ5LndpbGRjYXJkLkxFQURJTkcgfCBsdW5yLlF1ZXJ5LndpbGRjYXJkLlRSQUlMSU5HXG4gKiB9KVxuICovXG5cbmx1bnIuUXVlcnkud2lsZGNhcmQgPSBuZXcgU3RyaW5nIChcIipcIilcbmx1bnIuUXVlcnkud2lsZGNhcmQuTk9ORSA9IDBcbmx1bnIuUXVlcnkud2lsZGNhcmQuTEVBRElORyA9IDFcbmx1bnIuUXVlcnkud2lsZGNhcmQuVFJBSUxJTkcgPSAyXG5cbi8qKlxuICogQ29uc3RhbnRzIGZvciBpbmRpY2F0aW5nIHdoYXQga2luZCBvZiBwcmVzZW5jZSBhIHRlcm0gbXVzdCBoYXZlIGluIG1hdGNoaW5nIGRvY3VtZW50cy5cbiAqXG4gKiBAY29uc3RhbnRcbiAqIEBlbnVtIHtudW1iZXJ9XG4gKiBAc2VlIGx1bnIuUXVlcnl+Q2xhdXNlXG4gKiBAc2VlIGx1bnIuUXVlcnkjY2xhdXNlXG4gKiBAc2VlIGx1bnIuUXVlcnkjdGVybVxuICogQGV4YW1wbGUgPGNhcHRpb24+cXVlcnkgdGVybSB3aXRoIHJlcXVpcmVkIHByZXNlbmNlPC9jYXB0aW9uPlxuICogcXVlcnkudGVybSgnZm9vJywgeyBwcmVzZW5jZTogbHVuci5RdWVyeS5wcmVzZW5jZS5SRVFVSVJFRCB9KVxuICovXG5sdW5yLlF1ZXJ5LnByZXNlbmNlID0ge1xuICAvKipcbiAgICogVGVybSdzIHByZXNlbmNlIGluIGEgZG9jdW1lbnQgaXMgb3B0aW9uYWwsIHRoaXMgaXMgdGhlIGRlZmF1bHQgdmFsdWUuXG4gICAqL1xuICBPUFRJT05BTDogMSxcblxuICAvKipcbiAgICogVGVybSdzIHByZXNlbmNlIGluIGEgZG9jdW1lbnQgaXMgcmVxdWlyZWQsIGRvY3VtZW50cyB0aGF0IGRvIG5vdCBjb250YWluXG4gICAqIHRoaXMgdGVybSB3aWxsIG5vdCBiZSByZXR1cm5lZC5cbiAgICovXG4gIFJFUVVJUkVEOiAyLFxuXG4gIC8qKlxuICAgKiBUZXJtJ3MgcHJlc2VuY2UgaW4gYSBkb2N1bWVudCBpcyBwcm9oaWJpdGVkLCBkb2N1bWVudHMgdGhhdCBkbyBjb250YWluXG4gICAqIHRoaXMgdGVybSB3aWxsIG5vdCBiZSByZXR1cm5lZC5cbiAgICovXG4gIFBST0hJQklURUQ6IDNcbn1cblxuLyoqXG4gKiBBIHNpbmdsZSBjbGF1c2UgaW4gYSB7QGxpbmsgbHVuci5RdWVyeX0gY29udGFpbnMgYSB0ZXJtIGFuZCBkZXRhaWxzIG9uIGhvdyB0b1xuICogbWF0Y2ggdGhhdCB0ZXJtIGFnYWluc3QgYSB7QGxpbmsgbHVuci5JbmRleH0uXG4gKlxuICogQHR5cGVkZWYge09iamVjdH0gbHVuci5RdWVyeX5DbGF1c2VcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nW119IGZpZWxkcyAtIFRoZSBmaWVsZHMgaW4gYW4gaW5kZXggdGhpcyBjbGF1c2Ugc2hvdWxkIGJlIG1hdGNoZWQgYWdhaW5zdC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbYm9vc3Q9MV0gLSBBbnkgYm9vc3QgdGhhdCBzaG91bGQgYmUgYXBwbGllZCB3aGVuIG1hdGNoaW5nIHRoaXMgY2xhdXNlLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtlZGl0RGlzdGFuY2VdIC0gV2hldGhlciB0aGUgdGVybSBzaG91bGQgaGF2ZSBmdXp6eSBtYXRjaGluZyBhcHBsaWVkLCBhbmQgaG93IGZ1enp5IHRoZSBtYXRjaCBzaG91bGQgYmUuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFt1c2VQaXBlbGluZV0gLSBXaGV0aGVyIHRoZSB0ZXJtIHNob3VsZCBiZSBwYXNzZWQgdGhyb3VnaCB0aGUgc2VhcmNoIHBpcGVsaW5lLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFt3aWxkY2FyZD1sdW5yLlF1ZXJ5LndpbGRjYXJkLk5PTkVdIC0gV2hldGhlciB0aGUgdGVybSBzaG91bGQgaGF2ZSB3aWxkY2FyZHMgYXBwZW5kZWQgb3IgcHJlcGVuZGVkLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtwcmVzZW5jZT1sdW5yLlF1ZXJ5LnByZXNlbmNlLk9QVElPTkFMXSAtIFRoZSB0ZXJtcyBwcmVzZW5jZSBpbiBhbnkgbWF0Y2hpbmcgZG9jdW1lbnRzLlxuICovXG5cbi8qKlxuICogQWRkcyBhIHtAbGluayBsdW5yLlF1ZXJ5fkNsYXVzZX0gdG8gdGhpcyBxdWVyeS5cbiAqXG4gKiBVbmxlc3MgdGhlIGNsYXVzZSBjb250YWlucyB0aGUgZmllbGRzIHRvIGJlIG1hdGNoZWQgYWxsIGZpZWxkcyB3aWxsIGJlIG1hdGNoZWQuIEluIGFkZGl0aW9uXG4gKiBhIGRlZmF1bHQgYm9vc3Qgb2YgMSBpcyBhcHBsaWVkIHRvIHRoZSBjbGF1c2UuXG4gKlxuICogQHBhcmFtIHtsdW5yLlF1ZXJ5fkNsYXVzZX0gY2xhdXNlIC0gVGhlIGNsYXVzZSB0byBhZGQgdG8gdGhpcyBxdWVyeS5cbiAqIEBzZWUgbHVuci5RdWVyeX5DbGF1c2VcbiAqIEByZXR1cm5zIHtsdW5yLlF1ZXJ5fVxuICovXG5sdW5yLlF1ZXJ5LnByb3RvdHlwZS5jbGF1c2UgPSBmdW5jdGlvbiAoY2xhdXNlKSB7XG4gIGlmICghKCdmaWVsZHMnIGluIGNsYXVzZSkpIHtcbiAgICBjbGF1c2UuZmllbGRzID0gdGhpcy5hbGxGaWVsZHNcbiAgfVxuXG4gIGlmICghKCdib29zdCcgaW4gY2xhdXNlKSkge1xuICAgIGNsYXVzZS5ib29zdCA9IDFcbiAgfVxuXG4gIGlmICghKCd1c2VQaXBlbGluZScgaW4gY2xhdXNlKSkge1xuICAgIGNsYXVzZS51c2VQaXBlbGluZSA9IHRydWVcbiAgfVxuXG4gIGlmICghKCd3aWxkY2FyZCcgaW4gY2xhdXNlKSkge1xuICAgIGNsYXVzZS53aWxkY2FyZCA9IGx1bnIuUXVlcnkud2lsZGNhcmQuTk9ORVxuICB9XG5cbiAgaWYgKChjbGF1c2Uud2lsZGNhcmQgJiBsdW5yLlF1ZXJ5LndpbGRjYXJkLkxFQURJTkcpICYmIChjbGF1c2UudGVybS5jaGFyQXQoMCkgIT0gbHVuci5RdWVyeS53aWxkY2FyZCkpIHtcbiAgICBjbGF1c2UudGVybSA9IFwiKlwiICsgY2xhdXNlLnRlcm1cbiAgfVxuXG4gIGlmICgoY2xhdXNlLndpbGRjYXJkICYgbHVuci5RdWVyeS53aWxkY2FyZC5UUkFJTElORykgJiYgKGNsYXVzZS50ZXJtLnNsaWNlKC0xKSAhPSBsdW5yLlF1ZXJ5LndpbGRjYXJkKSkge1xuICAgIGNsYXVzZS50ZXJtID0gXCJcIiArIGNsYXVzZS50ZXJtICsgXCIqXCJcbiAgfVxuXG4gIGlmICghKCdwcmVzZW5jZScgaW4gY2xhdXNlKSkge1xuICAgIGNsYXVzZS5wcmVzZW5jZSA9IGx1bnIuUXVlcnkucHJlc2VuY2UuT1BUSU9OQUxcbiAgfVxuXG4gIHRoaXMuY2xhdXNlcy5wdXNoKGNsYXVzZSlcblxuICByZXR1cm4gdGhpc1xufVxuXG4vKipcbiAqIEEgbmVnYXRlZCBxdWVyeSBpcyBvbmUgaW4gd2hpY2ggZXZlcnkgY2xhdXNlIGhhcyBhIHByZXNlbmNlIG9mXG4gKiBwcm9oaWJpdGVkLiBUaGVzZSBxdWVyaWVzIHJlcXVpcmUgc29tZSBzcGVjaWFsIHByb2Nlc3NpbmcgdG8gcmV0dXJuXG4gKiB0aGUgZXhwZWN0ZWQgcmVzdWx0cy5cbiAqXG4gKiBAcmV0dXJucyBib29sZWFuXG4gKi9cbmx1bnIuUXVlcnkucHJvdG90eXBlLmlzTmVnYXRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNsYXVzZXMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAodGhpcy5jbGF1c2VzW2ldLnByZXNlbmNlICE9IGx1bnIuUXVlcnkucHJlc2VuY2UuUFJPSElCSVRFRCkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWVcbn1cblxuLyoqXG4gKiBBZGRzIGEgdGVybSB0byB0aGUgY3VycmVudCBxdWVyeSwgdW5kZXIgdGhlIGNvdmVycyB0aGlzIHdpbGwgY3JlYXRlIGEge0BsaW5rIGx1bnIuUXVlcnl+Q2xhdXNlfVxuICogdG8gdGhlIGxpc3Qgb2YgY2xhdXNlcyB0aGF0IG1ha2UgdXAgdGhpcyBxdWVyeS5cbiAqXG4gKiBUaGUgdGVybSBpcyB1c2VkIGFzIGlzLCBpLmUuIG5vIHRva2VuaXphdGlvbiB3aWxsIGJlIHBlcmZvcm1lZCBieSB0aGlzIG1ldGhvZC4gSW5zdGVhZCBjb252ZXJzaW9uXG4gKiB0byBhIHRva2VuIG9yIHRva2VuLWxpa2Ugc3RyaW5nIHNob3VsZCBiZSBkb25lIGJlZm9yZSBjYWxsaW5nIHRoaXMgbWV0aG9kLlxuICpcbiAqIFRoZSB0ZXJtIHdpbGwgYmUgY29udmVydGVkIHRvIGEgc3RyaW5nIGJ5IGNhbGxpbmcgYHRvU3RyaW5nYC4gTXVsdGlwbGUgdGVybXMgY2FuIGJlIHBhc3NlZCBhcyBhblxuICogYXJyYXksIGVhY2ggdGVybSBpbiB0aGUgYXJyYXkgd2lsbCBzaGFyZSB0aGUgc2FtZSBvcHRpb25zLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fG9iamVjdFtdfSB0ZXJtIC0gVGhlIHRlcm0ocykgdG8gYWRkIHRvIHRoZSBxdWVyeS5cbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gLSBBbnkgYWRkaXRpb25hbCBwcm9wZXJ0aWVzIHRvIGFkZCB0byB0aGUgcXVlcnkgY2xhdXNlLlxuICogQHJldHVybnMge2x1bnIuUXVlcnl9XG4gKiBAc2VlIGx1bnIuUXVlcnkjY2xhdXNlXG4gKiBAc2VlIGx1bnIuUXVlcnl+Q2xhdXNlXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5hZGRpbmcgYSBzaW5nbGUgdGVybSB0byBhIHF1ZXJ5PC9jYXB0aW9uPlxuICogcXVlcnkudGVybShcImZvb1wiKVxuICogQGV4YW1wbGUgPGNhcHRpb24+YWRkaW5nIGEgc2luZ2xlIHRlcm0gdG8gYSBxdWVyeSBhbmQgc3BlY2lmeWluZyBzZWFyY2ggZmllbGRzLCB0ZXJtIGJvb3N0IGFuZCBhdXRvbWF0aWMgdHJhaWxpbmcgd2lsZGNhcmQ8L2NhcHRpb24+XG4gKiBxdWVyeS50ZXJtKFwiZm9vXCIsIHtcbiAqICAgZmllbGRzOiBbXCJ0aXRsZVwiXSxcbiAqICAgYm9vc3Q6IDEwLFxuICogICB3aWxkY2FyZDogbHVuci5RdWVyeS53aWxkY2FyZC5UUkFJTElOR1xuICogfSlcbiAqIEBleGFtcGxlIDxjYXB0aW9uPnVzaW5nIGx1bnIudG9rZW5pemVyIHRvIGNvbnZlcnQgYSBzdHJpbmcgdG8gdG9rZW5zIGJlZm9yZSB1c2luZyB0aGVtIGFzIHRlcm1zPC9jYXB0aW9uPlxuICogcXVlcnkudGVybShsdW5yLnRva2VuaXplcihcImZvbyBiYXJcIikpXG4gKi9cbmx1bnIuUXVlcnkucHJvdG90eXBlLnRlcm0gPSBmdW5jdGlvbiAodGVybSwgb3B0aW9ucykge1xuICBpZiAoQXJyYXkuaXNBcnJheSh0ZXJtKSkge1xuICAgIHRlcm0uZm9yRWFjaChmdW5jdGlvbiAodCkgeyB0aGlzLnRlcm0odCwgbHVuci51dGlscy5jbG9uZShvcHRpb25zKSkgfSwgdGhpcylcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgdmFyIGNsYXVzZSA9IG9wdGlvbnMgfHwge31cbiAgY2xhdXNlLnRlcm0gPSB0ZXJtLnRvU3RyaW5nKClcblxuICB0aGlzLmNsYXVzZShjbGF1c2UpXG5cbiAgcmV0dXJuIHRoaXNcbn1cbmx1bnIuUXVlcnlQYXJzZUVycm9yID0gZnVuY3Rpb24gKG1lc3NhZ2UsIHN0YXJ0LCBlbmQpIHtcbiAgdGhpcy5uYW1lID0gXCJRdWVyeVBhcnNlRXJyb3JcIlxuICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlXG4gIHRoaXMuc3RhcnQgPSBzdGFydFxuICB0aGlzLmVuZCA9IGVuZFxufVxuXG5sdW5yLlF1ZXJ5UGFyc2VFcnJvci5wcm90b3R5cGUgPSBuZXcgRXJyb3Jcbmx1bnIuUXVlcnlMZXhlciA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgdGhpcy5sZXhlbWVzID0gW11cbiAgdGhpcy5zdHIgPSBzdHJcbiAgdGhpcy5sZW5ndGggPSBzdHIubGVuZ3RoXG4gIHRoaXMucG9zID0gMFxuICB0aGlzLnN0YXJ0ID0gMFxuICB0aGlzLmVzY2FwZUNoYXJQb3NpdGlvbnMgPSBbXVxufVxuXG5sdW5yLlF1ZXJ5TGV4ZXIucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YXRlID0gbHVuci5RdWVyeUxleGVyLmxleFRleHRcblxuICB3aGlsZSAoc3RhdGUpIHtcbiAgICBzdGF0ZSA9IHN0YXRlKHRoaXMpXG4gIH1cbn1cblxubHVuci5RdWVyeUxleGVyLnByb3RvdHlwZS5zbGljZVN0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN1YlNsaWNlcyA9IFtdLFxuICAgICAgc2xpY2VTdGFydCA9IHRoaXMuc3RhcnQsXG4gICAgICBzbGljZUVuZCA9IHRoaXMucG9zXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmVzY2FwZUNoYXJQb3NpdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICBzbGljZUVuZCA9IHRoaXMuZXNjYXBlQ2hhclBvc2l0aW9uc1tpXVxuICAgIHN1YlNsaWNlcy5wdXNoKHRoaXMuc3RyLnNsaWNlKHNsaWNlU3RhcnQsIHNsaWNlRW5kKSlcbiAgICBzbGljZVN0YXJ0ID0gc2xpY2VFbmQgKyAxXG4gIH1cblxuICBzdWJTbGljZXMucHVzaCh0aGlzLnN0ci5zbGljZShzbGljZVN0YXJ0LCB0aGlzLnBvcykpXG4gIHRoaXMuZXNjYXBlQ2hhclBvc2l0aW9ucy5sZW5ndGggPSAwXG5cbiAgcmV0dXJuIHN1YlNsaWNlcy5qb2luKCcnKVxufVxuXG5sdW5yLlF1ZXJ5TGV4ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiAodHlwZSkge1xuICB0aGlzLmxleGVtZXMucHVzaCh7XG4gICAgdHlwZTogdHlwZSxcbiAgICBzdHI6IHRoaXMuc2xpY2VTdHJpbmcoKSxcbiAgICBzdGFydDogdGhpcy5zdGFydCxcbiAgICBlbmQ6IHRoaXMucG9zXG4gIH0pXG5cbiAgdGhpcy5zdGFydCA9IHRoaXMucG9zXG59XG5cbmx1bnIuUXVlcnlMZXhlci5wcm90b3R5cGUuZXNjYXBlQ2hhcmFjdGVyID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmVzY2FwZUNoYXJQb3NpdGlvbnMucHVzaCh0aGlzLnBvcyAtIDEpXG4gIHRoaXMucG9zICs9IDFcbn1cblxubHVuci5RdWVyeUxleGVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5wb3MgPj0gdGhpcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gbHVuci5RdWVyeUxleGVyLkVPU1xuICB9XG5cbiAgdmFyIGNoYXIgPSB0aGlzLnN0ci5jaGFyQXQodGhpcy5wb3MpXG4gIHRoaXMucG9zICs9IDFcbiAgcmV0dXJuIGNoYXJcbn1cblxubHVuci5RdWVyeUxleGVyLnByb3RvdHlwZS53aWR0aCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMucG9zIC0gdGhpcy5zdGFydFxufVxuXG5sdW5yLlF1ZXJ5TGV4ZXIucHJvdG90eXBlLmlnbm9yZSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuc3RhcnQgPT0gdGhpcy5wb3MpIHtcbiAgICB0aGlzLnBvcyArPSAxXG4gIH1cblxuICB0aGlzLnN0YXJ0ID0gdGhpcy5wb3Ncbn1cblxubHVuci5RdWVyeUxleGVyLnByb3RvdHlwZS5iYWNrdXAgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMucG9zIC09IDFcbn1cblxubHVuci5RdWVyeUxleGVyLnByb3RvdHlwZS5hY2NlcHREaWdpdFJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGNoYXIsIGNoYXJDb2RlXG5cbiAgZG8ge1xuICAgIGNoYXIgPSB0aGlzLm5leHQoKVxuICAgIGNoYXJDb2RlID0gY2hhci5jaGFyQ29kZUF0KDApXG4gIH0gd2hpbGUgKGNoYXJDb2RlID4gNDcgJiYgY2hhckNvZGUgPCA1OClcblxuICBpZiAoY2hhciAhPSBsdW5yLlF1ZXJ5TGV4ZXIuRU9TKSB7XG4gICAgdGhpcy5iYWNrdXAoKVxuICB9XG59XG5cbmx1bnIuUXVlcnlMZXhlci5wcm90b3R5cGUubW9yZSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMucG9zIDwgdGhpcy5sZW5ndGhcbn1cblxubHVuci5RdWVyeUxleGVyLkVPUyA9ICdFT1MnXG5sdW5yLlF1ZXJ5TGV4ZXIuRklFTEQgPSAnRklFTEQnXG5sdW5yLlF1ZXJ5TGV4ZXIuVEVSTSA9ICdURVJNJ1xubHVuci5RdWVyeUxleGVyLkVESVRfRElTVEFOQ0UgPSAnRURJVF9ESVNUQU5DRSdcbmx1bnIuUXVlcnlMZXhlci5CT09TVCA9ICdCT09TVCdcbmx1bnIuUXVlcnlMZXhlci5QUkVTRU5DRSA9ICdQUkVTRU5DRSdcblxubHVuci5RdWVyeUxleGVyLmxleEZpZWxkID0gZnVuY3Rpb24gKGxleGVyKSB7XG4gIGxleGVyLmJhY2t1cCgpXG4gIGxleGVyLmVtaXQobHVuci5RdWVyeUxleGVyLkZJRUxEKVxuICBsZXhlci5pZ25vcmUoKVxuICByZXR1cm4gbHVuci5RdWVyeUxleGVyLmxleFRleHRcbn1cblxubHVuci5RdWVyeUxleGVyLmxleFRlcm0gPSBmdW5jdGlvbiAobGV4ZXIpIHtcbiAgaWYgKGxleGVyLndpZHRoKCkgPiAxKSB7XG4gICAgbGV4ZXIuYmFja3VwKClcbiAgICBsZXhlci5lbWl0KGx1bnIuUXVlcnlMZXhlci5URVJNKVxuICB9XG5cbiAgbGV4ZXIuaWdub3JlKClcblxuICBpZiAobGV4ZXIubW9yZSgpKSB7XG4gICAgcmV0dXJuIGx1bnIuUXVlcnlMZXhlci5sZXhUZXh0XG4gIH1cbn1cblxubHVuci5RdWVyeUxleGVyLmxleEVkaXREaXN0YW5jZSA9IGZ1bmN0aW9uIChsZXhlcikge1xuICBsZXhlci5pZ25vcmUoKVxuICBsZXhlci5hY2NlcHREaWdpdFJ1bigpXG4gIGxleGVyLmVtaXQobHVuci5RdWVyeUxleGVyLkVESVRfRElTVEFOQ0UpXG4gIHJldHVybiBsdW5yLlF1ZXJ5TGV4ZXIubGV4VGV4dFxufVxuXG5sdW5yLlF1ZXJ5TGV4ZXIubGV4Qm9vc3QgPSBmdW5jdGlvbiAobGV4ZXIpIHtcbiAgbGV4ZXIuaWdub3JlKClcbiAgbGV4ZXIuYWNjZXB0RGlnaXRSdW4oKVxuICBsZXhlci5lbWl0KGx1bnIuUXVlcnlMZXhlci5CT09TVClcbiAgcmV0dXJuIGx1bnIuUXVlcnlMZXhlci5sZXhUZXh0XG59XG5cbmx1bnIuUXVlcnlMZXhlci5sZXhFT1MgPSBmdW5jdGlvbiAobGV4ZXIpIHtcbiAgaWYgKGxleGVyLndpZHRoKCkgPiAwKSB7XG4gICAgbGV4ZXIuZW1pdChsdW5yLlF1ZXJ5TGV4ZXIuVEVSTSlcbiAgfVxufVxuXG4vLyBUaGlzIG1hdGNoZXMgdGhlIHNlcGFyYXRvciB1c2VkIHdoZW4gdG9rZW5pc2luZyBmaWVsZHNcbi8vIHdpdGhpbiBhIGRvY3VtZW50LiBUaGVzZSBzaG91bGQgbWF0Y2ggb3RoZXJ3aXNlIGl0IGlzXG4vLyBub3QgcG9zc2libGUgdG8gc2VhcmNoIGZvciBzb21lIHRva2VucyB3aXRoaW4gYSBkb2N1bWVudC5cbi8vXG4vLyBJdCBpcyBwb3NzaWJsZSBmb3IgdGhlIHVzZXIgdG8gY2hhbmdlIHRoZSBzZXBhcmF0b3Igb24gdGhlXG4vLyB0b2tlbml6ZXIgc28gaXQgX21pZ2h0XyBjbGFzaCB3aXRoIGFueSBvdGhlciBvZiB0aGUgc3BlY2lhbFxuLy8gY2hhcmFjdGVycyBhbHJlYWR5IHVzZWQgd2l0aGluIHRoZSBzZWFyY2ggc3RyaW5nLCBlLmcuIDouXG4vL1xuLy8gVGhpcyBtZWFucyB0aGF0IGl0IGlzIHBvc3NpYmxlIHRvIGNoYW5nZSB0aGUgc2VwYXJhdG9yIGluXG4vLyBzdWNoIGEgd2F5IHRoYXQgbWFrZXMgc29tZSB3b3JkcyB1bnNlYXJjaGFibGUgdXNpbmcgYSBzZWFyY2hcbi8vIHN0cmluZy5cbmx1bnIuUXVlcnlMZXhlci50ZXJtU2VwYXJhdG9yID0gbHVuci50b2tlbml6ZXIuc2VwYXJhdG9yXG5cbmx1bnIuUXVlcnlMZXhlci5sZXhUZXh0ID0gZnVuY3Rpb24gKGxleGVyKSB7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgdmFyIGNoYXIgPSBsZXhlci5uZXh0KClcblxuICAgIGlmIChjaGFyID09IGx1bnIuUXVlcnlMZXhlci5FT1MpIHtcbiAgICAgIHJldHVybiBsdW5yLlF1ZXJ5TGV4ZXIubGV4RU9TXG4gICAgfVxuXG4gICAgLy8gRXNjYXBlIGNoYXJhY3RlciBpcyAnXFwnXG4gICAgaWYgKGNoYXIuY2hhckNvZGVBdCgwKSA9PSA5Mikge1xuICAgICAgbGV4ZXIuZXNjYXBlQ2hhcmFjdGVyKClcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuXG4gICAgaWYgKGNoYXIgPT0gXCI6XCIpIHtcbiAgICAgIHJldHVybiBsdW5yLlF1ZXJ5TGV4ZXIubGV4RmllbGRcbiAgICB9XG5cbiAgICBpZiAoY2hhciA9PSBcIn5cIikge1xuICAgICAgbGV4ZXIuYmFja3VwKClcbiAgICAgIGlmIChsZXhlci53aWR0aCgpID4gMCkge1xuICAgICAgICBsZXhlci5lbWl0KGx1bnIuUXVlcnlMZXhlci5URVJNKVxuICAgICAgfVxuICAgICAgcmV0dXJuIGx1bnIuUXVlcnlMZXhlci5sZXhFZGl0RGlzdGFuY2VcbiAgICB9XG5cbiAgICBpZiAoY2hhciA9PSBcIl5cIikge1xuICAgICAgbGV4ZXIuYmFja3VwKClcbiAgICAgIGlmIChsZXhlci53aWR0aCgpID4gMCkge1xuICAgICAgICBsZXhlci5lbWl0KGx1bnIuUXVlcnlMZXhlci5URVJNKVxuICAgICAgfVxuICAgICAgcmV0dXJuIGx1bnIuUXVlcnlMZXhlci5sZXhCb29zdFxuICAgIH1cblxuICAgIC8vIFwiK1wiIGluZGljYXRlcyB0ZXJtIHByZXNlbmNlIGlzIHJlcXVpcmVkXG4gICAgLy8gY2hlY2tpbmcgZm9yIGxlbmd0aCB0byBlbnN1cmUgdGhhdCBvbmx5XG4gICAgLy8gbGVhZGluZyBcIitcIiBhcmUgY29uc2lkZXJlZFxuICAgIGlmIChjaGFyID09IFwiK1wiICYmIGxleGVyLndpZHRoKCkgPT09IDEpIHtcbiAgICAgIGxleGVyLmVtaXQobHVuci5RdWVyeUxleGVyLlBSRVNFTkNFKVxuICAgICAgcmV0dXJuIGx1bnIuUXVlcnlMZXhlci5sZXhUZXh0XG4gICAgfVxuXG4gICAgLy8gXCItXCIgaW5kaWNhdGVzIHRlcm0gcHJlc2VuY2UgaXMgcHJvaGliaXRlZFxuICAgIC8vIGNoZWNraW5nIGZvciBsZW5ndGggdG8gZW5zdXJlIHRoYXQgb25seVxuICAgIC8vIGxlYWRpbmcgXCItXCIgYXJlIGNvbnNpZGVyZWRcbiAgICBpZiAoY2hhciA9PSBcIi1cIiAmJiBsZXhlci53aWR0aCgpID09PSAxKSB7XG4gICAgICBsZXhlci5lbWl0KGx1bnIuUXVlcnlMZXhlci5QUkVTRU5DRSlcbiAgICAgIHJldHVybiBsdW5yLlF1ZXJ5TGV4ZXIubGV4VGV4dFxuICAgIH1cblxuICAgIGlmIChjaGFyLm1hdGNoKGx1bnIuUXVlcnlMZXhlci50ZXJtU2VwYXJhdG9yKSkge1xuICAgICAgcmV0dXJuIGx1bnIuUXVlcnlMZXhlci5sZXhUZXJtXG4gICAgfVxuICB9XG59XG5cbmx1bnIuUXVlcnlQYXJzZXIgPSBmdW5jdGlvbiAoc3RyLCBxdWVyeSkge1xuICB0aGlzLmxleGVyID0gbmV3IGx1bnIuUXVlcnlMZXhlciAoc3RyKVxuICB0aGlzLnF1ZXJ5ID0gcXVlcnlcbiAgdGhpcy5jdXJyZW50Q2xhdXNlID0ge31cbiAgdGhpcy5sZXhlbWVJZHggPSAwXG59XG5cbmx1bnIuUXVlcnlQYXJzZXIucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmxleGVyLnJ1bigpXG4gIHRoaXMubGV4ZW1lcyA9IHRoaXMubGV4ZXIubGV4ZW1lc1xuXG4gIHZhciBzdGF0ZSA9IGx1bnIuUXVlcnlQYXJzZXIucGFyc2VDbGF1c2VcblxuICB3aGlsZSAoc3RhdGUpIHtcbiAgICBzdGF0ZSA9IHN0YXRlKHRoaXMpXG4gIH1cblxuICByZXR1cm4gdGhpcy5xdWVyeVxufVxuXG5sdW5yLlF1ZXJ5UGFyc2VyLnByb3RvdHlwZS5wZWVrTGV4ZW1lID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5sZXhlbWVzW3RoaXMubGV4ZW1lSWR4XVxufVxuXG5sdW5yLlF1ZXJ5UGFyc2VyLnByb3RvdHlwZS5jb25zdW1lTGV4ZW1lID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbGV4ZW1lID0gdGhpcy5wZWVrTGV4ZW1lKClcbiAgdGhpcy5sZXhlbWVJZHggKz0gMVxuICByZXR1cm4gbGV4ZW1lXG59XG5cbmx1bnIuUXVlcnlQYXJzZXIucHJvdG90eXBlLm5leHRDbGF1c2UgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBjb21wbGV0ZWRDbGF1c2UgPSB0aGlzLmN1cnJlbnRDbGF1c2VcbiAgdGhpcy5xdWVyeS5jbGF1c2UoY29tcGxldGVkQ2xhdXNlKVxuICB0aGlzLmN1cnJlbnRDbGF1c2UgPSB7fVxufVxuXG5sdW5yLlF1ZXJ5UGFyc2VyLnBhcnNlQ2xhdXNlID0gZnVuY3Rpb24gKHBhcnNlcikge1xuICB2YXIgbGV4ZW1lID0gcGFyc2VyLnBlZWtMZXhlbWUoKVxuXG4gIGlmIChsZXhlbWUgPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICBzd2l0Y2ggKGxleGVtZS50eXBlKSB7XG4gICAgY2FzZSBsdW5yLlF1ZXJ5TGV4ZXIuUFJFU0VOQ0U6XG4gICAgICByZXR1cm4gbHVuci5RdWVyeVBhcnNlci5wYXJzZVByZXNlbmNlXG4gICAgY2FzZSBsdW5yLlF1ZXJ5TGV4ZXIuRklFTEQ6XG4gICAgICByZXR1cm4gbHVuci5RdWVyeVBhcnNlci5wYXJzZUZpZWxkXG4gICAgY2FzZSBsdW5yLlF1ZXJ5TGV4ZXIuVEVSTTpcbiAgICAgIHJldHVybiBsdW5yLlF1ZXJ5UGFyc2VyLnBhcnNlVGVybVxuICAgIGRlZmF1bHQ6XG4gICAgICB2YXIgZXJyb3JNZXNzYWdlID0gXCJleHBlY3RlZCBlaXRoZXIgYSBmaWVsZCBvciBhIHRlcm0sIGZvdW5kIFwiICsgbGV4ZW1lLnR5cGVcblxuICAgICAgaWYgKGxleGVtZS5zdHIubGVuZ3RoID49IDEpIHtcbiAgICAgICAgZXJyb3JNZXNzYWdlICs9IFwiIHdpdGggdmFsdWUgJ1wiICsgbGV4ZW1lLnN0ciArIFwiJ1wiXG4gICAgICB9XG5cbiAgICAgIHRocm93IG5ldyBsdW5yLlF1ZXJ5UGFyc2VFcnJvciAoZXJyb3JNZXNzYWdlLCBsZXhlbWUuc3RhcnQsIGxleGVtZS5lbmQpXG4gIH1cbn1cblxubHVuci5RdWVyeVBhcnNlci5wYXJzZVByZXNlbmNlID0gZnVuY3Rpb24gKHBhcnNlcikge1xuICB2YXIgbGV4ZW1lID0gcGFyc2VyLmNvbnN1bWVMZXhlbWUoKVxuXG4gIGlmIChsZXhlbWUgPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICBzd2l0Y2ggKGxleGVtZS5zdHIpIHtcbiAgICBjYXNlIFwiLVwiOlxuICAgICAgcGFyc2VyLmN1cnJlbnRDbGF1c2UucHJlc2VuY2UgPSBsdW5yLlF1ZXJ5LnByZXNlbmNlLlBST0hJQklURURcbiAgICAgIGJyZWFrXG4gICAgY2FzZSBcIitcIjpcbiAgICAgIHBhcnNlci5jdXJyZW50Q2xhdXNlLnByZXNlbmNlID0gbHVuci5RdWVyeS5wcmVzZW5jZS5SRVFVSVJFRFxuICAgICAgYnJlYWtcbiAgICBkZWZhdWx0OlxuICAgICAgdmFyIGVycm9yTWVzc2FnZSA9IFwidW5yZWNvZ25pc2VkIHByZXNlbmNlIG9wZXJhdG9yJ1wiICsgbGV4ZW1lLnN0ciArIFwiJ1wiXG4gICAgICB0aHJvdyBuZXcgbHVuci5RdWVyeVBhcnNlRXJyb3IgKGVycm9yTWVzc2FnZSwgbGV4ZW1lLnN0YXJ0LCBsZXhlbWUuZW5kKVxuICB9XG5cbiAgdmFyIG5leHRMZXhlbWUgPSBwYXJzZXIucGVla0xleGVtZSgpXG5cbiAgaWYgKG5leHRMZXhlbWUgPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIGVycm9yTWVzc2FnZSA9IFwiZXhwZWN0aW5nIHRlcm0gb3IgZmllbGQsIGZvdW5kIG5vdGhpbmdcIlxuICAgIHRocm93IG5ldyBsdW5yLlF1ZXJ5UGFyc2VFcnJvciAoZXJyb3JNZXNzYWdlLCBsZXhlbWUuc3RhcnQsIGxleGVtZS5lbmQpXG4gIH1cblxuICBzd2l0Y2ggKG5leHRMZXhlbWUudHlwZSkge1xuICAgIGNhc2UgbHVuci5RdWVyeUxleGVyLkZJRUxEOlxuICAgICAgcmV0dXJuIGx1bnIuUXVlcnlQYXJzZXIucGFyc2VGaWVsZFxuICAgIGNhc2UgbHVuci5RdWVyeUxleGVyLlRFUk06XG4gICAgICByZXR1cm4gbHVuci5RdWVyeVBhcnNlci5wYXJzZVRlcm1cbiAgICBkZWZhdWx0OlxuICAgICAgdmFyIGVycm9yTWVzc2FnZSA9IFwiZXhwZWN0aW5nIHRlcm0gb3IgZmllbGQsIGZvdW5kICdcIiArIG5leHRMZXhlbWUudHlwZSArIFwiJ1wiXG4gICAgICB0aHJvdyBuZXcgbHVuci5RdWVyeVBhcnNlRXJyb3IgKGVycm9yTWVzc2FnZSwgbmV4dExleGVtZS5zdGFydCwgbmV4dExleGVtZS5lbmQpXG4gIH1cbn1cblxubHVuci5RdWVyeVBhcnNlci5wYXJzZUZpZWxkID0gZnVuY3Rpb24gKHBhcnNlcikge1xuICB2YXIgbGV4ZW1lID0gcGFyc2VyLmNvbnN1bWVMZXhlbWUoKVxuXG4gIGlmIChsZXhlbWUgPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICBpZiAocGFyc2VyLnF1ZXJ5LmFsbEZpZWxkcy5pbmRleE9mKGxleGVtZS5zdHIpID09IC0xKSB7XG4gICAgdmFyIHBvc3NpYmxlRmllbGRzID0gcGFyc2VyLnF1ZXJ5LmFsbEZpZWxkcy5tYXAoZnVuY3Rpb24gKGYpIHsgcmV0dXJuIFwiJ1wiICsgZiArIFwiJ1wiIH0pLmpvaW4oJywgJyksXG4gICAgICAgIGVycm9yTWVzc2FnZSA9IFwidW5yZWNvZ25pc2VkIGZpZWxkICdcIiArIGxleGVtZS5zdHIgKyBcIicsIHBvc3NpYmxlIGZpZWxkczogXCIgKyBwb3NzaWJsZUZpZWxkc1xuXG4gICAgdGhyb3cgbmV3IGx1bnIuUXVlcnlQYXJzZUVycm9yIChlcnJvck1lc3NhZ2UsIGxleGVtZS5zdGFydCwgbGV4ZW1lLmVuZClcbiAgfVxuXG4gIHBhcnNlci5jdXJyZW50Q2xhdXNlLmZpZWxkcyA9IFtsZXhlbWUuc3RyXVxuXG4gIHZhciBuZXh0TGV4ZW1lID0gcGFyc2VyLnBlZWtMZXhlbWUoKVxuXG4gIGlmIChuZXh0TGV4ZW1lID09IHVuZGVmaW5lZCkge1xuICAgIHZhciBlcnJvck1lc3NhZ2UgPSBcImV4cGVjdGluZyB0ZXJtLCBmb3VuZCBub3RoaW5nXCJcbiAgICB0aHJvdyBuZXcgbHVuci5RdWVyeVBhcnNlRXJyb3IgKGVycm9yTWVzc2FnZSwgbGV4ZW1lLnN0YXJ0LCBsZXhlbWUuZW5kKVxuICB9XG5cbiAgc3dpdGNoIChuZXh0TGV4ZW1lLnR5cGUpIHtcbiAgICBjYXNlIGx1bnIuUXVlcnlMZXhlci5URVJNOlxuICAgICAgcmV0dXJuIGx1bnIuUXVlcnlQYXJzZXIucGFyc2VUZXJtXG4gICAgZGVmYXVsdDpcbiAgICAgIHZhciBlcnJvck1lc3NhZ2UgPSBcImV4cGVjdGluZyB0ZXJtLCBmb3VuZCAnXCIgKyBuZXh0TGV4ZW1lLnR5cGUgKyBcIidcIlxuICAgICAgdGhyb3cgbmV3IGx1bnIuUXVlcnlQYXJzZUVycm9yIChlcnJvck1lc3NhZ2UsIG5leHRMZXhlbWUuc3RhcnQsIG5leHRMZXhlbWUuZW5kKVxuICB9XG59XG5cbmx1bnIuUXVlcnlQYXJzZXIucGFyc2VUZXJtID0gZnVuY3Rpb24gKHBhcnNlcikge1xuICB2YXIgbGV4ZW1lID0gcGFyc2VyLmNvbnN1bWVMZXhlbWUoKVxuXG4gIGlmIChsZXhlbWUgPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICBwYXJzZXIuY3VycmVudENsYXVzZS50ZXJtID0gbGV4ZW1lLnN0ci50b0xvd2VyQ2FzZSgpXG5cbiAgaWYgKGxleGVtZS5zdHIuaW5kZXhPZihcIipcIikgIT0gLTEpIHtcbiAgICBwYXJzZXIuY3VycmVudENsYXVzZS51c2VQaXBlbGluZSA9IGZhbHNlXG4gIH1cblxuICB2YXIgbmV4dExleGVtZSA9IHBhcnNlci5wZWVrTGV4ZW1lKClcblxuICBpZiAobmV4dExleGVtZSA9PSB1bmRlZmluZWQpIHtcbiAgICBwYXJzZXIubmV4dENsYXVzZSgpXG4gICAgcmV0dXJuXG4gIH1cblxuICBzd2l0Y2ggKG5leHRMZXhlbWUudHlwZSkge1xuICAgIGNhc2UgbHVuci5RdWVyeUxleGVyLlRFUk06XG4gICAgICBwYXJzZXIubmV4dENsYXVzZSgpXG4gICAgICByZXR1cm4gbHVuci5RdWVyeVBhcnNlci5wYXJzZVRlcm1cbiAgICBjYXNlIGx1bnIuUXVlcnlMZXhlci5GSUVMRDpcbiAgICAgIHBhcnNlci5uZXh0Q2xhdXNlKClcbiAgICAgIHJldHVybiBsdW5yLlF1ZXJ5UGFyc2VyLnBhcnNlRmllbGRcbiAgICBjYXNlIGx1bnIuUXVlcnlMZXhlci5FRElUX0RJU1RBTkNFOlxuICAgICAgcmV0dXJuIGx1bnIuUXVlcnlQYXJzZXIucGFyc2VFZGl0RGlzdGFuY2VcbiAgICBjYXNlIGx1bnIuUXVlcnlMZXhlci5CT09TVDpcbiAgICAgIHJldHVybiBsdW5yLlF1ZXJ5UGFyc2VyLnBhcnNlQm9vc3RcbiAgICBjYXNlIGx1bnIuUXVlcnlMZXhlci5QUkVTRU5DRTpcbiAgICAgIHBhcnNlci5uZXh0Q2xhdXNlKClcbiAgICAgIHJldHVybiBsdW5yLlF1ZXJ5UGFyc2VyLnBhcnNlUHJlc2VuY2VcbiAgICBkZWZhdWx0OlxuICAgICAgdmFyIGVycm9yTWVzc2FnZSA9IFwiVW5leHBlY3RlZCBsZXhlbWUgdHlwZSAnXCIgKyBuZXh0TGV4ZW1lLnR5cGUgKyBcIidcIlxuICAgICAgdGhyb3cgbmV3IGx1bnIuUXVlcnlQYXJzZUVycm9yIChlcnJvck1lc3NhZ2UsIG5leHRMZXhlbWUuc3RhcnQsIG5leHRMZXhlbWUuZW5kKVxuICB9XG59XG5cbmx1bnIuUXVlcnlQYXJzZXIucGFyc2VFZGl0RGlzdGFuY2UgPSBmdW5jdGlvbiAocGFyc2VyKSB7XG4gIHZhciBsZXhlbWUgPSBwYXJzZXIuY29uc3VtZUxleGVtZSgpXG5cbiAgaWYgKGxleGVtZSA9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBlZGl0RGlzdGFuY2UgPSBwYXJzZUludChsZXhlbWUuc3RyLCAxMClcblxuICBpZiAoaXNOYU4oZWRpdERpc3RhbmNlKSkge1xuICAgIHZhciBlcnJvck1lc3NhZ2UgPSBcImVkaXQgZGlzdGFuY2UgbXVzdCBiZSBudW1lcmljXCJcbiAgICB0aHJvdyBuZXcgbHVuci5RdWVyeVBhcnNlRXJyb3IgKGVycm9yTWVzc2FnZSwgbGV4ZW1lLnN0YXJ0LCBsZXhlbWUuZW5kKVxuICB9XG5cbiAgcGFyc2VyLmN1cnJlbnRDbGF1c2UuZWRpdERpc3RhbmNlID0gZWRpdERpc3RhbmNlXG5cbiAgdmFyIG5leHRMZXhlbWUgPSBwYXJzZXIucGVla0xleGVtZSgpXG5cbiAgaWYgKG5leHRMZXhlbWUgPT0gdW5kZWZpbmVkKSB7XG4gICAgcGFyc2VyLm5leHRDbGF1c2UoKVxuICAgIHJldHVyblxuICB9XG5cbiAgc3dpdGNoIChuZXh0TGV4ZW1lLnR5cGUpIHtcbiAgICBjYXNlIGx1bnIuUXVlcnlMZXhlci5URVJNOlxuICAgICAgcGFyc2VyLm5leHRDbGF1c2UoKVxuICAgICAgcmV0dXJuIGx1bnIuUXVlcnlQYXJzZXIucGFyc2VUZXJtXG4gICAgY2FzZSBsdW5yLlF1ZXJ5TGV4ZXIuRklFTEQ6XG4gICAgICBwYXJzZXIubmV4dENsYXVzZSgpXG4gICAgICByZXR1cm4gbHVuci5RdWVyeVBhcnNlci5wYXJzZUZpZWxkXG4gICAgY2FzZSBsdW5yLlF1ZXJ5TGV4ZXIuRURJVF9ESVNUQU5DRTpcbiAgICAgIHJldHVybiBsdW5yLlF1ZXJ5UGFyc2VyLnBhcnNlRWRpdERpc3RhbmNlXG4gICAgY2FzZSBsdW5yLlF1ZXJ5TGV4ZXIuQk9PU1Q6XG4gICAgICByZXR1cm4gbHVuci5RdWVyeVBhcnNlci5wYXJzZUJvb3N0XG4gICAgY2FzZSBsdW5yLlF1ZXJ5TGV4ZXIuUFJFU0VOQ0U6XG4gICAgICBwYXJzZXIubmV4dENsYXVzZSgpXG4gICAgICByZXR1cm4gbHVuci5RdWVyeVBhcnNlci5wYXJzZVByZXNlbmNlXG4gICAgZGVmYXVsdDpcbiAgICAgIHZhciBlcnJvck1lc3NhZ2UgPSBcIlVuZXhwZWN0ZWQgbGV4ZW1lIHR5cGUgJ1wiICsgbmV4dExleGVtZS50eXBlICsgXCInXCJcbiAgICAgIHRocm93IG5ldyBsdW5yLlF1ZXJ5UGFyc2VFcnJvciAoZXJyb3JNZXNzYWdlLCBuZXh0TGV4ZW1lLnN0YXJ0LCBuZXh0TGV4ZW1lLmVuZClcbiAgfVxufVxuXG5sdW5yLlF1ZXJ5UGFyc2VyLnBhcnNlQm9vc3QgPSBmdW5jdGlvbiAocGFyc2VyKSB7XG4gIHZhciBsZXhlbWUgPSBwYXJzZXIuY29uc3VtZUxleGVtZSgpXG5cbiAgaWYgKGxleGVtZSA9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBib29zdCA9IHBhcnNlSW50KGxleGVtZS5zdHIsIDEwKVxuXG4gIGlmIChpc05hTihib29zdCkpIHtcbiAgICB2YXIgZXJyb3JNZXNzYWdlID0gXCJib29zdCBtdXN0IGJlIG51bWVyaWNcIlxuICAgIHRocm93IG5ldyBsdW5yLlF1ZXJ5UGFyc2VFcnJvciAoZXJyb3JNZXNzYWdlLCBsZXhlbWUuc3RhcnQsIGxleGVtZS5lbmQpXG4gIH1cblxuICBwYXJzZXIuY3VycmVudENsYXVzZS5ib29zdCA9IGJvb3N0XG5cbiAgdmFyIG5leHRMZXhlbWUgPSBwYXJzZXIucGVla0xleGVtZSgpXG5cbiAgaWYgKG5leHRMZXhlbWUgPT0gdW5kZWZpbmVkKSB7XG4gICAgcGFyc2VyLm5leHRDbGF1c2UoKVxuICAgIHJldHVyblxuICB9XG5cbiAgc3dpdGNoIChuZXh0TGV4ZW1lLnR5cGUpIHtcbiAgICBjYXNlIGx1bnIuUXVlcnlMZXhlci5URVJNOlxuICAgICAgcGFyc2VyLm5leHRDbGF1c2UoKVxuICAgICAgcmV0dXJuIGx1bnIuUXVlcnlQYXJzZXIucGFyc2VUZXJtXG4gICAgY2FzZSBsdW5yLlF1ZXJ5TGV4ZXIuRklFTEQ6XG4gICAgICBwYXJzZXIubmV4dENsYXVzZSgpXG4gICAgICByZXR1cm4gbHVuci5RdWVyeVBhcnNlci5wYXJzZUZpZWxkXG4gICAgY2FzZSBsdW5yLlF1ZXJ5TGV4ZXIuRURJVF9ESVNUQU5DRTpcbiAgICAgIHJldHVybiBsdW5yLlF1ZXJ5UGFyc2VyLnBhcnNlRWRpdERpc3RhbmNlXG4gICAgY2FzZSBsdW5yLlF1ZXJ5TGV4ZXIuQk9PU1Q6XG4gICAgICByZXR1cm4gbHVuci5RdWVyeVBhcnNlci5wYXJzZUJvb3N0XG4gICAgY2FzZSBsdW5yLlF1ZXJ5TGV4ZXIuUFJFU0VOQ0U6XG4gICAgICBwYXJzZXIubmV4dENsYXVzZSgpXG4gICAgICByZXR1cm4gbHVuci5RdWVyeVBhcnNlci5wYXJzZVByZXNlbmNlXG4gICAgZGVmYXVsdDpcbiAgICAgIHZhciBlcnJvck1lc3NhZ2UgPSBcIlVuZXhwZWN0ZWQgbGV4ZW1lIHR5cGUgJ1wiICsgbmV4dExleGVtZS50eXBlICsgXCInXCJcbiAgICAgIHRocm93IG5ldyBsdW5yLlF1ZXJ5UGFyc2VFcnJvciAoZXJyb3JNZXNzYWdlLCBuZXh0TGV4ZW1lLnN0YXJ0LCBuZXh0TGV4ZW1lLmVuZClcbiAgfVxufVxuXG4gIC8qKlxuICAgKiBleHBvcnQgdGhlIG1vZHVsZSB2aWEgQU1ELCBDb21tb25KUyBvciBhcyBhIGJyb3dzZXIgZ2xvYmFsXG4gICAqIEV4cG9ydCBjb2RlIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL3VtZGpzL3VtZC9ibG9iL21hc3Rlci9yZXR1cm5FeHBvcnRzLmpzXG4gICAqL1xuICA7KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG4gICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgLy8gQU1ELiBSZWdpc3RlciBhcyBhbiBhbm9ueW1vdXMgbW9kdWxlLlxuICAgICAgZGVmaW5lKGZhY3RvcnkpXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcbiAgICAgIC8qKlxuICAgICAgICogTm9kZS4gRG9lcyBub3Qgd29yayB3aXRoIHN0cmljdCBDb21tb25KUywgYnV0XG4gICAgICAgKiBvbmx5IENvbW1vbkpTLWxpa2UgZW52aXJvbWVudHMgdGhhdCBzdXBwb3J0IG1vZHVsZS5leHBvcnRzLFxuICAgICAgICogbGlrZSBOb2RlLlxuICAgICAgICovXG4gICAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBCcm93c2VyIGdsb2JhbHMgKHJvb3QgaXMgd2luZG93KVxuICAgICAgcm9vdC5sdW5yID0gZmFjdG9yeSgpXG4gICAgfVxuICB9KHRoaXMsIGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBKdXN0IHJldHVybiBhIHZhbHVlIHRvIGRlZmluZSB0aGUgbW9kdWxlIGV4cG9ydC5cbiAgICAgKiBUaGlzIGV4YW1wbGUgcmV0dXJucyBhbiBvYmplY3QsIGJ1dCB0aGUgbW9kdWxlXG4gICAgICogY2FuIHJldHVybiBhIGZ1bmN0aW9uIGFzIHRoZSBleHBvcnRlZCB2YWx1ZS5cbiAgICAgKi9cbiAgICByZXR1cm4gbHVuclxuICB9KSlcbn0pKCk7XG4iLCJyZXF1aXJlKFwiLi9zaGltL2FycmF5XCIpXHJcbnJlcXVpcmUoXCIuL3NoaW0vb2JqZWN0XCIpXHJcbiIsIi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5pbmNsdWRlc1xyXG5pZiAoIUFycmF5LnByb3RvdHlwZS5pbmNsdWRlcykge1xyXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBcnJheS5wcm90b3R5cGUsICdpbmNsdWRlcycsIHtcclxuICAgIHZhbHVlOiBmdW5jdGlvbihzZWFyY2hFbGVtZW50LCBmcm9tSW5kZXgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuaW5kZXhPZihzZWFyY2hFbGVtZW50LCBmcm9tSW5kZXgpICE9PSAtMVxyXG4gICAgfVxyXG4gIH0pO1xyXG59XHJcbiIsIi8vaHR0cHM6Ly90YzM5LmVzL3Byb3Bvc2FsLW9iamVjdC12YWx1ZXMtZW50cmllcy9cclxuLy9odHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1vYmplY3QtdmFsdWVzLWVudHJpZXNcclxuaWYgKCFPYmplY3QuZW50cmllcykge1xyXG4gIE9iamVjdC5lbnRyaWVzID0gZnVuY3Rpb24oIG9iaiApe1xyXG4gICAgdmFyIG93blByb3BzID0gT2JqZWN0LmtleXMoIG9iaiApLFxyXG4gICAgICBpID0gb3duUHJvcHMubGVuZ3RoLFxyXG4gICAgICByZXNBcnJheSA9IG5ldyBBcnJheShpKTsgLy8gcHJlYWxsb2NhdGUgdGhlIEFycmF5XHJcbiAgICB3aGlsZSAoaS0tKSB7XHJcbiAgICAgIHJlc0FycmF5W2ldID0gW293blByb3BzW2ldLCBvYmpbb3duUHJvcHNbaV1dXTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgcmV0dXJuIHJlc0FycmF5O1xyXG4gIH07XHJcbn1cclxuIiwicmVxdWlyZSgnLi4vZnJhbWV3b3Jrcy9zaGltJylcclxucmVxdWlyZSgnanMtcG9seWZpbGxzL2VzNScpXHJcbnJlcXVpcmUoJ2pzLXBvbHlmaWxscy9lczYnKVxyXG5cclxuaWYgKGdsb2JhbC5yaCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgZ2xvYmFsLnJoID0ge307XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZ2xvYmFsLnJoXHJcbiIsImNsYXNzIENvdW50aW5nU2VhbWFwaG9yZXtcclxuICBjb25zdHJ1Y3RvcihjYWxsYmFjayl7XHJcbiAgICB0aGlzLl9jYWxsYmFjayA9IGNhbGxiYWNrO1xyXG4gICAgdGhpcy5fY291bnQgPSAwO1xyXG4gIH1cclxuICBzaWduYWwoKXtcclxuICAgIHRoaXMuX2NvdW50Kys7XHJcbiAgICBpZih0aGlzLl9jb3VudCA+PSAwICYmIHRoaXMuX2NhbGxiYWNrKXtcclxuICAgICAgdGhpcy5fY2FsbGJhY2soKTtcclxuICAgIH1cclxuICB9XHJcbiAgd2FpdChjb3VudCl7XHJcbiAgICBsZXQgZGVjX2NvdW50ID0gY291bnQgfHwgMTtcclxuICAgIHRoaXMuX2NvdW50LT0gZGVjX2NvdW50O1xyXG4gIH1cclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDb3VudGluZ1NlYW1hcGhvcmU7IiwicmVxdWlyZShcIi4uL2xpYi9yaFwiKVxyXG5yZXF1aXJlKFwiLi4vLi4vbGVuaWVudF9zcmMvcm9ib2hlbHAvbGF5b3V0L3VybF91dGlsc1wiKVxyXG5yZXF1aXJlKFwiLi4vLi4vbGVuaWVudF9zcmMvcm9ib2hlbHAvbGF5b3V0L2luaXRcIilcclxucmVxdWlyZShcIi4uLy4uL2xlbmllbnRfc3JjL3JvYm9oZWxwL2xheW91dC9tcFwiKVxyXG5yZXF1aXJlKFwiLi4vLi4vbGVuaWVudF9zcmMvcm9ib2hlbHAvbGF5b3V0L2V4cHJlc3Npb25fYnVpbGRlclwiKVxyXG5yZXF1aXJlKFwiLi4vLi4vbGVuaWVudF9zcmMvcm9ib2hlbHAvbGF5b3V0L2Jyb3dzZXNlcXVlbmNlX2J1aWxkZXJcIilcclxucmVxdWlyZShcIi4uLy4uL2xlbmllbnRfc3JjL3JvYm9oZWxwL2xheW91dC9zZWFyY2hfZmlsZWRcIilcclxucmVxdWlyZShcIi4uLy4uL2xlbmllbnRfc3JjL3JvYm9oZWxwL2xheW91dC9sYXlvdXRmaXhcIilcclxucmVxdWlyZShcIi4uLy4uL2xlbmllbnRfc3JjL3JvYm9oZWxwL2xheW91dC9maWx0ZXJfY29udHJvbGxlclwiKVxyXG5yZXF1aXJlKFwiLi4vLi4vbGVuaWVudF9zcmMvcm9ib2hlbHAvbGF5b3V0L21vZGVybl9sYXlvdXRfY29udHJvbGxlclwiKVxyXG5yZXF1aXJlKFwiLi4vLi4vbGVuaWVudF9zcmMvcm9ib2hlbHAvbGF5b3V0L2pzX2xvYWRpbmdfY29udHJvbGxlclwiKVxyXG5yZXF1aXJlKFwiLi4vLi4vbGVuaWVudF9zcmMvcm9ib2hlbHAvbGF5b3V0L2xvYWRfcHJvamVjdHNcIilcclxucmVxdWlyZShcIi4vbGF5b3V0L3VpL2Nhcm91c2VsXCIpXHJcbnJlcXVpcmUoXCIuL2xheW91dC9ob21lX2NvbnRyb2xsZXJcIilcclxucmVxdWlyZShcIi4uLy4uL2xlbmllbnRfc3JjL2xheW91dC9zZWFyY2hfdXRpbFwiKVxyXG5yZXF1aXJlKFwiLi9sYXlvdXQvc2VhcmNoL3N1Z2dlc3Rpb24vc2VhcmNoX2NvbnRyb2xsZXJcIilcclxucmVxdWlyZShcIi4vbGF5b3V0L2Zhdm9yaXRlc19jb250cm9sbGVyXCIpXHJcbnJlcXVpcmUoXCIuL2xheW91dC90b2NfYnJlYWRjcnVtYnNfY29udHJvbGxlci5qc1wiKVxyXG5yZXF1aXJlKFwiLi4vLi4vbGVuaWVudF9zcmMvbGF5b3V0L3RvY19vcmRlclwiKVxyXG5yZXF1aXJlKFwiLi4vLi4vbGVuaWVudF9zcmMvbGF5b3V0L3RvY19jb250cm9sbGVyXCIpXHJcbnJlcXVpcmUoXCIuLi8uLi9sZW5pZW50X3NyYy9sYXlvdXQvaW5kZXhfY29udHJvbGxlclwiKVxyXG5yZXF1aXJlKFwiLi4vLi4vbGVuaWVudF9zcmMvbGF5b3V0L2dsb3NzYXJ5X2NvbnRyb2xsZXJcIilcclxucmVxdWlyZShcIi4uLy4uL2xlbmllbnRfc3JjL2xheW91dC9ldmVudF9oYW5kbGVyc1wiKVxyXG5yZXF1aXJlKFwiLi9sYXlvdXQvcmgyMDE3bGF5b3V0Y29udHJvbGxlclwiKVxyXG5yZXF1aXJlKFwiLi9sYXlvdXQvbW9kYWxfZGlhbG9nXCIpXHJcbnJlcXVpcmUoXCIuL2xheW91dC9zZWFyY2hfcmVzdWx0X2NvbnRyb2xsZXIuanNcIilcclxucmVxdWlyZShcIi4uLy4uL2xlbmllbnRfc3JjL3JvYm9oZWxwL2xheW91dC9maWx0ZXJfaGFuZGxlclwiKVxyXG5yZXF1aXJlKFwiLi9sYXlvdXQvY3VzdG9tX2J1dHRvbnNcIilcclxucmVxdWlyZShcIi4vbGF5b3V0L2V4cGFuZF9hbGxcIilcclxuIiwiY29uc3QgcmggPSByZXF1aXJlKFwiLi4vLi4vbGliL3JoXCIpLFxyXG4gIGNvbnN0cyA9IHJoLmNvbnN0cyxcclxuICBtb2RlbCA9IHJoLm1vZGVsLFxyXG4gIF8gPSByaC5fXHJcblxyXG5tb2RlbC5zdWJzY3JpYmUoY29uc3RzKCdLRVlfQ1VTVE9NX0JVVFRPTlNfQ09ORklHJyksIGNvbmZpZyA9PiB7XHJcbiAgbGV0IGJ1dHRvbnMgPSBfLm1hcChjb25maWcsIChpdGVtLCBpbmRleCkgPT4ge1xyXG4gICAgcmV0dXJuIF8uZXh0ZW5kKHtjbGFzczogYGN1c3RvbS1idXR0b24tJHtpbmRleH1gfSwgaXRlbSlcclxuICB9KVxyXG4gIG1vZGVsLnB1Ymxpc2goY29uc3RzKCdLRVlfQ1VTVE9NX0JVVFRPTlMnKSwgYnV0dG9ucylcclxufSlcclxuIiwibGV0IHJoID0gcmVxdWlyZShcIi4uLy4uL2xpYi9yaFwiKVxyXG5cclxucmgubW9kZWwuY3N1YnNjcmliZSgnRVZUX0VYUEFORF9DT0xMQVBTRV9BTEwnLCAoKSA9PiB7XHJcbiAgbGV0IGN1cnJlbnRTdGF0ZSA9IHJoLm1vZGVsLmNnZXQoJ0FMTF9BUkVfRVhQQU5ERUQnKVxyXG4gIGlmKGN1cnJlbnRTdGF0ZSkge1xyXG4gICAgcmgubW9kZWwuY3B1Ymxpc2goJ0VWVF9DT0xMQVBTRV9BTEwnKVxyXG4gIH0gZWxzZSB7XHJcbiAgICByaC5tb2RlbC5jcHVibGlzaCgnRVZUX0VYUEFORF9BTEwnKVxyXG4gIH1cclxufSlcclxuXHJcbnJoLm1vZGVsLmNzdWJzY3JpYmUoJ0VWVF9DT0xMQVBTRV9BTEwnLCAoKSA9PiB7XHJcbiAgcmgubW9kZWwuY3B1Ymxpc2goJ0FMTF9BUkVfRVhQQU5ERUQnLCBmYWxzZSlcclxufSlcclxuXHJcbnJoLm1vZGVsLmNzdWJzY3JpYmUoJ0VWVF9FWFBBTkRfQUxMJywgKCkgPT4ge1xyXG4gIHJoLm1vZGVsLmNwdWJsaXNoKCdBTExfQVJFX0VYUEFOREVEJywgdHJ1ZSlcclxufSlcclxuIiwiXHJcbmNvbnN0IHJoID0gcmVxdWlyZShcIi4uLy4uL2xpYi9yaFwiKVxyXG5jb25zdCBjb25zdHMgPSByaC5jb25zdHNcclxuXHJcbmNsYXNzIEZhdm9yaXRlc0NvbnRyb2xsZXJ7XHJcbiAgY29uc3RydWN0b3Iod2lkZ2V0KXtcclxuICAgIHRoaXMud2lkZ2V0ID0gd2lkZ2V0O1xyXG4gICAgdGhpcy5mYXZTdG9yYWdlID0gbmV3IHJoLlN0b3JhZ2UoKVxyXG4gICAgLyogSW50ZXJuYWwgZnVuY3Rpb25zIGFuZCB2YXJpYWJsZXMgKi9cclxuICAgIHRoaXMuX2xvYWRGcm9tU3RvcmFnZSA9IGZhbHNlOy8qIEZhdm9yaXRlcyBhbHJlYWR5IGxvYWRlZCBmcm9tIHN0b3JhZ2U/ICovXHJcblxyXG4gICAgdGhpcy5fZmF2TWVtb3J5U3RvcmUgPSB1bmRlZmluZWQ7LyogVmFyaWFibGUgdG8gaG9sZCBmYXZvcml0ZXMgb2JqZWN0ICovXHJcbiAgICByaC5tb2RlbC5zdWJzY3JpYmVPbmNlKGNvbnN0cygnRVZUX1BST0pFQ1RfTE9BREVEJyksICgpID0+e1xyXG4gICAgICB0aGlzLmluaXQoKTtcclxuICAgIH0pO1xyXG4gIH1cclxuICBfZ2V0VW5pcXVlSWQoKSB7XHJcbiAgICBmdW5jdGlvbiBfcDgocykge1xyXG4gICAgICBjb25zdCBwID0gKGAke01hdGgucmFuZG9tKCkudG9TdHJpbmcoMTYpfTAwMDAwMDAwMGApLnN1YnN0cigyLDgpO1xyXG4gICAgICByZXR1cm4gcyA/IGAtJHtwLnN1YnN0cigwLDQpfS0ke3Auc3Vic3RyKDQsNCl9YCA6IHAgO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIF9wOCgpICsgX3A4KHRydWUpICsgX3A4KHRydWUpICsgX3A4KCk7XHJcbiAgfVxyXG5cclxuICBudW1iZXJPZkl0ZW1zKEpTT04pIHsvKiBDb3VudCB0aGUgbnVtYmVyIG9mIGl0ZW1zIGluIGFuIG9iamVjdCAqL1xyXG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKEpTT04pLmxlbmd0aDtcclxuICB9XHJcbiAgX2dldEZhdkhUTUxFbGVtZW50cyh0eXBlKSB7XHJcbiAgICAgIC8qIEZpbmQgYWxsIGVsZW1lbnRzIGluIHRoZSBIVE1MIHRoYXQgY2FuIGhvbGQgYSBmYXZvcml0ZSB3aWRnZXQgKi9cclxuXHJcbiAgICBsZXQgYWxsRWxlbWVudHMgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImRpdlwiKTsvKiBPbmx5IGRpdnMgY2FuIGJlIGZhdm9yaXRlIGhvbGRlcnMgKi9cclxuICAgIGxldCBlbGVtZW50cyA9IFtdO1xyXG5cclxuICAgIGZvcihsZXQgaT0wOyBpPGFsbEVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGlmKGFsbEVsZW1lbnRzW2ldLmdldEF0dHJpYnV0ZShyaC5jb25zdHMoJ0ZBVkFUVFJJQlVURScpKSA9PT0gdHlwZSkge1xyXG4gICAgICAgIGVsZW1lbnRzLnB1c2goYWxsRWxlbWVudHNbaV0pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGVsZW1lbnRzO1xyXG4gIH1cclxuXHJcbiAgZ2V0TGlua1RpdGxlKGlzRmF2b3JpdGUpe1xyXG4gICAgbGV0IGxuZyA9IHJoLm1vZGVsLmdldChjb25zdHMoJ0tFWV9MTkcnKSlcclxuICAgIGlmKGlzRmF2b3JpdGUpe1xyXG4gICAgICByZXR1cm4gKGxuZyAmJiBsbmcudW5zZXRBc0Zhdm9yaXRlKSB8fCAnJztcclxuICAgIH1cclxuICAgIGVsc2VcclxuICAgIHtcclxuICAgICAgcmV0dXJuIChsbmcgJiYgbG5nLnNldEFzRmF2b3JpdGUpIHx8ICcnO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcblxyXG4gIF9sb2FkRmF2b3JpdGVzRnJvbVN0b3JhZ2UoKXtcclxuICAgICAgLyogTG9hZCBzZXR0aW5nIGZyb20gc3RvcmFnZSAqL1xyXG4gICAgbGV0IHN0b3JhZ2VPYmplY3Q7XHJcbiAgICBsZXQgbG9hZFN0cmluZyA9IHRoaXMuZmF2U3RvcmFnZS5mZXRjaChjb25zdHMoJ0ZBVlNUT1JBR0UnKSk7XHJcblxyXG4gICAgaWYodHlwZW9mKGxvYWRTdHJpbmcpID09PSBcInVuZGVmaW5lZFwiIHx8IGxvYWRTdHJpbmcgPT09IG51bGwpIHsvKiBObyBzZXR0aW5ncyB5ZXQsIGNyZWF0ZSBuZXcgb2JqZWN0LiAqL1xyXG4gICAgICBzdG9yYWdlT2JqZWN0ID0ge307XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBzdG9yYWdlT2JqZWN0ID0gSlNPTi5wYXJzZShsb2FkU3RyaW5nKTsvKiBQYXJzZSBzdHJpbmcgdG8gb2JqZWN0ICovXHJcbiAgICB9XHJcbiAgICByZXR1cm4gc3RvcmFnZU9iamVjdDtcclxuICB9XHJcblxyXG4gIF9sb2FkRmF2b3JpdGVzKCl7XHJcbiAgICBpZih0aGlzLl9sb2FkRnJvbVN0b3JhZ2UgPT09IGZhbHNlKSB7LyogT25seSBsb2FkIG9uY2UsIHRoZW4gdXNlIG9iamVjdCBpbiBtZW1vcnkuIFNhdmVzIGEgZmV3IHBhcnNpbmdzLiAqL1xyXG4gICAgICB0aGlzLl9mYXZNZW1vcnlTdG9yZSA9IHRoaXMuX2xvYWRGYXZvcml0ZXNGcm9tU3RvcmFnZSgpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXMuX2Zhdk1lbW9yeVN0b3JlO1xyXG4gIH1cclxuXHJcbiAgX3NhdmVGYXZvcml0ZXMoKXtcclxuICAgIGxldCBmYXZvcml0ZXNTdHJpbmc7XHJcbiAgICBmYXZvcml0ZXNTdHJpbmcgPSBKU09OLnN0cmluZ2lmeSh0aGlzLl9mYXZNZW1vcnlTdG9yZSk7XHJcbiAgICB0aGlzLmZhdlN0b3JhZ2UucGVyc2lzdChyaC5jb25zdHMoJ0ZBVlNUT1JBR0UnKSwgZmF2b3JpdGVzU3RyaW5nKTtcclxuICB9XHJcblxyXG4gIF91bkZhdm9yaXRlVG9waWModG9waWMpe1xyXG4gICAgZm9yKGNvbnN0IGkgaW4gdGhpcy5fZmF2TWVtb3J5U3RvcmUpIHtcclxuICAgICAgY29uc3QgY3VycmVudCA9IHRoaXMuX2Zhdk1lbW9yeVN0b3JlW2ldO1xyXG4gICAgICBpZihjdXJyZW50LnRvcGljID09PSAgdG9waWMpIHtcclxuICAgICAgICBkZWxldGUgdGhpcy5fZmF2TWVtb3J5U3RvcmVbaV07XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHRoaXMuX3NhdmVGYXZvcml0ZXMoKTtcclxuICAgIHJoLm1vZGVsLnB1Ymxpc2gocmguY29uc3RzKCdFVkVOVEZBVkNIQU5HRScpLCBudWxsKTsvKiBQdWJsaXNoIHNvIGZhdm9yaXRlcyBzdWJzY3JpYmVycyBhcmUgbm90aWZpZWQgb2YgY2hhbmdlcyAqL1xyXG4gIH1cclxuXHJcbiAgX2Zhdm9yaXRlVG9waWModXJsLCB0aXRsZSl7XHJcbiAgICAvL2xldCBpZDtcclxuICAgIHRoaXMuX2Zhdk1lbW9yeVN0b3JlW3RoaXMuX2dldFVuaXF1ZUlkKCldID0ge1widG9waWNcIiA6IHVybCwgXCJ0aXRsZVwiIDogdGl0bGV9O1xyXG4gICAgdGhpcy5fc2F2ZUZhdm9yaXRlcygpO1xyXG4gICAgcmgubW9kZWwucHVibGlzaChyaC5jb25zdHMoJ0VWRU5URkFWQ0hBTkdFJyksIG51bGwpOy8qIFB1Ymxpc2ggc28gZmF2b3JpdGVzIHN1YnNjcmliZXJzIGFyZSBub3RpZmllZCBvZiBjaGFuZ2VzICovXHJcbiAgfVxyXG5cclxuICAvKiBQdWJsaWMgZnVuY3Rpb25zOiBmb3IgdXNlIGluIG90aGVyIHNjcmlwdHMgKi9cclxuICBnZXRTdG9yYWdlSWQgKCl7IHJldHVybiBgZmF2LSR7cmguXy5nZXRIb3N0Rm9sZGVyKCl9YCB9XHJcblxyXG4gIGdldFRvcGljVVJMKCl7IC8qIEdldCB0aGUgVVJMIG9mIHRoZSBjdXJyZW50IHRvcGljICovXHJcbiAgICByZXR1cm4gcmgubW9kZWwuZ2V0KHJoLmNvbnN0cygnS0VZX1RPUElDX1VSTCcpKTtcclxuICB9XHJcblxyXG4gIGdldFRvcGljVGl0bGUoKXsgLyogR2V0IHRpdGxlIG9mIGN1cnJlbnRseSBvcGVuZWQgdG9waWMgKi9cclxuICAgIHJldHVybiByaC5tb2RlbC5nZXQocmguY29uc3RzKCdLRVlfVE9QSUNfVElUTEUnKSk7XHJcbiAgfVxyXG5cclxuICBpc1RvcGljRmF2b3JpdGUodG9waWMpe1xyXG4gICAgICAvKiBJcyB0aGUgY3VycmVudCB0b3BpYyBhIGZhdm9yaXRlIHRvcGljPyAqL1xyXG4gICAgbGV0IGZhdm9yaXRlcztcclxuICAgIGxldCBpc0Zhdm9yaXRlO1xyXG4gICAgaWYoIXRvcGljKSB7XHJcbiAgICAgIHRvcGljID0gdGhpcy5nZXRUb3BpY1VSTCgpO1xyXG4gICAgfVxyXG4gICAgZmF2b3JpdGVzID0gdGhpcy5fbG9hZEZhdm9yaXRlcygpO1xyXG5cclxuICAgIGlzRmF2b3JpdGUgPSBmYWxzZTtcclxuICAgIGZvcihjb25zdCBpIGluIGZhdm9yaXRlcykge1xyXG4gICAgICBjb25zdCBjdXJyZW50ID0gZmF2b3JpdGVzW2ldO1xyXG4gICAgICBpZihjdXJyZW50LnRvcGljID09PSB0b3BpYykge1xyXG4gICAgICAgIGlzRmF2b3JpdGUgPSB0cnVlO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGlzRmF2b3JpdGU7XHJcbiAgfVxyXG4gIHNldGZhdm9yaXRlc1RpdGxlKGlzRmF2b3JpdGUpe1xyXG4gICAgbGV0IHRpdGxlID0gdGhpcy5nZXRMaW5rVGl0bGUoaXNGYXZvcml0ZSlcclxuICAgIHJoLm1vZGVsLnB1Ymxpc2goY29uc3RzKCdGQVZPUklURVNfQlVUVE9OX1RJVExFJyksIHRpdGxlKVxyXG4gIH1cclxuICBzZXRUb3BpY0Zhdm9yaXRlU3RhdGUoKXtcclxuICAgIHJoLm1vZGVsLnB1Ymxpc2goY29uc3RzKCdUT1BJQ19GQVZPUklURScpLCB0aGlzLmlzVG9waWNGYXZvcml0ZSgpKTtcclxuICB9XHJcblxyXG4gIHNldEZhdm9yaXRlc0xpc3QoKXsvKiBXcml0ZSB0aGUgZmF2b3JpdGVzIGxpc3QgKi9cclxuICAgIC8vbGV0IGZhdmhvbGRlcnM7XHJcbiAgICBsZXQgZmF2b3JpdGVzID0gW107XHJcbiAgICBsZXQgaWRcclxuICAgIGxldCBmYXZvcml0ZXNfbWFwID0gdGhpcy5fbG9hZEZhdm9yaXRlcygpO1xyXG4gICAgZm9yKGlkIGluIGZhdm9yaXRlc19tYXApe1xyXG4gICAgICBmYXZvcml0ZXMucHVzaChmYXZvcml0ZXNfbWFwW2lkXSk7XHJcbiAgICB9XHJcbiAgICByaC5tb2RlbC5wdWJsaXNoKGNvbnN0cygnS0VZX0ZBVk9SSVRFUycpLCBmYXZvcml0ZXMpXHJcbiAgfVxyXG5cclxuICB0b2dnbGVGYXZvcml0ZSh0b3BpY1VSTCl7LyogVG9nZ2xlIHdoZXRoZXIgdGhlIHBhZ2UgaXMgYSBmYXZvcml0ZSAqL1xyXG4gICAgaWYoIXRvcGljVVJMKSB7XHJcbiAgICAgIHRvcGljVVJMID0gdGhpcy5nZXRUb3BpY1VSTCgpO1xyXG4gICAgfVxyXG4gICAgaWYodGhpcy5pc1RvcGljRmF2b3JpdGUodG9waWNVUkwpKSB7XHJcbiAgICAgIHRoaXMuX3VuRmF2b3JpdGVUb3BpYyh0b3BpY1VSTCk7LyogQmVjYXVzZSB0aGUgZmF2b3JpdGVzIGxpc3QgY2FuIHJlbW92ZSB0b3BpY3MsIHJlbW92aW5nIGEgdG9waWMgY2FuIGJlIGEgZGlmZmVyZW50IFVSTCB0aGFuIHRoZSBjdXJyZW50IHRvcGljLiAqL1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5fZmF2b3JpdGVUb3BpYyh0b3BpY1VSTCwgdGhpcy5nZXRUb3BpY1RpdGxlKCkpOy8qIFRoaXMgY2FuIG9ubHkgYmUgdGhlIGN1cnJlbnQgdG9waWMgKi9cclxuICAgIH1cclxuICAgIHRoaXMuc2V0VG9waWNGYXZvcml0ZVN0YXRlKCk7XHJcbiAgfVxyXG5cclxuICBpbml0KCl7LyogSW5pdGlhbGlzZSB0aGUgZmF2b3JpdGVzICovXHJcblxyXG4gICAgdGhpcy5mYXZTdG9yYWdlLmluaXQocmguXy5nZXRSb290VXJsKCkpXHJcblxyXG4gICAgLyogU3Vic2NyaWJlIHRvIHRvcGljIGV2ZW50cyAqL1xyXG4gICAgcmgubW9kZWwuc3Vic2NyaWJlKHJoLmNvbnN0cygnS0VZX1RPUElDX1VSTCcpLCB0aGlzLnNldFRvcGljRmF2b3JpdGVTdGF0ZS5iaW5kKHRoaXMpKTtcclxuICAgIHJoLm1vZGVsLnN1YnNjcmliZShyaC5jb25zdHMoJ0VWRU5URkFWQ0hBTkdFJyksIHRoaXMuc2V0RmF2b3JpdGVzTGlzdC5iaW5kKHRoaXMpKTtcclxuICAgIHJoLm1vZGVsLnN1YnNjcmliZShyaC5jb25zdHMoJ1RPUElDX0ZBVk9SSVRFJyksIHRoaXMuc2V0ZmF2b3JpdGVzVGl0bGUuYmluZCh0aGlzKSk7XHJcblxyXG4gICAgdGhpcy5zZXRGYXZvcml0ZXNMaXN0KCk7XHJcbiAgICByaC5tb2RlbC5wdWJsaXNoKGNvbnN0cygnVE9QSUNfRkFWT1JJVEUnKSwgdGhpcy5pc1RvcGljRmF2b3JpdGUoKSk7XHJcbiAgfVxyXG59XHJcblxyXG5yaC5jb250cm9sbGVyKCdGYXZvcml0ZXNDb250cm9sbGVyJywgRmF2b3JpdGVzQ29udHJvbGxlcilcclxuIiwibGV0IHJoID0gcmVxdWlyZShcIi4uLy4uL2xpYi9yaFwiKVxyXG5sZXQgXyA9IHJoLl9cclxuY2xhc3MgSG9tZUNvbnRyb2xsZXIge1xyXG5cclxuICBjb25zdHJ1Y3Rvcih3aWRnZXQpIHtcclxuICAgIHRoaXMud2lkZ2V0ID0gd2lkZ2V0XHJcbiAgfVxyXG5cclxuICBnb1RvSG9tZSh0b2NJZCkge1xyXG4gICAgaWYocmguY29uc3RzKCdIT01FX0ZJTEVQQVRIJykgPT09IHJoLl8uZ2V0RmlsZU5hbWUoKSkge1xyXG4gICAgICByZXR1cm4gdGhpcy5jaGFuZ2VUb0RlZmF1bHRUb3BpYyh0b2NJZClcclxuICAgIH1cclxuICAgIGxldCBoYXNoTWFwXHJcbiAgICBpZih0b2NJZCAhPT0gdW5kZWZpbmVkICYmIHRvY0lkICE9PScnKXtcclxuICAgICAgaGFzaE1hcCA9IHtyaHRvY2lkOnRvY0lkfVxyXG4gICAgfVxyXG4gICAgXy5nb1RvSG9tZShoYXNoTWFwKTtcclxuICAgIHJldHVybiB0cnVlXHJcbiAgfVxyXG5cclxuICBjaGFuZ2VUb0RlZmF1bHRUb3BpYyh0b2NJZCkge1xyXG4gICAgbGV0IGhhc2hNYXAgPSB7dDogd2luZG93LmdEZWZhdWx0VG9waWMuc3Vic3RyaW5nKDEpfVxyXG4gICAgaWYodG9jSWQgIT09IHVuZGVmaW5lZCAmJiB0b2NJZCAhPT0nJyl7XHJcbiAgICAgIGhhc2hNYXAucmh0b2NpZCA9IHRvY0lkXHJcbiAgICB9XHJcbiAgICBfLnF1ZXVlVXBkYXRlSGFzaE1hcChoYXNoTWFwLCB0cnVlKVxyXG4gICAgcmV0dXJuIHRydWVcclxuICB9XHJcbn1cclxuXHJcbnJoLmNvbnRyb2xsZXIoJ0hvbWVDb250cm9sbGVyJywgSG9tZUNvbnRyb2xsZXIpXHJcbiIsImxldCByaCA9IHJlcXVpcmUoXCIuLi8uLi9saWIvcmhcIilcclxubGV0IG5vZGVVdGlscyA9IHJlcXVpcmUoXCIuLi91dGlscy9ub2RlX3V0aWxzXCIpXHJcbmxldCAkID0gcmguJFxyXG5sZXQgXyA9IHJoLl87XHJcbmNsYXNzIE1vZGFsRGlhbG9nIHtcclxuXHJcbiAgY3JlYXRlQ2hpbGRXaWRnZXQoKSB7XHJcbiAgICB0aGlzLm5vZGUgPSAkLmNyZWF0ZUVsZW1lbnQoJ2RpdicsIHRoaXMudGVtcGxhdGUpXHJcbiAgICBub2RlVXRpbHMuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuYm9keSwgdGhpcy5ub2RlKTtcclxuICAgIHRoaXMud2lkZ2V0ID0gbmV3IHJoLldpZGdldCh7bm9kZTogdGhpcy5ub2RlfSlcclxuICAgIHRoaXMud2lkZ2V0LmluaXQoKVxyXG4gIH1cclxuXHJcblxyXG4gIGdldCB0ZW1wbGF0ZSgpIHtcclxuICAgIGxldCBpbml0aWFsU3R5bGUgPSB0aGlzLmluaXRpYWxTdHlsZSgpXHJcblxyXG4gICAgcmV0dXJuIGBcclxuICAgIDxkaXYgY2xhc3M9XCJyaC1tb2RhbFwiPlxyXG4gICAgICAgIDxkaXYgY2xhc3M9XCJyaC1tb2RhbC1jb250YWluZXJcIiAke2luaXRpYWxTdHlsZX0+XHJcbiAgICAgICAgICA8ZGl2IGNsYXNzPVwicmgtbW9kYWwtY29udGVudFwiIGRhdGEtaHRtbD1cImNvbnRlbnRcIj48L2Rpdj5cclxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJyaC1tb2RhbC1jbG9zZVwiIGRhdGEtY2xpY2s9XCJAY2xvc2UodHJ1ZSlcIj4gPC9kaXY+XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICA8L2Rpdj5gO1xyXG4gIH1cclxuXHJcbiAgc2V0T25JbWFnZUxvYWQoKXtcclxuICAgIGxldCBtb2RhbENvbnRlbnQgPSAkLmZpbmQodGhpcy5ub2RlLCAnLnJoLW1vZGFsLWNvbnRlbnQnKVswXVxyXG4gICAgaWYoIW1vZGFsQ29udGVudCkge1xyXG4gICAgICByZXR1cm5cclxuICAgIH1cclxuICAgIHRoaXMubW9kYWxDb250ZW50ID0gbW9kYWxDb250ZW50XHJcbiAgICBsZXQgaW1nID0gJC5maW5kKG1vZGFsQ29udGVudCwgJ2ltZycpWzBdXHJcbiAgICBpZihpbWcpe1xyXG4gICAgICB0aGlzLmltZyA9IGltZ1xyXG4gICAgICBpbWcuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIHRoaXMuc2V0TW9kYWxTaXplLmJpbmQodGhpcykpXHJcbiAgICAgIGltZy5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIHRoaXMuc2V0TW9kYWxTaXplLmJpbmQodGhpcykpXHJcbiAgICB9XHJcbiAgfVxyXG4gIHNldE1vZGFsU2l6ZSgpe1xyXG4gICAgdGhpcy5pbWFnZVdpZHRoID0gdGhpcy5pbWcubmF0dXJhbFdpZHRoXHJcbiAgICB0aGlzLmltYWdlSGVpZ2h0ID0gdGhpcy5pbWcubmF0dXJhbEhlaWdodFxyXG4gICAgbGV0IHBvc2l0aW9uID0gdGhpcy5jYWxjdWxhdGVQb3NpdGlvbih0aGlzLmltYWdlV2lkdGgsIHRoaXMuaW1hZ2VIZWlnaHQpXHJcbiAgICBsZXQgbW9kYWxDb250YWluZXIgPSAkLmZpbmQodGhpcy5ub2RlLCAnLnJoLW1vZGFsLWNvbnRhaW5lcicpWzBdXHJcbiAgICBpZihtb2RhbENvbnRhaW5lcil7XHJcbiAgICAgIHRoaXMuc2V0Q29udGFpbmVyU3R5bGUobW9kYWxDb250YWluZXIsIHBvc2l0aW9uKVxyXG4gICAgfVxyXG4gIH1cclxuICBzZXRDb250YWluZXJTdHlsZShtb2RhbENvbnRhaW5lciwgcG9zaXRpb24pe1xyXG4gICAgbGV0IHRvcCA9IE1hdGgucm91bmQocG9zaXRpb24udG9wKVxyXG4gICAgbGV0IGxlZnQgPSBNYXRoLnJvdW5kKHBvc2l0aW9uLmxlZnQpXHJcblxyXG4gICAgJC5jc3MobW9kYWxDb250YWluZXIsICdsZWZ0JywgbGVmdC50b1N0cmluZygpICsgJ3B4JylcclxuICAgICQuY3NzKG1vZGFsQ29udGFpbmVyLCAndG9wJywgdG9wLnRvU3RyaW5nKCkgKyAncHgnKVxyXG5cclxuICAgIGlmKHRoaXMubW9kYWxDb250ZW50KSB7XHJcbiAgICAgIHRoaXMuc2V0SW1hZ2VTaXplKHBvc2l0aW9uLndpZHRoLCBwb3NpdGlvbi5oZWlnaHQpXHJcbiAgICB9XHJcbiAgICAkLmNzcyhtb2RhbENvbnRhaW5lciwgJ2Rpc3BsYXknLCBcImJsb2NrXCIpXHJcblxyXG4gIH1cclxuICBjYWxjdWxhdGVJbWFnZVNpemUoc2l6ZSl7XHJcbiAgICBsZXQgYXNwZWN0ID0gc2l6ZS5pbWFnZVdpZHRoL3NpemUuaW1hZ2VIZWlnaHRcclxuICAgIGlmKHNpemUuaW1hZ2VXaWR0aCA8IHNpemUucGFnZVdpZHRoICYmIHNpemUuaW1hZ2VIZWlnaHQgPCBzaXplLnBhZ2VIZWlnaHQpe1xyXG4gICAgICByZXR1cm4ge3dpZHRoOiBzaXplLmltYWdlV2lkdGgsIGhlaWdodDogc2l6ZS5pbWFnZUhlaWdodH1cclxuICAgIH1cclxuXHJcbiAgICBpZihzaXplLmltYWdlV2lkdGggPj0gc2l6ZS5wYWdlV2lkdGggJiYgc2l6ZS5pbWFnZUhlaWdodCA8PSBzaXplLnBhZ2VIZWlnaHQpe1xyXG4gICAgICByZXR1cm4ge2hlaWdodDogc2l6ZS5wYWdlV2lkdGgvYXNwZWN0LCB3aWR0aDogc2l6ZS5wYWdlV2lkdGh9XHJcbiAgICB9XHJcbiAgICBpZihzaXplLmltYWdlV2lkdGggPD0gc2l6ZS5wYWdlV2lkdGggJiYgc2l6ZS5pbWFnZUhlaWdodCA+PSBzaXplLnBhZ2VIZWlnaHQpe1xyXG4gICAgICByZXR1cm4ge2hlaWdodDogc2l6ZS5wYWdlSGVpZ2h0LCB3aWR0aDogc2l6ZS5wYWdlSGVpZ2h0KmFzcGVjdFxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBpZihzaXplLmltYWdlV2lkdGggPj0gc2l6ZS5wYWdlV2lkdGggJiYgc2l6ZS5pbWFnZUhlaWdodCA+PSBzaXplLnBhZ2VIZWlnaHQpe1xyXG4gICAgICByZXR1cm4gdGhpcy5fY2FsY3VsYXRlRnVsbHlFeGNlZWRTaXplKHNpemUsIGFzcGVjdClcclxuICAgIH1cclxuICB9XHJcbiAgX2NhbGN1bGF0ZUZ1bGx5RXhjZWVkU2l6ZShzaXplLCBhc3BlY3Qpe1xyXG4gICAgbGV0IHBhZ2VBc3BlY3QgPSBzaXplLnBhZ2VXaWR0aC9zaXplLnBhZ2VIZWlnaHRcclxuICAgIGlmKGFzcGVjdCA8IHBhZ2VBc3BlY3Qpe1xyXG4gICAgICByZXR1cm4ge2hlaWdodDogc2l6ZS5wYWdlSGVpZ2h0LCB3aWR0aDogc2l6ZS5wYWdlSGVpZ2h0KmFzcGVjdH1cclxuICAgIH1cclxuICAgIGVsc2V7XHJcbiAgICAgIHJldHVybnsgaGVpZ2h0OiBzaXplLnBhZ2VXaWR0aC9hc3BlY3QsIHdpZHRoOiBzaXplLnBhZ2VXaWR0aH1cclxuICAgIH1cclxuICB9XHJcblxyXG5cclxuXHJcbiAgY2FsY3VsYXRlUG9zaXRpb24oaW1hZ2VXaWR0aCwgaW1hZ2VIZWlnaHQpe1xyXG4gICAgbGV0IHBhZ2VXaWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoIHx8IGRvY3VtZW50LmJvZHkuY2xpZW50V2lkdGhcclxuICAgIGxldCBwYWdlSGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0IHx8IGRvY3VtZW50LmJvZHkuY2xpZW50SGVpZ2h0XHJcbiAgICBwYWdlV2lkdGggLT0gNzBcclxuICAgIHBhZ2VIZWlnaHQgLT0gNzBcclxuICAgIHBhZ2VXaWR0aCA9IChwYWdlV2lkdGggPj0gMCk/ICBwYWdlV2lkdGg6IDBcclxuICAgIHBhZ2VIZWlnaHQgPSAocGFnZUhlaWdodCA+PSAwKT8gIHBhZ2VIZWlnaHQ6IDBcclxuXHJcbiAgICBsZXQgc2l6ZSA9IHtpbWFnZVdpZHRoOmltYWdlV2lkdGgsIGltYWdlSGVpZ2h0OmltYWdlSGVpZ2h0LCBwYWdlV2lkdGg6cGFnZVdpZHRoLCBwYWdlSGVpZ2h0OnBhZ2VIZWlnaHR9XHJcbiAgICBsZXQgaW1hZ2Vfc2l6ZSA9IHRoaXMuY2FsY3VsYXRlSW1hZ2VTaXplKHNpemUpXHJcbiAgICBpbWFnZVdpZHRoID0gaW1hZ2Vfc2l6ZS53aWR0aFxyXG4gICAgaW1hZ2VIZWlnaHQgPSBpbWFnZV9zaXplLmhlaWdodFxyXG4gICAgbGV0IGxlZnQgPSBNYXRoLm1heCg1LCAocGFnZVdpZHRoIC0gaW1hZ2VXaWR0aCkvMiApXHJcbiAgICBsZXQgdG9wID0gTWF0aC5tYXgoNSwgKHBhZ2VIZWlnaHQgLSBpbWFnZUhlaWdodCkvMiApXHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgbGVmdDogbGVmdCxcclxuICAgICAgdG9wOiB0b3AsXHJcbiAgICAgIHdpZHRoOiBpbWFnZVdpZHRoLFxyXG4gICAgICBoZWlnaHQ6IGltYWdlSGVpZ2h0LFxyXG4gICAgICBwYWdlV2lkdGg6IHBhZ2VXaWR0aCxcclxuICAgICAgcGFnZUhlaWdodDogcGFnZUhlaWdodFxyXG4gICAgfVxyXG4gIH1cclxuICBpbml0aWFsU3R5bGUoKXtcclxuICAgIHJldHVybiAodGhpcy5pc0ltYWdlKT8gYHN0eWxlPVwiZGlzcGxheTpub25lXCJgIDogJydcclxuICB9XHJcblxyXG4gIFNob3dNb2RhbChjb25maWcpIHtcclxuICAgIHRoaXMuaXNJbWFnZSA9IGNvbmZpZy5pc0ltYWdlXHJcbiAgICB0aGlzLmNyZWF0ZUNoaWxkV2lkZ2V0KClcclxuICAgIHRoaXMud2lkZ2V0LnN1YnNjcmliZSgnY2xvc2UnLCB0aGlzLl9jbG9zZS5iaW5kKHRoaXMpKVxyXG4gICAgdGhpcy53aWRnZXQucHVibGlzaCgnY29udGVudCcsIGNvbmZpZy5jb250ZW50KVxyXG4gICAgXy5kZWZlcih0aGlzLnNldE9uSW1hZ2VMb2FkLmJpbmQodGhpcykpXHJcblxyXG4gIH1cclxuXHJcbiAgc2V0SW1hZ2VTaXplKG1heFdpZHRoLCBtYXhIZWlnaHQpe1xyXG4gICAgaWYodGhpcy5pbWFnZVdpZHRoID4gbWF4V2lkdGgpe1xyXG4gICAgICAkLmNzcyh0aGlzLmltZywgJ3dpZHRoJywgYCR7TWF0aC5yb3VuZChtYXhXaWR0aCl9cHhgKVxyXG4gICAgfVxyXG4gICAgaWYodGhpcy5pbWFnZUhlaWdodCA+IG1heEhlaWdodCl7XHJcbiAgICAgICQuY3NzKHRoaXMuaW1nLCAnaGVpZ2h0JywgYCR7TWF0aC5yb3VuZChtYXhIZWlnaHQpfXB4YClcclxuICAgIH1cclxuICB9XHJcbiAgX2Nsb3NlKCl7XHJcbiAgICB0aGlzLndpZGdldC5kZXN0cnVjdCgpO1xyXG4gICAgdGhpcy53aWRnZXQgPSB1bmRlZmluZWQ7XHJcbiAgICBub2RlVXRpbHMucmVtb3ZlQ2hpbGQodGhpcy5ub2RlKTtcclxuICAgIHRoaXMubm9kZSA9IHVuZGVmaW5lZDtcclxuICB9XHJcbn1cclxuXHJcblxyXG5pZiAoIV8uaXNJZnJhbWUoKSkge1xyXG4gIHJoLm1vZGVsLmNzdWJzY3JpYmUoJ1NIT1dfTU9EQUwnLCBjb25maWcgPT4ge1xyXG4gICAgbGV0IG1vZGVsID0gbmV3IE1vZGFsRGlhbG9nKClcclxuICAgIG1vZGVsLlNob3dNb2RhbChjb25maWcpXHJcbiAgfSlcclxufVxyXG5cclxucmgubW9kZWwuY3N1YnNjcmliZSgnU0hPV19NT0RBTF9JTl9UT1BJQycsIGNvbmZpZyA9PiB7XHJcbiAgbGV0IG1vZGVsID0gbmV3IE1vZGFsRGlhbG9nKClcclxuICBtb2RlbC5TaG93TW9kYWwoY29uZmlnKVxyXG59KVxyXG4iLCJsZXQgcmggPSByZXF1aXJlKFwiLi4vLi4vbGliL3JoXCIpXHJcbmxldCAkID0gcmguJDtcclxubGV0IF8gPSByaC5fO1xyXG5sZXQgY29uc3RzID0gcmguY29uc3RzO1xyXG5jbGFzcyBSSDIwMTdMYXlvdXRDb250cm9sbGVyIHtcclxuXHJcbiAgY29uc3RydWN0b3Iod2lkZ2V0KSB7XHJcbiAgICB0aGlzLndpZGdldCA9IHdpZGdldDtcclxuICAgIHRoaXMudG9waWNGcmFtZSA9ICcudG9waWMtY29udGFpbmVyIGlmcmFtZSc7XHJcbiAgICB0aGlzLmluaXRMYXlvdXQoKTtcclxuICAgIHRoaXMuaW5pdE1vZGFsKCk7XHJcbiAgfVxyXG5cclxuICBpc0xheW91dE1vZGUoaGFzaE1hcCkge1xyXG4gICAgbGV0IGhhc2ggPSBoYXNoTWFwIHx8IF8uaGFzaFBhcmFtcygpO1xyXG4gICAgbGV0IHRvcGljTW9kZSA9IGhhc2hbcmguY29uc3RzKCdIQVNIX0tFWV9UT1BJQycpXTtcclxuICAgIHJldHVybiAoaGFzaFtyaC5jb25zdHMoJ0hBU0hfS0VZX1VJTU9ERScpXSAhPT0gY29uc3RzKCdIRUxQX1NFQVJDSF9NT0RFJykgJiYgKCF0b3BpY01vZGUgfHxcclxuICAgICAgICAoaGFzaFtyaC5jb25zdHMoJ0hBU0hfSE9NRVBBR0VfTU9ERScpXSA9PT0gJ3RydWUnKSB8fFxyXG4gICAgICAgICBoYXNoW3JoLmNvbnN0cygnSEFTSF9LRVlfUkhfVE9DSUQnKV0pKTtcclxuICB9XHJcblxyXG4gIGluaXRMYXlvdXQoKSB7XHJcbiAgICByaC5tb2RlbC5zdWJzY3JpYmUoY29uc3RzKCdFVlRfSEFTSF9DSEFOR0UnKSwgKG9iaikgPT4ge1xyXG4gICAgICBsZXQgaGFzaE1hcCA9IG9iai5uZXdNYXAsIG9sZEhhc2hNYXAgPSBvYmoub2xkTWFwO1xyXG4gICAgICBpZih0aGlzLmlzTGF5b3V0TW9kZSgpKSB7XHJcbiAgICAgICAgdGhpcy53aWRnZXQucHVibGlzaChyaC5jb25zdHMoJ0tFWV9WSUVXX01PREUnKSwgcmguY29uc3RzKCdIRUxQX0xBWU9VVF9NT0RFJykpO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2UgaWYoaGFzaE1hcFtyaC5jb25zdHMoJ0hBU0hfS0VZX1VJTU9ERScpXSA9PT0gJ3NlYXJjaCcpe1xyXG4gICAgICAgIHRoaXMud2lkZ2V0LnB1Ymxpc2gocmguY29uc3RzKCdLRVlfVklFV19NT0RFJyksIHJoLmNvbnN0cygnSEVMUF9TRUFSQ0hfTU9ERScpKTtcclxuICAgICAgICBfLnF1ZXVlVXBkYXRlSGFzaE1hcCh7W2NvbnN0cygnSEFTSF9IT01FUEFHRV9NT0RFJyldOiBmYWxzZX0sIGZhbHNlKTtcclxuICAgICAgfVxyXG4gICAgICBlbHNlIHtcclxuICAgICAgICB0aGlzLndpZGdldC5wdWJsaXNoKHJoLmNvbnN0cygnS0VZX1ZJRVdfTU9ERScpLCByaC5jb25zdHMoJ0hFTFBfVE9QSUNfTU9ERScpKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIGZlYXR1cmUgPSByaC5tb2RlbC5nZXQocmguY29uc3RzKCdLRVlfRkVBVFVSRScpKVxyXG4gICAgICBpZihmZWF0dXJlICYmIGZlYXR1cmUuc2hvd0RlZlRvcGljID09PSBmYWxzZSAmJlxyXG4gICAgICAgICFoYXNoTWFwW3JoLmNvbnN0cygnSEFTSF9LRVlfUkhfVE9DSUQnKV0gJiZcclxuICAgICAgICAhb2xkSGFzaE1hcFtyaC5jb25zdHMoJ0hBU0hfS0VZX1RPUElDJyldICYmXHJcbiAgICAgICAgaGFzaE1hcFtyaC5jb25zdHMoJ0hBU0hfS0VZX1RPUElDJyldKSB7XHJcbiAgICAgICAgXy5xdWV1ZVVwZGF0ZUhhc2hNYXAoe1tjb25zdHMoJ0hBU0hfSE9NRVBBR0VfTU9ERScpXTogJ2ZhbHNlJ30sIGZhbHNlKVxyXG4gICAgICB9XHJcbiAgICAgIGVsc2UgaWYob2xkSGFzaE1hcFtyaC5jb25zdHMoJ0hBU0hfS0VZX1RPUElDJyldICYmXHJcbiAgICAgICAgIWhhc2hNYXBbcmguY29uc3RzKCdIQVNIX0tFWV9SSF9UT0NJRCcpXSAmJlxyXG4gICAgICAgIG9sZEhhc2hNYXBbcmguY29uc3RzKCdIQVNIX0tFWV9UT1BJQycpXSAhPT0gaGFzaE1hcFtyaC5jb25zdHMoJ0hBU0hfS0VZX1RPUElDJyldICYmXHJcbiAgICAgICAgaGFzaE1hcFtyaC5jb25zdHMoJ0hBU0hfSE9NRVBBR0VfTU9ERScpXSA9PT0gJ3RydWUnICYmXHJcbiAgICAgICAgb2xkSGFzaE1hcFtyaC5jb25zdHMoJ0hBU0hfSE9NRVBBR0VfTU9ERScpXSA9PT0gaGFzaE1hcFtyaC5jb25zdHMoJ0hBU0hfSE9NRVBBR0VfTU9ERScpXSkge1xyXG4gICAgICAgIF8ucXVldWVVcGRhdGVIYXNoTWFwKHtbY29uc3RzKCdIQVNIX0hPTUVQQUdFX01PREUnKV06ICdmYWxzZSd9LCBmYWxzZSk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIGxldCBoYXNoTWFwID0gXy5oYXNoUGFyYW1zKCk7XHJcbiAgICBpZih0aGlzLmlzTGF5b3V0TW9kZSgpICYmXHJcbiAgICAgICAgaGFzaE1hcFtyaC5jb25zdHMoJ0hBU0hfSE9NRVBBR0VfTU9ERScpXSAhPT0gJ3RydWUnKVxyXG4gICAge1xyXG4gICAgICBfLnF1ZXVlVXBkYXRlSGFzaE1hcCh7W2NvbnN0cygnSEFTSF9IT01FUEFHRV9NT0RFJyldOiB0cnVlfSwgZmFsc2UpO1xyXG4gICAgfVxyXG4gICAgcmgubW9kZWwuc3Vic2NyaWJlKCdFVlRfVE9DX0xPQURFRGdvdG90YWInLCAoYm9va0RhdGEpID0+IHtcclxuICAgICAgaWYoYm9va0RhdGEua2V5KSB7XHJcbiAgICAgICAgcmgubW9kZWwuc3Vic2NyaWJlKGJvb2tEYXRhLmtleSwgKGJvb2tUT0MsIGtleSwgdW5zdWIpID0+IHtcclxuICAgICAgICAgIHVuc3ViKCk7XHJcbiAgICAgICAgICBpZihib29rRGF0YS5pdGVtICYmIGJvb2tEYXRhLml0ZW0udXJsICYmICFib29rVE9DWzBdLmFkZGVkKSB7XHJcbiAgICAgICAgICAgIGJvb2tUT0MudW5zaGlmdCh7J3R5cGUnOiAnaXRlbScsICd1cmwnOiBib29rRGF0YS5pdGVtLnVybCxcclxuICAgICAgICAgICAgICAnbmFtZSc6IGJvb2tEYXRhLml0ZW0ubmFtZSwgJ2FkZGVkJzogdHJ1ZX0pO1xyXG4gICAgICAgICAgICByaC5tb2RlbC5wdWJsaXNoKGJvb2tEYXRhLmtleSwgYm9va1RPQyk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgICAgaWYoYm9va0RhdGEuaXRlbS51cmwpIHtcclxuICAgICAgICB0aGlzLnZpZXdUb3BpY0luTGF5b3V0TW9kZShib29rRGF0YS5pdGVtLnVybCk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgdmlld1RvcGljSW5MYXlvdXRNb2RlKHRvcGljVXJsKSB7XHJcbiAgICBsZXQgcGFyYW1NYXAgPSB7J2hvbWVwYWdlJzogJ3RydWUnLFxyXG4gICAgICBbcmguY29uc3RzKCdIQVNIX0tFWV9SSF9UT0NJRCcpXTogdHJ1ZX1cclxuICAgIGlmKHRvcGljVXJsICYmIHRvcGljVXJsICE9PSAnIycpIHtcclxuICAgICAgcGFyYW1NYXAudCA9IHRvcGljVXJsXHJcbiAgICB9XHJcbiAgICBfLnF1ZXVlVXBkYXRlSGFzaE1hcChwYXJhbU1hcCwgZmFsc2UpXHJcbiAgfVxyXG5cclxuICBpbml0TW9kYWwoKSB7XHJcbiAgICBsZXQgYkhhbmRsZWQgPSBmYWxzZVxyXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgZSA9PiB7XHJcbiAgICAgIGlmICggZS5rZXlDb2RlID09PSAyNyApIHsgLy8gRVNDXHJcbiAgICAgICAgcmguXy5lYWNoKCQuZmluZCgnLm1vZGFsJyksIGl0ZW0gPT4ge1xyXG4gICAgICAgICAgJC5hZGRDbGFzcyhpdGVtLCAncmgtaGlkZScpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9LCBmYWxzZSk7XHJcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgaWYoIWJIYW5kbGVkKSB7XHJcbiAgICAgICAgcmguXy5lYWNoKCQuZmluZCgnLm1vZGFsJyksIGZ1bmN0aW9uIChpdGVtKSB7XHJcbiAgICAgICAgICAkLmFkZENsYXNzKGl0ZW0sICdyaC1oaWRlJyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgICAgYkhhbmRsZWQgPSBmYWxzZVxyXG4gICAgfSk7XHJcbiAgICByaC5fLmVhY2goJC5maW5kKCcubW9kYWwtY29udGVudCcpLCBmdW5jdGlvbiAoaXRlbSkge1xyXG4gICAgICBfLmFkZEV2ZW50TGlzdGVuZXIoaXRlbSwgJ2NsaWNrJywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgYkhhbmRsZWQgPSB0cnVlXHJcbiAgICAgIH0pXHJcbiAgICB9KTtcclxuICB9XHJcbn1cclxuXHJcbnJoLmNvbnRyb2xsZXIoJ1JIMjAxN0xheW91dENvbnRyb2xsZXInLCBSSDIwMTdMYXlvdXRDb250cm9sbGVyKVxyXG4iLCJsZXQgcmggPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vbGliL3JoXCIpXHJcbmxldCBfID0gcmguXztcclxuXHJcbmNsYXNzIE1lcmdlcntcclxuICBjb25zdHJ1Y3RvcihpdGVtcywgbWF4X2l0ZW1zKXtcclxuICAgIHRoaXMuX2l0ZW1zID0gaXRlbXM7IFxyXG4gICAgdGhpcy5fbWF4X2l0ZW1zID0gbWF4X2l0ZW1zIHx8IHJoLm1vZGVsLmdldChyaC5jb25zdHMoJ01BWF9TRUFSQ0hfUkVTVUxUUycpKXx8IDIwO1xyXG4gIH1cclxuICBnZXQgaXRlbXMoKXtcclxuICAgIHJldHVybiB0aGlzLl9pdGVtc1xyXG4gIH1cclxuICBtZXJnZShuZXdJdGVtcyl7XHJcbiAgICBfLmVhY2gobmV3SXRlbXMsIChpdGVtKSA9PiB7XHJcbiAgICAgIHRoaXMubWVyZ2VJdGVtKGl0ZW0pO1xyXG4gICAgfSk7XHJcbiAgICB0aGlzLl9zb3J0KCk7XHJcbiAgICB0aGlzLl9wdXJnZSgpO1xyXG4gIH1cclxuICBjbGVhcigpe1xyXG4gICAgdGhpcy5faXRlbXMgPSBbXTtcclxuICB9XHJcbiAgX3B1cmdlKCl7XHJcbiAgICBpZih0aGlzLl9pdGVtcy5sZW5ndGggPiB0aGlzLl9tYXhfaXRlbXMpe1xyXG4gICAgICB0aGlzLl9pdGVtcy5zcGxpY2UodGhpcy5fbWF4X2l0ZW1zKTtcclxuICAgIH1cclxuICB9XHJcbiAgbWVyZ2VJdGVtKGl0ZW0pe1xyXG4gICAgbGV0IGV4aXN0aW5nX2l0ZW0gPSB0aGlzLmZpbmRfaXRlbShpdGVtKTtcclxuICAgIGlmKGV4aXN0aW5nX2l0ZW0pe1xyXG4gICAgICBleGlzdGluZ19pdGVtLm1lcmdlKGl0ZW0pXHJcbiAgICB9XHJcbiAgICBlbHNle1xyXG4gICAgICB0aGlzLl9pdGVtcy5wdXNoKGl0ZW0pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZmluZF9pdGVtKG1hdGNoX2l0ZW0pIHtcclxuICAgIHJldHVybiBfLmZpbmQodGhpcy5faXRlbXMsIChpdGVtKSA9PiB7XHJcbiAgICAgIHJldHVybiBpdGVtLm1hdGNoKG1hdGNoX2l0ZW0pXHJcbiAgICB9KTtcclxuICB9XHJcbiAgXHJcbiAgbWVyZ2VfaXRlbShleGlzdGluZ19pdGVtLCBuZXdfaXRlbSkge1xyXG4gICAgZXhpc3RpbmdfaXRlbS5wcm9iYWJpbGl0eSArPSBuZXdfaXRlbS5wcm9iYWJpbGl0eTtcclxuICAgIGV4aXN0aW5nX2l0ZW0uY291bnQgPSBNYXRoLm1heChleGlzdGluZ19pdGVtLmNvdW50LCBuZXdfaXRlbS5jb3VudCk7XHJcbiAgfVxyXG5cclxuICBfc29ydCgpe1xyXG4gICAgdGhpcy5pdGVtcy5zb3J0KHRoaXMuY29tcGFyZV9pdGVtcyk7XHJcbiAgfVxyXG4gIGNvbXBhcmVfaXRlbXMocDEsIHAyKXtcclxuICAgIHJldHVybiBwMS5jb21wYXJlKHAyKVxyXG4gIH1cclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBNZXJnZXI7XHJcbiIsImxldCByaCA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi9saWIvcmhcIilcclxuY29uc3QgY29uc3RzID0gcmguY29uc3RzO1xyXG5cclxuY2xhc3MgUGF0aHN7XHJcbiAgY29uc3RydWN0b3IocGF0aCl7XHJcbiAgICB0aGlzLl9wYXRoID0gcGF0aCB8fCBcIlwiXHJcbiAgICB0aGlzLmluaXRQYXRoKClcclxuICB9XHJcbiAgZ2V0UGF0aCgpeyBcclxuICAgIHJldHVybiB0aGlzLl9wYXRoXHJcbiAgfVxyXG4gIGluaXRQYXRoKCl7XHJcbiAgICBpZih0aGlzLl9wYXRoID09PSBcIi5cIil7XHJcbiAgICAgIHRoaXMuX3BhdGggPSBcIlwiXHJcbiAgICB9XHJcbiAgICBpZih0aGlzLl9wYXRoWzBdID09PSAnLicgJiYgdGhpcy5fcGF0aFsxXSA9PT0gJy8nKXtcclxuICAgICAgdGhpcy5fcGF0aCA9IHRoaXMuX3BhdGguc2xpY2UoMilcclxuICAgIH1cclxuICB9XHJcbiAgX2dldE1vZGVsRmlsZU5hbWUoZmlsZU5vKXtcclxuICAgIGxldCBwcmVmaXggPSBjb25zdHMoXCJTRUFSQ0hfTU9ERUxfQUREUlwiKTtcclxuICAgIGlmKHJoLm1vZGVsLmdldChyaC5jb25zdHMoJ0tFWV9DTEFTU0lDX09VVFBVVCcpKSkge1xyXG4gICAgICBwcmVmaXggPSBjb25zdHMoXCJTRUFSQ0hfTU9ERUxfQUREUl9PTERcIik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gIHByZWZpeCArIGZpbGVOby50b1N0cmluZygpICtcIi5qc1wiO1xyXG4gIH1cclxuICBnZXRNb2RlbEZpbGVQYXRoKGZpbGVubyl7XHJcbiAgICBsZXQgZmlsZU5hbWUgPSB0aGlzLl9nZXRNb2RlbEZpbGVOYW1lKGZpbGVubylcclxuICAgIHJldHVybiB0aGlzLl9nZXRSZWxhdGl2ZVBhdGgoZmlsZU5hbWUpXHJcbiAgfVxyXG4gIF9nZXRSZWxhdGl2ZVBhdGgoZmlsZXBhdGgpe1xyXG4gICAgbGV0IHBhdGggPSAodGhpcy5fcGF0aCA9PT0gXCJcIik/IGZpbGVwYXRoIDogIHRoaXMuX3BhdGggKyAnLycgKyBmaWxlcGF0aFxyXG5cclxuICAgIHJldHVybiBwYXRoXHJcbiAgfVxyXG4gIF9nZXRQYXRoS2V5KCl7XHJcbiAgICByZXR1cm4gKHRoaXMuX3BhdGggPT09IFwiXCIpPyBcIlwiIDogICdfJyArIHRoaXMuX3BhdGggKyAnXydcclxuICB9XHJcbiAgZ2V0TW9kZWxLZXkgKGZpbGVObyl7XHJcbiAgICByZXR1cm4gY29uc3RzKCdTRUFSQ0hfTU9ERUxfS0VZJykgKyB0aGlzLl9nZXRQYXRoS2V5KCkgKyBmaWxlTm8udG9TdHJpbmcoKTtcclxuICB9XHJcblxyXG4gIF9nZXRNYXBGaWxlTmFtZSgpe1xyXG4gICAgaWYocmgubW9kZWwuZ2V0KHJoLmNvbnN0cygnS0VZX0NMQVNTSUNfT1VUUFVUJykpKSB7XHJcbiAgICAgIHJldHVybiBjb25zdHMoXCJTRUFSQ0hfTUFQX0FERFJfT0xEXCIpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNvbnN0cyhcIlNFQVJDSF9NQVBfQUREUlwiKTtcclxuICB9XHJcbiAgZ2V0TWFwRmlsZVBhdGgoKXtcclxuICAgIGxldCBmaWxlTmFtZSA9IHRoaXMuX2dldE1hcEZpbGVOYW1lKClcclxuICAgIHJldHVybiB0aGlzLl9nZXRSZWxhdGl2ZVBhdGgoZmlsZU5hbWUpO1xyXG4gIH1cclxuICBnZXRJbmRleEZpbGVQYXRoKCkge1xyXG4gICAgbGV0IGZpbGVOYW1lID0gY29uc3RzKFwiU0VBUkNIX0lOREVYX0ZJTEVcIik7XHJcbiAgICBpZihyaC5tb2RlbC5nZXQocmguY29uc3RzKCdLRVlfQ0xBU1NJQ19PVVRQVVQnKSkpIHtcclxuICAgICAgZmlsZU5hbWUgPSBjb25zdHMoXCJTRUFSQ0hfSU5ERVhfRklMRV9PTERcIik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcy5fZ2V0UmVsYXRpdmVQYXRoKGZpbGVOYW1lKTtcclxuICB9XHJcbiAgZ2V0VG9waWNVcmwodXJsKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fZ2V0UmVsYXRpdmVQYXRoKHVybClcclxuICB9XHJcbiAgZ2V0U2VhcmNoRGJGaWxlUGF0aCgpe1xyXG4gICAgbGV0IGZpbGVOYW1lID0gY29uc3RzKFwiU0VBUkNIX0RCX0ZJTEVcIilcclxuICAgIHJldHVybiB0aGlzLl9nZXRSZWxhdGl2ZVBhdGgoZmlsZU5hbWUpO1xyXG5cclxuICB9XHJcbiAgZ2V0TWV0YWRhdGFGaWxlUGF0aCgpe1xyXG4gICAgbGV0IGZpbGVOYW1lID0gY29uc3RzKFwiU0VBUkNIX01FVEFEQVRBX0ZJTEVcIilcclxuICAgIHJldHVybiB0aGlzLl9nZXRSZWxhdGl2ZVBhdGgoZmlsZU5hbWUpO1xyXG4gIH1cclxuXHJcbiAgZ2V0VGV4dEZpbGVQYXRoKGlkKSB7XHJcbiAgICBsZXQgZm9sZGVyUGF0aCA9IGNvbnN0cyhcIlNFQVJDSF9URVhUX0ZJTEVcIilcclxuICAgIGxldCByZWxGb2xkZXJQYXRoID0gdGhpcy5fZ2V0UmVsYXRpdmVQYXRoKGZvbGRlclBhdGgpXHJcbiAgICByZXR1cm4gYCR7cmVsRm9sZGVyUGF0aH0vJHtpZH0uanNgXHJcbiAgfVxyXG5cclxufVxyXG5tb2R1bGUuZXhwb3J0cyA9IFBhdGhzXHJcbiIsImNvbnN0IHJoID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uL2xpYi9yaFwiKVxyXG5jb25zdCBfID0gcmguX1xyXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIFN5bm9ueW1uc3tcclxuICBjb25zdHJ1Y3RvcihzeW5vbnltbnMpIHtcclxuXHJcbiAgICB0aGlzLnN5bm9ueW1ucyA9IHN5bm9ueW1ucyB8fCBbXVxyXG4gICAgdGhpcy5yb290V29yZHMgPSB7fVxyXG4gICAgdGhpcy5tZXJnZSgpXHJcbiAgfVxyXG4gIG1lcmdlKCkge1xyXG4gICAgdGhpcy5yb290V29yZHMgPSB7fVxyXG4gICAgXy5lYWNoKHRoaXMuc3lub255bW5zLCAoaXRlbSkgPT4ge1xyXG4gICAgICBsZXQgc3lub255bW5zID0gaXRlbS53b3Jkc1xyXG4gICAgICBsZXQgd29yZCA9IGl0ZW0ubmFtZVxyXG4gICAgICBfLmVhY2goc3lub255bW5zLCAoc3luKSA9PiB7XHJcbiAgICAgICAgdGhpcy5fYWRkKHdvcmQsIHN5bilcclxuICAgICAgfSkgICAgICBcclxuICAgIH0pXHJcbiAgfVxyXG4gIF9hZGQod29yZCwgc3luKSB7XHJcbiAgICBzeW4gPSBzeW4udG9Mb3dlckNhc2UoKVxyXG4gICAgd29yZCA9IHdvcmQudG9Mb3dlckNhc2UoKVxyXG4gICAgdGhpcy5yb290V29yZHNbc3luXSA9IHRoaXMucm9vdFdvcmRzW3dvcmRdIHx8IHdvcmRcclxuICB9XHJcblxyXG4gIGdldFJvb3Qod29yZCkge1xyXG4gICAgcmV0dXJuIHRoaXMucm9vdFdvcmRzW3dvcmRdIHx8IHdvcmRcclxuICB9XHJcbn0iLCJsZXQgX2V4cG9ydHMgPSB7XHJcbiAgbWluUHJldmlvdXNUaHJlc2hvbGQ6IDAuMixcclxuICBwcmV2aW91c25HcmFtOiAxLFxyXG4gIG1heF9wcmVkaWN0aW9uczo1LFxyXG4gIFBSRURJQ1RPUl9TT1VSQ0VfSUQ6e1xyXG4gICAgSElTVE9SWV9QUkVESUNUT1I6MCxcclxuICAgIE5HUkFNX1BSRURJQ1RPUjoxLFxyXG4gICAgR0VORVJBTF9QUkVESUNUT1I6MixcclxuICAgIENPUlJFQ1RPUjogM1xyXG4gIH1cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gX2V4cG9ydHM7IiwiY29uc3QgSU5ERVggPSByZXF1aXJlKCcuL2luZGljZXMnKTtcclxuY29uc3QgcmggPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vbGliL3JoXCIpXHJcbmNvbnN0IF8gPSByaC5fO1xyXG5jb25zdCBQcmVkaWN0aW9uID0gcmVxdWlyZSgnLi9wcmVkaWN0aW9uJyk7XHJcbmNvbnN0IHNlYXJjaF9jb25zdHMgPSByZXF1aXJlKCcuL2NvbnN0cycpO1xyXG5jb25zdCBzZWFyY2hfdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XHJcbmNvbnN0IFByZWRpY3Rpb25MaXN0ID0gcmVxdWlyZSgnLi9wcmVkaWN0aW9uX2xpc3QnKTtcclxuXHJcblxyXG5jbGFzcyBDb3JyZWN0b3J7XHJcbiAgY29uc3RydWN0b3IoIGxvYWRlciwgY2FsbGJhY2ssIG1heF9wcmVkaWN0aW9ucyA9IDIwKXtcclxuICAgIHRoaXMuX2xvYWRlciA9IGxvYWRlclxyXG4gICAgdGhpcy5wcmVkaWN0aW9ucyA9IFtdO1xyXG4gICAgdGhpcy5tYXhfcHJlZGljdGlvbnMgPSBtYXhfcHJlZGljdGlvbnM7XHJcbiAgICB0aGlzLl9jYWxsYmFjayA9IGNhbGxiYWNrO1xyXG4gIH1cclxuICBnZXRDb3JyZWN0aW9ucyhwYXJzZWRfaW5wdXQpe1xyXG4gICAgdGhpcy5fcGFyc2VkX2lucHV0ID0gcGFyc2VkX2lucHV0O1xyXG4gICAgdGhpcy5wcmVkaWN0aW9ucyA9IFtdO1xyXG4gICAgdGhpcy5fY29tcHV0ZVByZWRpY3Rpb25zKCk7XHJcbiAgICBsZXQgaGFzaGVzID0gdGhpcy5fbG9hZGVyLmdldEhhc2hlcyh0aGlzLl9wYXJzZWRfaW5wdXQuX3BhcnRpYWwpXHJcbiAgICBpZihoYXNoZXMpe1xyXG4gICAgICBsZXQgaGFzaF9jb3VudCA9IGhhc2hlcy5sZW5ndGg7XHJcbiAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCBoYXNoX2NvdW50ICYmIHRoaXMucHJlZGljdGlvbnMubGVuZ3RoIDwgdGhpcy5tYXhfcHJlZGljdGlvbnM7IGkrKyl7XHJcbiAgICAgICAgbGV0IGhhc2ggPSBoYXNoZXNbaV07XHJcbiAgICAgICAgdGhpcy5fYWRkQ29ycmVjdGlvbihoYXNoKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgdGhpcy5vblJlc3VsdENhbGN1bGF0ZWQoKTtcclxuICB9XHJcbiAgY2xlYXIoKXtcclxuICAgIHRoaXMucHJlZGljdGlvbnMgPSBbXVxyXG4gIH1cclxuICBfY29tcHV0ZVByZWRpY3Rpb25zKCl7XHJcblxyXG4gICAgbGV0IHdvcmRfaGFzaGVzID0gdGhpcy5fbG9hZGVyLmdldEhhc2hlcyh0aGlzLl9wYXJzZWRfaW5wdXQuX3BhcnRpYWwpO1xyXG4gICAgaWYod29yZF9oYXNoZXMpe1xyXG4gICAgICB0aGlzLl9hZGRDb3JyZWN0aW9uKHdvcmRfaGFzaGVzKTtcclxuICAgIH1cclxuICB9XHJcbiAgb25SZXN1bHRDYWxjdWxhdGVkKCl7XHJcbiAgICBpZih0aGlzLl9jYWxsYmFjaykge1xyXG4gICAgICB0aGlzLl9jYWxsYmFjayhuZXcgUHJlZGljdGlvbkxpc3QodGhpcy5wcmVkaWN0aW9ucywgdGhpcy5fcGFyc2VkX2lucHV0KSwgdGhpcy5fbG9hZGVyKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIF9tYXRjaENvcnJlY3Rpb24od29yZCl7XHJcbiAgICB0aGlzLl9oYW1taW5nX2Rpc3QgPSB0aGlzLl9nZXREaXN0YW5jZSh3b3JkKTtcclxuICAgIGlmKHRoaXMuX2hhbW1pbmdfZGlzdCA8PSAyICYmICF0aGlzLl9sb2FkZXIuaXNTdG9wV29yZCh3b3JkKSl7XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgX2FkZENvcnJlY3Rpb24od29yZF9oYXNoKXtcclxuICAgIGlmKCF3b3JkX2hhc2gpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgbGV0IHdvcmQgPSBzZWFyY2hfdXRpbHMuZ2V0U2FmZUVsZW1lbnQod29yZF9oYXNoLCBJTkRFWC5NQVAuV09SRCk7XHJcbiAgICBpZighd29yZCkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgaWYodGhpcy5fbWF0Y2hDb3JyZWN0aW9uKHdvcmQpKXtcclxuICAgICAgbGV0IGNvbXBsZXRlX3dvcmQgPSB0aGlzLl9wYXJzZWRfaW5wdXQucmVwbGFjZUxhc3RXb3JkKHdvcmQpXHJcbiAgICAgIGxldCB0ZXJtID0gdGhpcy5fcGFyc2VkX2lucHV0LmNvbXBsZXRlU3VnZ2VzdGlvbihjb21wbGV0ZV93b3JkKVxyXG4gICAgICBsZXQgcHJlZGljdGlvbiA9IG5ldyBQcmVkaWN0aW9uKHRlcm0sIDEvdGhpcy5faGFtbWluZ19kaXN0LCAyLCBzZWFyY2hfY29uc3RzLlBSRURJQ1RPUl9TT1VSQ0VfSUQuQ09SUkVDVE9SICk7XHJcbiAgICAgIHRoaXMucHJlZGljdGlvbnMucHVzaChwcmVkaWN0aW9uKTtcclxuICAgIH1cclxuICB9XHJcbiAgX2dldERpc3RhbmNlKHdvcmQpe1xyXG4gICAgcmV0dXJuIF8uZmluZEVkaXREaXN0KHRoaXMuX3BhcnNlZF9pbnB1dC5fcGFydGlhbCwgd29yZCk7XHJcbiAgfVxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENvcnJlY3RvcjtcclxuIiwiY29uc3QgUHJlZGljdGlvbkxpc3QgPSByZXF1aXJlKCcuL3ByZWRpY3Rpb25fbGlzdCcpO1xyXG5jb25zdCBQcmVkaWN0b25DcmVhdG9yID0gcmVxdWlyZSgnLi9wcmVkaWN0aW9uX2NyZWF0b3InKTtcclxuY29uc3Qgc2VhcmNoX2NvbnN0cyA9IHJlcXVpcmUoJy4vY29uc3RzJyk7XHJcbmNvbnN0IElOREVYID0gcmVxdWlyZSgnLi9pbmRpY2VzJyk7XHJcbmNvbnN0IHJoID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uL2xpYi9yaFwiKVxyXG5jb25zdCBfID0gcmguXztcclxuY29uc3QgUHJlZGljdG9uTWVyZ2VyID0gcmVxdWlyZSgnLi4vY29tbW9uL21lcmdlcicpO1xyXG5cclxuY2xhc3MgR2VuZXJhbFByZWRpY3RvcntcclxuICBjb25zdHJ1Y3RvcihjYWxsYmFjaywgbG9hZGVyLCBtYXhfcHJlZGljdGlvbnMgPSAyMCl7XHJcbiAgICB0aGlzLl9tYXhfcHJlZGljdGlvbnMgPSBtYXhfcHJlZGljdGlvbnM7XHJcbiAgICB0aGlzLl9sb2FkZXIgPSBsb2FkZXI7XHJcbiAgICB0aGlzLnRvdGFsX2NvdW50ID0gdGhpcy5fbG9hZGVyLmdldFRvdGFsQ291bnQoKTtcclxuICAgIHRoaXMuX2NhbGxiYWNrID0gY2FsbGJhY2s7XHJcbiAgICB0aGlzLl9zb3VyY2UgPSBzZWFyY2hfY29uc3RzLlBSRURJQ1RPUl9TT1VSQ0VfSUQuR0VORVJBTF9QUkVESUNUT1I7XHJcbiAgICB0aGlzLnByZWRpY3Rpb25fbWVyZ2VyID0gbmV3IFByZWRpY3Rvbk1lcmdlcihbXSwgdGhpcy50b3RhbF9jb3VudCo1KTtcclxuICB9XHJcbiAgY2xlYXIoKXtcclxuICAgIHRoaXMucHJlZGljdGlvbl9tZXJnZXIuY2xlYXIoKTtcclxuICAgIHRoaXMucGFyc2VkX2lucHV0ID0gdW5kZWZpbmVkXHJcbiAgfVxyXG4gIGdldFByZWRpY3Rpb25zKHBhcnNlZF9pbnB1dCl7XHJcblxyXG4gICAgdGhpcy5faW5pdChwYXJzZWRfaW5wdXQpO1xyXG4gICAgdGhpcy5fY29tcHV0ZVByZWRpY3Rpb25zKClcclxuXHJcbiAgICB0aGlzLl9vblJlc3VsdENvbXB1dGVkKCk7XHJcbiAgfVxyXG4gIF9jb21wdXRlUHJlZGljdGlvbnMoKXtcclxuXHJcbiAgICBsZXQgd29yZF9oYXNoZXMgPSB0aGlzLl9nZXRXb3JkSGFzaGVzKCk7XHJcbiAgICBpZih3b3JkX2hhc2hlcyl7XHJcbiAgICAgIHRoaXMuX2FkZFByZWRpY3Rpb25zKHdvcmRfaGFzaGVzKTtcclxuICAgIH1cclxuICB9XHJcbiAgX2lzV2hvbGVXb3JkSW5wdXQoKXtcclxuICAgIHJldHVybiB0aGlzLnBhcnNlZF9pbnB1dC5pc1dob2xlV29yZDtcclxuICB9XHJcbiAgX2dldFdvcmRIYXNoZXMoKXtcclxuICAgIHJldHVybiAodGhpcy5wYXJzZWRfaW5wdXQuaXNXaG9sZVdvcmQpP1xyXG4gICAgICAgICAgICAgdGhpcy5fbG9hZGVyLnRvcF93b3Jkc1xyXG4gICAgICAgICAgICAgOnRoaXMuX2xvYWRlci5nZXRIYXNoZXModGhpcy5wYXJzZWRfaW5wdXQuX3BhcnRpYWwpXHJcbiAgfVxyXG4gIF9pbml0KHBhcnNlZF9pbnB1dCl7XHJcbiAgICB0aGlzLnByZWRpY3Rpb25fbWVyZ2VyID0gbmV3IFByZWRpY3Rvbk1lcmdlcihbXSwgdGhpcy50b3RhbF9jb3VudCo1KTtcclxuICAgIHRoaXMucGFyc2VkX2lucHV0ID0gcGFyc2VkX2lucHV0O1xyXG4gIH1cclxuICBnZXQgcHJlZGljdGlvbnMgKCl7XHJcbiAgICByZXR1cm4gdGhpcy5wcmVkaWN0aW9uX21lcmdlci5pdGVtc1xyXG4gIH1cclxuICBfb25SZXN1bHRDb21wdXRlZCgpe1xyXG4gICAgaWYodGhpcy5fY2FsbGJhY2spe1xyXG4gICAgICB0aGlzLl9jYWxsYmFjayAobmV3IFByZWRpY3Rpb25MaXN0KHRoaXMucHJlZGljdGlvbnMsIHRoaXMucGFyc2VkX2lucHV0KSwgdGhpcy5fbG9hZGVyKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHNldCBtYXhfcHJlZGljdGlvbnMobmV3VmFsdWUpe1xyXG4gICAgdGhpcy5fbWF4X3ByZWRpY3Rpb25zID0gbmV3VmFsdWU7XHJcbiAgfVxyXG4gIGdldCBtYXhfcHJlZGljdGlvbnMoKXtcclxuICAgIHJldHVybiB0aGlzLl9tYXhfcHJlZGljdGlvbnM7XHJcbiAgfVxyXG4gIF9hZGRQcmVkaWN0aW9ucyhoYXNoZXMpe1xyXG4gICAgaWYoIWhhc2hlcykge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IGhhc2hfY291bnQgPSBoYXNoZXMubGVuZ3RoO1xyXG4gICAgZm9yKGxldCBpID0gMDsgaSA8IGhhc2hfY291bnQgJiYgdGhpcy5wcmVkaWN0aW9ucy5sZW5ndGggPCB0aGlzLm1heF9wcmVkaWN0aW9uczsgaSsrKXtcclxuICAgICAgbGV0IGhhc2ggPSBoYXNoZXNbaV07XHJcbiAgICAgIHRoaXMuX2FkZFdvcmRQcmVkaWN0aW9uKGhhc2gpO1xyXG4gICAgfVxyXG4gIH1cclxuICBfYWRkV29yZFByZWRpY3Rpb24od29yZF9oYXNoLCBtYXRjaEZuKXtcclxuICAgIG1hdGNoRm4gPSBtYXRjaEZuIHx8IHRoaXMuX21hdGNoZXNfcGFydGlhbGx5LmJpbmQodGhpcyk7XHJcbiAgICBsZXQgbW9kZWxfZGF0YSA9IHRoaXMuX2xvYWRlci5nZXRNb2RlbERhdGEod29yZF9oYXNoKTtcclxuICAgIGxldCB0b3RhbF9jb3VudCA9IHRoaXMuX2xvYWRlci50b3RhbF9jb3VudDtcclxuICAgIGlmKG1hdGNoRm4od29yZF9oYXNoKSl7XHJcbiAgICAgIGxldCB3b3JkID0gd29yZF9oYXNoW0lOREVYLk1BUC5XT1JEXTtcclxuICAgICAgaWYodGhpcy5fc2hvdWxkX2FkZF9wcmVkaWN0aW9uKHdvcmQpKXtcclxuICAgICAgICB0aGlzLl9jcmVhdGVfcHJlZGljdGlvbnMod29yZF9oYXNoLCB0b3RhbF9jb3VudCwgbW9kZWxfZGF0YSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIF9jb250aW51ZUZuKCl7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcbiAgX3Nob3VsZF9hZGRfcHJlZGljdGlvbih3b3JkKXtcclxuICAgIHJldHVybiAhdGhpcy5fbG9hZGVyLmlzU3RvcFdvcmQod29yZCkgJiYgIXRoaXMucGFyc2VkX2lucHV0LmVxdWFsTGFzdFdvcmQod29yZClcclxuICB9XHJcbiAgX21hdGNoZXNfcGFydGlhbGx5KHdvcmRfaGFzaCl7XHJcbiAgICBpZih0aGlzLnBhcnNlZF9pbnB1dC5pc1dob2xlV29yZCl7XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIGxldCB3b3JkID0gd29yZF9oYXNoW0lOREVYLk1BUC5XT1JEXTtcclxuICAgIHJldHVybiB0aGlzLnBhcnNlZF9pbnB1dC5jb21wYXJlUGFydGlhbCh3b3JkKTtcclxuICB9XHJcbiAgX2NyZWF0ZV9wcmVkaWN0aW9ucyh3b3JkX2hhc2gsIG1vZGVsX2NvdW50LCBtb2RlbF9pdGVtKXtcclxuICAgIGxldCBjcmVhdG9yID0gbmV3IFByZWRpY3RvbkNyZWF0b3Ioe2xvYWRlcjogdGhpcy5fbG9hZGVyLCBtb2RlbF9pdGVtLCB0b3RhbF9jb3VudDptb2RlbF9jb3VudCwgcGFyc2VkX2lucHV0OnRoaXMucGFyc2VkX2lucHV0LCBjb250aW51ZUZuOiB0aGlzLl9jb250aW51ZUZufSk7XHJcbiAgICBsZXQgcHJlZGljdGlvbnMgPSBjcmVhdG9yLmdldE11bHRpUHJlZGljdGlvbnMod29yZF9oYXNoLCB0cnVlLCB1bmRlZmluZWQsIHRoaXMuX3NvdXJjZSk7XHJcbiAgICBfLmVhY2gocHJlZGljdGlvbnMsIChwcmVkaWN0aW9uKSA9PiB7XHJcbiAgICAgIGlmKHByZWRpY3Rpb24gIT09IHVuZGVmaW5lZCl7XHJcbiAgICAgICAgdGhpcy5wcmVkaWN0aW9uX21lcmdlci5tZXJnZUl0ZW0ocHJlZGljdGlvbilcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBfY2FsY3VsYXRlX3Byb2JhYmlsaXR5KGNvdW50KXtcclxuICAgIHJldHVybiAoY291bnQvdGhpcy50b3RhbF9jb3VudCk7XHJcbiAgfVxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEdlbmVyYWxQcmVkaWN0b3I7XHJcbiIsImxldCByaCA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi9saWIvcmhcIilcclxubGV0IF8gPSByaC5fO1xyXG5sZXQgUHJlZGljdGlvbiA9IHJlcXVpcmUoJy4vcHJlZGljdGlvbicpO1xyXG5sZXQgUGFyc2VyID0gcmVxdWlyZSgnLi9pbnB1dF9wYXJzZXInKTtcclxubGV0IFByZWRpY3Rpb25MaXN0ID0gcmVxdWlyZSgnLi9wcmVkaWN0aW9uX2xpc3QnKTtcclxuY29uc3Qgc2VhcmNoX2NvbnN0cyA9IHJlcXVpcmUoJy4vY29uc3RzJyk7XHJcblxyXG5jbGFzcyBIaXN0b3J5UHJlZGljdG9ye1xyXG4gIGNvbnN0cnVjdG9yKHJlYWRlciwgY2FsbGJhY2spe1xyXG4gICAgdGhpcy5fcmVhZGVyID0gcmVhZGVyO1xyXG4gICAgdGhpcy5fcHJlZGljdGlvbnMgPSBbXTtcclxuICAgIHRoaXMuX2NhbGxiYWNrID0gY2FsbGJhY2s7XHJcbiAgICB0aGlzLl9zb3VyY2UgPSBzZWFyY2hfY29uc3RzLlBSRURJQ1RPUl9TT1VSQ0VfSUQuSElTVE9SWV9QUkVESUNUT1I7XHJcbiAgICB0aGlzLl9tYXhfcHJlZGljdGlvbnMgPSAoc2VhcmNoX2NvbnN0cy5fbWF4X2hpc3RvcnlfcHJlZGljdGlvbnMgPT09IHVuZGVmaW5lZCk/IDI6IHNlYXJjaF9jb25zdHMuX21heF9oaXN0b3J5X3ByZWRpY3Rpb25zO1xyXG4gIH1cclxuICBnZXRQcmVkaWN0aW9ucyhwYXJzZWRfaW5wdXQpIHtcclxuICAgIHRoaXMuX3ByZWRpY3Rpb25zID0gW107XHJcbiAgICB0aGlzLl9wYXJzZWRfaW5wdXQgPSBwYXJzZWRfaW5wdXQ7XHJcbiAgICB0aGlzLl9jb21wdXRlUHJlZGljdGlvbnMoKTtcclxuICAgIGlmKHRoaXMuX2NhbGxiYWNrKXtcclxuICAgICAgdGhpcy5fY2FsbGJhY2sobmV3IFByZWRpY3Rpb25MaXN0KHRoaXMuX3ByZWRpY3Rpb25zLCB0aGlzLl9wYXJzZWRfaW5wdXQpKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzLl9wcmVkaWN0aW9ucztcclxuICB9XHJcbiAgaW5pdCgpe1xyXG4gIH1cclxuICBjbGVhcigpe1xyXG4gICAgdGhpcy5fcHJlZGljdGlvbnMgPSBbXTtcclxuICB9XHJcbiAgX2NvbXB1dGVQcmVkaWN0aW9ucygpe1xyXG4gICAgaWYodGhpcy5fcGFyc2VkX2lucHV0LnRyaW1tZWRUZXh0ICE9PSBcIlwiKXtcclxuICAgICAgXy5lYWNoKHRoaXMuX3JlYWRlci5fbGlzdCwgKGl0ZW0pPT57XHJcbiAgICAgICAgaWYodGhpcy5fbWF0Y2goaXRlbS50ZXh0KSl7XHJcbiAgICAgICAgICB0aGlzLl9wcmVkaWN0aW9ucy5wdXNoKHRoaXMuX2NyZWF0ZVByZWRpY3Rpb24oaXRlbSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICAgIHRoaXMuX3B1cmdlKCk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIF9wdXJnZSgpe1xyXG4gICAgdGhpcy5fcHJlZGljdGlvbnMuc3BsaWNlKHRoaXMuX21heF9wcmVkaWN0aW9ucyk7XHJcbiAgfVxyXG4gIF9jcmVhdGVQcmVkaWN0aW9uKGl0ZW0pe1xyXG4gICAgbGV0IG5ld1ByZWRpY3Rpb24gPSBuZXcgUHJlZGljdGlvbihpdGVtLnRleHQsIDEsIGl0ZW0uY291bnQsIHRoaXMuX3NvdXJjZSk7XHJcbiAgICByZXR1cm4gbmV3UHJlZGljdGlvbjtcclxuICB9XHJcbiAgX21hdGNoKHRleHQpe1xyXG4gICAgaWYodGhpcy5fcGFyc2VkX2lucHV0Lm9yaWdpbmFsX3RleHQubGVuZ3RoID4gdGV4dC5sZW5ndGgpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlXHJcbiAgICB9XHJcbiAgICBsZXQgcGFyc2VkX3RleHQgPSBuZXcgUGFyc2VyKHRleHQsIHRydWUpO1xyXG4gICAgcmV0dXJuIHRoaXMuX3BhcnNlZF9pbnB1dC5jb21wYXJlKHBhcnNlZF90ZXh0KTtcclxuICB9XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gSGlzdG9yeVByZWRpY3RvcjtcclxuIiwibGV0IHJoID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uL2xpYi9yaFwiKVxyXG5sZXQgXyA9IHJoLl87XHJcbmNvbnN0IHNlYXJjaF91dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcclxuXHJcbmNsYXNzIEhpc3RvcnlSZWFkZXJ7XHJcbiAgY29uc3RydWN0b3IoKXtcclxuICB9XHJcblxyXG5cclxuICBpbml0SGlzdG9yeShsaXN0KXtcclxuICAgIGlmKHRoaXMuX2xpc3QgPT09IHVuZGVmaW5lZCl7XHJcbiAgICAgIHRoaXMuX2xpc3QgPSBsaXN0IHx8IFtdO1xyXG4gICAgfVxyXG4gIH1cclxuICBnZXRIaXN0b3J5KCl7XHJcbiAgICByZXR1cm4gdGhpcy5fbGlzdCB8fCBbXTtcclxuICB9XHJcblxyXG4gIF91cGRhdGVUZXh0KHRleHQsIGluZGV4KXtcclxuICAgIHRoaXMuZ2V0SGlzdG9yeSgpLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICB0aGlzLmdldEhpc3RvcnkoKS51bnNoaWZ0KHRleHQpO1xyXG4gIH1cclxuXHJcbiAgX2FkZE5ld1RleHQobmV3VGV4dCl7XHJcbiAgICB0aGlzLmdldEhpc3RvcnkoKS5wdXNoKG5ld1RleHQpO1xyXG4gIH1cclxuXHJcbiAgYWRkKG5ld1RleHQpe1xyXG4gICAgbGV0IG5JbmRleCA9IF8uZmluZEluZGV4KHRoaXMuZ2V0SGlzdG9yeSgpLCAoaXRlbSkgPT4ge3JldHVybiBzZWFyY2hfdXRpbHMuY29tcGFyZU5vQ2FzZShuZXdUZXh0LnRleHQsIGl0ZW0udGV4dCkgPT09IDA7fSk7XHJcbiAgICBpZihuSW5kZXggPj0wKXtcclxuICAgICAgdGhpcy5fdXBkYXRlVGV4dChuZXdUZXh0LCBuSW5kZXgpO1xyXG4gICAgfVxyXG4gICAgZWxzZXtcclxuICAgICAgdGhpcy5fYWRkTmV3VGV4dChuZXdUZXh0KTtcclxuICAgIH1cclxuICB9XHJcbiAgZGVsZXRlKHNlYXJjaFRleHQpe1xyXG4gICAgbGV0IG5JbmRleCA9IF8uZmluZEluZGV4KHRoaXMuZ2V0SGlzdG9yeSgpLCAoaXRlbSkgPT4ge3JldHVybiBzZWFyY2hfdXRpbHMuY29tcGFyZU5vQ2FzZShzZWFyY2hUZXh0LCBpdGVtLnRleHQpID09PSAwO30pO1xyXG4gICAgaWYobkluZGV4ID49MCl7XHJcbiAgICAgIHRoaXMuZ2V0SGlzdG9yeSgpLnNwbGljZShuSW5kZXgpO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBuZXcgSGlzdG9yeVJlYWRlcigpO1xyXG4iLCJsZXQgX2V4cG9ydHMgPSB7XHJcbiAgTUFQOntcclxuICAgIFdPUkQ6MCxcclxuICAgIEhBU0g6MSxcclxuICAgIENPVU5UOjIsXHJcbiAgICBNT0RFTF9GSUxFX05POjMsXHJcbiAgICBNT0RFTF9JTkRFWDo0LFxyXG4gICAgVE9QSUNTOjVcclxuICB9LFxyXG5cclxuICBNT0RFTCA6e1xyXG4gICAgV09SRF9IQVNIOjAsXHJcbiAgICBDT1VOVDogMSxcclxuICAgIE5FWFRfTU9ERUw6IDJcclxuICB9LFxyXG5cclxuICBGSVJTVF9QUkVESUNUSU9OOntcclxuICAgIE5FWFQ6MCxcclxuICAgIFBSRVZJT1VTOjFcclxuICB9XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IF9leHBvcnRzOyIsImNvbnN0IHNlYXJjaF91dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcclxuY29uc3QgcmggPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vLi4vc3JjL2xpYi9yaFwiKVxyXG5jb25zdCBfID0gcmguXztcclxuXHJcbmNsYXNzIElucHV0UGFyc2Vye1xyXG4gIGNvbnN0cnVjdG9yKHRleHQsIGlzV2hvbGVXb3JkLCBzZWxlY3Rpb24sIGlzUHJldmlvdXMpe1xyXG4gICAgdGhpcy5pc1ByZXZpb3VzID0gaXNQcmV2aW91cztcclxuICAgIHRoaXMuc2VsZWN0aW9uID0gKHNlbGVjdGlvbiA9PT0gdW5kZWZpbmVkKSA/IHRleHQubGVuZ3RoIDogc2VsZWN0aW9uXHJcbiAgICBsZXQgc2VwYXJhdG9yID0gdGhpcy5fY2FsY3VsYXRlU2VwYXJhdG9yKHRleHQpO1xyXG4gICAgaWYoIXRoaXMuaXNQcmV2aW91cyl7XHJcbiAgICAgIHRoaXMuaXNXaG9sZVdvcmQgPSBpc1dob2xlV29yZCB8fCB0aGlzLl9pc1dob2xlV29yZCh0ZXh0LCBzZXBhcmF0b3IpO1xyXG4gICAgfVxyXG4gICAgdGhpcy5pbml0VGV4dCh0ZXh0LCBzZXBhcmF0b3IpO1xyXG4gIH1cclxuXHJcbiAgaW5pdFRleHQodGV4dCwgc2VwYXJhdG9yKXtcclxuICAgIHRoaXMuX2NvbXB1dGVUZXh0KHRleHQsIHNlcGFyYXRvcik7XHJcbiAgICB0aGlzLnRyaW1tZWRUZXh0ID0gdGhpcy5vcmlnaW5hbF90ZXh0LnRyaW0oKTtcclxuICAgIHRoaXMud29yZHMgPSBfLmNvbXBhY3QodGhpcy50cmltbWVkVGV4dC5zcGxpdChcIiBcIikgfHwgW10pO1xyXG4gICAgdGhpcy5fcmV2ZXJzZUlmUHJldmlvdXMoKTtcclxuICAgIGlmKCF0aGlzLmlzV2hvbGVXb3JkICYmIHRoaXMud29yZHMubGVuZ3RoID4gMCl7XHJcbiAgICAgIHRoaXMuX3BhcnRpYWwgPSAodGhpcy53b3Jkcy5zcGxpY2UoLTEpKVswXTtcclxuICAgIH1cclxuICB9XHJcbiAgX2NvbXB1dGVUZXh0KHRleHQsIHNlcGFyYXRvcil7XHJcbiAgICB0aGlzLl9yaWdodF90ZXh0ID0gXCJcIjtcclxuICAgIHRoaXMuX2xlZnRfdGV4dCA9IFwiXCI7XHJcblxyXG4gICAgaWYoc2VwYXJhdG9yID09PSB1bmRlZmluZWQpe1xyXG4gICAgICBzZXBhcmF0b3IgPSB0ZXh0Lmxlbmd0aDtcclxuICAgIH1cclxuICAgIHRoaXMuaXNTcGxpdFRleHQgPSAhKHNlcGFyYXRvciA9PT0gMCB8fCBzZXBhcmF0b3IgPT09IHRleHQubGVuZ3RoKVxyXG4gICAgbGV0IGxlZnRfdGV4dCA9IHRleHQuc3Vic3RyaW5nKDAsIHNlcGFyYXRvcik7XHJcbiAgICBsZXQgcmlnaHRfdGV4dCA9IHRleHQuc3Vic3RyaW5nKHNlcGFyYXRvcik7XHJcblxyXG4gICAgaWYodGhpcy5pc1ByZXZpb3VzKXtcclxuICAgICAgdGhpcy5vcmlnaW5hbF90ZXh0ID0gcmlnaHRfdGV4dDtcclxuICAgICAgdGhpcy5fbGVmdF90ZXh0ID0gbGVmdF90ZXh0LnRyaW0oKTtcclxuICAgIH1cclxuICAgIGVsc2V7XHJcbiAgICAgIHRoaXMub3JpZ2luYWxfdGV4dCA9IGxlZnRfdGV4dDtcclxuICAgICAgdGhpcy5fcmlnaHRfdGV4dCA9IHJpZ2h0X3RleHQudHJpbSgpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZXF1YWxSZW1haW5nV29yZCh3b3JkKXtcclxuICAgIGlmKHRoaXMuX2xlZnRfdGV4dCAhPT0gXCJcIiB8fCB0aGlzLl9yaWdodF90ZXh0ICE9PVwiXCIpe1xyXG4gICAgICBsZXQgcmVtYWluaW5nV29yZCA9IHRoaXMuX2dldFJlbWFpbmlnV29yZCgpO1xyXG4gICAgICBpZihyZW1haW5pbmdXb3JkKXtcclxuICAgICAgICByZXR1cm4gc2VhcmNoX3V0aWxzLmNvbXBhcmVOb0Nhc2UocmVtYWluaW5nV29yZCwgd29yZCkgPT09IDA7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZVxyXG4gIH1cclxuXHJcblxyXG4gIF9nZXRSZW1haW5pZ1dvcmQoKXtcclxuICAgIGxldCB3b3JkcyA9ICh0aGlzLmlzUHJldmlvdXMpPyB0aGlzLl9sZWZ0X3RleHQuc3BsaXQoXCIgXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdGhpcy5fcmlnaHRfdGV4dC5zcGxpdChcIiBcIik7XHJcblxyXG4gICAgd29yZHMgPSB3b3JkcyB8fCBbXVxyXG4gICAgd29yZHMgPSBfLmNvbXBhY3Qod29yZHMpO1xyXG4gICAgaWYod29yZHMubGVuZ3RoID4gMCl7XHJcbiAgICAgIHJldHVybiAodGhpcy5pc1ByZXZpb3VzKT8gd29yZHNbd29yZHMubGVuZ3RoIC0xXSA6IHdvcmRzWzBdO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgY29tcGxldGVTdWdnZXN0aW9uKHRleHQpe1xyXG4gICAgaWYodGhpcy5pc1ByZXZpb3VzKXtcclxuICAgICAgcmV0dXJuICh0aGlzLl9sZWZ0X3RleHQubGVuZ3RoID09PSAwKT8gdGV4dCA6IHRoaXMuX2xlZnRfdGV4dCArIFwiIFwiICsgdGV4dDtcclxuICAgIH1cclxuICAgIGVsc2V7XHJcbiAgICAgIHJldHVybiAodGhpcy5fcmlnaHRfdGV4dC5sZW5ndGggPT09IDApPyB0ZXh0IDogdGV4dCArIFwiIFwiICsgdGhpcy5fcmlnaHRfdGV4dDtcclxuICAgIH1cclxuICB9XHJcbiAgX2NhbGN1bGF0ZVNlcGFyYXRvcih0ZXh0KXtcclxuXHJcbiAgICBpZih0aGlzLmlzUHJldmlvdXMpe1xyXG4gICAgICBpZih0aGlzLnNlbGVjdGlvbiA9PT0gMCl7XHJcbiAgICAgICAgdGhpcy5pc1dob2xlV29yZCA9IHRydWU7XHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgIH1cclxuICAgICAgaWYoKHRleHQubGVuZ3RoID4gdGhpcy5zZWxlY3Rpb24pICYmIHRleHRbdGhpcy5zZWxlY3Rpb24tMV0gIT09IFwiIFwiKXtcclxuICAgICAgICBsZXQgcHJldmlvdXNTcGFjZUluZGV4ID0gdGV4dC5sYXN0SW5kZXhPZihcIiBcIiwgdGhpcy5zZWxlY3Rpb24tMSk7XHJcbiAgICAgICAgdGhpcy5pc1dob2xlV29yZCA9IGZhbHNlO1xyXG4gICAgICAgIHJldHVybiAocHJldmlvdXNTcGFjZUluZGV4ID49IDApID8gcHJldmlvdXNTcGFjZUluZGV4KzEgOiAwO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuaXNXaG9sZVdvcmQgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXMuc2VsZWN0aW9uO1xyXG4gIH1cclxuICBfcmV2ZXJzZUlmUHJldmlvdXMoKXtcclxuICAgIGlmKHRoaXMuaXNQcmV2aW91cyl7XHJcbiAgICAgIHRoaXMud29yZHMucmV2ZXJzZSgpO1xyXG4gICAgfVxyXG4gIH1cclxuICBfaXNXaG9sZVdvcmQodGV4dCwgc2VwYXJhdG9yKXtcclxuICAgIGlmKHRoaXMuaXNQcmV2aW91cyl7XHJcbiAgICAgIGlmIChzZXBhcmF0b3IgPT09IDApIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gKHRleHQubGVuZ3RoID4gc2VwYXJhdG9yKSAmJiB0ZXh0W3NlcGFyYXRvci0xXSA9PT0gXCIgXCI7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHNlcGFyYXRvciA+IDAgJiYgdGV4dFtzZXBhcmF0b3IgLTFdID09PSBcIiBcIjtcclxuICB9XHJcbiAgY29tcGFyZShvdGhlcl9pbnB1dCwgc3RhcnQgPSAwLCBlbmQgPSB1bmRlZmluZWQpe1xyXG4gICAgZW5kID0gKGVuZCA9PT0gdW5kZWZpbmVkKSA/ICB0aGlzLndvcmRzLmxlbmd0aCAtMSA6IGVuZDtcclxuICAgIGlmKHRoaXMud29yZHMubGVuZ3RoID4gb3RoZXJfaW5wdXQud29yZHMubGVuZ3RoKXtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgbGV0IGkgPSBzdGFydDtcclxuICAgIGZvcig7IGkgPD0gZW5kOyBpKyspe1xyXG4gICAgICBsZXQgd29yZDEgPSB0aGlzLndvcmRzW2ldO1xyXG4gICAgICBsZXQgd29yZDIgPSBvdGhlcl9pbnB1dC53b3Jkc1tpXTtcclxuICAgICAgaWYoc2VhcmNoX3V0aWxzLmNvbXBhcmVOb0Nhc2Uod29yZDEsIHdvcmQyKSAhPT0gMCkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXMubWF0Y2hQYXJ0aWFsKG90aGVyX2lucHV0LCBpKTtcclxuICB9XHJcbiAgbWF0Y2hQYXJ0aWFsKG90aGVyX2lucHV0LCBpbmRleCl7XHJcbiAgICBpZih0aGlzLl9wYXJ0aWFsID09PSB1bmRlZmluZWQpe1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIGlmKG90aGVyX2lucHV0LndvcmRzLmxlbmd0aCA8PSBpbmRleCl7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGxldCBvdGhlcl93b3JkID0gb3RoZXJfaW5wdXQud29yZHNbaW5kZXhdO1xyXG4gICAgcmV0dXJuIHRoaXMuY29tcGFyZVBhcnRpYWwob3RoZXJfd29yZCk7XHJcbiAgfVxyXG4gIGNvbXBhcmVQYXJ0aWFsKHdvcmQpe1xyXG4gICAgdGhpcy5fbWF0Y2hFeHAgPSBuZXcgUmVnRXhwKCdeJyArIHRoaXMuX3BhcnRpYWwsICdpJyk7XHJcbiAgICByZXR1cm4gdGhpcy5fbWF0Y2hFeHAudGVzdCh3b3JkKTtcclxuICB9XHJcbiAgY29tcGxldGVXb3JkKG5leHRfd29yZCl7XHJcbiAgICBpZih0aGlzLmlzV2hvbGVXb3JkIHx8IHRoaXMuX3BhcnRpYWwgPT09IHVuZGVmaW5lZCB8fCB0aGlzLl9wYXJ0aWFsLmxlbmd0aCA9PT0gMCl7XHJcbiAgICAgIHJldHVybiB0aGlzLmdldFRlcm1Gb3JDb21wbGV0ZVdvcmQobmV4dF93b3JkLCB0aGlzLnRyaW1tZWRUZXh0KTtcclxuICAgIH1cclxuICAgIGVsc2V7XHJcbiAgICAgIHJldHVybiB0aGlzLmdldFRlcm1Gb3JQYXJ0aWFsVGV4dChuZXh0X3dvcmQpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZ2V0VGVybUZvclBhcnRpYWxUZXh0KG5leHRfd29yZCl7XHJcbiAgICBsZXQgcGFydGlhbF9uZXh0X3dvcmQgPSBuZXh0X3dvcmQuc3Vic3RyaW5nKHRoaXMuX3BhcnRpYWwubGVuZ3RoLCBuZXh0X3dvcmQubGVuZ3RoKTtcclxuICAgIGlmKHRoaXMuaXNQcmV2aW91cyl7XHJcbiAgICAgIGxldCB0cmltbWVkVGV4dCA9IFwiXCI7XHJcbiAgICAgIGxldCBmaXJzdFNwYWNlSW5kZXggPSB0aGlzLnRyaW1tZWRUZXh0LmluZGV4T2YoJyAnKTtcclxuICAgICAgaWYoZmlyc3RTcGFjZUluZGV4ID49IDApe1xyXG4gICAgICAgIHRyaW1tZWRUZXh0ID0gdGhpcy50cmltbWVkVGV4dC5zdWJzdHJpbmcoZmlyc3RTcGFjZUluZGV4KTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gdGhpcy5fcGFydGlhbCArIHBhcnRpYWxfbmV4dF93b3JkICsgdHJpbW1lZFRleHQ7XHJcbiAgICB9XHJcbiAgICBlbHNle1xyXG4gICAgICByZXR1cm4gdGhpcy50cmltbWVkVGV4dCArIHBhcnRpYWxfbmV4dF93b3JkO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZ2V0VGVybUZvckNvbXBsZXRlV29yZChuZXh0X3dvcmQpe1xyXG4gICAgaWYodGhpcy5pc1ByZXZpb3VzKXtcclxuICAgICAgcmV0dXJuIG5leHRfd29yZCArIFwiIFwiICsgdGhpcy50cmltbWVkVGV4dDtcclxuICAgIH1cclxuICAgIGVsc2V7XHJcbiAgICAgIHJldHVybiB0aGlzLnRyaW1tZWRUZXh0ICsgXCIgXCIgKyBuZXh0X3dvcmQ7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXBsYWNlTGFzdFdvcmQobmV4dF93b3JkKXtcclxuICAgIGxldCB0ZXh0ID0gdGhpcy50cmltbWVkVGV4dDtcclxuICAgIGlmKHRoaXMuX3BhcnRpYWwgIT09IHVuZGVmaW5lZCAmJiAhdGhpcy5pc1dob2xlV29yZCl7XHJcbiAgICAgIGxldCBpbmRleCA9IHRoaXMudHJpbW1lZFRleHQubGVuZ3RoIC0gdGhpcy5fcGFydGlhbC5sZW5ndGg7XHJcbiAgICAgIHRleHQgPSB0aGlzLnRyaW1tZWRUZXh0LnN1YnN0cmluZygwLCBpbmRleCk7XHJcbiAgICAgIHRleHQgPSB0ZXh0LnRyaW0oKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0ZXh0ICsgXCIgXCIgKyBuZXh0X3dvcmQ7XHJcbiAgfVxyXG4gIGVxdWFsTGFzdFdvcmQod29yZCl7XHJcbiAgICBpZih0aGlzLndvcmRzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBsZXQgbGFzdF93b3JkID0gdGhpcy53b3Jkc1t0aGlzLndvcmRzLmxlbmd0aCAtMV07XHJcbiAgICByZXR1cm4gc2VhcmNoX3V0aWxzLmNvbXBhcmVOb0Nhc2UobGFzdF93b3JkLCB3b3JkKSA9PT0gMDtcclxuICB9XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gSW5wdXRQYXJzZXI7XHJcbiIsImNvbnN0IHJoID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uL2xpYi9yaFwiKVxyXG5jb25zdCBfID0gcmguXztcclxuY29uc3QgbW9kZWwgPSByaC5tb2RlbDtcclxuY29uc3Qgc2VhcmNoX3V0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xyXG5jb25zdCBJTkRFWCA9IHJlcXVpcmUoJy4vaW5kaWNlcycpO1xyXG5jb25zdCBTRUFSQ0hfQ09OU1RTID0gcmVxdWlyZSgnLi9jb25zdHMnKTtcclxuY29uc3QgUGF0aHMgPSByZXF1aXJlKCcuLi9jb21tb24vcGF0aHMnKVxyXG5cclxuXHJcbmNsYXNzIExvYWRlciB7XHJcbiAgY29uc3RydWN0b3IocGF0aCA9IFwiXCIpe1xyXG4gICAgdGhpcy5fcGF0aHMgPSBuZXcgUGF0aHMocGF0aClcclxuICB9XHJcblxyXG4gIGluaXQoY2FsbGJhY2tGbil7XHJcbiAgICB0aGlzLmxvYWRJbmRleChjYWxsYmFja0ZuKTtcclxuICAgIHRoaXMubG9hZE1hcChjYWxsYmFja0ZuKTtcclxuICB9XHJcblxyXG4gIF9pc0luZGV4TG9hZGVkKCl7XHJcbiAgICByZXR1cm4gdGhpcy5pbmRleF9kYXRhICE9PSB1bmRlZmluZWQ7XHJcbiAgfVxyXG5cclxuICBnZXRNb2RlbENvdW50KCl7XHJcbiAgICByZXR1cm4gdGhpcy5pbmRleF9kYXRhLk1vZGVsLmxlbmd0aDtcclxuICB9XHJcbiAgZ2V0TWFwSGFzaChoYXNoX2tleSl7XHJcbiAgICByZXR1cm4gdGhpcy5faGFzaF90b193b3JkW2hhc2hfa2V5XTtcclxuICB9XHJcbiAgZ2V0SGFzaGVzKGlucHV0KXtcclxuICAgIGlmKGlucHV0ICE9PSB1bmRlZmluZWQgJiYgaW5wdXQubGVuZ3RoID4gMCl7XHJcbiAgICAgIHJldHVybiB0aGlzLmdldEFwbGhhYmV0SGFzaGVzKGlucHV0WzBdKTtcclxuICAgIH1cclxuICB9XHJcbiAgZ2V0QXBsaGFiZXRIYXNoZXMoYWxwaGFiZXQpe1xyXG4gICAgaWYodGhpcy5tYXBfZGF0YSAmJiBhbHBoYWJldC5sZW5ndGggPT09IDEpe1xyXG4gICAgICBsZXQgbGFscGhhYmV0ID0gYWxwaGFiZXQudG9Mb3dlckNhc2UoKVxyXG4gICAgICByZXR1cm4gdGhpcy5tYXBfZGF0YVtsYWxwaGFiZXRdO1xyXG4gICAgfVxyXG4gIH1cclxuICBnZXRXb3JkTW9kZWwod29yZCwgbW9kZWxfZGF0YSl7XHJcbiAgICBsZXQgd29yZF9tb2RlbDtcclxuICAgIGxldCB3b3JkX2hhc2ggPSB0aGlzLl9nZXRIYXNoRm9yV29yZCh3b3JkKTtcclxuICAgIGlmKHdvcmRfaGFzaCAmJiBtb2RlbF9kYXRhKXtcclxuICAgICAgd29yZF9tb2RlbCA9IG1vZGVsX2RhdGFbd29yZF9oYXNoW0lOREVYLk1BUC5NT0RFTF9JTkRFWF1dO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHdvcmRfbW9kZWw7XHJcbiAgfVxyXG5cclxuICBnZXRDb3VudCh3b3JkKXtcclxuICAgIGxldCB3b3JkX2hhc2ggPSB0aGlzLl9nZXRIYXNoRm9yV29yZCh3b3JkKTtcclxuICAgIGlmKHdvcmRfaGFzaCl7XHJcbiAgICAgIHJldHVybiB3b3JkX2hhc2hbSU5ERVguTUFQLkNPVU5UXTtcclxuICAgIH1cclxuICB9XHJcbiAgZ2V0TW9kZWxEYXRhKHdvcmRfaGFzaCl7IC8vIGFzeW5jIGNhbGwgaWYgbm90IGxvYWRlZCByZXR1cm4gZW1wdHkgYXJyYXlcclxuICAgIGxldCBmaWxlbm8gPSB3b3JkX2hhc2hbSU5ERVguTUFQLk1PREVMX0ZJTEVfTk9dO1xyXG4gICAgbGV0IG1vZGVsX2luZGV4ID0gd29yZF9oYXNoW0lOREVYLk1BUC5NT0RFTF9JTkRFWF07XHJcbiAgICBsZXQgZGF0YSA9IG1vZGVsLmdldCh0aGlzLl9wYXRocy5nZXRNb2RlbEtleShmaWxlbm8pKTtcclxuICAgIGlmKCFkYXRhKXtcclxuICAgICAgdGhpcy5sb2FkTW9kZWwoZmlsZW5vKTtcclxuICAgIH1cclxuICAgIHJldHVybiBkYXRhICYmIGRhdGFbbW9kZWxfaW5kZXhdIDtcclxuICB9XHJcbiAgX2NvbXBhcmVXb3JkQ291bnQoaGFzaF9pdGVtMSwgaGFzaF9pdGVtMil7XHJcbiAgICBsZXQgY291bnQxID0gc2VhcmNoX3V0aWxzLmdldFNhZmVFbGVtZW50KGhhc2hfaXRlbTEsIElOREVYLk1BUC5DT1VOVCk7XHJcbiAgICBsZXQgY291bnQyID0gc2VhcmNoX3V0aWxzLmdldFNhZmVFbGVtZW50KGhhc2hfaXRlbTIsIElOREVYLk1BUC5DT1VOVCk7XHJcbiAgICBpZihjb3VudDEgJiYgY291bnQyKSB7XHJcbiAgICAgIHJldHVybiBjb3VudDIgLSBjb3VudDE7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gMDtcclxuICB9XHJcbiAgX2J1aWxkVG9wV29yZHMod29yZHMpe1xyXG4gICAgd29yZHMuc29ydCh0aGlzLl9jb21wYXJlV29yZENvdW50KTtcclxuICAgIHdvcmRzLnNwbGljZShTRUFSQ0hfQ09OU1RTLm1heF9wcmVkaWN0aW9ucyAqMTAwKVxyXG4gICAgdGhpcy5fdG9wX3dvcmRzID0gd29yZHM7XHJcbiAgfVxyXG4gIGdldCB0b3Bfd29yZHMoKXtcclxuICAgIHJldHVybiB0aGlzLl90b3Bfd29yZHM7XHJcbiAgfVxyXG4gIGdldE1vZGVsRmlsZU5vKHdvcmQpe1xyXG4gICAgbGV0IHdvcmRfaGFzaCA9IHRoaXMuX2dldEhhc2hGb3JXb3JkKHdvcmQpO1xyXG4gICAgaWYod29yZF9oYXNoKXtcclxuICAgICAgcmV0dXJuIHdvcmRfaGFzaFtJTkRFWC5NQVAuTU9ERUxfRklMRV9OT107XHJcbiAgICB9XHJcbiAgfVxyXG4gIF9nZXRIYXNoRm9yV29yZCh3b3JkKXtcclxuICAgIGxldCBoYXNoO1xyXG4gICAgbGV0IHdvcmRfa2V5ID0gdGhpcy5nZXRIYXNoS2V5KHdvcmQpO1xyXG4gICAgaWYod29yZF9rZXkpe1xyXG4gICAgICBoYXNoID0gdGhpcy5faGFzaF90b193b3JkW3dvcmRfa2V5XTtcclxuICAgIH1cclxuICAgIHJldHVybiBoYXNoO1xyXG4gIH1cclxuICBnZXRIYXNoS2V5KHdvcmQpe1xyXG4gICAgaWYod29yZCAmJiB3b3JkLmxlbmd0aCA+IDApe1xyXG4gICAgICBsZXQgbFdvcmQgPSB3b3JkLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgIHJldHVybiB0aGlzLl93b3JkX2hhc2hbbFdvcmRdO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgbG9hZEluZGV4KGNhbGxiYWNrRm4pIHtcclxuICAgIGlmKHRoaXMuX2lzSW5kZXhMb2FkZWQoKSA9PT0gZmFsc2Upe1xyXG4gICAgICBfLmxvYWRTY3JpcHQodGhpcy5fcGF0aHMuZ2V0SW5kZXhGaWxlUGF0aCgpLCB0cnVlLCAoKSA9PiB7XHJcbiAgICAgICAgdGhpcy5pbmRleF9kYXRhID0gXy5leHBvcnRzKCk7XHJcbiAgICAgICAgdGhpcy5vbkluZGV4TG9hZGVkKGNhbGxiYWNrRm4pO1xyXG4gICAgICB9LCB0cnVlKTtcclxuICAgIH1cclxuICAgIGVsc2V7XHJcbiAgICAgIHRoaXMub25JbmRleExvYWRlZChjYWxsYmFja0ZuKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGdldCBuR3JhbSgpe1xyXG4gICAgcmV0dXJuIHRoaXMuaW5kZXhfZGF0YS5uR3JhbTtcclxuICB9XHJcbiAgZ2V0IHNlYXJjaF9tb2RlbCAoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5pbmRleF9kYXRhLk1vZGVsO1xyXG4gIH1cclxuICBnZXQgc2VhcmNoX21hcCgpe1xyXG4gICAgcmV0dXJuIHRoaXMuaW5kZXhfZGF0YS5NYXA7XHJcbiAgfVxyXG4gIGdldCB0b3RhbF9jb3VudCgpe1xyXG4gICAgcmV0dXJuIHRoaXMuaW5kZXhfZGF0YS50b3RhbENvdW50O1xyXG4gIH1cclxuICBnZXQgc3RvcF93b3Jkcygpe1xyXG4gICAgcmV0dXJuIHRoaXMuaW5kZXhfZGF0YS5zdG9wV29yZHM7XHJcbiAgfVxyXG5cclxuICBsb2FkTW9kZWwoZmlsZU5vLCBjYWxsYmFja0ZuKSB7XHJcbiAgICBsZXQgZGF0YSA9IFtdO1xyXG4gICAgaWYoZmlsZU5vIT09IHVuZGVmaW5lZCl7XHJcbiAgICAgIGxldCBrZXkgPSB0aGlzLl9wYXRocy5nZXRNb2RlbEtleShmaWxlTm8pXHJcbiAgICAgIGxldCBkYXRhID0gbW9kZWwuZ2V0KGtleSlcclxuICAgICAgaWYoZGF0YSA9PT0gdW5kZWZpbmVkKXtcclxuICAgICAgICBtb2RlbC5wdWJsaXNoKGtleSwgbnVsbClcclxuXHJcbiAgICAgICAgbGV0IGZpbGVwYXRoID0gdGhpcy5fcGF0aHMuZ2V0TW9kZWxGaWxlUGF0aChmaWxlTm8pXHJcbiAgICAgICAgXy5sb2FkU2NyaXB0KGZpbGVwYXRoLCB0cnVlLCB0aGlzLmdldE9uTW9kZWxMb2FkRm4oZmlsZU5vLCBjYWxsYmFja0ZuKSwgdHJ1ZSk7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSBpZihkYXRhID09PSBudWxsICYmIGNhbGxiYWNrRm4gIT09IHVuZGVmaW5lZCl7XHJcblxyXG4gICAgICAgIG1vZGVsLnN1YnNjcmliZShrZXksIGNhbGxiYWNrRm4pO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2V7XHJcbiAgICAgICAgdGhpcy5kb0NhbGxiYWNrKGNhbGxiYWNrRm4sIGRhdGEsIGZpbGVObylcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZXtcclxuICAgICAgdGhpcy5kb0NhbGxiYWNrKGNhbGxiYWNrRm4sIGRhdGEsIGZpbGVObylcclxuICAgIH1cclxuICB9XHJcbiAgZG9DYWxsYmFjayhjYWxsYmFja0ZuLCBkYXRhLCBmaWxlbm8pe1xyXG4gICAgaWYoY2FsbGJhY2tGbikge1xyXG4gICAgICBjYWxsYmFja0ZuKGRhdGEsIGZpbGVubylcclxuICAgIH1cclxuICB9XHJcbiAgZ2V0T25Nb2RlbExvYWRGbihmaWxlTm8sIGNhbGxiYWNrRm4pe1xyXG4gICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgbGV0IGRhdGEgPSBfLmV4cG9ydHMoKTtcclxuICAgICAgbW9kZWwucHVibGlzaCh0aGlzLl9wYXRocy5nZXRNb2RlbEtleShmaWxlTm8pLCBkYXRhKTtcclxuICAgICAgaWYoY2FsbGJhY2tGbil7XHJcbiAgICAgICAgY2FsbGJhY2tGbihkYXRhLCBmaWxlTm8pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG4gIG9uTWFwTG9hZGVkKGNhbGxiYWNrRm4pe1xyXG4gICAgdGhpcy5wYXJzZU1hcCgpO1xyXG4gICAgaWYodGhpcy5pbmRleF9kYXRhICYmIGNhbGxiYWNrRm4pe1xyXG4gICAgICBjYWxsYmFja0ZuKHRoaXMpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgb25JbmRleExvYWRlZChjYWxsYmFja0ZuKXtcclxuICAgIGlmKHRoaXMubWFwX2RhdGEgJiYgY2FsbGJhY2tGbil7XHJcbiAgICAgIGNhbGxiYWNrRm4odGhpcyk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHBhcnNlTWFwKCl7XHJcbiAgICBsZXQgZGF0YSA9IHRoaXMubWFwX2RhdGE7XHJcbiAgICB0aGlzLl93b3JkX2hhc2ggPSB7fTtcclxuICAgIHRoaXMuX2hhc2hfdG9fd29yZCA9e307XHJcbiAgICBsZXQgd29yZHMgPSBbXTtcclxuICAgIGZvciAoY29uc3QgbGV0dGVyIGluIGRhdGEpe1xyXG4gICAgICBsZXQgd29yZHNfZGF0YSA9IGRhdGFbbGV0dGVyXTtcclxuICAgICAgdGhpcy5fcGFyc2VXb3Jkc0RhdGEod29yZHNfZGF0YSlcclxuICAgICAgd29yZHMgPSB3b3Jkcy5jb25jYXQod29yZHNfZGF0YSk7XHJcbiAgICB9XHJcbiAgICB0aGlzLl9idWlsZFRvcFdvcmRzKHdvcmRzKTtcclxuICB9XHJcbiAgX3BhcnNlV29yZHNEYXRhKHdvcmRzX2RhdGEpe1xyXG4gICAgXy5lYWNoKHdvcmRzX2RhdGEsICh3b3JkX2RhdGEpID0+e1xyXG4gICAgICBsZXQgaGFzaF9rZXkgPSBwYXJzZUludCh3b3JkX2RhdGFbSU5ERVguTUFQLkhBU0hdKTtcclxuICAgICAgaWYod29yZF9kYXRhW0lOREVYLk1BUC5XT1JEXSkge1xyXG4gICAgICAgIGxldCB3b3JkID0gd29yZF9kYXRhW0lOREVYLk1BUC5XT1JEXS50b1N0cmluZygpO1xyXG4gICAgICAgIHRoaXMuX3dvcmRfaGFzaFt3b3JkXSA9IGhhc2hfa2V5O1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuX2hhc2hfdG9fd29yZFtoYXNoX2tleV0gPSB3b3JkX2RhdGE7XHJcbiAgICB9KTtcclxuICB9XHJcbiAgaXNTdG9wV29yZCh3b3JkKXtcclxuICAgIGxldCBpbmRleCA9IF8uZmluZCh0aGlzLmluZGV4X2RhdGEuc3RvcFdvcmRzLCAoc3RvcF93b3JkKSA9PntcclxuICAgICAgcmV0dXJuIHNlYXJjaF91dGlscy5jb21wYXJlTm9DYXNlKHdvcmQsIHN0b3Bfd29yZCkgPT09IDBcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIGluZGV4ICE9PSB1bmRlZmluZWQ7XHJcbiAgfVxyXG5cclxuICBnZXRUb3RhbENvdW50KCl7XHJcbiAgICByZXR1cm4gdGhpcy5pbmRleF9kYXRhLnRvdGFsQ291bnQ7XHJcbiAgfVxyXG4gIHdvcmRIYXNoZnJvbUluZGV4S2V5KGluZGV4X2tleSwgZmlsZW5vKXtcclxuICAgIHJldHVybiBfLmZpbmQodGhpcy5faGFzaF90b193b3JkLCAobWFwX2l0ZW0pID0+e1xyXG4gICAgICByZXR1cm4gbWFwX2l0ZW1bSU5ERVguTUFQLk1PREVMX0lOREVYXSA9PT0gaW5kZXhfa2V5ICYmIG1hcF9pdGVtW0lOREVYLk1BUC5NT0RFTF9GSUxFX05PXSA9PT0gZmlsZW5vO1xyXG4gICAgfSk7XHJcbiAgfVxyXG4gIGxvYWRNYXAoY2FsbGJhY2tGbil7XHJcbiAgICBpZih0aGlzLm1hcF9kYXRhID09PSB1bmRlZmluZWQpe1xyXG4gICAgICBfLmxvYWRTY3JpcHQodGhpcy5fcGF0aHMuZ2V0TWFwRmlsZVBhdGgoKSwgdHJ1ZSwgKCkgPT4ge1xyXG4gICAgICAgIHRoaXMubWFwX2RhdGEgPSBfLmV4cG9ydHMoKTtcclxuICAgICAgICB0aGlzLm9uTWFwTG9hZGVkKGNhbGxiYWNrRm4pO1xyXG4gICAgICB9LCB0cnVlKTtcclxuICAgIH1cclxuICAgIGVsc2V7XHJcbiAgICAgIHRoaXMub25NYXBMb2FkZWQoY2FsbGJhY2tGbik7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IExvYWRlcjtcclxuIiwibGV0IHJoID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uL2xpYi9yaFwiKVxyXG5sZXQgXyA9IHJoLl87XHJcbmxldCBQcmVkaWN0b25DcmVhdG9yID0gcmVxdWlyZSgnLi9wcmVkaWN0aW9uX2NyZWF0b3InKTtcclxuLy9sZXQgc2VhcmNoX3V0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xyXG4vL2xldCBQcmVkaWN0aW9uID0gcmVxdWlyZSgnLi9wcmVkaWN0aW9uJyk7XHJcbmxldCBQcmVkaWN0aW9uTGlzdCA9IHJlcXVpcmUoJy4vcHJlZGljdGlvbl9saXN0Jyk7XHJcbmNvbnN0IHNlYXJjaF9jb25zdHMgPSByZXF1aXJlKCcuL2NvbnN0cycpO1xyXG5jb25zdCBJTkRFWCA9IHJlcXVpcmUoJy4vaW5kaWNlcycpO1xyXG5cclxuY2xhc3MgTkdyYW1QcmVkaWN0b3J7XHJcbiAgY29uc3RydWN0b3Ioe2xvYWRlciwgbGV2ZWwsIGNhbGxiYWNrLCBwcmV2aW91cywgbWF4X3ByZWRpY3Rpb25zID0gMjB9KXtcclxuICAgIHRoaXMubGV2ZWwgPSBsZXZlbDtcclxuICAgIHRoaXMucHJldmlvdXMgPSAgcHJldmlvdXM7XHJcbiAgICB0aGlzLl9tYXhfcHJlZGljdGlvbnMgPSBtYXhfcHJlZGljdGlvbnM7XHJcbiAgICB0aGlzLnByZWRpY3Rpb25zID0gW107XHJcbiAgICB0aGlzLl9jYWxsYmFjayA9IGNhbGxiYWNrO1xyXG4gICAgdGhpcy5fbG9hZGVyID0gbG9hZGVyXHJcbiAgICB0aGlzLl9zb3VyY2UgPSBzZWFyY2hfY29uc3RzLlBSRURJQ1RPUl9TT1VSQ0VfSUQuTkdSQU1fUFJFRElDVE9SO1xyXG4gIH1cclxuXHJcbiAgaW5pdCgpe1xyXG5cclxuICB9XHJcbiAgY2xlYXIoKXtcclxuICAgIHRoaXMuX3dvcmRfbW9kZWwgPSB1bmRlZmluZWQ7XHJcbiAgICB0aGlzLl9wcmVkaWN0aW9uX2FycmF5ID0gdW5kZWZpbmVkO1xyXG4gICAgdGhpcy5wYXJzZWRfaW5wdXQgPSB1bmRlZmluZWQ7XHJcbiAgICB0aGlzLnByZWRpY3Rpb25zID0gW107XHJcbiAgfVxyXG5cclxuICBnZXRQcmVkaWN0aW9ucyhwYXJzZWRfaW5wdXQpIHtcclxuICAgIHRoaXMucGFyc2VkX2lucHV0ID0gcGFyc2VkX2lucHV0XHJcbiAgICB0aGlzLnByZWRpY3Rpb25zID0gW107XHJcbiAgICBpZihwYXJzZWRfaW5wdXQgIT09IHVuZGVmaW5lZCAmJiAocGFyc2VkX2lucHV0LndvcmRzLmxlbmd0aCA+PSB0aGlzLmxldmVsKSl7XHJcbiAgICAgIHRoaXMud29yZF9pbmRleCA9IHBhcnNlZF9pbnB1dC53b3Jkcy5sZW5ndGggLSB0aGlzLmxldmVsO1xyXG4gICAgICB0aGlzLl93b3JkID0gcGFyc2VkX2lucHV0LndvcmRzW3RoaXMud29yZF9pbmRleF07XHJcbiAgICAgIHRoaXMuX2xvYWRJbnB1dE1vZGVsKHRoaXMuX3dvcmQsIHRoaXMuX2NvbXB1dGVfd29yZF9wcmVkaWN0aW9ucy5iaW5kKHRoaXMpKTtcclxuICAgIH1cclxuICAgIGVsc2V7XHJcbiAgICAgIHRoaXMuX29uUmVzdWx0c0NvbXB1dGVkKCk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHNldCBtYXhfcHJlZGljdGlvbnMobmV3VmFsdWUpe1xyXG4gICAgdGhpcy5tYXhfcHJlZGljdGlvbnMgPSBuZXdWYWx1ZTtcclxuICB9XHJcbiAgZ2V0IG1heF9wcmVkaWN0aW9ucygpe1xyXG4gICAgcmV0dXJuIHRoaXMuX21heF9wcmVkaWN0aW9ucztcclxuICB9XHJcblxyXG4gIF9jb21wdXRlX3dvcmRfcHJlZGljdGlvbnMobW9kZWxfZGF0YSl7XHJcbiAgICB0aGlzLnByZWRpY3Rpb25zID0gW107XHJcbiAgICBsZXQgbGV2ZWwgPSB0aGlzLmxldmVsO1xyXG4gICAgbGV0IHdvcmQgPSB0aGlzLl93b3JkO1xyXG4gICAgbGV0IHRvdGFsX2NvdW50ID0gdGhpcy5fbG9hZGVyLmdldENvdW50KHdvcmQpO1xyXG4gICAgdGhpcy5fd29yZF9tb2RlbCA9IHRoaXMuX2xvYWRlci5nZXRXb3JkTW9kZWwod29yZCwgbW9kZWxfZGF0YSk7XHJcbiAgICBpZih0aGlzLl93b3JkX21vZGVsKXtcclxuICAgICAgdGhpcy5fcHJlZGljdGlvbl9hcnJheSA9IHRoaXMuX2dldF9wcmVkaWN0aW9uX2FycmF5KCk7XHJcbiAgICAgIHRoaXMuX2NvbXB1dGVfcHJlZGljdGlvbl9mcm9tX21vZGVsKHdvcmQsIGxldmVsLCB0b3RhbF9jb3VudCk7XHJcbiAgICB9XHJcbiAgICB0aGlzLl9vblJlc3VsdHNDb21wdXRlZCgpO1xyXG4gIH1cclxuICBfb25SZXN1bHRzQ29tcHV0ZWQoKXtcclxuICAgIGlmKHRoaXMuX2NhbGxiYWNrKXtcclxuICAgICAgdGhpcy5fY2FsbGJhY2sobmV3IFByZWRpY3Rpb25MaXN0KHRoaXMucHJlZGljdGlvbnMsIHRoaXMucGFyc2VkX2lucHV0KSwgdGhpcy5fbG9hZGVyKTtcclxuICAgIH1cclxuICB9XHJcbiAgX2NvbXB1dGVfcHJlZGljdGlvbl9mcm9tX21vZGVsKHdvcmQsIGxldmVsLCB0b3RhbF9jb3VudCl7XHJcbiAgICBpZih0aGlzLl9wcmVkaWN0aW9uX2FycmF5ID09PSB1bmRlZmluZWQpe1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgaWYodGhpcy5faXNfbXlfbGV2ZWwobGV2ZWwpKSB7XHJcbiAgICAgIHRoaXMuX2NvbXB1dGVfbmV4dF93b3Jkcyh0b3RhbF9jb3VudCk7XHJcbiAgICB9XHJcbiAgICBlbHNle1xyXG4gICAgICBsZXZlbC0tO1xyXG4gICAgICBsZXQgbmV4dF9pbmRleCA9IHRoaXMuX2dldF93b3JkX2luZGV4KGxldmVsKTtcclxuICAgICAgbGV0IG5leHRfd29yZCA9IHRoaXMucGFyc2VkX2lucHV0LndvcmRzW25leHRfaW5kZXhdO1xyXG4gICAgICBsZXQgbmV4dF93b3JkX2tleSA9IHRoaXMuX2xvYWRlci5nZXRIYXNoS2V5KG5leHRfd29yZCk7XHJcbiAgICAgIGxldCBuZXh0X3dvcmRfbW9kZWwgPSB0aGlzLl9nZXRfbmV4dF9tb2RlbCh0aGlzLl9wcmVkaWN0aW9uX2FycmF5LCBuZXh0X3dvcmRfa2V5KTtcclxuICAgICAgaWYobmV4dF93b3JkX21vZGVsKXtcclxuICAgICAgICB0b3RhbF9jb3VudCA9IG5leHRfd29yZF9tb2RlbFtJTkRFWC5NT0RFTC5DT1VOVF07XHJcbiAgICAgICAgdGhpcy5fcHJlZGljdGlvbl9hcnJheSA9IG5leHRfd29yZF9tb2RlbFtJTkRFWC5NT0RFTC5ORVhUX01PREVMXTtcclxuICAgICAgICB0aGlzLl9jb21wdXRlX3ByZWRpY3Rpb25fZnJvbV9tb2RlbChuZXh0X3dvcmQsIGxldmVsLCB0b3RhbF9jb3VudCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbiAgX2dldF9uZXh0X21vZGVsKG1vZGVsX2RhdGEsIHdvcmRfaGFzaF9rZXkpe1xyXG4gICAgaWYoIXdvcmRfaGFzaF9rZXkpe1xyXG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG4gICAgbGV0IG5leHRfd29yZF9wcmVkaWN0aW9uID0gXy5maW5kKG1vZGVsX2RhdGEsIChpdGVtKSA9PntcclxuICAgICAgcmV0dXJuIChpdGVtLmxlbmd0aCA+MSkgJiYgKGl0ZW1bSU5ERVguTU9ERUwuV09SRF9IQVNIXSA9PT0gd29yZF9oYXNoX2tleSk7XHJcbiAgICB9KTtcclxuICAgIGlmKCBuZXh0X3dvcmRfcHJlZGljdGlvbiAmJiBuZXh0X3dvcmRfcHJlZGljdGlvbi5sZW5ndGggPiBJTkRFWC5NT0RFTC5ORVhUX01PREVMICYmIEFycmF5LmlzQXJyYXkobmV4dF93b3JkX3ByZWRpY3Rpb24pKXtcclxuICAgICAgcmV0dXJuIG5leHRfd29yZF9wcmVkaWN0aW9uOyAgLy8gVE9ETyBtYXkgYmUgbmVlZHMgYSBmaXhcclxuICAgIH1cclxuICB9XHJcbiAgX2dldF93b3JkX2luZGV4KGxldmVsKXtcclxuICAgIHJldHVybiB0aGlzLnBhcnNlZF9pbnB1dC53b3Jkcy5sZW5ndGggLSBsZXZlbDtcclxuICB9XHJcbiAgX2lzX215X2xldmVsKGxldmVsKXtcclxuICAgIHJldHVybiBsZXZlbCA9PT0gMTtcclxuICB9XHJcbiAgX2NvbnRpbnVlRm4oKXtcclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH1cclxuICBfY29tcHV0ZV9uZXh0X3dvcmRzKHRvdGFsX2NvdW50KXtcclxuICAgIGxldCBwcmVkaWN0aW9uX2FycmF5ID0gdGhpcy5fcHJlZGljdGlvbl9hcnJheTtcclxuICAgIGlmKCEocHJlZGljdGlvbl9hcnJheSAmJiBwcmVkaWN0aW9uX2FycmF5Lmxlbmd0aCA+IDApKXtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGZvcihsZXQgaT0gMDsgdGhpcy5wcmVkaWN0aW9ucy5sZW5ndGggPCB0aGlzLm1heF9wcmVkaWN0aW9ucyAmJiBpIDwgcHJlZGljdGlvbl9hcnJheS5sZW5ndGggJiYgcHJlZGljdGlvbl9hcnJheVtpXS5sZW5ndGggPiAxOyBpKyspe1xyXG4gICAgICBpZighdGhpcy5fbWF0Y2hlc19wYXJ0aWFsbHkocHJlZGljdGlvbl9hcnJheVtpXSkpIHtcclxuICAgICAgICBjb250aW51ZTtcclxuICAgICAgfVxyXG4gICAgICBsZXQgcHJlZGljdGlvbnMgPSB0aGlzLl9jcmVhdGVfcHJlZGljdGlvbnMocHJlZGljdGlvbl9hcnJheVtpXSwgdG90YWxfY291bnQpO1xyXG4gICAgICB0aGlzLl9jb21wdXRlX25leHRfbXVsdGlfd29yZHMocHJlZGljdGlvbnMpO1xyXG4gICAgfVxyXG4gIH1cclxuICBfY29tcHV0ZV9uZXh0X211bHRpX3dvcmRzKHByZWRpY3Rpb25zKXtcclxuICAgIF8uZWFjaChwcmVkaWN0aW9ucywgKHByZWRpY3Rpb24pID0+IHtcclxuICAgICAgaWYocHJlZGljdGlvbiAhPT0gdW5kZWZpbmVkKXtcclxuICAgICAgICB0aGlzLnByZWRpY3Rpb25zLnB1c2gocHJlZGljdGlvbik7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxuICBfZ2V0X3dvcmRfaGFzaChtb2RlbF9pdGVtKXtcclxuICAgIHJldHVybiB0aGlzLl9sb2FkZXIuZ2V0TWFwSGFzaChtb2RlbF9pdGVtW0lOREVYLk1PREVMLldPUkRfSEFTSF0pO1xyXG4gIH1cclxuXHJcbiAgX21hdGNoZXNfcGFydGlhbGx5KHByZWRpY3Rpb24pe1xyXG4gICAgaWYodGhpcy5wYXJzZWRfaW5wdXQuaXNXaG9sZVdvcmQpe1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIGxldCB3b3JkX2hhc2ggPSB0aGlzLl9sb2FkZXIuZ2V0TWFwSGFzaChwcmVkaWN0aW9uW0lOREVYLk1PREVMLldPUkRfSEFTSF0pO1xyXG4gICAgLy8gVE9ETyB3aGF0IGlmIG5vdCBhIHdvcmQgaGFzaCA/XHJcbiAgICBpZighd29yZF9oYXNoKSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGxldCB3b3JkID0gd29yZF9oYXNoW0lOREVYLk1BUC5XT1JEXTtcclxuICAgIHJldHVybiB0aGlzLnBhcnNlZF9pbnB1dC5jb21wYXJlUGFydGlhbCh3b3JkKTtcclxuICB9XHJcbiAgX2NyZWF0ZV9wcmVkaWN0aW9ucyhuZXh0X2FycmF5LCB0b3RhbF9jb3VudCl7XHJcbiAgICBsZXQgY3JlYXRvciA9IG5ldyBQcmVkaWN0b25DcmVhdG9yKHtsb2FkZXI6dGhpcy5fbG9hZGVyLCBtb2RlbF9pdGVtOm5leHRfYXJyYXksIHRvdGFsX2NvdW50LCBwYXJzZWRfaW5wdXQ6dGhpcy5wYXJzZWRfaW5wdXQsIGNvbnRpbnVlRm46dGhpcy5fY29udGludWVGbn0pO1xyXG4gICAgcmV0dXJuICBjcmVhdG9yLmdldE11bHRpUHJlZGljdGlvbnModW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdGhpcy5fc291cmNlKTtcclxuICB9XHJcblxyXG4gIF9nZXRfcHJlZGljdGlvbl9hcnJheSgpeyAvLyByZXR1cm5zIGFuIGFycmF5IGZyb20gd2hpY2ggcHJlZGljdGlvbnMgYXJlIHRvIGJlIGNhbGN1bGF0ZXNcclxuICAgIGlmKHRoaXMucGFyc2VkX2lucHV0LmlzUHJldmlvdXMgJiYgdGhpcy5fd29yZF9tb2RlbC5sZW5ndGggPiAxKXtcclxuICAgICAgcmV0dXJuIHRoaXMuX3dvcmRfbW9kZWxbMV07XHJcbiAgICB9XHJcbiAgICBlbHNle1xyXG4gICAgICByZXR1cm4gdGhpcy5fd29yZF9tb2RlbFswXTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIF9sb2FkSW5wdXRNb2RlbCh3b3JkLCBjYWxsYmFja0ZuKXtcclxuICAgIGxldCBuRmlsZUluZGV4ID0gdGhpcy5fZmluZEZpbGVJbmRleCh3b3JkKTtcclxuICAgIHRoaXMuX2xvYWRlci5sb2FkTW9kZWwobkZpbGVJbmRleCwgY2FsbGJhY2tGbik7XHJcbiAgfVxyXG5cclxuICBfZmluZEZpbGVJbmRleCh3b3JkKXtcclxuICAgIHJldHVybiB0aGlzLl9sb2FkZXIuZ2V0TW9kZWxGaWxlTm8od29yZCk7XHJcbiAgfVxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IE5HcmFtUHJlZGljdG9yO1xyXG4iLCJpbXBvcnQgc2VhcmNoX3V0aWxzIGZyb20gJy4vdXRpbHMnXHJcbmNsYXNzIFByZWRpY3Rpb24ge1xyXG4gIGNvbnN0cnVjdG9yKHRlcm0sIHByb2JhYmlsaXR5LCBjb3VudCwgc291cmNlKXtcclxuICAgIHRoaXMucHJvYmFiaWxpdHkgPSBwcm9iYWJpbGl0eTtcclxuICAgIHRoaXMudGVybSA9IHRlcm07XHJcbiAgICB0aGlzLmNvdW50ID0gY291bnQ7XHJcbiAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcclxuICB9XHJcbiAgbWVyZ2UobmV3X2l0ZW0pIHtcclxuICAgIHRoaXMucHJvYmFiaWxpdHkgKz0gbmV3X2l0ZW0ucHJvYmFiaWxpdHk7XHJcbiAgICB0aGlzLmNvdW50ID0gTWF0aC5tYXgodGhpcy5jb3VudCwgbmV3X2l0ZW0uY291bnQpO1xyXG4gIH1cclxuICBjb21wYXJlKG90aGVyKSB7XHJcbiAgICByZXR1cm4gb3RoZXIucHJvYmFiaWxpdHkgLSB0aGlzLnByb2JhYmlsaXR5XHJcbiAgfVxyXG4gIG1hdGNoKG90aGVyKSB7XHJcbiAgICByZXR1cm4gc2VhcmNoX3V0aWxzLmNvbXBhcmVOb0Nhc2Uob3RoZXIudGVybSwgdGhpcy50ZXJtKSA9PT0gMDtcclxuICB9XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUHJlZGljdGlvbjsiLCJsZXQgUHJlZGljdGlvbiA9IHJlcXVpcmUoJy4vcHJlZGljdGlvbicpO1xyXG5sZXQgc2VhcmNoX3V0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xyXG5jb25zdCBJTkRFWCA9IHJlcXVpcmUoJy4vaW5kaWNlcycpO1xyXG5sZXQgSW5wdXRQYXJzZXIgPSByZXF1aXJlKCcuL2lucHV0X3BhcnNlcicpO1xyXG5jb25zdCBzZWFyY2hfY29uc3RzID0gcmVxdWlyZSgnLi9jb25zdHMnKTtcclxuXHJcblxyXG5jbGFzcyBQcmVkaWN0b25DcmVhdG9ye1xyXG4gIGNvbnN0cnVjdG9yKHtsb2FkZXIsIG1vZGVsX2l0ZW0sIHRvdGFsX2NvdW50LCBwYXJzZWRfaW5wdXQsIGNvbnRpbnVlRm59KXtcclxuICAgIHRoaXMuX21vZGVsX2l0ZW0gPSBtb2RlbF9pdGVtO1xyXG4gICAgdGhpcy5wYXJzZWRfaW5wdXQgPSBwYXJzZWRfaW5wdXQgfHwgbmV3IElucHV0UGFyc2VyKFwiXCIpO1xyXG4gICAgdGhpcy5faW5pdCgpO1xyXG4gICAgdGhpcy5fdG90YWxfY291bnQgPSB0b3RhbF9jb3VudDtcclxuICAgIHRoaXMuX2NvbnRpbnVlRm4gPSBjb250aW51ZUZuIHx8IHRoaXMuX2lzU3RvcFdvcmQ7XHJcbiAgICB0aGlzLl9uZXh0TW9kZWxGbiA9IHRoaXMuX25leHRNb2RlbDtcclxuICAgIHRoaXMuX3ByZWRpY3Rpb25zID0gW107XHJcbiAgICB0aGlzLl9tdWx0aV9wcmVkaWN0aW9uID0gZmFsc2U7XHJcbiAgICB0aGlzLl9sb2FkZXIgPSBsb2FkZXI7XHJcbiAgfVxyXG5cclxuICBfaW5pdCgpe1xyXG4gICAgdGhpcy50ZXJtID0gXCJcIjtcclxuICAgIHRoaXMucHJvYmFiaWxpdHkgPSAxO1xyXG4gICAgdGhpcy5fZmlyc3Rfd29yZCA9IHRydWU7XHJcbiAgICB0aGlzLmlzRmlyc3RMZXZlbCA9IGZhbHNlO1xyXG4gICAgdGhpcy5fbGV2ZWwgPSAwO1xyXG4gIH1cclxuXHJcbiAgZ2V0UHJlZGljdGlvbih3b3JkX2hhc2gsIGlzRmlyc3RMZXZlbCwgcHJldmlvdXMsIHNvdXJjZSl7XHJcbiAgICB0aGlzLndvcmRfaGFzaCA9IHdvcmRfaGFzaDtcclxuICAgIHRoaXMuaXNGaXJzdExldmVsID0gaXNGaXJzdExldmVsO1xyXG4gICAgdGhpcy5wcmV2aW91cyA9IHByZXZpb3VzO1xyXG4gICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XHJcbiAgICBpZih0aGlzLmlzRmlyc3RMZXZlbCl7XHJcbiAgICAgIHRoaXMuX2FwcGVuZFByZXZpb3VzUHJlZGljdGlvbnModGhpcy5fbW9kZWxfaXRlbSk7XHJcbiAgICB9XHJcbiAgICB0aGlzLl9hcHBlbmRQcmVkaWN0aW9uKHRoaXMuX21vZGVsX2l0ZW0sIHdvcmRfaGFzaCk7XHJcbiAgICByZXR1cm4gdGhpcy5fY3JlYXRlUHJlZGljdGlvbigpO1xyXG4gIH1cclxuICBnZXRNdWx0aVByZWRpY3Rpb25zKHdvcmRfaGFzaCwgaXNGaXJzdExldmVsLCBwcmV2aW91cywgc291cmNlKXtcclxuICAgIHRoaXMuX211bHRpX3ByZWRpY3Rpb24gPSB0cnVlO1xyXG4gICAgdGhpcy53b3JkX2hhc2ggPSB3b3JkX2hhc2g7XHJcbiAgICB0aGlzLmlzRmlyc3RMZXZlbCA9IGlzRmlyc3RMZXZlbDtcclxuICAgIHRoaXMucHJldmlvdXMgPSBwcmV2aW91cztcclxuICAgIHRoaXMuc291cmNlID0gc291cmNlO1xyXG4gICAgaWYodGhpcy5pc0ZpcnN0TGV2ZWwpe1xyXG4gICAgICB0aGlzLl9hcHBlbmRQcmV2aW91c1ByZWRpY3Rpb25zKHRoaXMuX21vZGVsX2l0ZW0pO1xyXG4gICAgfVxyXG4gICAgdGhpcy5fYXBwZW5kUHJlZGljdGlvbih0aGlzLl9tb2RlbF9pdGVtLCB3b3JkX2hhc2gpO1xyXG4gICAgcmV0dXJuIHRoaXMuX3ByZWRpY3Rpb25zO1xyXG4gIH1cclxuXHJcbiAgZXF1YWxSZW1haW5nV29yZChtb2RlbF9pdGVtKXtcclxuICAgIGxldCB3b3JkID0gdGhpcy5fZ2V0d29yZChtb2RlbF9pdGVtLCB0aGlzLndvcmRfaGFzaCk7XHJcbiAgICBpZih3b3JkKXtcclxuICAgICAgaWYodGhpcy5wYXJzZWRfaW5wdXQuZXF1YWxSZW1haW5nV29yZCh3b3JkKSkge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG4gIF9hcHBlbmRQcmV2aW91c1ByZWRpY3Rpb25zKG1vZGVsX2l0ZW0pe1xyXG4gICAgbGV0IHByZXZpb3VzX2l0ZW0gPSB0aGlzLl9nZXRQcmV2aW91c0l0ZW0obW9kZWxfaXRlbSk7XHJcbiAgICBpZighcHJldmlvdXNfaXRlbSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBsZXQgcHJldmlvdXNfcHJvYmFpbGl0eSA9IHRoaXMuX2dldFByZXZpb3VzUHJvYmFiaWxpdHkocHJldmlvdXNfaXRlbSk7XHJcbiAgICBpZihwcmV2aW91c19wcm9iYWlsaXR5ID4gc2VhcmNoX2NvbnN0cy5taW5QcmV2aW91c1RocmVzaG9sZCl7XHJcbiAgICAgIHRoaXMuX2FwcGVuZFByZXZpb3VzVGVybShwcmV2aW91c19pdGVtKTtcclxuICAgIH1cclxuICB9XHJcbiAgX2dldFByZXZpb3VzSXRlbShtb2RlbF9pdGVtKXtcclxuICAgIGxldCBwcmV2aW91c19pdGVtcyA9IHNlYXJjaF91dGlscy5nZXRGaXJzdExldmVsTmV4dE1vZGVsKG1vZGVsX2l0ZW0sIHRydWUpO1xyXG4gICAgaWYocHJldmlvdXNfaXRlbXMpe1xyXG4gICAgICBsZXQgcHJldmlvdXNfaXRlbSA9IHNlYXJjaF91dGlscy5nZXRTYWZlRWxlbWVudChwcmV2aW91c19pdGVtcywgMCk7XHJcbiAgICAgIHJldHVybiBwcmV2aW91c19pdGVtO1xyXG4gICAgfVxyXG4gIH1cclxuICBfYXBwZW5kUHJldmlvdXNUZXJtKG1vZGVsX2l0ZW0pe1xyXG4gICAgbGV0IHdvcmQgPSB0aGlzLl9nZXR3b3JkKG1vZGVsX2l0ZW0pO1xyXG4gICAgaWYod29yZCl7XHJcbiAgICAgIGlmKHRoaXMucGFyc2VkX2lucHV0LmVxdWFsTGFzdFdvcmQod29yZCkpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy50ZXJtID0gdGhpcy5wYXJzZWRfaW5wdXQucmVwbGFjZUxhc3RXb3JkKHdvcmQpO1xyXG4gICAgICB0aGlzLl9maXJzdF93b3JkID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgfVxyXG4gIF9jcmVhdGVQcmVkaWN0aW9uKCl7XHJcbiAgICBpZih0aGlzLnRlcm0gIT09IFwiXCIpe1xyXG4gICAgICBsZXQgc3VnZ2VzdGlvbl90ZXh0ID0gdGhpcy5wYXJzZWRfaW5wdXQuY29tcGxldGVTdWdnZXN0aW9uKHRoaXMudGVybSk7XHJcbiAgICAgIHJldHVybiBuZXcgUHJlZGljdGlvbihzdWdnZXN0aW9uX3RleHQsIHRoaXMucHJvYmFiaWxpdHksIDEsIHRoaXMuc291cmNlKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIF9hcHBlbmRQcmVkaWN0aW9uKG1vZGVsX2l0ZW0pe1xyXG4gICAgdGhpcy5wcm9iYWJpbGl0eSA9IHRoaXMucHJvYmFiaWxpdHkgKiB0aGlzLl9jYWxjdWxhdGVQcm9iYWJpbGl0eShtb2RlbF9pdGVtKTtcclxuICAgIHRoaXMuX3VwZGF0ZV90ZXJtKG1vZGVsX2l0ZW0pO1xyXG4gICAgaWYodGhpcy5fc2hvdWxkQ3JlYXRlUHJlZGljdGlvbihtb2RlbF9pdGVtKSl7XHJcbiAgICAgIHRoaXMuX3ByZWRpY3Rpb25zLnB1c2godGhpcy5fY3JlYXRlUHJlZGljdGlvbigpKVxyXG4gICAgfVxyXG4gICAgaWYodGhpcy5fY29udGludWVGbihtb2RlbF9pdGVtKSl7XHJcbiAgICAgIGxldCBuZXh0X21vZGVsID0gdGhpcy5fbmV4dE1vZGVsKG1vZGVsX2l0ZW0pO1xyXG4gICAgICB0aGlzLl90b3RhbF9jb3VudCA9IHRoaXMuX2dldENvdW50KG1vZGVsX2l0ZW0pO1xyXG4gICAgICB0aGlzLl9sZXZlbCsrO1xyXG4gICAgICB0aGlzLl9maXJzdF93b3JkID0gZmFsc2U7XHJcbiAgICAgIHRoaXMuaXNGaXJzdExldmVsID0gZmFsc2U7XHJcbiAgICAgIHRoaXMud29yZF9oYXNoID0gdW5kZWZpbmVkO1xyXG4gICAgICBpZihuZXh0X21vZGVsKXtcclxuICAgICAgICB0aGlzLl9hcHBlbmRQcmVkaWN0aW9uKG5leHRfbW9kZWwpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG4gIF9nZXRQcmV2aW91c1Byb2JhYmlsaXR5KHByZXZpb3VzX2l0ZW0pe1xyXG4gICAgbGV0IHRvdGFsX2NvdW50ID0gIHRoaXMuX2dldENvdW50KHRoaXMubW9kZWxfaXRlbSk7XHJcbiAgICBsZXQgY291bnQgPSBzZWFyY2hfdXRpbHMuZ2V0Q291bnRmcm9tTW9kZWwocHJldmlvdXNfaXRlbSk7XHJcbiAgICByZXR1cm4gY291bnQvdG90YWxfY291bnQ7XHJcbiAgfVxyXG4gIF91cGRhdGVfdGVybShtb2RlbF9pdGVtKXtcclxuICAgIGlmKHRoaXMucGFyc2VkX2lucHV0LmlzUHJldmlvdXMpe1xyXG4gICAgICB0aGlzLnRlcm0gPSB0aGlzLl9uZXh0VGVybShtb2RlbF9pdGVtKSArIHRoaXMudGVybTtcclxuICAgIH1cclxuICAgIGVsc2V7XHJcbiAgICAgIHRoaXMudGVybSA9IHRoaXMudGVybSArIHRoaXMuX25leHRUZXJtKG1vZGVsX2l0ZW0pO1xyXG4gICAgfVxyXG4gIH1cclxuICBfZ2V0d29yZChtb2RlbF9pdGVtLCB3b3JkX2hhc2gpe1xyXG4gICAgd29yZF9oYXNoID0gd29yZF9oYXNoIHx8IHRoaXMuX2dldF93b3JkX2hhc2gobW9kZWxfaXRlbSk7XHJcbiAgICByZXR1cm4gc2VhcmNoX3V0aWxzLmdldFNhZmVFbGVtZW50KHdvcmRfaGFzaCwgSU5ERVguTUFQLldPUkQpO1xyXG4gIH1cclxuXHJcbiAgX2dldF93b3JkX2hhc2gobW9kZWxfaXRlbSl7XHJcbiAgICByZXR1cm4gdGhpcy5fbG9hZGVyLmdldE1hcEhhc2gobW9kZWxfaXRlbVtJTkRFWC5NT0RFTC5XT1JEX0hBU0hdKTtcclxuICB9XHJcbiAgX25leHRNb2RlbChtb2RlbF9pdGVtKXtcclxuICAgIGxldCBuZXh0X21vZGVsO1xyXG4gICAgaWYodGhpcy5pc0ZpcnN0TGV2ZWwpe1xyXG4gICAgICBuZXh0X21vZGVsID0gc2VhcmNoX3V0aWxzLmdldEZpcnN0TGV2ZWxOZXh0TW9kZWwobW9kZWxfaXRlbSwgdGhpcy5wcmV2aW91cyk7XHJcbiAgICB9XHJcbiAgICBlbHNle1xyXG4gICAgICBuZXh0X21vZGVsID0gc2VhcmNoX3V0aWxzLmdldE5leHRNb2RlbChtb2RlbF9pdGVtKTtcclxuICAgIH1cclxuICAgIGlmKG5leHRfbW9kZWwgJiYgbmV4dF9tb2RlbC5sZW5ndGggPiAgMCl7XHJcbiAgICAgIHJldHVybiBzZWFyY2hfdXRpbHMuZ2V0Rmlyc3RQcmVkaWN0aW9uKG5leHRfbW9kZWwpO1xyXG4gICAgfVxyXG4gIH1cclxuICBfbmV4dFRlcm0obW9kZWxfaXRlbSl7XHJcbiAgICBsZXQgd29yZCA9IHRoaXMuX2dldHdvcmQobW9kZWxfaXRlbSwgdGhpcy53b3JkX2hhc2gpO1xyXG4gICAgaWYod29yZCl7XHJcbiAgICAgIHJldHVybiAodGhpcy5fZmlyc3Rfd29yZCkgPyB0aGlzLnBhcnNlZF9pbnB1dC5jb21wbGV0ZVdvcmQod29yZCkgOiBcIiBcIiArIHdvcmQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gXCJcIjtcclxuICB9XHJcbiAgX2NhbGN1bGF0ZVByb2JhYmlsaXR5KG1vZGVsX2l0ZW0pe1xyXG4gICAgbGV0IGNvdW50ID0gdGhpcy5fZ2V0Q291bnQobW9kZWxfaXRlbSk7XHJcbiAgICByZXR1cm4gKGNvdW50IC8gdGhpcy5fdG90YWxfY291bnQpO1xyXG4gIH1cclxuICBfZ2V0Q291bnQobW9kZWxfaXRlbSl7XHJcbiAgICBpZih0aGlzLndvcmRfaGFzaCl7XHJcbiAgICAgIHJldHVybiBzZWFyY2hfdXRpbHMuZ2V0Q291bnRmcm9tV29yZEhhc2godGhpcy53b3JkX2hhc2gpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgIHJldHVybiBzZWFyY2hfdXRpbHMuZ2V0Q291bnRmcm9tTW9kZWwobW9kZWxfaXRlbSk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIF9zaG91bGRDcmVhdGVQcmVkaWN0aW9uKG1vZGVsX2l0ZW0pe1xyXG5cclxuICAgIHJldHVybiB0aGlzLl9tdWx0aV9wcmVkaWN0aW9uICYmXHJcbiAgICAgICAgICAgICF0aGlzLl9pc1N0b3BXb3JkKG1vZGVsX2l0ZW0pICYmXHJcbiAgICAgICAgICAgICF0aGlzLmVxdWFsUmVtYWluZ1dvcmQobW9kZWxfaXRlbSk7XHJcbiAgfVxyXG4gIF9pc1N0b3BXb3JkKG1vZGVsX2l0ZW0pe1xyXG4gICAgbGV0IHdvcmQgPSB0aGlzLl9nZXR3b3JkKG1vZGVsX2l0ZW0sIHRoaXMud29yZF9oYXNoKTtcclxuICAgIGlmKCF3b3JkKXtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXMuX2xvYWRlci5pc1N0b3BXb3JkKHdvcmQpO1xyXG4gIH1cclxufVxyXG5tb2R1bGUuZXhwb3J0cyA9IFByZWRpY3RvbkNyZWF0b3I7XHJcbiIsImNsYXNzIFByZWRpY3Rpb25MaXN0IHtcclxuICBjb25zdHJ1Y3RvcihsaXN0ICwgcGFyc2VkX2lucHV0KXtcclxuICAgIHRoaXMucGFyc2VkX2lucHV0ID0gcGFyc2VkX2lucHV0O1xyXG4gICAgdGhpcy5fbGlzdCA9IGxpc3QgfHwgW107XHJcbiAgfVxyXG4gIGdldCBwcmVkaWN0aW9ucyAoKXtcclxuICAgIHJldHVybiB0aGlzLl9saXN0O1xyXG4gIH1cclxuICBpc0ZvcklucHV0KGlucHV0LCBwcmV2aW91c19pbnB1dCl7XHJcbiAgICBpZih0aGlzLnBhcnNlZF9pbnB1dC5pc1ByZXZpb3VzKXtcclxuICAgICAgcmV0dXJuIChwcmV2aW91c19pbnB1dCAhPT0gdW5kZWZpbmVkKSAmJiAodGhpcy5wYXJzZWRfaW5wdXQub3JpZ2luYWxfdGV4dCA9PT0gcHJldmlvdXNfaW5wdXQub3JpZ2luYWxfdGV4dCk7XHJcbiAgICB9XHJcbiAgICBlbHNle1xyXG4gICAgICByZXR1cm4gdGhpcy5wYXJzZWRfaW5wdXQub3JpZ2luYWxfdGV4dCA9PT0gaW5wdXQub3JpZ2luYWxfdGV4dDtcclxuICAgIH1cclxuICB9XHJcbiAgaXNFbXB0eSgpe1xyXG4gICAgcmV0dXJuIHRoaXMuX2xpc3QubGVuZ3RoID09PSAwO1xyXG4gIH1cclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBQcmVkaWN0aW9uTGlzdDsiLCJjb25zdCBMb2FkZXIgPSByZXF1aXJlKCcuL2xvYWRlcicpO1xyXG5jb25zdCByaCA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi9saWIvcmhcIilcclxuY29uc3QgXyA9IHJoLl9cclxuY29uc3QgSGlzdG9yeVByZWRpY3RvciA9IHJlcXVpcmUoJy4vaGlzdG9yeV9wcmVkaWN0b3InKTtcclxuY29uc3QgTmdyYW1QcmVkaWN0b3IgPSByZXF1aXJlKCcuL25ncmFtX3ByZWRpY3RvcicpO1xyXG5jb25zdCBHZW5lcmFsUHJlZGljdG9yID0gcmVxdWlyZSAoJy4vZ2VuZXJhbF9wcmVkaWN0b3InKTtcclxuY29uc3QgQ29ycmVjdG9yID0gcmVxdWlyZSgnLi9jb3JyZWN0b3InKTtcclxuY29uc3Qgc2VhcmNoX2NvbnN0cyA9IHJlcXVpcmUoJy4vY29uc3RzJyk7XHJcblxyXG4vL3RoaXMucHJvY2Vzc1Jlc3VsdC5iaW5kKHRoaXMpXHJcbmNsYXNzIFByZWRpY3RvcnNDcmVhdG9ye1xyXG4gIGNvbnN0cnVjdG9yKGhpc3RvcnlfcmVhZGVyLCBwcm9jZXNzUmVzdWx0Rm4pe1xyXG4gICAgdGhpcy5faGlzdG9yeV9yZWFkZXIgPSBoaXN0b3J5X3JlYWRlclxyXG4gICAgdGhpcy5fcHJvY2Vzc1Jlc3VsdEZuID0gcHJvY2Vzc1Jlc3VsdEZuXHJcbiAgfVxyXG5cclxuICBnZXQgcHJvamVjdFBhdGhzKCl7XHJcbiAgICByZXR1cm4gcmgubW9kZWwuZ2V0KHJoLmNvbnN0cygnS0VZX1BST0pFQ1RfTElTVCcpKVxyXG4gIH1cclxuICBcclxuICBfY3JlYXRlTG9hZGVycygpIHtcclxuICAgIHJldHVybiBfLm1hcCh0aGlzLnByb2plY3RQYXRocywgKHBhdGgpID0+IHtcclxuICAgICAgcmV0dXJuIG5ldyBMb2FkZXIocGF0aClcclxuICAgIH0pXHJcbiAgfVxyXG4gIGNyZWF0ZVByZWRpY3RvcnMoYWRkRm4sIHByZXZBZGRGbiwgYWRkQ29ycmVjdG9yRm4pe1xyXG4gICAgdGhpcy5fYWRkRm4gPSBhZGRGblxyXG4gICAgdGhpcy5fcHJldmFkZEZuID0gcHJldkFkZEZuXHJcbiAgICB0aGlzLl9hZGRDb3JyZWN0b3JGbiA9IGFkZENvcnJlY3RvckZuXHJcbiAgICBsZXQgaGlzdG9yeV9wcmVkaWN0b3IgPSBuZXcgSGlzdG9yeVByZWRpY3Rvcih0aGlzLl9oaXN0b3J5X3JlYWRlciwgdGhpcy5fcHJvY2Vzc1Jlc3VsdEZuKTtcclxuICAgIHRoaXMuX2FkZEZuKGhpc3RvcnlfcHJlZGljdG9yKTtcclxuXHJcbiAgICBsZXQgbG9hZGVycyA9IHRoaXMuX2NyZWF0ZUxvYWRlcnMoKVxyXG4gICAgXy5lYWNoKGxvYWRlcnMsIChsb2FkZXIpID0+IHtcclxuICAgICAgbG9hZGVyLmluaXQodGhpcy5hZGRQcmVkaWN0b3JzLmJpbmQodGhpcykpXHJcbiAgICB9KTtcclxuICB9XHJcbiAgYWRkUHJlZGljdG9ycyhsb2FkZXIpe1xyXG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPD0gbG9hZGVyLm5HcmFtOyBpKyspe1xyXG5cclxuICAgICAgbGV0IG5ncCA9IG5ldyBOZ3JhbVByZWRpY3Rvcih7bG9hZGVyLCBsZXZlbDppLCBjYWxsYmFjazp0aGlzLl9wcm9jZXNzUmVzdWx0Rm59KTtcclxuICAgICAgbmdwLmluaXQoKTtcclxuICAgICAgdGhpcy5fYWRkRm4obmdwKVxyXG4gICAgfVxyXG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPD0gc2VhcmNoX2NvbnN0cy5wcmV2aW91c25HcmFtOyBpKyspe1xyXG4gICAgICBsZXQgbmdwID0gbmV3IE5ncmFtUHJlZGljdG9yKHtsb2FkZXIsIGxldmVsOmksIGNhbGxiYWNrOnRoaXMuX3Byb2Nlc3NSZXN1bHRGbiwgcHJldmlvdXM6dHJ1ZX0pO1xyXG4gICAgICBuZ3AuaW5pdCgpO1xyXG4gICAgICB0aGlzLl9wcmV2YWRkRm4obmdwKTtcclxuICAgIH1cclxuXHJcbiAgICBsZXQgZ2VuZXJhbF9wcmVkaWN0b3IgPSBuZXcgR2VuZXJhbFByZWRpY3Rvcih0aGlzLl9wcm9jZXNzUmVzdWx0Rm4sIGxvYWRlcilcclxuICAgIHRoaXMuX2FkZEZuKGdlbmVyYWxfcHJlZGljdG9yKTtcclxuXHJcbiAgICBsZXQgY29ycmVjdG9yID0gbmV3IENvcnJlY3Rvcihsb2FkZXIsIHRoaXMuX3Byb2Nlc3NSZXN1bHRGbilcclxuICAgIHRoaXMuX2FkZENvcnJlY3RvckZuKGNvcnJlY3Rvcik7XHJcblxyXG4gIH1cclxufVxyXG5tb2R1bGUuZXhwb3J0cyA9IFByZWRpY3RvcnNDcmVhdG9yXHJcbiIsImNvbnN0IHJoID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uL2xpYi9yaFwiKVxyXG5jb25zdCBfID0gcmguX1xyXG5jb25zdCBjb25zdHMgPSByaC5jb25zdHM7XHJcbmNvbnN0IGhpc3RvcnlfcmVhZGVyID0gcmVxdWlyZSgnLi9oaXN0b3J5X3JlYWRlcicpO1xyXG5jb25zdCBJbnB1dFBhcnNlciA9IHJlcXVpcmUoJy4vaW5wdXRfcGFyc2VyJyk7XHJcbmNvbnN0IFByZWRpY3Rvbk1lcmdlciA9IHJlcXVpcmUoJy4uL2NvbW1vbi9tZXJnZXInKTtcclxuY29uc3QgVG9waWNDb3VudGVyID0gcmVxdWlyZSgnLi90b3BpY19jb3VudGVyJyk7XHJcbmNvbnN0IHNlYXJjaF91dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcclxuY29uc3Qgc2VhcmNoX2NvbnN0cyA9IHJlcXVpcmUoJy4vY29uc3RzJyk7XHJcbmNvbnN0IFNlYW1hcGhvcmUgPSByZXF1aXJlKCcuLy4uLy4uLy4uL2NvbW1vbi9jb3VudGluZ19zZWFtYXBob3JlJyk7XHJcbmNvbnN0IFByZWRpY3RvckNyZWF0b3IgPSByZXF1aXJlKCcuL3ByZWRpY3RvcnNfY3JlYXRvcicpO1xyXG5jb25zdCBTZWFyY2hIYW5kbGVyID0gcmVxdWlyZSgnLi4vdG9waWMvaGFuZGxlcicpO1xyXG5cclxuY29uc3QgbWF4X3ByZWRpY3Rpb25zID0gNTtcclxuXHJcbmNsYXNzIFNlYXJjaENvbnRyb2xsZXIge1xyXG4gIGNvbnN0cnVjdG9yKHdpZGdldCkge1xyXG4gICAgdGhpcy53aWRnZXQgPSB3aWRnZXQ7XHJcbiAgICB0aGlzLl9wcmVkaWN0b3JzID0gW107XHJcbiAgICB0aGlzLl9jb3JyZWN0b3JzID0gW107XHJcbiAgICB0aGlzLl9wcmV2aW91c19wcmVkaWN0b3JzID0gW107XHJcbiAgICB0aGlzLmluaXRIYW5kbGVLZXlIYXNoKCk7XHJcbiAgICB0aGlzLm1heF9wcmVkaWN0aW9ucyA9IG1heF9wcmVkaWN0aW9ucztcclxuICAgIHRoaXMucHJlZGljdG9uX21lcmdlciA9IG5ldyBQcmVkaWN0b25NZXJnZXIoW10pXHJcbiAgICB3aWRnZXQubW9kZWwuc3Vic2NyaWJlKGNvbnN0cygnS0VZX1BST0pFQ1RfTElTVCcpLCAoKSA9PiB7XHJcbiAgICAgIHRoaXMuaW5pdCgpO1xyXG4gICAgfSk7XHJcblxyXG4gIH1cclxuICBpbml0KCkge1xyXG4gICAgbGV0IGhpc3RvcnlfbGlzdCA9IHJoLnN0b3JhZ2UuZmV0Y2goY29uc3RzKCdQUkVWX1NFQVJDSF9LRVknKSk7XHJcbiAgICBoaXN0b3J5X3JlYWRlci5pbml0SGlzdG9yeShoaXN0b3J5X2xpc3QpO1xyXG4gICAgdGhpcy5jcmVhdGVfcHJlZGljdG9ycygpXHJcbiAgICB0aGlzLndpZGdldC5tb2RlbC5jc3Vic2NyaWJlKCdFVlRfQ0xPU0VfU0VBUkNIX1NVR0dFU1RJT04nLCB0aGlzLmNsb3NlU3VnZ2VzdGlvbnMuYmluZCh0aGlzKSlcclxuICAgIGlmKCFyaC5tb2RlbC5nZXQocmguY29uc3RzKCdLRVlfQ0xBU1NJQ19PVVRQVVQnKSkpIHtcclxuICAgICAgdGhpcy5zZWFyY2hfaGFuZGxlciA9IG5ldyBTZWFyY2hIYW5kbGVyKHRoaXMud2lkZ2V0KVxyXG4gICAgICB0aGlzLndpZGdldC5tb2RlbC5jc3Vic2NyaWJlKCdFVlRfU0VBUkNIX1RFUk0nLCB0aGlzLnNlYXJjaC5iaW5kKHRoaXMpKVxyXG4gICAgICB0aGlzLndpZGdldC5tb2RlbC5jc3Vic2NyaWJlKCdFVlRfUVVFUllfU0VBUkNIX1JFU1VMVFMnLCB0aGlzLnNlYXJjaC5iaW5kKHRoaXMpKVxyXG4gICAgfVxyXG4gIH1cclxuICBzZWFyY2goKVxyXG4gIHtcclxuICAgIGlmICghcmgucmhzLmRvU2VhcmNoKCkpXHJcbiAgICB7XHJcbiAgICAgIGxldCB0ZXh0ID0gdGhpcy53aWRnZXQuZ2V0KGNvbnN0cygnS0VZX1NFQVJDSF9URVJNJykpXHJcbiAgICAgIHRoaXMuc2VhcmNoX2hhbmRsZXIuc2hvd1NlYXJjaFJlc3VsdHModGV4dCkgIFxyXG4gICAgfVxyXG4gIH1cclxuICBjcmVhdGVfcHJlZGljdG9ycygpIHtcclxuICAgIHRoaXMuX3ByZWRpY3RvcnMgPSBbXVxyXG4gICAgbGV0IHByZWRpY3Rvcl9jcmVhdG9yID0gbmV3IFByZWRpY3RvckNyZWF0b3IoaGlzdG9yeV9yZWFkZXIsIHRoaXMucHJvY2Vzc1Jlc3VsdC5iaW5kKHRoaXMpKVxyXG4gICAgcHJlZGljdG9yX2NyZWF0b3IuY3JlYXRlUHJlZGljdG9ycyh0aGlzLmFkZFByZWRpY3Rvci5iaW5kKHRoaXMpLFxyXG4gICAgICB0aGlzLmFkZFByZXZQcmVkaWN0b3IuYmluZCh0aGlzKSxcclxuICAgICAgdGhpcy5hZGRDb3JyZWN0b3IuYmluZCh0aGlzKSlcclxuICB9XHJcbiAgYWRkUHJlZGljdG9yKHByZWRpY3Rvcikge1xyXG4gICAgdGhpcy5fcHJlZGljdG9ycy5wdXNoKHByZWRpY3RvcilcclxuICB9XHJcbiAgYWRkUHJldlByZWRpY3RvcihwcmVkaWN0b3IpIHtcclxuICAgIHRoaXMuX3ByZXZpb3VzX3ByZWRpY3RvcnMucHVzaChwcmVkaWN0b3IpXHJcbiAgfVxyXG4gIGFkZENvcnJlY3Rvcihjb3JyZWN0b3IpIHtcclxuICAgIHRoaXMuX2NvcnJlY3RvcnMucHVzaChjb3JyZWN0b3IpXHJcbiAgfVxyXG4gIHNob3dTdWdnZXN0aW9ucyhrZXlFdnQpIHtcclxuICAgIHRoaXMuX2luaXRTdWdnZXN0aW9ucyhrZXlFdnQpO1xyXG4gICAgdGhpcy5fY2FsY3VsYXRlU3VnZ3Vlc3Rpb25zKCk7XHJcbiAgfVxyXG5cclxuICBfaW5pdFN1Z2dlc3Rpb25zKGtleUV2dCkge1xyXG4gICAgdGhpcy5faW5pdFJlc3VsdCgpO1xyXG4gICAgdGhpcy5faW5pdElucHV0cyhrZXlFdnQpO1xyXG4gICAgdGhpcy5fcmVzdXRTZWFtYXBob3JlID0gbmV3IFNlYW1hcGhvcmUodGhpcy5vblJlc3VsdENvbXBsZXRlLmJpbmQodGhpcykpO1xyXG4gIH1cclxuICBfaW5pdElucHV0cyhrZXlFdnQpIHtcclxuICAgIHRoaXMucGFyc2VkX2lucHV0ID0gbmV3IElucHV0UGFyc2VyKGtleUV2dC50ZXh0LCBmYWxzZSwga2V5RXZ0LnNlbFN0YXJ0LCBmYWxzZSk7XHJcbiAgICBpZiAoc2VhcmNoX3V0aWxzLmlzUHJldmlvdXMoa2V5RXZ0KSkge1xyXG4gICAgICB0aGlzLl9wcmV2aW91c19pbnB1dCA9IG5ldyBJbnB1dFBhcnNlcihrZXlFdnQudGV4dCwgZmFsc2UsIGtleUV2dC5zZWxTdGFydCwgdHJ1ZSk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIF9jYWxjdWxhdGVTdWdndWVzdGlvbnMoKSB7XHJcbiAgICB0aGlzLl9yZXN1dFNlYW1hcGhvcmUud2FpdCh0aGlzLl9wcmVkaWN0b3JDb3VudCgpKTtcclxuICAgIF8uZWFjaCh0aGlzLl9wcmVkaWN0b3JzLCAocHJlZGljdG9yKSA9PiB7XHJcbiAgICAgIHByZWRpY3Rvci5nZXRQcmVkaWN0aW9ucyh0aGlzLnBhcnNlZF9pbnB1dCk7XHJcbiAgICB9KTtcclxuICAgIGlmICh0aGlzLl9wcmV2aW91c19pbnB1dCkge1xyXG4gICAgICBfLmVhY2godGhpcy5fcHJldmlvdXNfcHJlZGljdG9ycywgKHByZWRpY3RvcikgPT4ge1xyXG4gICAgICAgIHByZWRpY3Rvci5nZXRQcmVkaWN0aW9ucyh0aGlzLl9wcmV2aW91c19pbnB1dCk7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH1cclxuICBfY2xlYXJQcmVkaWN0b3JzKCkge1xyXG4gICAgXy5lYWNoKHRoaXMuX3ByZWRpY3RvcnMsIChwcmVkaWN0b3IpID0+IHtcclxuICAgICAgcHJlZGljdG9yLmNsZWFyKCk7XHJcbiAgICB9KTtcclxuICAgIF8uZWFjaCh0aGlzLl9wcmV2aW91c19wcmVkaWN0b3JzLCAocHJlZGljdG9yKSA9PiB7XHJcbiAgICAgIHByZWRpY3Rvci5jbGVhcigpO1xyXG4gICAgfSk7XHJcbiAgICBfLmVhY2godGhpcy5fY29ycmVjdG9ycywgKGNvcnJlY3RvcikgPT4ge1xyXG4gICAgICBjb3JyZWN0b3IuY2xlYXIoKTtcclxuICAgIH0pO1xyXG4gIH1cclxuICBfcHJlZGljdG9yQ291bnQoKSB7XHJcbiAgICBsZXQgY291bnQgPSB0aGlzLl9wcmVkaWN0b3JzLmxlbmd0aDtcclxuICAgIGlmICh0aGlzLl9wcmV2aW91c19pbnB1dCkge1xyXG4gICAgICBjb3VudCArPSB0aGlzLl9wcmV2aW91c19wcmVkaWN0b3JzLmxlbmd0aDtcclxuICAgIH1cclxuICAgIHJldHVybiBjb3VudDtcclxuICB9XHJcbiAgX2luaXRSZXN1bHQoKSB7XHJcbiAgICBpZiAodGhpcy5wcmVkaWN0b25fbWVyZ2VyKSB7XHJcbiAgICAgIHRoaXMucHJlZGljdG9uX21lcmdlci5jbGVhcigpO1xyXG4gICAgfVxyXG4gICAgdGhpcy53aWRnZXQucHVibGlzaChcInNlbGVjdGVkXCIsIHVuZGVmaW5lZCk7XHJcbiAgICB0aGlzLl9wcmV2aW91c19pbnB1dCA9IHVuZGVmaW5lZDtcclxuICAgIHRoaXMuX2NvbXB1dGluZ19jb3JyZWN0aW9uID0gZmFsc2U7XHJcbiAgfVxyXG4gIF9jbGVhclJlc3VsdCgpIHtcclxuICAgIHRoaXMuX3Jlc2V0TW92ZW1lbnQoKTtcclxuICAgIHRoaXMuX3ByZXZpb3VzX2lucHV0ID0gdW5kZWZpbmVkO1xyXG4gICAgdGhpcy5wYXJzZWRfaW5wdXQgPSB1bmRlZmluZWQ7XHJcbiAgICB0aGlzLl9yZXN1dFNlYW1hcGhvcmUgPSB1bmRlZmluZWQ7XHJcbiAgICB0aGlzLl9jbGVhclByZWRpY3RvcnMoKVxyXG4gIH1cclxuXHJcbiAgaXNTdWdnZXN0aW9uc09wZW4oKSB7XHJcbiAgICBsZXQgcHJlZGljdGlvbnMgPSB0aGlzLndpZGdldC5nZXQoY29uc3RzKFwiU0VBUkNIX1JFU1VMVFNfS0VZXCIpKVxyXG4gICAgcmV0dXJuIHByZWRpY3Rpb25zICYmIHByZWRpY3Rpb25zLmxlbmd0aCA+IDBcclxuICB9XHJcbiAgcHJvY2Vzc1Jlc3VsdChwcmVkaWN0aW9uTGlzdCwgbG9hZGVyKSB7XHJcbiAgICBpZiAoIXByZWRpY3Rpb25MaXN0LmlzRm9ySW5wdXQodGhpcy5wYXJzZWRfaW5wdXQsIHRoaXMuX3ByZXZpb3VzX2lucHV0KSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBpZiAoIXByZWRpY3Rpb25MaXN0LmlzRW1wdHkoKSkge1xyXG4gICAgICB0aGlzLnByZWRpY3Rvbl9tZXJnZXIubWVyZ2UocHJlZGljdGlvbkxpc3QucHJlZGljdGlvbnMpO1xyXG4gICAgICBsZXQgY291bnRlciA9IG5ldyBUb3BpY0NvdW50ZXIobG9hZGVyKTtcclxuICAgICAgdGhpcy5wcmVkaWN0aW9ucyA9IGNvdW50ZXIuY29tcHV0ZUNvdW50cyh0aGlzLnByZWRpY3Rpb25zLCB0aGlzLnBhcnNlZF9pbnB1dCk7XHJcbiAgICB9XHJcbiAgICB0aGlzLl9yZXN1dFNlYW1hcGhvcmUuc2lnbmFsKCk7XHJcbiAgfVxyXG4gIG9uUmVzdWx0Q29tcGxldGUoKSB7XHJcbiAgICBpZiAodGhpcy5uZWVkQ29ycmVjdGlvbigpKSB7XHJcbiAgICAgIHRoaXMuZG9Db3JyZWN0aW9uKCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLnByZWRpY3Rpb25zLnNwbGljZSh0aGlzLm1heF9wcmVkaWN0aW9ucyk7XHJcbiAgICAgIHRoaXMud2lkZ2V0LnB1Ymxpc2goY29uc3RzKFwiU0VBUkNIX1JFU1VMVFNfS0VZXCIpLCB0aGlzLnByZWRpY3Rpb25zKTtcclxuICAgICAgdGhpcy5fY2xlYXJSZXN1bHQoKTtcclxuICAgIH1cclxuICB9XHJcbiAgbmVlZENvcnJlY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gIXRoaXMuX2NvbXB1dGluZ19jb3JyZWN0aW9uICYmXHJcbiAgICAgIHRoaXMucHJlZGljdGlvbnMubGVuZ3RoID09PSAwICYmXHJcbiAgICAgIHRoaXMucGFyc2VkX2lucHV0LnRyaW1tZWRUZXh0ICE9PSBcIlwiO1xyXG4gIH1cclxuICBkb0NvcnJlY3Rpb24oKSB7XHJcbiAgICB0aGlzLl9jb21wdXRpbmdfY29ycmVjdGlvbiA9IHRydWU7XHJcbiAgICB0aGlzLl9yZXN1dFNlYW1hcGhvcmUgPSBuZXcgU2VhbWFwaG9yZSh0aGlzLm9uUmVzdWx0Q29tcGxldGUuYmluZCh0aGlzKSk7XHJcbiAgICB0aGlzLl9yZXN1dFNlYW1hcGhvcmUud2FpdCh0aGlzLl9jb3JyZWN0b3JzLmxlbmd0aClcclxuICAgIF8uZWFjaCh0aGlzLl9jb3JyZWN0b3JzLCAoY29ycmVjdG9yKSA9PiB7XHJcbiAgICAgIGNvcnJlY3Rvci5nZXRDb3JyZWN0aW9ucyh0aGlzLnBhcnNlZF9pbnB1dCk7XHJcbiAgICB9KTtcclxuICB9XHJcbiAgY2FuRGVsZXRlKGlkKSB7XHJcbiAgICBsZXQgcHJlZGljdGlvbiA9IHRoaXMucHJlZGljdGlvbnNbaWRdO1xyXG4gICAgaWYgKHByZWRpY3Rpb24gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcHJlZGljdGlvbi5zb3VyY2UgPT09IHNlYXJjaF9jb25zdHMuUFJFRElDVE9SX1NPVVJDRV9JRC5ISVNUT1JZX1BSRURJQ1RPUjtcclxuICB9XHJcbiAgaGFuZGxlRGVsZXRlKGlkKSB7XHJcbiAgICBsZXQgcHJlZGljdGlvbiA9IHRoaXMucHJlZGljdGlvbnNbaWRdO1xyXG4gICAgdGhpcy5fZGVsZXRlRnJvbUhpc3RvcnkocHJlZGljdGlvbi50ZXJtKTtcclxuICAgIHRoaXMuX3JlbW92ZVByZWRpY3Rpb24oaWQpO1xyXG4gICAgdGhpcy53aWRnZXQucHVibGlzaChcImhpc3RvcnlfZGVsZXRlZFwiLCB0cnVlKTtcclxuICB9XHJcblxyXG4gIF9yZW1vdmVQcmVkaWN0aW9uKGlkKSB7XHJcbiAgICB0aGlzLnByZWRpY3Rpb25zLnNwbGljZShpZCwgMSk7XHJcbiAgICB0aGlzLndpZGdldC5wdWJsaXNoKGNvbnN0cyhcIlNFQVJDSF9SRVNVTFRTX0tFWVwiKSwgdGhpcy5wcmVkaWN0aW9ucyk7XHJcbiAgfVxyXG5cclxuICBoYW5kbGVDbGljayhpZCkge1xyXG4gICAgbGV0IGhpc3RvcnlfZGVsZXRlZCA9IHRoaXMud2lkZ2V0LmdldChcImhpc3RvcnlfZGVsZXRlZFwiKTtcclxuICAgIGlmIChoaXN0b3J5X2RlbGV0ZWQpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgbGV0IHByZWRpY3Rpb24gPSB0aGlzLnByZWRpY3Rpb25zW2lkXTtcclxuICAgIGlmIChwcmVkaWN0aW9uID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGxldCBuZXdfdGV4dCA9IHByZWRpY3Rpb24udGVybTtcclxuICAgIHRoaXMudHJpZ2dlclNlYXJjaChuZXdfdGV4dClcclxuICB9XHJcblxyXG4gIHRyaWdnZXJTZWFyY2godGVybSkge1xyXG4gICAgdGhpcy5fYWRkVG9IaXN0b3J5KHRlcm0pO1xyXG4gICAgdGhpcy5jbG9zZVN1Z2dlc3Rpb25zKCk7XHJcbiAgICB0aGlzLndpZGdldC5wdWJsaXNoKGNvbnN0cygnS0VZX1NFQVJDSF9URVJNJyksIHRlcm0pO1xyXG4gICAgdGhpcy53aWRnZXQucHVibGlzaChyaC5jb25zdHMoJ0VWVF9TRUFSQ0hfVEVSTScpLCB0cnVlKTtcclxuICB9XHJcblxyXG4gIGhhbmRsZUZvY3VzT3V0KGtleSwgZm9jdXNfa2V5KSB7XHJcbiAgICBsZXQgaGlzdG9yeV9kZWxldGVkID0gdGhpcy53aWRnZXQuZ2V0KFwiaGlzdG9yeV9kZWxldGVkXCIpO1xyXG4gICAgaWYgKCFoaXN0b3J5X2RlbGV0ZWQpIHtcclxuICAgICAgdGhpcy53aWRnZXQucHVibGlzaChrZXksIGZhbHNlKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMud2lkZ2V0LnB1Ymxpc2goXCJoaXN0b3J5X2RlbGV0ZWRcIiwgZmFsc2UpO1xyXG4gICAgICB0aGlzLndpZGdldC5wdWJsaXNoKGZvY3VzX2tleSwgdHJ1ZSk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGdldEZpcnN0U3VnZ2VzdGlvbkluZGV4KGxlbmd0aCwgZG93bikge1xyXG4gICAgcmV0dXJuIGRvd24gPyAwIDogbGVuZ3RoIC0gMTtcclxuICB9XHJcblxyXG4gIGdldCBwcmVkaWN0aW9ucygpIHtcclxuICAgIHJldHVybiB0aGlzLnByZWRpY3Rvbl9tZXJnZXIuaXRlbXM7XHJcbiAgfVxyXG4gIHNldCBwcmVkaWN0aW9ucyhwcmVkaWN0aW9ucykge1xyXG4gICAgdGhpcy5wcmVkaWN0b25fbWVyZ2VyID0gbmV3IFByZWRpY3Rvbk1lcmdlcihwcmVkaWN0aW9ucyk7XHJcbiAgfVxyXG5cclxuICBnZXROZXh0U3VnZ2VzdGlvbkluZGV4KGN1cnJfc2VsZWN0ZWQsIGxlbmd0aCwgZG93bikge1xyXG4gICAgbGV0IG1vdmUgPSBkb3duID8gMSA6IGxlbmd0aCAtIDE7XHJcbiAgICBjdXJyX3NlbGVjdGVkID0gKGN1cnJfc2VsZWN0ZWQgPT09IHVuZGVmaW5lZCkgPyAwIDogY3Vycl9zZWxlY3RlZDtcclxuICAgIGN1cnJfc2VsZWN0ZWQgPSAoY3Vycl9zZWxlY3RlZCArIG1vdmUpICUgbGVuZ3RoO1xyXG4gICAgcmV0dXJuIGN1cnJfc2VsZWN0ZWQ7XHJcbiAgfVxyXG5cclxuICBoYW5kbGVBcnJvd0tleShrZXlFdnQpIHtcclxuICAgIGxldCBjdXJyX3NlbGVjdGVkID0gdGhpcy53aWRnZXQuZ2V0KFwic2VsZWN0ZWRcIik7XHJcbiAgICBsZXQgZG93biA9IGtleUV2dC5rZXlDb2RlID09PSA0MDtcclxuICAgIGxldCBsZW5ndGggPSB0aGlzLmdldFByZWRpY3Rpb25zTGVuZ3RoKCk7XHJcbiAgICBpZiAobGVuZ3RoID4gMCkge1xyXG4gICAgICBpZiAoY3Vycl9zZWxlY3RlZCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgY3Vycl9zZWxlY3RlZCA9IHRoaXMuZ2V0Rmlyc3RTdWdnZXN0aW9uSW5kZXgobGVuZ3RoLCBkb3duKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBjdXJyX3NlbGVjdGVkID0gdGhpcy5nZXROZXh0U3VnZ2VzdGlvbkluZGV4KGN1cnJfc2VsZWN0ZWQsIGxlbmd0aCwgZG93bik7XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy53aWRnZXQucHVibGlzaChcInNlbGVjdGVkXCIsIGN1cnJfc2VsZWN0ZWQpO1xyXG4gICAgICBsZXQgbmV3X3RleHQgPSB0aGlzLmdldE5ld0lucHV0VGV4dCh0aGlzLnJlc3VsdHNbY3Vycl9zZWxlY3RlZF0pO1xyXG4gICAgICB0aGlzLndpZGdldC5wdWJsaXNoKGNvbnN0cygnS0VZX1NFQVJDSF9URVJNJyksIG5ld190ZXh0KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGdldE5ld0lucHV0VGV4dChwcmVkaWN0aW9uKSB7XHJcbiAgICByZXR1cm4gcHJlZGljdGlvbi50ZXJtO1xyXG4gIH1cclxuXHJcbiAgZ2V0UHJlZGljdGlvbnNMZW5ndGgoKSB7XHJcbiAgICBsZXQgbGVuZ3RoO1xyXG4gICAgdGhpcy5yZXN1bHRzID0gdGhpcy53aWRnZXQuZ2V0KGNvbnN0cyhcIlNFQVJDSF9SRVNVTFRTX0tFWVwiKSk7XHJcbiAgICBpZiAodGhpcy5yZXN1bHRzKSB7XHJcbiAgICAgIGxlbmd0aCA9IHRoaXMucmVzdWx0cy5sZW5ndGg7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbGVuZ3RoO1xyXG4gIH1cclxuXHJcbiAgY2xvc2VTdWdnZXN0aW9ucygpIHtcclxuICAgIHRoaXMuX2NsZWFyUmVzdWx0KCk7XHJcbiAgICB0aGlzLndpZGdldC5wdWJsaXNoKFwic2VsZWN0ZWRcIiwgdW5kZWZpbmVkKTtcclxuICAgIHRoaXMub3JpZ2luYWxfcGFyc2VkX2lucHV0ID0gdW5kZWZpbmVkO1xyXG4gICAgdGhpcy53aWRnZXQucHVibGlzaChjb25zdHMoXCJTRUFSQ0hfUkVTVUxUU19LRVlcIiksIFtdKTtcclxuICB9XHJcbiAgX2RlbGV0ZUZyb21IaXN0b3J5KHRleHQpIHtcclxuICAgIGhpc3RvcnlfcmVhZGVyLmRlbGV0ZSh0ZXh0KTtcclxuICAgIHRoaXMuX3NhdmVIaXN0b3J5KCk7XHJcbiAgfVxyXG4gIF9hZGRUb0hpc3RvcnkodGV4dCkge1xyXG4gICAgaWYgKHRleHQgJiYgdGV4dCAhPT0gXCJcIikge1xyXG4gICAgICBoaXN0b3J5X3JlYWRlci5hZGQoe1xyXG4gICAgICAgIHRleHQ6IHRleHQudHJpbSgpLFxyXG4gICAgICAgIGNvdW50OiAxMFxyXG4gICAgICB9KTsgLy8gVE9ETyBjaGFuZ2VcclxuICAgICAgdGhpcy5fc2F2ZUhpc3RvcnkoKTtcclxuICAgIH1cclxuICB9XHJcbiAgX3NhdmVIaXN0b3J5KCkge1xyXG4gICAgcmguc3RvcmFnZS5wZXJzaXN0KGNvbnN0cygnUFJFVl9TRUFSQ0hfS0VZJyksIGhpc3RvcnlfcmVhZGVyLmdldEhpc3RvcnkoKSk7XHJcbiAgfVxyXG4gIGhhbmRsZURlZmF1bHQoa2V5RXZ0KSB7IFxyXG4gICAgaWYgKGtleUV2dC50ZXh0ID09PSBcIlwiKSB7XHJcbiAgICAgIHRoaXMuY2xvc2VTdWdnZXN0aW9ucygpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgbGV0IHN1YnN0ciA9IChrZXlFdnQudGV4dHx8JycpLnN1YnN0cigwLCBrZXlFdnQuc2VsU3RhcnQpXHJcbiAgICAgIGtleUV2dC50ZXh0ID0gc3Vic3RyXHJcbiAgICAgIHRoaXMuc2hvd1N1Z2dlc3Rpb25zKGtleUV2dCk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGhhbmRsZVNob3dTdWdnZXN0aW9uKGtleUV2dCkge1xyXG4gICAgaWYgKGtleUV2dC50ZXh0ID09PSBcIlwiIHx8IHNlYXJjaF91dGlscy5zaG91bGRTaG93U3VnZ2VzdGlvbihrZXlFdnQpID09PSBmYWxzZSkge1xyXG4gICAgICB0aGlzLmNsb3NlU3VnZ2VzdGlvbnMoKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMuc2hvd1N1Z2dlc3Rpb25zKGtleUV2dCk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGhhbmRsZVJldHVybihrZXlFdnQpXHJcbiAge1xyXG4gICAgdGhpcy50cmlnZ2VyU2VhcmNoKGtleUV2dC50ZXh0KTtcclxuICB9XHJcbiAgX2lzTW92ZW1lbnRLZXkoa2V5Q29kZSkge1xyXG4gICAgcmV0dXJuIFszOCwgMzksIDQwXS5pbmRleE9mKGtleUNvZGUpID49IDA7XHJcbiAgfVxyXG4gIF9yZXNldE1vdmVtZW50KCkge1xyXG4gICAgdGhpcy5vcmlnaW5hbF9wYXJzZWRfaW5wdXQgPSB1bmRlZmluZWQ7XHJcbiAgICB0aGlzLndpZGdldC5wdWJsaXNoKFwic2VsZWN0ZWRcIiwgdW5kZWZpbmVkKTtcclxuICB9XHJcbiAgX2lzSGFuZGxpbmdDdXJzb3JNb3ZlKCkge1xyXG4gICAgbGV0IGN1cnJfc2VsZWN0ZWQgPSB0aGlzLndpZGdldC5nZXQoXCJzZWxlY3RlZFwiKTtcclxuICAgIHJldHVybiBjdXJyX3NlbGVjdGVkICE9PSB1bmRlZmluZWQ7XHJcbiAgfVxyXG4gIGluaXRIYW5kbGVLZXlIYXNoKCkge1xyXG4gICAgdGhpcy5oYW5kbGVfa2V5X2hhc2ggPSB7XHJcbiAgICAgIHVwOiB0aGlzLmhhbmRsZUFycm93S2V5LmJpbmQodGhpcyksXHJcbiAgICAgIGRvd246IHRoaXMuaGFuZGxlQXJyb3dLZXkuYmluZCh0aGlzKSxcclxuICAgICAgYmFja3NwYWNlOiB0aGlzLmhhbmRsZUJhY2tTcGFjZS5iaW5kKHRoaXMpLFxyXG4gICAgICByZXR1cm46IHRoaXMuaGFuZGxlUmV0dXJuLmJpbmQodGhpcyksXHJcbiAgICAgIGRlZmF1bHQ6IHRoaXMuaGFuZGxlRGVmYXVsdC5iaW5kKHRoaXMpLFxyXG4gICAgICBlc2NhcGU6IHRoaXMuaGFuZGxlRXNjYXBlLmJpbmQodGhpcyksXHJcbiAgICAgIHJpZ2h0OiB0aGlzLmhhbmRsZVJpZ2h0LmJpbmQodGhpcylcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGhhbmRsZVJpZ2h0KGtleUV2dCkge1xyXG4gICAgaWYgKCF0aGlzLl9pc0hhbmRsaW5nQ3Vyc29yTW92ZSgpKSB7XHJcbiAgICAgIHRoaXMuX3Jlc2V0TW92ZW1lbnQoKVxyXG4gICAgICByZXR1cm4gdGhpcy5oYW5kbGVTaG93U3VnZ2VzdGlvbihrZXlFdnQpXHJcbiAgICB9XHJcbiAgICBpZiAoc2VhcmNoX3V0aWxzLnNob3VsZEFwcGVuZFNwYWNlKGtleUV2dCkpIHtcclxuICAgICAga2V5RXZ0LnRleHQgKz0gXCIgXCI7XHJcbiAgICAgIGtleUV2dC5zZWxTdGFydCArPSAxXHJcbiAgICAgIHRoaXMud2lkZ2V0LnB1Ymxpc2goY29uc3RzKCdLRVlfU0VBUkNIX1RFUk0nKSwga2V5RXZ0LnRleHQpO1xyXG4gICAgfVxyXG4gICAgdGhpcy5fcmVzZXRNb3ZlbWVudCgpO1xyXG4gICAgdGhpcy5oYW5kbGVTaG93U3VnZ2VzdGlvbihrZXlFdnQpXHJcbiAgICByZXR1cm4gZmFsc2VcclxuICB9XHJcbiAgaGFuZGxlQmFja1NwYWNlKGtleUV2dCkge1xyXG4gICAgcmV0dXJuIHRoaXMuaGFuZGxlU2hvd1N1Z2dlc3Rpb24oa2V5RXZ0KTtcclxuICB9XHJcbiAgaGFuZGxlRXNjYXBlKCkge1xyXG4gICAgdGhpcy5jbG9zZVN1Z2dlc3Rpb25zKCk7XHJcbiAgfVxyXG4gIGhhbmRsZUtleShldmVudCkge1xyXG5cclxuICAgIGxldCBrZXlDb2RlID0gZXZlbnQua2V5Q29kZTtcclxuICAgIGxldCBrZXlFdnQgPSB7XHJcbiAgICAgIGtleUNvZGU6IGtleUNvZGUsXHJcbiAgICAgIHNlbFN0YXJ0OiBldmVudC50YXJnZXQuc2VsZWN0aW9uU3RhcnQsXHJcbiAgICAgIHRleHQ6IGV2ZW50LnRhcmdldC52YWx1ZVxyXG4gICAgfVxyXG4gICAgaWYgKCF0aGlzLl9pc01vdmVtZW50S2V5KGtleUNvZGUpKSB7XHJcbiAgICAgIHRoaXMuX3Jlc2V0TW92ZW1lbnQoKTtcclxuICAgIH1cclxuICAgIGxldCBpbmRleCA9IF8uZ2V0S2V5SW5kZXgoa2V5Q29kZSk7XHJcblxyXG4gICAgaWYgKGluZGV4ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICBsZXQgaGFuZGxlRm4gPSB0aGlzLmhhbmRsZV9rZXlfaGFzaFtpbmRleF07XHJcbiAgICBpZiAoaGFuZGxlRm4pIHtcclxuICAgICAgcmV0dXJuIGhhbmRsZUZuKGtleUV2dCk7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5yaC5jb250cm9sbGVyKCdTZWFyY2hDb250cm9sbGVyJywgU2VhcmNoQ29udHJvbGxlcikiLCJjbGFzcyBTb3J0ZWRTZXR7XHJcbiAgY29uc3RydWN0b3Ioc2V0KXtcclxuICAgIHRoaXMuX3NldCA9IHNldCB8fCBbXTtcclxuICAgIHRoaXMuX2luaXRpYWxpc2VkID0gZmFsc2U7XHJcbiAgfVxyXG4gIGludGVyc2VjdChvdGhlcil7XHJcbiAgICBpZighQXJyYXkuaXNBcnJheShvdGhlcikpe1xyXG4gICAgICBvdGhlciA9IG90aGVyLnNldDtcclxuICAgIH1cclxuICAgIGxldCBuZXdfc2V0ID0gIFtdO1xyXG4gICAgbGV0IGNvdW50ID0wIDtcclxuICAgIGxldCBpID0gMDsgbGV0IGo9IDA7XHJcbiAgICBmb3IoOyBpIDwgdGhpcy5fc2V0Lmxlbmd0aCAmJiBqIDwgb3RoZXIubGVuZ3RoOyl7XHJcbiAgICAgIGlmKHRoaXMuX3NldFtpXSA8IG90aGVyW2pdKSB7XHJcbiAgICAgICAgaSsrO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2UgaWYgKHRoaXMuX3NldFtpXSA+IG90aGVyW2pdKSB7XHJcbiAgICAgICAgaisrO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2Uge1xyXG4gICAgICAgIG5ld19zZXRbY291bnQrK10gPSB0aGlzLl9zZXRbaV07XHJcbiAgICAgICAgaSsrOyBqKys7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHRoaXMuX3NldCA9IG5ld19zZXQ7XHJcbiAgfVxyXG4gIGludGVyc2VjdE9yU2V0KG90aGVyKXtcclxuICAgIGlmKHRoaXMuX2luaXRpYWxpc2VkKXtcclxuICAgICAgdGhpcy5pbnRlcnNlY3Qob3RoZXIpXHJcbiAgICB9XHJcbiAgICBlbHNle1xyXG4gICAgICBpZighQXJyYXkuaXNBcnJheShvdGhlcikpe1xyXG4gICAgICAgIG90aGVyID0gb3RoZXIuc2V0O1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuc2V0ID0gb3RoZXJcclxuICAgICAgdGhpcy5faW5pdGlhbGlzZWQgPSB0cnVlXHJcbiAgICB9XHJcbiAgfVxyXG4gIGludGVyc2VjdENvdW50KG90aGVyKXtcclxuICAgIGlmKCFBcnJheS5pc0FycmF5KG90aGVyKSl7XHJcbiAgICAgIG90aGVyID0gb3RoZXIuc2V0O1xyXG4gICAgfVxyXG4gICAgbGV0IGNvdW50ID0gMDtcclxuICAgIGxldCBpID0gMDtcclxuICAgIGxldCBqID0gMDtcclxuICAgIGZvcig7IGkgPCB0aGlzLl9zZXQubGVuZ3RoICYmIGogPCBvdGhlci5sZW5ndGg7KXtcclxuICAgICAgaWYodGhpcy5fc2V0W2ldIDwgb3RoZXJbal0pIHtcclxuICAgICAgICBpKys7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSBpZiAodGhpcy5fc2V0W2ldID4gb3RoZXJbal0pIHtcclxuICAgICAgICBqKys7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSB7XHJcbiAgICAgICAgY291bnQrKztcclxuICAgICAgICBpKys7IGorKztcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNvdW50O1xyXG4gIH1cclxuICBzZXQgc2V0KHNldCl7XHJcbiAgICB0aGlzLl9zZXQgPSBzZXQgfHwgW107XHJcbiAgfVxyXG4gIGdldCBzZXQoKXtcclxuICAgIHJldHVybiB0aGlzLl9zZXQ7XHJcbiAgfVxyXG4gIGdldCBsZW5ndGgoKXtcclxuICAgIHJldHVybiB0aGlzLl9zZXQubGVuZ3RoO1xyXG4gIH1cclxuXHJcbn1cclxubW9kdWxlLmV4cG9ydHMgPSBTb3J0ZWRTZXQ7XHJcbiIsImNvbnN0IFNvcnRlZFNldCA9IHJlcXVpcmUoJy4vc29ydGVkX3NldCcpO1xyXG5jb25zdCBQYXJzZXIgPSByZXF1aXJlKCcuL2lucHV0X3BhcnNlcicpO1xyXG5jb25zdCBQcmVkaWN0aW9uID0gcmVxdWlyZSgnLi9wcmVkaWN0aW9uJyk7XHJcbmNvbnN0IHJoID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uL2xpYi9yaFwiKVxyXG5jb25zdCBfID0gcmguXztcclxuY29uc3QgSU5ERVggPSByZXF1aXJlKFwiLi9pbmRpY2VzXCIpXHJcblxyXG5cclxuY2xhc3MgVG9waWNDb3VudGVye1xyXG4gIGNvbnN0cnVjdG9yKGxvYWRlcil7XHJcbiAgICB0aGlzLm5ld1ByZWRpY3Rpb25zID0gW107XHJcbiAgICB0aGlzLnByZWRpY3Rpb25TZXQgPSBuZXcgU29ydGVkU2V0KCk7XHJcbiAgICB0aGlzLmlucHV0U2V0ID0gbmV3IFNvcnRlZFNldCgpO1xyXG4gICAgdGhpcy5fbG9hZGVyID0gbG9hZGVyO1xyXG4gIH1cclxuICBjb21wdXRlQ291bnRzKHByZWRpY3Rpb25zLCBwYXJzZWRfaW5wdXQpe1xyXG4gICAgdGhpcy5uZXdQcmVkaWN0aW9uID0gW107XHJcbiAgICB0aGlzLnBhcnNlZF9pbnB1dCA9IHBhcnNlZF9pbnB1dDtcclxuICAgIF8uZWFjaChwcmVkaWN0aW9ucywgKHByZWRpY3Rpb24pID0+IHtcclxuICAgICAgdGhpcy5hZGRVcGRhdGVkUHJlZGljdGlvbihwcmVkaWN0aW9uKTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHRoaXMubmV3UHJlZGljdGlvbnM7XHJcbiAgfVxyXG5cclxuICBhZGRVcGRhdGVkUHJlZGljdGlvbihwcmVkaWN0aW9uKXtcclxuICAgIGxldCBjb3VudCA9IDE7XHJcbiAgICBpZih0aGlzLl9sb2FkZXIgIT09IHVuZGVmaW5lZCl7XHJcbiAgICAgIHRoaXMuY3JlYXRlUHJlZGljdGlvblNldChwcmVkaWN0aW9uKTtcclxuICAgICAgY291bnQgPSB0aGlzLmNvbXB1dGVUb3BpY0NvdW50KCk7XHJcbiAgICB9XHJcbiAgICBpZihjb3VudCA+IDApe1xyXG4gICAgICBsZXQgbmV3UHJkaWN0aW9uID0gbmV3IFByZWRpY3Rpb24ocHJlZGljdGlvbi50ZXJtLCBwcmVkaWN0aW9uLnByb2JhYmlsaXR5LCBjb3VudCwgcHJlZGljdGlvbi5zb3VyY2UpO1xyXG4gICAgICB0aGlzLm5ld1ByZWRpY3Rpb25zLnB1c2gobmV3UHJkaWN0aW9uKTtcclxuICAgIH1cclxuICB9XHJcbiAgY29tcHV0ZVRvcGljQ291bnQoKXtcclxuICAgIHJldHVybiB0aGlzLnByZWRpY3Rpb25TZXQuc2V0Lmxlbmd0aDtcclxuICB9XHJcblxyXG4gIGNyZWF0ZVByZWRpY3Rpb25TZXQocHJlZGljdGlvbil7XHJcbiAgICB0aGlzLnByZWRpY3Rpb25TZXQgPSBuZXcgU29ydGVkU2V0KCk7XHJcbiAgICBsZXQgcGFyc2VkX3ByZWRpY3Rpb24gPSBuZXcgUGFyc2VyKHByZWRpY3Rpb24udGVybSwgdHJ1ZSk7XHJcbiAgICBfLmVhY2gocGFyc2VkX3ByZWRpY3Rpb24ud29yZHMsICh3b3JkLCBpbmRleCkgPT57XHJcbiAgICAgIHRoaXMuX2FkZFdvcmRUb1NldCh3b3JkLCB0aGlzLnByZWRpY3Rpb25TZXQsIGluZGV4KTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgaW5pdElucHV0KHBhcnNlZF9pbnB1dCl7XHJcbiAgICB0aGlzLmlucHV0U2V0ID0gbmV3IFNvcnRlZFNldCgpO1xyXG4gICAgXy5lYWNoKHBhcnNlZF9pbnB1dC53b3JkcywgKHdvcmQpID0+e1xyXG4gICAgICB0aGlzLl9hZGRXb3JkVG9TZXQod29yZCwgdGhpcy5pbnB1dFNldCk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIF9hZGRXb3JkVG9TZXQod29yZCwgc2V0KXtcclxuICAgIGlmKHRoaXMuX2xvYWRlci5pc1N0b3BXb3JkKHdvcmQpKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGxldCB3b3JkSGFzaCA9IHRoaXMuX2xvYWRlci5fZ2V0SGFzaEZvcldvcmQod29yZCk7XHJcbiAgICBpZih3b3JkSGFzaCAmJiB3b3JkSGFzaC5sZW5ndGggPiBJTkRFWC5NQVAuVE9QSUNTKXtcclxuICAgICAgc2V0LmludGVyc2VjdE9yU2V0KHdvcmRIYXNoW0lOREVYLk1BUC5UT1BJQ1NdKTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gVG9waWNDb3VudGVyO1xyXG4iLCJcclxuXHJcbmNvbnN0IElOREVYID0gcmVxdWlyZSgnLi9pbmRpY2VzJyk7XHJcblxyXG5sZXQgX2V4cG9ydHMgPSB7XHJcbiAgZ2V0TmV4dE1vZGVsOiAobW9kZWxfaXRlbSkgPT57XHJcblxyXG4gICAgaWYoIG1vZGVsX2l0ZW0gICYmIEFycmF5LmlzQXJyYXkobW9kZWxfaXRlbSkgJiYgbW9kZWxfaXRlbS5sZW5ndGggPiBJTkRFWC5NT0RFTC5ORVhUX01PREVMKXtcclxuICAgICAgcmV0dXJuIG1vZGVsX2l0ZW1bSU5ERVguTU9ERUwuTkVYVF9NT0RFTF07XHJcbiAgICB9XHJcbiAgfSxcclxuICBnZXRGaXJzdExldmVsTmV4dE1vZGVsOiAobW9kZWxfaXRlbSwgYnByZXZpb3VzKSA9PiB7XHJcbiAgICBpZihtb2RlbF9pdGVtICYmIEFycmF5LmlzQXJyYXkobW9kZWxfaXRlbSkpe1xyXG4gICAgICBpZiggIWJwcmV2aW91cyAmJiBtb2RlbF9pdGVtLmxlbmd0aCA+IElOREVYLkZJUlNUX1BSRURJQ1RJT04uTkVYVCl7XHJcbiAgICAgICAgcmV0dXJuIG1vZGVsX2l0ZW1bSU5ERVguRklSU1RfUFJFRElDVElPTi5ORVhUXTtcclxuICAgICAgfVxyXG4gICAgICBpZiggYnByZXZpb3VzICYmIG1vZGVsX2l0ZW0ubGVuZ3RoID4gSU5ERVguRklSU1RfUFJFRElDVElPTi5QUkVWSU9VUyApe1xyXG4gICAgICAgIHJldHVybiBtb2RlbF9pdGVtW0lOREVYLkZJUlNUX1BSRURJQ1RJT04uUFJFVklPVVNdO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgZ2V0Rmlyc3RQcmVkaWN0aW9uOiAobW9kZWxfaXRlbSk9PiB7XHJcbiAgICBpZihtb2RlbF9pdGVtICYmIEFycmF5LmlzQXJyYXkobW9kZWxfaXRlbSkgJiYgbW9kZWxfaXRlbS5sZW5ndGggPiAwICYmIEFycmF5LmlzQXJyYXkobW9kZWxfaXRlbVswXSkpe1xyXG4gICAgICByZXR1cm4gbW9kZWxfaXRlbVswXTtcclxuICAgIH1cclxuICB9LFxyXG4gIGNvbXBhcmVOb0Nhc2Uod29yZDEsIHdvcmQyKXtcclxuICAgIGlmKGdsb2JhbC5jb21wYXJlICE9PSB1bmRlZmluZWQpe1xyXG4gICAgICByZXR1cm4gZ2xvYmFsLmNvbXBhcmUod29yZDEsIHdvcmQyKTtcclxuICAgIH1cclxuICAgIGVsc2V7XHJcbiAgICAgIHJldHVybiAod29yZDEgPT09IHdvcmQyKSA/IDAgOiAtMTtcclxuICAgIH1cclxuICB9LFxyXG4gIGhhbW1pbmdEaXN0YW5jZSh3b3JkMSwgd29yZDIpe1xyXG4gICAgbGV0IG1pbkxlbmd0aCA9IE1hdGgubWluKHdvcmQxLmxlbmd0aCwgd29yZDIubGVuZ3RoKTtcclxuICAgIGxldCBoYW1taW5nRGlzdGFuY2UgPSAwO1xyXG4gICAgZm9yKGxldCBpPTA7IGk8bWluTGVuZ3RoOyBpKyspe1xyXG4gICAgICBpZih3b3JkMVtpXSAhPT0gd29yZDJbaV0pIHtcclxuICAgICAgICBoYW1taW5nRGlzdGFuY2UrKztcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYod29yZDEubGVuZ3RoID4gbWluTGVuZ3RoKSB7XHJcbiAgICAgIGhhbW1pbmdEaXN0YW5jZSs9IHdvcmQxLmxlbmd0aCAtIG1pbkxlbmd0aDtcclxuICAgIH1cclxuICAgIHJldHVybiBoYW1taW5nRGlzdGFuY2U7XHJcbiAgfSxcclxuICBpc1ByZXZpb3VzKGtleUV2dCl7XHJcbiAgICByZXR1cm4gKGtleUV2dC5zZWxTdGFydCA8IGtleUV2dC50ZXh0Lmxlbmd0aClcclxuICB9LFxyXG4gIHNob3VsZFNob3dTdWdnZXN0aW9uKGtleUV2dCl7XHJcbiAgICBsZXQgdGV4dCA9IGtleUV2dC50ZXh0XHJcbiAgICBsZXQgc2VsU3RhcnQgPSBrZXlFdnQuc2VsU3RhcnRcclxuICAgIGlmKHNlbFN0YXJ0ID09PSAwIHx8IHNlbFN0YXJ0ID09PSB0ZXh0Lmxlbmd0aCl7XHJcbiAgICAgIHJldHVybiB0cnVlXHJcbiAgICB9XHJcbiAgICBpZih0ZXh0Lmxlbmd0aCA+IDAgKXsgLy8gaWYgY3Vyc29yIGlzIGJlZm9yZSB0aGUgZW5kXHJcbiAgICAgIHJldHVybiB0ZXh0W3NlbFN0YXJ0XSA9PT0gJyAnIHx8IHRleHRbc2VsU3RhcnQtMV0gPT09ICcgJ1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH0sXHJcbiAgc2hvdWxkQXBwZW5kU3BhY2Uoa2V5RXZ0KXtcclxuICAgIGxldCB0ZXh0ID0ga2V5RXZ0LnRleHRcclxuICAgIGxldCBzZWxTdGFydCA9IGtleUV2dC5zZWxTdGFydFxyXG4gICAgaWYgKHRleHQubGVuZ3RoID4gMCAmJiBzZWxTdGFydCA9PT0gdGV4dC5sZW5ndGgpey8vY3Vzcm9yIGF0IGxhc3RcclxuICAgICAgcmV0dXJuIHRleHRbdGV4dC5sZW5ndGggLTFdICE9PSBcIiBcIjtcclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9LFxyXG5cclxuICBnZXRTYWZlRWxlbWVudChhcnIsIGluZGV4KXtcclxuICAgIGlmKGFyciAmJiBBcnJheS5pc0FycmF5KGFycikgJiYgYXJyLmxlbmd0aCA+IGluZGV4KSB7XHJcbiAgICAgIHJldHVybiBhcnJbaW5kZXhdO1xyXG4gICAgfVxyXG4gIH0sXHJcbiAgZ2V0Q291bnRmcm9tTW9kZWwobW9kZWxfaXRlbSl7XHJcbiAgICBpZihBcnJheS5pc0FycmF5KG1vZGVsX2l0ZW0pICYmIG1vZGVsX2l0ZW0ubGVuZ3RoID4gSU5ERVguTU9ERUwuQ09VTlQpIHtcclxuICAgICAgcmV0dXJuIG1vZGVsX2l0ZW1bSU5ERVguTU9ERUwuQ09VTlRdO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIDA7XHJcbiAgfSxcclxuICBnZXRDb3VudGZyb21Xb3JkSGFzaCh3b3JkX2hhc2gpe1xyXG4gICAgaWYoQXJyYXkuaXNBcnJheSh3b3JkX2hhc2gpICYmIHdvcmRfaGFzaC5sZW5ndGggPiBJTkRFWC5NQVAuQ09VTlQpIHtcclxuICAgICAgcmV0dXJuIHdvcmRfaGFzaFtJTkRFWC5NQVAuQ09VTlRdO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIDA7XHJcbiAgfVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBfZXhwb3J0cztcclxuIiwiY29uc3QgUXVlcnlQcm9jZXNzb3IgPSByZXF1aXJlKCcuL3F1ZXJ5L3Byb2Nlc3NvcicpXHJcbmNvbnN0IHJoID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uL2xpYi9yaFwiKVxyXG5jb25zdCBfID0gcmguX1xyXG5jb25zdCBjb25zdHMgPSByaC5jb25zdHNcclxuY29uc3QgTG9hZGVyID0gcmVxdWlyZSgnLi9xdWVyeS9sb2FkZXInKVxyXG5jb25zdCBSZXN1bHRNZXJnZXIgPSByZXF1aXJlKCcuLi9jb21tb24vbWVyZ2VyJylcclxuY29uc3QgU2VhbWFwaG9yZSA9IHJlcXVpcmUoJy4uLy4uLy4uL2NvbW1vbi9jb3VudGluZ19zZWFtYXBob3JlJylcclxuY29uc3QgU2VhcmNoUmVzdWx0ID0gcmVxdWlyZSgnLi9yZXN1bHQnKVxyXG5sZXQgJCA9IHJoLiRcclxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBTZWFyY2hIYW5kbGVye1xyXG4gIGNvbnN0cnVjdG9yKHdpZGdldCwgbWF4X3Jlc3VsdHMgPTIwKSB7XHJcbiAgICB0aGlzLndpZGdldCA9IHdpZGdldFxyXG4gICAgdGhpcy5pbml0RG9uZSA9IGZhbHNlXHJcbiAgICB0aGlzLm1heF9yZXN1bHRzID0gbWF4X3Jlc3VsdHM7XHJcbiAgICB0aGlzLnF1ZXJ5UHJvY2Vzc29ycyA9IFtdXHJcbiAgICB0aGlzLm1lcmdlciA9IG5ldyBSZXN1bHRNZXJnZXIoW10pXHJcbiAgICB0aGlzLl9yZXN1dFNlYW1hcGhvcmUgPSBuZXcgU2VhbWFwaG9yZSh0aGlzLm9uUmVzdWx0Q29tcGxldGUuYmluZCh0aGlzKSk7XHJcbiAgICB0aGlzLndpZGdldC5tb2RlbC5zdWJzY3JpYmUoY29uc3RzKCdLRVlfUFJPSkVDVF9MSVNUJyksICgpID0+IHtcclxuICAgICAgdGhpcy5pbml0KClcclxuICAgIH0pXHJcbiAgfVxyXG4gIFxyXG4gIGluaXQoKSB7XHJcbiAgICBpZiAoIXRoaXMuaW5pdERvbmUpIHtcclxuICAgICAgbGV0IGxvYWRlcnMgPSB0aGlzLl9jcmVhdGVMb2FkZXJzKClcclxuICAgICAgXy5lYWNoKGxvYWRlcnMsIChsb2FkZXIsIGlkKSA9PiB7XHJcbiAgICAgICAgbG9hZGVyLmluaXQoaWQsIHRoaXMuYWRkUHJvY2Vzc29ycy5iaW5kKHRoaXMpKVxyXG4gICAgICB9KVxyXG4gICAgICB0aGlzLmluaXREb25lID0gdHJ1ZVxyXG4gICAgICBpZih0aGlzLnBlbmRpbmdUZXh0KXtcclxuICAgICAgICB0aGlzLnNob3dTZWFyY2hSZXN1bHRzKHRoaXMucGVuZGluZ1RleHQpXHJcbiAgICAgICAgdGhpcy5wZW5kaW5nVGV4dCA9IG51bGxcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgYWRkUHJvY2Vzc29ycyhsb2FkZXIpIHtcclxuICAgIHRoaXMucXVlcnlQcm9jZXNzb3JzLnB1c2gobmV3IFF1ZXJ5UHJvY2Vzc29yKGxvYWRlcikpXHJcbiAgfVxyXG4gIGdldCBwcm9qZWN0UGF0aHMoKSB7XHJcbiAgICByZXR1cm4gcmgubW9kZWwuZ2V0KHJoLmNvbnN0cygnS0VZX1BST0pFQ1RfTElTVCcpKVxyXG4gIH1cclxuXHJcbiAgX2NyZWF0ZUxvYWRlcnMoKSB7XHJcbiAgICByZXR1cm4gXy5tYXAodGhpcy5wcm9qZWN0UGF0aHMsIChwYXRoKSA9PiB7XHJcbiAgICAgIHJldHVybiBuZXcgTG9hZGVyKHBhdGgpXHJcbiAgICB9KVxyXG4gIH1cclxuXHJcbiAgc2hvd1NlYXJjaFJlc3VsdHModGV4dCkge1xyXG4gICAgaWYoIXRoaXMuaW5pdERvbmUpe1xyXG4gICAgICB0aGlzLnBlbmRpbmdUZXh0ID0gdGV4dFxyXG4gICAgICByZXR1cm5cclxuICAgIH1cclxuICAgIGxldCBpc05ld1F1ZXJ5ID0gXy5maW5kKHRoaXMucXVlcnlQcm9jZXNzb3JzLCBwcm9jZXNzb3IgPT4gcHJvY2Vzc29yLmlzTmV3UXVlcnkodGV4dCwgdGhpcy5zZWFyY2hPcHRzKHByb2Nlc3Nvci5nZXRQYXRoKCkpKSlcclxuICAgIGlmKGlzTmV3UXVlcnkpe1xyXG4gICAgICB0aGlzLm1lcmdlciA9IG5ldyBSZXN1bHRNZXJnZXIoW10pXHJcbiAgICAgIHRoaXMuX3Jlc3V0U2VhbWFwaG9yZSA9IG5ldyBTZWFtYXBob3JlKHRoaXMub25SZXN1bHRDb21wbGV0ZS5iaW5kKHRoaXMpKTtcclxuICAgICAgdGhpcy5fcmVzdXRTZWFtYXBob3JlLndhaXQodGhpcy5wcm9jZXNzb3JDb3VudClcclxuICAgICAgLy9yaC5tb2RlbC5wdWJsaXNoKHJoLmNvbnN0cygnRVZUX1NFQVJDSF9JTl9QUk9HUkVTUycpLCB0cnVlLCB7c3luYzogdHJ1ZX0pO1xyXG4gICAgICAvL3JoLm1vZGVsLnB1Ymxpc2gocmguY29uc3RzKCdLRVlfU0VBUkNIX1BST0dSRVNTJyksIDAsIHtzeW5jOiB0cnVlfSk7XHJcbiAgICAgIF8uZWFjaCh0aGlzLnF1ZXJ5UHJvY2Vzc29ycywgcHJvY2Vzc29yID0+e1xyXG4gICAgICAgIHByb2Nlc3Nvci5zZWFyY2godGV4dCwgdGhpcy5zZWFyY2hPcHRzKHByb2Nlc3Nvci5nZXRQYXRoKCkpLCB0aGlzLnRvcGljQ2FsbGJhY2suYmluZCh0aGlzKSwgdGhpcy5vblNlYXJjaFJlc3VsdHMuYmluZCh0aGlzKSlcclxuICAgICAgfSlcclxuICAgIH1cclxuICB9XHJcbiAgXHJcbiAgICBcclxuICBcclxuICBnZXQgcHJvY2Vzc29yQ291bnQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5xdWVyeVByb2Nlc3NvcnMubGVuZ3RoXHJcbiAgfVxyXG4gIG9uU2VhcmNoUmVzdWx0cyh0ZXh0LCBzZWFyY2hSZXN1bHQsIGdsb3NzYXJ5X3Jlc3VsdHMpIHtcclxuICAgIHRoaXMucHJvY2Vzc1RvcGljc1Jlc3VsdHModGV4dCwgc2VhcmNoUmVzdWx0KVxyXG4gICAgdGhpcy5wcm9jZXNzR2xvc3NhcnlSZXN1bHRzKHRleHQsIGdsb3NzYXJ5X3Jlc3VsdHMpXHJcbiAgICB0aGlzLl9yZXN1dFNlYW1hcGhvcmUuc2lnbmFsKClcclxuICB9XHJcblxyXG4gIG9uUmVzdWx0Q29tcGxldGUoKSB7XHJcbiAgICB0aGlzLndpZGdldC5wdWJsaXNoKHJoLmNvbnN0cygnRVZUX1NFQVJDSF9JTl9QUk9HUkVTUycpLCBmYWxzZSwge1xyXG4gICAgICBzeW5jOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIHZhciBzZWFyY2hUZXJtID0gdGhpcy53aWRnZXQuZ2V0KGNvbnN0cygnS0VZX1NFQVJDSF9URVJNJykpXHJcbiAgICB2YXIgc2VhcmNoVGVybU1hcCA9IHtbY29uc3RzKCdIQVNIX0tFWV9SSF9TRUFSQ0gnKV06IHNlYXJjaFRlcm19XHJcbiAgICBsZXQgcmVzdWx0c1BhcmFtcyA9IF8ubWFwVG9FbmNvZGVkU3RyaW5nKHNlYXJjaFRlcm1NYXApXHJcbiAgICB0aGlzLndpZGdldC5wdWJsaXNoKGNvbnN0cygnS0VZX1NFQVJDSF9SRVNVTFRfUEFSQU1TJyksIHJlc3VsdHNQYXJhbXMpXHJcbiAgICB0aGlzLndpZGdldC5wdWJsaXNoKCcucC5zZWFyY2hyZXN1bHRzJywgdGhpcy5tZXJnZXIuaXRlbXMpXHJcbiAgICBpZih3aW5kb3cuX3RleHRUb0h0bWxfbm9uYnNwKSB7XHJcbiAgICAgIHRoaXMuc2hvd1NlYXJjaE1zZyh0aGlzLm1lcmdlci5pdGVtcy5sZW5ndGgsIHdpbmRvdy5fdGV4dFRvSHRtbF9ub25ic3Aoc2VhcmNoVGVybSkpXHJcbiAgICB9XHJcbiAgICBpZiAocmgubW9kZWwuZ2V0KGNvbnN0cygnS0VZX1NIT1dfQ09OVEVYVCcpKSA9PT0gZmFsc2UpXHJcbiAgICB7XHJcbiAgICAgIHRoaXMuaGlkZUNvbnRleHRzKClcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHNob3dTZWFyY2hNc2coYSwgYil7XHJcbiAgICB2YXIgYyA9IHJoLm1vZGVsLmdldChyaC5jb25zdHMoXCJLRVlfTE5HXCIpKTtcclxuICAgIGMgPSBjLlJlc3VsdHNGb3VuZFRleHQgfHwgXCIlMSByZXN1bHQocykgZm91bmQgZm9yICUyXCJcclxuICAgIGMgPSBjLnJlcGxhY2UoXCIlMVwiLCBhKVxyXG4gICAgYyA9IGMucmVwbGFjZShcIiUyXCIsIFwiJ1wiICsgYiArIFwiJ1wiKVxyXG4gICAgdGhpcy5kaXNwbGF5TXNnKGMpXHJcbiAgfVxyXG5cclxuICBkaXNwbGF5TXNnKGEpe1xyXG4gICAgdmFyIGIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInNlYXJjaE1zZ1wiKTtcclxuICAgIGlmKGIpe1xyXG4gICAgICBiLmlubmVySFRNTCA9IGFcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGhpZGVDb250ZXh0cygpXHJcbiAge1xyXG4gICAgbGV0IHNyY2hDdHh0cyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoXCJ3U2VhcmNoQ29udGV4dFwiKVxyXG4gICAgXy5kZWZlcigoKSA9PnsgXHJcbiAgICAgIF8uZWFjaChzcmNoQ3R4dHMsIGN0eHROb2RlID0+e1xyXG4gICAgICAgICQuYWRkQ2xhc3MoY3R4dE5vZGUsICdyaC1oaWRlJyk7XHJcbiAgICAgIH0pXHJcbiAgICB9KVxyXG4gICAgXHJcbiAgfVxyXG5cclxuICBzZWFyY2hPcHRzKHBhdGgpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIGFuZFNlYXJjaDogcmgubW9kZWwuZ2V0KHJoLmNvbnN0cygnS0VZX0FORF9TRUFSQ0gnKSkgPT09ICcxJyxcclxuICAgICAgY2J0OiByaC5tb2RlbC5jZ2V0KCdLRVlfVEFHX0VYUFJFU1NJT04nKSxcclxuICAgICAgb3JpZ2luOiBwYXRoXHJcbiAgICB9XHJcbiAgfVxyXG4gIHRvcGljQ2FsbGJhY2soaWQsIHN1bW1hcnksIHVybCkge1xyXG4gICAgdGhpcy53aWRnZXQucHVibGlzaChgLnAuc2VhcmNoc3VtbWFyeSR7aWR9YCwgc3VtbWFyeSlcclxuICAgIHRoaXMud2lkZ2V0LnB1Ymxpc2goYC5wLnNlYXJjaHVybCR7aWR9YCwgdXJsKVxyXG4gIH1cclxuICBwcm9jZXNzR2xvc3NhcnlSZXN1bHRzKHRleHQsIGdsb3NzYXJ5X3Jlc3VsdCkge1xyXG4gICAgbGV0IHRlcm0gPSBnbG9zc2FyeV9yZXN1bHQgJiYgT2JqZWN0LmtleXMoZ2xvc3NhcnlfcmVzdWx0KVswXVxyXG4gICAgdGhpcy53aWRnZXQucHVibGlzaChjb25zdHMoJ0tFWV9HTE9TU0FSWV9SRVNVTFRfVEVSTScpLCB0ZXJtKVxyXG4gICAgdGhpcy53aWRnZXQucHVibGlzaChjb25zdHMoJ0tFWV9HTE9TU0FSWV9SRVNVTFQnKSwgZ2xvc3NhcnlfcmVzdWx0W3Rlcm1dKVxyXG4gIH1cclxuXHJcbiAgcHJvY2Vzc1RvcGljc1Jlc3VsdHModGV4dCwgdG9waWNSZXN1bHRzKSB7XHJcbiAgICB0aGlzLnRleHQgPSB0ZXh0XHJcbiAgICBsZXQgcHJvY2Vzc2VkUmVzdWx0ID0gXy5tYXAodG9waWNSZXN1bHRzLCByZXN1bHQgPT4gbmV3IFNlYXJjaFJlc3VsdChyZXN1bHQpKVxyXG4gICAgdGhpcy5tZXJnZXIubWVyZ2UocHJvY2Vzc2VkUmVzdWx0KVxyXG4gIH1cclxuICBcclxufSIsIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbiogQURPQkUgQ09ORklERU5USUFMXHJcbiogX19fX19fX19fX19fX19fX19fX1xyXG4qXHJcbiogQ29weXJpZ2h0IDIwMTggQWRvYmVcclxuKiBBbGwgUmlnaHRzIFJlc2VydmVkLlxyXG4qXHJcbiogTk9USUNFOiBBbGwgaW5mb3JtYXRpb24gY29udGFpbmVkIGhlcmVpbiBpcywgYW5kIHJlbWFpbnNcclxuKiB0aGUgcHJvcGVydHkgb2YgQWRvYmUgYW5kIGl0cyBzdXBwbGllcnMsIGlmIGFueS4gVGhlIGludGVsbGVjdHVhbFxyXG4qIGFuZCB0ZWNobmljYWwgY29uY2VwdHMgY29udGFpbmVkIGhlcmVpbiBhcmUgcHJvcHJpZXRhcnkgdG8gQWRvYmVcclxuKiBhbmQgaXRzIHN1cHBsaWVycyBhbmQgYXJlIHByb3RlY3RlZCBieSBhbGwgYXBwbGljYWJsZSBpbnRlbGxlY3R1YWxcclxuKiBwcm9wZXJ0eSBsYXdzLCBpbmNsdWRpbmcgdHJhZGUgc2VjcmV0IGFuZCBjb3B5cmlnaHQgbGF3cy5cclxuKiBEaXNzZW1pbmF0aW9uIG9mIHRoaXMgaW5mb3JtYXRpb24gb3IgcmVwcm9kdWN0aW9uIG9mIHRoaXMgbWF0ZXJpYWxcclxuKiBpcyBzdHJpY3RseSBmb3JiaWRkZW4gdW5sZXNzIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbiBpcyBvYnRhaW5lZFxyXG4qIGZyb20gQWRvYmUuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xyXG5jb25zdCByaCA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi9saWIvcmhcIilcclxuY29uc3QgXyA9IHJoLl9cclxuY29uc3QgY29uc3RzID0gcmguY29uc3RzXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIFNlYXJjaExhbmd1YWdlIHtcclxuXHJcbiAgY29uc3RydWN0b3IoY29kZSwgbG9hZGVyLCBjYikge1xyXG4gICAgdGhpcy5jYiA9IGNiIFxyXG4gICAgdGhpcy5waXBlTGluZUZuID0ge31cclxuICAgIHRoaXMuY29kZSA9IHRoaXMuX2V4dHJhY3RDb2RlKGNvZGUpXHJcbiAgICB0aGlzLnVzZUxhbmcgPSB0aGlzLl91c2VMYW5nKClcclxuICAgIHRoaXMubG9hZGVyID0gbG9hZGVyIFxyXG4gIH1cclxuICBzZXRMYW5ndWFnZShsdW5yKSB7XHJcbiAgICBpZiAodGhpcy51c2VMYW5nKSB7XHJcbiAgICAgIF8ubG9hZFNjcmlwdCh0aGlzLmxvYWRlci5nZXRVcmwoY29uc3RzKCdTRUFSQ0hfU1RFTU1FUl9TVVBQT1JUJykpLCB0cnVlLCAoKSA9PntcclxuICAgICAgICBsZXQgc3RlbW1lciA9IF8uZXhwb3J0cygpXHJcbiAgICAgICAgc3RlbW1lcihsdW5yKVxyXG4gICAgICAgIGlmKHRoaXMuY29kZSA9PT0gJ2pwJyl7XHJcbiAgICAgICAgICBfLmxvYWRTY3JpcHQodGhpcy5sb2FkZXIuZ2V0VXJsKGNvbnN0cygnU0VBUkNIX1RJTllfU0VHTUVOVEVSJykpLCB0cnVlLCAoKSA9PntcclxuICAgICAgICAgICAgbGV0IHNlZ21lbnRlciA9IF8uZXhwb3J0cygpXHJcbiAgICAgICAgICAgIHNlZ21lbnRlciAobHVucilcclxuICAgICAgICAgICAgXy5sb2FkU2NyaXB0KHRoaXMubG9hZGVyLmdldFVybChjb25zdHMoJ1NFQVJDSF9MTkdfU1VQUE9SVCcpKSwgdHJ1ZSwgKCkgPT57XHJcbiAgICAgICAgICAgICAgbGV0IGxuZ0hhbmRsZXIgPSBfLmV4cG9ydHMoKVxyXG4gICAgICAgICAgICAgIGxuZ0hhbmRsZXIobHVucilcclxuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jYiAmJiB0aGlzLmNiKGx1bnIpXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICB9KVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNle1xyXG4gICAgICAgICAgXy5sb2FkU2NyaXB0KHRoaXMubG9hZGVyLmdldFVybChjb25zdHMoJ1NFQVJDSF9MTkdfU1VQUE9SVCcpKSwgdHJ1ZSwgKCkgPT57XHJcbiAgICAgICAgICAgIGxldCBsbmdIYW5kbGVyID0gXy5leHBvcnRzKClcclxuICAgICAgICAgICAgbG5nSGFuZGxlcihsdW5yKVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jYiAmJiB0aGlzLmNiKGx1bnIpXHJcbiAgICAgICAgICB9KVxyXG4gICAgICAgIH1cclxuICAgICAgfSkgXHJcbiAgICB9XHJcbiAgICBlbHNle1xyXG4gICAgICB0aGlzLnNldFRva2VuaXplcihsdW5yKVxyXG4gICAgICByZXR1cm4gdGhpcy5jYiAmJiB0aGlzLmNiKGx1bnIpXHJcbiAgICB9XHJcbiAgICAvL3RoaXMuaW5pdEZucyhsdW5yKVxyXG4gIH1cclxuICByZXBsYWNlRm4oZGIsIGx1bnIpe1xyXG4gICAgaWYodGhpcy51c2VMYW5nKXtcclxuICAgICAgZGIucGlwZWxpbmUuYmVmb3JlKGx1bnIuc3RlbW1lciwgbHVuclt0aGlzLmNvZGVdLnN0ZW1tZXIpXHJcbiAgICAgIGRiLnBpcGVsaW5lLnJlbW92ZShsdW5yLnN0ZW1tZXIpXHJcbiAgICAgIGlmKGx1bnJbdGhpcy5jb2RlXSAmJiBsdW5yW3RoaXMuY29kZV0udG9rZW5pemVyKXtcclxuICAgICAgICBsdW5yLnRva2VuaXplciA9ICBsdW5yW3RoaXMuY29kZV0udG9rZW5pemVyIFxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG4gIHNldFRva2VuaXplcihsdW5yKSB7XHJcbiAgICBsdW5yLnRva2VuaXplci5zZXBhcmF0b3IgPSAvW1xcc1xcLlxcLVxcJ1xcLFxcbjtcXDpcXFxcXFwvXFxcIl0rL1xyXG4gIH1cclxuICBpbml0Rm5zKGx1bnIpIHtcclxuICAgIGxldCBsdW5yTG9jYWxpemVkID0gdGhpcy51c2VMYW5nPyBsdW5yW3RoaXMuY29kZV0gOiBsdW5yXHJcbiAgICBsZXQgZnVuY3Rpb25zID0gdGhpcy51c2VMYW5nPyB0aGlzLmZuW3RoaXMuY29kZV0gfHwgdGhpcy5mbi5lbiA6IHRoaXMuZm4uZW5cclxuICAgIF8uZWFjaChmdW5jdGlvbnMsIChmbk5hbWUsIGZpZWxkTmFtZSkgPT4geyBcclxuICAgICAgaWYodGhpcy5jb2RlICE9PSAnanAnKSB7XHJcbiAgICAgICAgbHVuci5QaXBlbGluZS5yZWdpc3RlckZ1bmN0aW9uKGx1bnJMb2NhbGl6ZWRbZm5OYW1lXSwgZmllbGROYW1lKVxyXG4gICAgICB9XHJcbiAgICAgIHRoaXMucGlwZUxpbmVGbltmaWVsZE5hbWVdID0gbHVuckxvY2FsaXplZFtmbk5hbWVdXHJcbiAgICB9KSBcclxuICB9XHJcbiAgXHJcbiAgZ2V0IHN0ZW1tZXIoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5waXBlTGluZUZuLnN0ZW1tZXJcclxuICB9XHJcbiAgXHJcbiAgZ2V0IHN0b3BXb3JkRmlsdGVyKCl7XHJcbiAgICByZXR1cm4gdGhpcy5waXBlTGluZUZuLnN0b3BXb3JkRmlsdGVyIFxyXG4gIH1cclxuXHJcbiAgZ2V0IHRva2VuaXplcigpIHtcclxuICAgIHJldHVybiB0aGlzLnBpcGVMaW5lRm4udG9rZW5pemVyXHJcbiAgfVxyXG4gIGluaXRJbmRleGluZyhub2RlLCBsdW5yKSB7XHJcbiAgICBpZiAodGhpcy51c2VMYW5nKSB7XHJcbiAgICAgIG5vZGUudXNlKGx1bnJbdGhpcy5jb2RlXSlcclxuICAgIH1cclxuICB9XHJcbiAgX3VzZUxhbmcoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5jb2RlICYmIChbJ2VuJ10uaW5kZXhPZih0aGlzLmNvZGUpID09PSAtMSApXHJcbiAgICAmJiB0aGlzLmNvZGVzLmluZGV4T2YodGhpcy5jb2RlKSAhPT0gLTFcclxuICB9XHJcbiAgX2V4dHJhY3RDb2RlKGNvZGUpIHtcclxuICAgIGlmIChjb2RlKSB7XHJcbiAgICAgIGxldCBpZCA9IGNvZGUuaW5kZXhPZignXycpXHJcbiAgICAgIGxldCBsbmdDb2RlID0gY29kZS5zdWJzdHJpbmcoMCwgaWQpLnRvTG93ZXJDYXNlKClcclxuICAgICAgaWYobG5nQ29kZSA9PT0gJ2phJyl7XHJcbiAgICAgICAgbG5nQ29kZSA9ICdqcCdcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gbG5nQ29kZVxyXG4gICAgfVxyXG4gICAgXHJcbiAgfVxyXG5cclxuICBnZXQgY29kZXMoKSB7XHJcbiAgICByZXR1cm4gW1xyXG4gICAgICBcImRhXCIsXHJcbiAgICAgIFwiZGVcIixcclxuICAgICAgXCJkdVwiLFxyXG4gICAgICBcImVzXCIsXHJcbiAgICAgIFwiZmlcIixcclxuICAgICAgXCJmclwiLFxyXG4gICAgICBcImh1XCIsXHJcbiAgICAgIFwiaXRcIixcclxuICAgICAgXCJqYVwiLFxyXG4gICAgICBcImpwXCIsXHJcbiAgICAgIFwibm9cIixcclxuICAgICAgXCJwdFwiLFxyXG4gICAgICBcInJvXCIsXHJcbiAgICAgIFwicnVcIixcclxuICAgICAgXCJzdlwiLFxyXG4gICAgICAvL1widGhcIixcclxuICAgICAgXCJ0clwiXHJcbiAgICBdXHJcbiAgfVxyXG4gIGdldCBmbigpe1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgXCJkYVwiOiB7XHJcbiAgICAgICAgdG9rZW5pemVyOiBcInRyaW1tZXJcIiwgc3RvcFdvcmRGaWx0ZXI6IFwic3RvcFdvcmRGaWx0ZXJcIiwgc3RlbW1lcjogXCJzdGVtbWVyXCJcclxuICAgICAgfSxcclxuICAgICAgXCJkZVwiOiB7XHJcbiAgICAgICAgdG9rZW5pemVyOiBcInRyaW1tZXJcIiwgc3RvcFdvcmRGaWx0ZXI6IFwic3RvcFdvcmRGaWx0ZXJcIiwgc3RlbW1lcjogXCJzdGVtbWVyXCJcclxuICAgICAgfSxcclxuICAgICAgXCJkdVwiOiB7XHJcbiAgICAgICAgdG9rZW5pemVyOiBcInRyaW1tZXJcIiwgc3RvcFdvcmRGaWx0ZXI6IFwic3RvcFdvcmRGaWx0ZXJcIiwgc3RlbW1lcjogXCJzdGVtbWVyXCJcclxuICAgICAgfSxcclxuICAgICAgXCJlblwiOiB7XHJcbiAgICAgICAgdG9rZW5pemVyOiBcInRva2VuaXplclwiLCBzdG9wV29yZEZpbHRlcjogXCJzdG9wV29yZEZpbHRlclwiLCBzdGVtbWVyOiBcInN0ZW1tZXJcIlxyXG4gICAgICB9LFxyXG4gICAgICBcImVzXCI6IHtcclxuICAgICAgICB0b2tlbml6ZXI6IFwidHJpbW1lclwiLCBzdG9wV29yZEZpbHRlcjogXCJzdG9wV29yZEZpbHRlclwiLCBzdGVtbWVyOiBcInN0ZW1tZXJcIlxyXG4gICAgICB9LFxyXG4gICAgICBcImZpXCI6IHtcclxuICAgICAgICB0b2tlbml6ZXI6IFwidHJpbW1lclwiLCBzdG9wV29yZEZpbHRlcjogXCJzdG9wV29yZEZpbHRlclwiLCBzdGVtbWVyOiBcInN0ZW1tZXJcIlxyXG4gICAgICB9LFxyXG4gICAgICBcImZyXCI6IHtcclxuICAgICAgICB0b2tlbml6ZXI6IFwidHJpbW1lclwiLCBzdG9wV29yZEZpbHRlcjogXCJzdG9wV29yZEZpbHRlclwiLCBzdGVtbWVyOiBcInN0ZW1tZXJcIlxyXG4gICAgICB9LFxyXG4gICAgICBcIml0XCI6IHtcclxuICAgICAgICB0b2tlbml6ZXI6IFwidHJpbW1lclwiLCBzdG9wV29yZEZpbHRlcjogXCJzdG9wV29yZEZpbHRlclwiLCBzdGVtbWVyOiBcInN0ZW1tZXJcIlxyXG4gICAgICB9LFxyXG4gICAgICBcImphXCI6IHtcclxuICAgICAgICB0b2tlbml6ZXI6IFwidHJpbW1lclwiLCBzdG9wV29yZEZpbHRlcjogXCJzdG9wV29yZEZpbHRlclwiLCBzdGVtbWVyOiBcInN0ZW1tZXJcIlxyXG4gICAgICB9LFxyXG4gICAgICBcImpwXCI6IHtcclxuICAgICAgICB0b2tlbml6ZXI6IFwidG9rZW5pemVyXCIsIHN0b3BXb3JkRmlsdGVyOiBcInN0b3BXb3JkRmlsdGVyXCIsIHN0ZW1tZXI6IFwic3RlbW1lclwiXHJcbiAgICAgIH0sXHJcbiAgICAgIFwibm9cIjoge1xyXG4gICAgICAgIHRva2VuaXplcjogXCJ0cmltbWVyXCIsIHN0b3BXb3JkRmlsdGVyOiBcInN0b3BXb3JkRmlsdGVyXCIsIHN0ZW1tZXI6IFwic3RlbW1lclwiXHJcbiAgICAgIH0sXHJcbiAgICAgIFwicHRcIjoge1xyXG4gICAgICAgIHRva2VuaXplcjogXCJ0cmltbWVyXCIsIHN0b3BXb3JkRmlsdGVyOiBcInN0b3BXb3JkRmlsdGVyXCIsIHN0ZW1tZXI6IFwic3RlbW1lclwiXHJcbiAgICAgIH0sXHJcbiAgICAgIFwicm9cIjoge1xyXG4gICAgICAgIHRva2VuaXplcjogXCJ0cmltbWVyXCIsIHN0b3BXb3JkRmlsdGVyOiBcInN0b3BXb3JkRmlsdGVyXCIsIHN0ZW1tZXI6IFwic3RlbW1lclwiXHJcbiAgICAgIH0sXHJcbiAgICAgIFwicnVcIjoge1xyXG4gICAgICAgIHRva2VuaXplcjogXCJ0cmltbWVyXCIsIHN0b3BXb3JkRmlsdGVyOiBcInN0b3BXb3JkRmlsdGVyXCIsIHN0ZW1tZXI6IFwic3RlbW1lclwiXHJcbiAgICAgIH0sXHJcbiAgICAgIFwic3ZcIjoge1xyXG4gICAgICAgIHRva2VuaXplcjogXCJ0cmltbWVyXCIsIHN0b3BXb3JkRmlsdGVyOiBcInN0b3BXb3JkRmlsdGVyXCIsIHN0ZW1tZXI6IFwic3RlbW1lclwiXHJcbiAgICAgIH0sXHJcbiAgICAgIFwidGhcIjoge1xyXG4gICAgICAgIHRva2VuaXplcjogXCJ0cmltbWVyXCIsIHN0b3BXb3JkRmlsdGVyOiBcInN0b3BXb3JkRmlsdGVyXCIsIHN0ZW1tZXI6IFwic3RlbW1lclwiXHJcbiAgICAgIH0sXHJcbiAgICAgIFwidHJcIjoge1xyXG4gICAgICAgIHRva2VuaXplcjogXCJ0cmltbWVyXCIsIHN0b3BXb3JkRmlsdGVyOiBcInN0b3BXb3JkRmlsdGVyXCIsIHN0ZW1tZXI6IFwic3RlbW1lclwiXHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IGNsYXNzIFNlYXJjaE1ldGFkYXRhIHtcclxuICBjb25zdHJ1Y3RvcihkYXRhKSB7XHJcbiAgICBpZihkYXRhKSB7XHJcbiAgICAgIHRoaXMuZGF0YSA9IEpTT04ucGFyc2UoZGF0YSlcclxuICAgIH1cclxuICB9XHJcbiAgZ2V0IHNldHRpbmdzKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZGF0YS5zZXR0aW5nc1xyXG4gIH1cclxuICBnZXQgdG9waWNEYXRhKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZGF0YS5tZXRhZGF0YVxyXG4gIH1cclxuICBnZXRUb3BpY0RhdGEoaWQpIHtcclxuICAgIHJldHVybiB0aGlzLnRvcGljRGF0YVtpZF1cclxuICB9XHJcblxyXG4gIGdldFRvcGljU3VtbWFyeShpZCkge1xyXG4gICAgcmV0dXJuIHRoaXMudG9waWNEYXRhW2lkXSAmJiB0aGlzLnRvcGljRGF0YVtpZF0uc3VtbWFyeVxyXG4gIH1cclxuXHJcbiAgZ2V0VG9waWNOZXh0SWQoaWQpIHtcclxuICAgIHJldHVybiB0aGlzLnRvcGljRGF0YVtpZF0gJiYgdGhpcy50b3BpY0RhdGFbaWRdLm5leHRcclxuICB9XHJcblxyXG4gIGdldCBjb250ZXh0KCkge1xyXG4gICAgcmV0dXJuIHRoaXMuc2V0dGluZ3MuY29udGV4dFxyXG4gIH1cclxuXHJcbiAgZ2V0IGNvbnRleHRMaW1pdCgpIHtcclxuICAgIHJldHVybiB0aGlzLnNldHRpbmdzLmNvbnRleHRMaW1pdFxyXG4gIH1cclxuXHJcbiAgZ2V0IGZpZWxkcygpIHtcclxuICAgIHJldHVybiB0aGlzLnNldHRpbmdzLmZpZWxkc1xyXG4gIH1cclxufSIsImNvbnN0IHJoID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uLy4uL2xpYi9yaFwiKVxyXG5jb25zdCBfID0gcmguX1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBDYnRGaWx0ZXIge1xyXG4gIGNvbnN0cnVjdG9yKGZpZWxkcywgb3JpZ2luLCB0YWdFeHBycykge1xyXG4gICAgdGhpcy5maWxlZHMgPSBmaWVsZHNcclxuICAgIHRoaXMub3JpZ2luID0gb3JpZ2luXHJcbiAgICB0aGlzLnRhZ0V4cHJzID0gdGFnRXhwcnNcclxuICB9XHJcbiAgZmlsdGVyKGl0ZW1MaXN0KSB7XHJcbiAgICByZXR1cm4gXy5yZWR1Y2UoaXRlbUxpc3QsIChmaWx0ZXJlZCwgaXRlbSkgPT4gZmlsdGVyZWQgfHwgdGhpcy5faXNGaWx0ZXJkKGl0ZW0pLCBmYWxzZSlcclxuICB9XHJcbiAgX2lzRmlsdGVyZChpdGVtKSB7XHJcbiAgICBsZXQgY2J0ID0gdGhpcy5nZXRDYnQoaXRlbSlcclxuICAgIHJldHVybiBjYnQgJiYgdGhpcy5faXNGaWx0ZXJlZENidChjYnQpXHJcblxyXG4gIH1cclxuICBfaXNGaWx0ZXJlZENidChjYnQpIHtcclxuICAgIGxldCBpZHMgPSBjYnQuc3BsaXQoJzsnKVxyXG4gICAgcmV0dXJuICFfLmFueShpZHMsIChpZCkgID0+IHtcclxuICAgICAgcmV0dXJuIF8uZXZhbFRhZ0V4cHJlc3Npb24oaWQsIHRoaXMudGFnRXhwcnMsIHRoaXMub3JpZ2luKVxyXG4gICAgfSlcclxuICAgIFxyXG4gICAgXHJcbiAgfVxyXG4gIGdldENidChpdGVtKSB7XHJcbiAgICByZXR1cm4gaXRlbSAmJiBpdGVtLmF0dHJpYnV0ZXNcclxuICAgICAgJiYgaXRlbS5hdHRyaWJ1dGVzLmxlbmd0aCA+IDAgJiYgXy5tYXAoaXRlbS5hdHRyaWJ1dGVzLCBhdHRyID0+IHtcclxuICAgICAgICByZXR1cm4gYXR0ci52YWx1ZVxyXG4gICAgICB9KS5qb2luKFwiO1wiKVxyXG4gIH1cclxufSIsImxldCBsdW5yID0gcmVxdWlyZSAoJ2x1bnInKVxyXG5sZXQgU3lub255bW5zID0gcmVxdWlyZSgnLi4vLi4vY29tbW9uL3N5bm9ueW1ucycpXHJcbmNvbnN0IHJoID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uLy4uL2xpYi9yaFwiKVxyXG5jb25zdCBfID0gcmguX1xyXG5jb25zdCBMYW5ndWFnZVNldHRlciA9IHJlcXVpcmUoJy4uL2xhbmd1YWdlJylcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgU2VhcmNoRGJ7XHJcbiAgY29uc3RydWN0b3IoY29udGVudCwgbG9hZGVyLCBzZXR0aW5ncyl7XHJcbiAgICB0aGlzLmluaXQoY29udGVudCwgbG9hZGVyLCBzZXR0aW5ncylcclxuICB9XHJcbiAgaW5pdChjb250ZW50LCBsb2FkZXIsIHNldHRpbmdzID0ge30pIHtcclxuICAgIGNvbnRlbnQgPSB0aGlzLmZpeENvbnRlbnQoY29udGVudClcclxuICAgIHRoaXMuc2V0dGluZ3MgPSBzZXR0aW5nc1xyXG4gICAgdGhpcy5jb250ZW50ID0gY29udGVudFxyXG4gICAgdGhpcy5jb2RlID0gIF8uZ2V0KHRoaXMuc2V0dGluZ3MsIFwibGFuZ3VhZ2UuY29kZVwiKVxyXG4gICAgdGhpcy5sYW5ndWFnZVNldHRlciA9IG5ldyBMYW5ndWFnZVNldHRlcih0aGlzLmNvZGUsIGxvYWRlciwgdGhpcy5sb2FkRGIuYmluZCh0aGlzKSlcclxuICAgIHRoaXMubGFuZ3VhZ2VTZXR0ZXIuc2V0TGFuZ3VhZ2UobHVucilcclxuICB9XHJcbiAgZml4Q29udGVudChjb250ZW50KSB7XHJcbiAgICBjb250ZW50LnBpcGVsaW5lID0gY29udGVudC5waXBlbGluZSB8fCBbXVxyXG4gICAgY29udGVudC5maWVsZFZlY3RvcnMgPSBjb250ZW50LmZpZWxkVmVjdG9ycyB8fCBbXVxyXG4gICAgY29udGVudC5pbnZlcnRlZEluZGV4ID0gY29udGVudC5pbnZlcnRlZEluZGV4IHx8IFtdXHJcbiAgICByZXR1cm4gY29udGVudFxyXG4gIH1cclxuICBsb2FkRGIoKXtcclxuICAgIHRoaXMucHJvY2Vzc1N5bigpXHJcbiAgICB0aGlzLnJlZ2lzdGVyRnVuY3Rpb25zKClcclxuICAgIHRoaXMuZGIgPSBsdW5yLkluZGV4LmxvYWQodGhpcy5jb250ZW50KVxyXG4gICAgaWYoIV8uaXNFbXB0eU9iamVjdCh0aGlzLmNvbnRlbnQucGlwZWxpbmUpKSB7XHJcbiAgICAgIHRoaXMubGFuZ3VhZ2VTZXR0ZXIucmVwbGFjZUZuKHRoaXMuZGIsIGx1bnIpXHJcbiAgICB9XHJcbiAgfVxyXG4gIHJlZ2lzdGVyRnVuY3Rpb25zKCkge1xyXG4gICAgbGV0IHBpcGVsaW5lRnVuY3Rpb24gPSB0aGlzLnJlcGxhY2VTeW5vbnltbi5iaW5kKHRoaXMpXHJcbiAgICBsZXQgYWRkUXVlcnlGdW5jdGlvbiA9IHRoaXMuYWRkUXVlcnkuYmluZCh0aGlzKVxyXG4gICAgbHVuci5QaXBlbGluZS5yZWdpc3RlckZ1bmN0aW9uKHBpcGVsaW5lRnVuY3Rpb24sICdyZXBsYWNlU3lub255bW4nKVxyXG4gICAgbHVuci5QaXBlbGluZS5yZWdpc3RlckZ1bmN0aW9uKGFkZFF1ZXJ5RnVuY3Rpb24sICdhZGRRdWVyeScpXHJcbiAgfVxyXG5cclxuICBwcm9jZXNzU3luKCkge1xyXG4gICAgbGV0IHN5bm9ueW1uc193b3JkcyA9ICh0aGlzLnNldHRpbmdzICYmIHRoaXMuc2V0dGluZ3Muc3lub255bXMpIHx8IHt9XHJcbiAgICBsZXQgc3lub255bXMgPSBuZXcgU3lub255bW5zKHN5bm9ueW1uc193b3JkcylcclxuICAgIHRoaXMuc2V0dGluZ3Mucm9vdFdvcmRzID0gc3lub255bXMucm9vdFdvcmRzXHJcbiAgfVxyXG4gIGFkZFF1ZXJ5KHRva2VuKSB7XHJcbiAgICBsZXQgd29yZCA9IHRva2VuLnRvU3RyaW5nKClcclxuICAgIHRoaXMucXVlcnlXb3Jkcy5wdXNoKHdvcmQpXHJcbiAgICB0aGlzLnF1ZXJ5V29yZHMgPSBfLnVuaXF1ZSh0aGlzLnF1ZXJ5V29yZHMpXHJcbiAgICByZXR1cm4gdG9rZW5cclxuICB9XHJcbiAgcmVwbGFjZVN5bm9ueW1uKHRva2VuKSB7XHJcbiAgICBsZXQgd29yZCA9IHRva2VuLnRvU3RyaW5nKClcclxuICAgIGxldCByb290ID0gdGhpcy5zZXR0aW5ncyAmJiB0aGlzLnNldHRpbmdzLnJvb3RXb3JkcyAmJiB0aGlzLnNldHRpbmdzLnJvb3RXb3Jkc1t3b3JkXVxyXG4gICAgaWYgKHJvb3QgJiYgcm9vdCAhPT0gd29yZCkge1xyXG4gICAgICByZXR1cm4gdG9rZW4udXBkYXRlKCgpID0+IHsgcmV0dXJuIHRoaXMuc2V0dGluZ3Mucm9vdFdvcmRzW3dvcmRdIH0pXHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgcmV0dXJuIHRva2VuXHJcbiAgICB9XHJcbiAgfVxyXG4gIGFkZFN0b3BXb3JkcyhpbmRleCwgc3RvcFdvcmRzKSB7XHJcbiAgICBpZiAoc3RvcFdvcmRzKSB7XHJcbiAgICAgIGxldCBzdG9wV29yZEZpbHRlciA9IGx1bnIuZ2VuZXJhdGVTdG9wV29yZEZpbHRlcihzdG9wV29yZHMpXHJcbiAgICAgIGluZGV4LnBpcGVsaW5lLmJlZm9yZShsdW5yLnN0b3BXb3JkRmlsdGVyLCBzdG9wV29yZEZpbHRlcilcclxuICAgICAgaW5kZXgucGlwZWxpbmUucmVtb3ZlKGx1bnIuc3RvcFdvcmRGaWx0ZXIpXHJcbiAgICB9XHJcbiAgfVxyXG4gIHNlYXJjaChxdWVyeSkge1xyXG4gICAgdGhpcy5xdWVyeVdvcmRzID0gW11cclxuICAgIGxldCBwYXJhbXMgPSBxdWVyeS5nZXRQYXJhbXModGhpcy5pc1N0b3BXb3JkLmJpbmQodGhpcykpXHJcbiAgICBsZXQgc2VhcmNoX3Jlc3VsdHMgPSBbXVxyXG4gICAgbGV0IGNsYXVzZXMgPSBfLmZsYXR0ZW4ocGFyYW1zKVxyXG4gICAgc2VhcmNoX3Jlc3VsdHMgPSB0aGlzLmRiICYmIGNsYXVzZXMubGVuZ3RoIT09MCAmJiB0aGlzLmRiLnF1ZXJ5KChxKSA9PiB7XHJcbiAgICAgIF8uZWFjaChjbGF1c2VzLCBjbGF1c2UgPT4gcS50ZXJtKGNsYXVzZS5uYW1lLCBjbGF1c2UpKVxyXG4gICAgfSkgfHwgW11cclxuICAgIHNlYXJjaF9yZXN1bHRzID0gc2VhcmNoX3Jlc3VsdHMuc29ydCgoYSwgYikgPT4gcmguXy5rZXlzKGIubWF0Y2hEYXRhLm1ldGFkYXRhKS5sZW5ndGggLSByaC5fLmtleXMoYS5tYXRjaERhdGEubWV0YWRhdGEpLmxlbmd0aClcclxuICAgIHJldHVybiAocXVlcnkub3B0cyk/XHJcbiAgICAgIF8uZmlsdGVyKHNlYXJjaF9yZXN1bHRzLCAocmVzdWx0KSA9PiB0aGlzLm1hdGNoKHJlc3VsdCwgcXVlcnkub3B0cykpXHJcbiAgICAgIDogc2VhcmNoX3Jlc3VsdHNcclxuICB9XHJcblxyXG4gIG1hdGNoKHJlc3VsdCwgb3B0cykge1xyXG4gICAgbGV0IHJldFZhbCA9IHRydWVcclxuICAgIGlmIChvcHRzLmFuZFNlYXJjaCkge1xyXG4gICAgICBsZXQgbWF0Y2hpbmdXb3JkcyA9IHJlc3VsdCAmJiByZXN1bHQubWF0Y2hEYXRhLm1ldGFkYXRhIHx8IFtdXHJcbiAgICAgIF8uZWFjaCh0aGlzLnF1ZXJ5V29yZHMsICh3b3JkKSA9PiB7XHJcbiAgICAgICAgaWYgKCFtYXRjaGluZ1dvcmRzW3dvcmRdICYmICF0aGlzLmlzU3RvcFdvcmQod29yZCkpIHtcclxuICAgICAgICAgIHJldFZhbCA9IGZhbHNlXHJcbiAgICAgICAgfVxyXG4gICAgICB9KVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJldFZhbFxyXG4gIH1cclxuXHJcbiAgaXNTdG9wV29yZCh3b3JkKXtcclxuICAgIHJldHVybiB0aGlzLnNldHRpbmdzLnN0b3BXb3Jkcy5pbmRleE9mKHdvcmQudG9Mb3dlckNhc2UoKSkgIT09IC0xXHJcbiAgfVxyXG5cclxuICBzZWFyY2hHbG9zc2FyeShxdWVyeSkge1xyXG4gICAgbGV0IGdsb3NzYXJ5ID0gKHRoaXMuc2V0dGluZ3MgJiYgdGhpcy5zZXR0aW5ncy5nbG9zc2FyeSkgfHwge31cclxuICAgIGxldCBxdWVyeVRva2VucyA9IHRoaXMuZ2V0Um9vdFRva2VucyhxdWVyeSlcclxuICAgIGxldCBnb3NzYXJ5UmVzdWx0cyA9IF8ucmVkdWNlKGdsb3NzYXJ5LCAocmVzdWx0LCBkZWZpbml0aW9uLCB0ZXJtKSA9PntcclxuICAgICAgbGV0IGdsb1Rva2VucyA9IHRoaXMuZ2V0Um9vdFRva2Vucyh0ZXJtKVxyXG4gICAgICBpZiAocXVlcnlUb2tlbnMubGVuZ3RoID09PSBnbG9Ub2tlbnMubGVuZ3RoICYmIHRoaXMubWF0Y2hUb2tlbnMocXVlcnlUb2tlbnMsIGdsb1Rva2VucykpIHtcclxuICAgICAgICByZXN1bHRbdGVybV0gPSBkZWZpbml0aW9uXHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHJlc3VsdFxyXG4gICAgfSwge30pXHJcbiAgICByZXR1cm4gZ29zc2FyeVJlc3VsdHNcclxuICB9XHJcblxyXG4gIG1hdGNoVG9rZW5zKHNldDEsIHNldDIpIHtcclxuICAgIGxldCBtYXRjaGVkID0gdHJ1ZVxyXG4gICAgXy5lYWNoKHNldDEsICh0ZXJtMSwgaW5kZXgpID0+IHtcclxuICAgICAgaWYgKHRlcm0xICE9PSBzZXQyW2luZGV4XSkge1xyXG4gICAgICAgIG1hdGNoZWQgPSBmYWxzZVxyXG4gICAgICB9XHJcbiAgICB9KVxyXG4gICAgcmV0dXJuIG1hdGNoZWRcclxuICB9XHJcblxyXG4gIGdldFJvb3RUb2tlbnModGV4dCkge1xyXG4gICAgbGV0IHRva2VucyA9IGx1bnIudG9rZW5pemVyKHRleHQpXHJcbiAgICByZXR1cm4gXy5tYXAodG9rZW5zLCAodG9rZW4pID0+IHtcclxuICAgICAgbGV0IHdvcmQgPSB0b2tlbi50b1N0cmluZygpXHJcbiAgICAgIHJldHVybiB0aGlzLnNldHRpbmdzLnJvb3RXb3Jkc1t3b3JkXSB8fCB3b3JkXHJcbiAgICB9KVxyXG4gIH1cclxuXHJcbiAgZXhwb3J0KCl7XHJcbiAgICByZXR1cm4gdGhpcy5kYi50b0pTT04oKVxyXG4gIH1cclxufVxyXG4iLCJcclxuY29uc3QgcmggPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vLi4vbGliL3JoXCIpXHJcbmNvbnN0IF8gPSByaC5fXHJcbmNvbnN0IFBhdGhzID0gcmVxdWlyZSgnLi4vLi4vY29tbW9uL3BhdGhzJylcclxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBTZWFyY2hMb2FkZXJ7XHJcbiAgY29uc3RydWN0b3IocGF0aCA9IFwiXCIpe1xyXG4gICAgdGhpcy5fcGF0aHMgPSBuZXcgUGF0aHMocGF0aClcclxuICB9XHJcbiAgZ2V0UGF0aCgpeyBcclxuICAgIHJldHVybiB0aGlzLl9wYXRocy5nZXRQYXRoKClcclxuICB9XHJcbiAgaW5pdChpZCwgY2FsbGJhY2tGbikge1xyXG4gICAgdGhpcy5pZCA9IGlkXHJcbiAgICBjYWxsYmFja0ZuKHRoaXMpXHJcbiAgfVxyXG4gIGxvYWREQihjYWxsYmFja0ZuKXtcclxuICAgIGxldCBwYXRoID0gdGhpcy5fcGF0aHMuZ2V0U2VhcmNoRGJGaWxlUGF0aCgpXHJcbiAgICBfLmxvYWRTY3JpcHQocGF0aCwgdHJ1ZSwgKCkgPT4ge1xyXG4gICAgICBsZXQgZGF0YSA9IF8uZXhwb3J0cygpXHJcbiAgICAgIGlmKGNhbGxiYWNrRm4pe1xyXG4gICAgICAgIGNhbGxiYWNrRm4oZGF0YSlcclxuICAgICAgfVxyXG4gICAgfSwgdHJ1ZSk7XHJcbiAgfVxyXG5cclxuICBnZXRJZChpZCkge1xyXG4gICAgcmV0dXJuIGAke3RoaXMuaWR9XyR7aWR9YFxyXG4gIH1cclxuICBnZXRVcmwodXJsKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fcGF0aHMuX2dldFJlbGF0aXZlUGF0aCh1cmwpXHJcbiAgfVxyXG4gIGxvYWRNZXRhRGF0YShjYWxsYmFja0ZuKXtcclxuICAgIGxldCBwYXRoID0gdGhpcy5fcGF0aHMuZ2V0TWV0YWRhdGFGaWxlUGF0aCgpXHJcbiAgICBfLmxvYWRTY3JpcHQocGF0aCwgdHJ1ZSwgKCkgPT4ge1xyXG4gICAgICBsZXQgZGF0YSA9IF8uZXhwb3J0cygpXHJcbiAgICAgIGlmKGNhbGxiYWNrRm4pe1xyXG4gICAgICAgIGNhbGxiYWNrRm4oZGF0YSlcclxuICAgICAgfVxyXG4gICAgfSwgdHJ1ZSk7XHJcbiAgfVxyXG4gIFxyXG4gIGxvYWRUZXh0RGF0YShxdWVyeSwgaWQsIGNhbGxiYWNrRm4pIHtcclxuICAgIGxldCBwYXRoID0gdGhpcy5fcGF0aHMuZ2V0VGV4dEZpbGVQYXRoKGlkKVxyXG4gICAgXy5sb2FkU2NyaXB0KHBhdGgsIHRydWUsICgpID0+IHtcclxuICAgICAgbGV0IGRhdGEgPSBfLmV4cG9ydHMoKVxyXG4gICAgICBpZiAoY2FsbGJhY2tGbikge1xyXG4gICAgICAgIGNhbGxiYWNrRm4ocXVlcnksIGlkLCBkYXRhKVxyXG4gICAgICB9XHJcbiAgICB9LCB0cnVlKTtcclxuICB9XHJcbn1cclxuIiwiY29uc3QgU2VhcmNoRGIgPSByZXF1aXJlICgnLi9kYicpXHJcbmNvbnN0IFF1ZXJ5ID0gcmVxdWlyZSgnLi9xdWVyeScpXHJcbmNvbnN0IFN1bW1hcnkgPSByZXF1aXJlKCcuL3N1bW1hcnknKVxyXG5jb25zdCByaCA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi8uLi9saWIvcmhcIilcclxuY29uc3QgXyA9IHJoLl9cclxuY29uc3QgU2VhbWFwaG9yZSA9IHJlcXVpcmUoJy4uLy4uLy4uLy4uL2NvbW1vbi9jb3VudGluZ19zZWFtYXBob3JlJylcclxuY29uc3QgVGV4dE1lcmdlciA9IHJlcXVpcmUoJy4uL3RleHRfbWVyZ2VyJylcclxuY29uc3QgU2VhcmNoTWV0YWRhdGEgPSByZXF1aXJlKCcuLi9tZXRhZGF0YScpXHJcbmNvbnN0IENidEZpbHRlciA9IHJlcXVpcmUoXCIuL2NidFwiKVxyXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIFNlYXJjaFByb2Nlc3NvcntcclxuICBjb25zdHJ1Y3Rvcihsb2FkZXIpe1xyXG4gICAgdGhpcy5sb2FkZXIgPSBsb2FkZXJcclxuICAgIHRoaXMubWV0YWRhdGFMb2FkZWQgPSB0aGlzLmRiTG9hZGVkID0gZmFsc2U7XHJcbiAgICB0aGlzLmxvYWRlci5sb2FkREIoKGRiQ29udGVudCk9PntcclxuICAgICAgdGhpcy5pbml0REIoZGJDb250ZW50KVxyXG4gICAgfSlcclxuICAgIHRoaXMubG9hZGVyLmxvYWRNZXRhRGF0YSgobWV0YWRhdGEpPT57XHJcbiAgICAgIHRoaXMuaW5pdE1ldGFkYXRhKG1ldGFkYXRhKVxyXG4gICAgfSlcclxuICB9XHJcblxyXG4gIGdldFBhdGgoKXtcclxuICAgIHJldHVybiB0aGlzLmxvYWRlci5nZXRQYXRoKClcclxuICB9XHJcbiAgXHJcbiAgaW5pdE1ldGFkYXRhKG1ldGFkYXRhKSB7XHJcbiAgICB0aGlzLm1ldGFkYXRhTG9hZGVkID0gdHJ1ZSBcclxuICAgIHRoaXMubWV0YWRhdGEgPSBuZXcgU2VhcmNoTWV0YWRhdGEobWV0YWRhdGEpXHJcbiAgICBcclxuICAgIGlmICghdGhpcy5pbml0ICYmIHRoaXMuZGJDb250ZW50KSB7XHJcbiAgICAgIHRoaXMuaW5pdERCKHRoaXMuZGJDb250ZW50KVxyXG4gICAgICB0aGlzLmRiQ29udGVudCA9IG51bGxcclxuICAgIH1cclxuICAgIHJoLm1vZGVsLnB1Ymxpc2gocmguY29uc3RzKCdLRVlfU0hPV19DT05URVhUJyksIHRoaXMuY29udGV4dExpbWl0ID4gMClcclxuXHJcbiAgfVxyXG5cclxuICBnZXQgc2VhcmNoU3Vic3RyaW5ncygpIHtcclxuICAgIHJldHVybiBfLmdldCh0aGlzLm1ldGFkYXRhLnNldHRpbmdzLCAnc2VhcmNoc3Vic3RyaW5ncycpXHJcbiAgfVxyXG5cclxuICBnZXQgY29udGV4dExpbWl0KClcclxuICB7XHJcbiAgICBsZXQgbnVtID0gcGFyc2VJbnQodGhpcy5tZXRhZGF0YS5jb250ZXh0TGltaXQpXHJcbiAgICBpZiAoTnVtYmVyLmlzTmFOKG51bSkpXHJcbiAgICB7IFxyXG4gICAgICByZXR1cm4gMTAwXHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVtXHJcbiAgICBcclxuICB9XHJcblxyXG4gIGluaXREQihkYkNvbnRlbnQpIHtcclxuICAgIGlmKHRoaXMubWV0YWRhdGFMb2FkZWQpe1xyXG4gICAgICB0aGlzLmRiID0gbmV3IFNlYXJjaERiKGRiQ29udGVudCwgdGhpcy5sb2FkZXIsIHRoaXMubWV0YWRhdGEuc2V0dGluZ3MpXHJcbiAgICAgIHRoaXMuaW5pdCA9IHRydWVcclxuICAgICAgaWYgKHRoaXMud2FpdGluZykge1xyXG4gICAgICAgIHRoaXMud2FpdGluZyA9IGZhbHNlXHJcbiAgICAgICAgdGhpcy5nZXRSZXN1bHRzKClcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgIHRoaXMuZGJDb250ZW50ID0gZGJDb250ZW50XHJcbiAgICB9XHJcbiAgfVxyXG4gIHRvcGljc0xvYWRlZCgpIHtcclxuICAgIGlmICh0aGlzLmV4YWN0U2VhcmNoKSB7XHJcbiAgICAgIHRoaXMuZmlsdGVyKClcclxuICAgIH1cclxuICB9XHJcbiAgXHJcbiAgaXNOZXdRdWVyeSh0ZXh0LCBvcHRzKXtcclxuICAgIGlmKCF0aGlzLmluaXQpe1xyXG4gICAgICByZXR1cm4gdHJ1ZVxyXG4gICAgfVxyXG4gICAgaWYoIXRoaXMubWV0YWRhdGEuc2V0dGluZ3Mpe1xyXG4gICAgICByZXR1cm4gZmFsc2VcclxuICAgIH1cclxuICAgIGxldCBxdWVyeSA9IHRoaXMuYnVpbGRRdWVyeSh0ZXh0LCBvcHRzKVxyXG4gICAgcmV0dXJuICF0aGlzLnF1ZXJ5IHx8ICF0aGlzLnF1ZXJ5LmlzRXF1YWwocXVlcnkpXHJcbiAgfVxyXG4gICAgXHJcbiAgc2VhcmNoKHRleHQsIG9wdHMsIGNhbGxiYWNrLCByZXN1bHRzQ2FsbGJhY2spIHtcclxuICAgIGlmKHRoaXMuaXNOZXdRdWVyeSh0ZXh0LCBvcHRzKSkge1xyXG4gICAgICB0aGlzLnRleHQgPSB0ZXh0XHJcbiAgICAgIHRoaXMuc2VhbWFwaG9yZSA9IG5ldyBTZWFtYXBob3JlKHRoaXMudG9waWNzTG9hZGVkLmJpbmQodGhpcykpXHJcbiAgICAgIHRoaXMudG9waWNDYWxsYmFjayA9IGNhbGxiYWNrXHJcbiAgICAgIHRoaXMub3B0cyA9IG9wdHNcclxuICAgICAgdGhpcy5zdW1tYXJpZXMgPSB7fVxyXG4gICAgICB0aGlzLnJlc3VsdHNDYWxsYmFjayA9IHJlc3VsdHNDYWxsYmFja1xyXG4gICAgICB0aGlzLmdldFJlc3VsdHMoKVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZmlsdGVyKCkge1xyXG4gICAgbGV0IHRlcm1zID0gdGhpcy5xdWVyeS5leGF4Y3RUZXJtc1xyXG4gICAgdGhpcy5yZXN1bHRzID0gXy5maWx0ZXIodGhpcy5yZXN1bHRzLCAocmVzdWx0KSA9PiB7XHJcbiAgICAgIGxldCB0b3BpY1RleHQgPSB0aGlzLnJlc3VsdHNNZXRhZGF0YVtyZXN1bHQuaWRdLnRvcGljVGV4dFxyXG4gICAgICByZXR1cm4gdGhpcy5tYXRjaGVzRXhhY3QodGVybXMsIHRvcGljVGV4dCwgcmVzdWx0LmlkKVxyXG4gICAgfSlcclxuICAgIHRoaXMucmVzdWx0c0NhbGxiYWNrKHRoaXMucXVlcnkudGV4dCwgdGhpcy5yZXN1bHRzLCB0aGlzLmdsb3NzYXJ5UmVzdWx0KVxyXG4gICAgdGhpcy5wcm9jZXNzU3VtbWFyeSgpXHJcbiAgfVxyXG5cclxuICBwcm9jZXNzU3VtbWFyeSgpe1xyXG4gICAgXy5lYWNoKHRoaXMucmVzdWx0cywgcmVzdWx0ID0+IHtcclxuICAgICAgbGV0IGlkID0gcmVzdWx0LmlkXHJcbiAgICAgIHRoaXMudG9waWNDYWxsYmFjayh0aGlzLmxvYWRlci5nZXRJZChpZCksIHRoaXMuc3VtbWFyaWVzW2lkXSwgdGhpcy5jcmVhdGVVcmwoaWQsIHRoaXMucXVlcnkuZXhheGN0VGVybXMpKSBcclxuICAgIH0pXHJcbiAgfVxyXG5cclxuICBtYXRjaGVzRXhhY3QodGVybXMsIHRleHQsIGlkKSB7XHJcbiAgICBsZXQgZm91bmQgPSBmYWxzZVxyXG4gICAgXy5lYWNoKHRlcm1zLCB0ZXJtID0+IHtcclxuICAgICAgbGV0IGlkeCA9IHRleHQudG9Mb3dlckNhc2UoKS5pbmRleE9mKHRlcm0pXHJcbiAgICAgIGlmIChpZHggIT09IC0xKSB7XHJcbiAgICAgICAgdGhpcy5hZGRTdW1tYXJ5KGlkLCB0ZXh0LCBpZHgsIHRlcm0pXHJcbiAgICAgICAgZm91bmQgPSB0cnVlXHJcbiAgICAgIH1cclxuICAgIH0pXHJcbiAgICByZXR1cm4gZm91bmRcclxuICB9XHJcbiAgXHJcbiAgYWRkU3VtbWFyeShpZCwgdGV4dCwgaWR4LCB0ZXJtKSB7XHJcbiAgICBsZXQgc3VtbWFyeSA9ICB0aGlzLm1ldGFkYXRhLmdldFRvcGljU3VtbWFyeShpZClcclxuICAgIGlmICh0aGlzLm1ldGFkYXRhLmNvbnRleHQgJiYgc3VtbWFyeSkge1xyXG4gICAgICB0aGlzLnN1bW1hcmllc1tpZF0gPSBzdW1tYXJ5XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgbGV0IHN1bW1hcnlFeHRyYWN0b3IgPSBuZXcgU3VtbWFyeSh0aGlzLm1ldGFkYXRhLnRvcGljRGF0YSwgdGhpcy5tZXRhZGF0YS5jb250ZXh0LCB0aGlzLm1ldGFkYXRhLmNvbnRleHRMaW1pdCkgICAgICBcclxuICAgICAgdGhpcy5zdW1tYXJpZXNbaWRdID0gc3VtbWFyeUV4dHJhY3Rvci5nZXRTdW1tYXJ5VGV4dCh0ZXh0LCBpZHgsIHRlcm0ubGVuZ3RoLCB0ZXJtKVxyXG4gICAgfVxyXG4gIH1cclxuICBcclxuICBnZXRSZXN1bHRzKCkge1xyXG4gICAgaWYgKCF0aGlzLmluaXQpIHtcclxuICAgICAgdGhpcy53YWl0aW5nID0gdHJ1ZVxyXG4gICAgICByZXR1cm5cclxuICAgIH1cclxuICAgIHRoaXMucXVlcnkgPSB0aGlzLmJ1aWxkUXVlcnkodGhpcy50ZXh0LCBfLmV4dGVuZCh0aGlzLm9wdHMsIHsgc2VhcmNoU3Vic3RyaW5nczogdGhpcy5zZWFyY2hTdWJzdHJpbmdzIH0pKVxyXG4gICAgdGhpcy5leGFjdFNlYXJjaCA9IHRoaXMucXVlcnkuZXhhY3RNYXRjaFxyXG4gICAgdGhpcy5nbG9zc2FyeVJlc3VsdCA9IHRoaXMuc2VhcmNoR2xvc3NhcnkodGhpcy50ZXh0KVxyXG4gICAgdGhpcy5yZXN1bHRzID0gdGhpcy5wcm9jZXNzKClcclxuICAgIGlmICh0aGlzLm5lZWRzQ29ycmVjdGlvbikge1xyXG4gICAgICB0aGlzLmRvQ29ycmVjdGlvbigpICAgIFxyXG4gICAgfVxyXG5cclxuICAgIGlmICghdGhpcy5leGFjdFNlYXJjaCB8fCB0aGlzLnJlc3VsdHMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgIHRoaXMucmVzdWx0c0NhbGxiYWNrKHRoaXMucXVlcnkudGV4dCwgdGhpcy5yZXN1bHRzLCB0aGlzLmdsb3NzYXJ5UmVzdWx0KVxyXG4gICAgfVxyXG4gIH1cclxuICBcclxuICBnZXQgbmVlZHNDb3JyZWN0aW9uICgpIHtcclxuICAgIHJldHVybiB0aGlzLnJlc3VsdHMubGVuZ3RoID09PSAwXHJcbiAgICAgICYmICB0aGlzLm1ldGFkYXRhLnNldHRpbmdzLmZ1enp5XHJcbiAgICAgICYmICF0aGlzLnF1ZXJ5LmV4YWN0TWF0Y2hcclxuICB9XHJcblxyXG4gIGRvQ29ycmVjdGlvbigpe1xyXG4gICAgdGhpcy5xdWVyeSA9IHRoaXMuYnVpbGRRdWVyeSh0aGlzLnF1ZXJ5LnRleHQsIF8uZXh0ZW5kKHRoaXMub3B0cywgeyBmdXp6eTogdHJ1ZSB9KSlcclxuICAgIHRoaXMucmVzdWx0cyA9IHRoaXMucHJvY2VzcygpXHJcbiAgfVxyXG4gIFxyXG4gIHNlYXJjaEdsb3NzYXJ5KCkge1xyXG4gICAgcmV0dXJuIHRoaXMucHJvY2Vzc0dsb3NzYXJ5KClcclxuICB9XHJcblxyXG4gIGJ1aWxkUXVlcnkodGV4dCwgb3B0cyl7XHJcbiAgICByZXR1cm4gbmV3IFF1ZXJ5KHRleHQsICB0aGlzLm1ldGFkYXRhLnNldHRpbmdzLCBvcHRzLCB0aGlzLmZpbHRlckl0ZW0uYmluZCh0aGlzKSlcclxuICB9XHJcbiAgXHJcbiAgcHJvY2VzcygpIHtcclxuICAgIHRoaXMucmVzdWx0c01ldGFkYXRhID0ge31cclxuICAgIGxldCBzZWFyY2hSZXN1bHRzID0gdGhpcy5kYi5zZWFyY2godGhpcy5xdWVyeSlcclxuICAgIHRoaXMuc2VhbWFwaG9yZS53YWl0KHNlYXJjaFJlc3VsdHMubGVuZ3RoKVxyXG4gICAgXy5lYWNoKChzZWFyY2hSZXN1bHRzKSwgKHJlc3VsdCkgPT4ge1xyXG4gICAgICBsZXQgdG9waWNEYXRhID0gdGhpcy5tZXRhZGF0YS5nZXRUb3BpY0RhdGEocmVzdWx0LnJlZilcclxuICAgICAgdGhpcy5yZXN1bHRzTWV0YWRhdGFbcmVzdWx0LnJlZl0gPSByZXN1bHQubWF0Y2hEYXRhLm1ldGFkYXRhXHJcbiAgICAgIHRoaXMubG9hZGVyLmxvYWRUZXh0RGF0YSh0aGlzLnF1ZXJ5LCByZXN1bHQucmVmLCB0aGlzLnByb2Nlc3NUb3BpY0RhdGEuYmluZCh0aGlzKSlcclxuICAgICAgXy5leHRlbmQocmVzdWx0LCB0b3BpY0RhdGEpXHJcbiAgICAgIHJlc3VsdC5pZCA9IHJlc3VsdC5yZWZcclxuICAgICAgcmVzdWx0LnJlZiA9IHRoaXMubG9hZGVyLmdldElkKHJlc3VsdC5yZWYpXHJcbiAgICB9KVxyXG4gICAgcmV0dXJuIHNlYXJjaFJlc3VsdHNcclxuICB9XHJcbiAgcHJvY2Vzc0dsb3NzYXJ5KCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZGIuc2VhcmNoR2xvc3NhcnkodGhpcy50ZXh0KVxyXG4gIH1cclxuXHJcbiAgcHJvY2Vzc1RvcGljRGF0YShxdWVyeSwgaWQsIGRhdGEpIHtcclxuICAgIGlmICghdGhpcy5xdWVyeS5pc0VxdWFsKHF1ZXJ5KSkge1xyXG4gICAgICByZXR1cm5cclxuICAgIH1cclxuICAgIGxldCBtYXRjaFJlc3VsdCA9IHRoaXMucmVzdWx0c01ldGFkYXRhW2lkXVxyXG4gICAgaWYgKG1hdGNoUmVzdWx0KSB7XHJcbiAgICAgIGxldCB3b3JkbGlzdCA9IFtdXHJcbiAgICAgIGxldCBzdW1tYXJ5RXh0cmFjdG9yID0gbmV3IFN1bW1hcnkodGhpcy5tZXRhZGF0YS50b3BpY0RhdGEsIHRoaXMubWV0YWRhdGEuY29udGV4dCwgdGhpcy5tZXRhZGF0YS5jb250ZXh0TGltaXQpXHJcbiAgICAgIGxldCBzdW1tYXJ5ID0gc3VtbWFyeUV4dHJhY3Rvci5nZXRTdW1tYXJ5KGlkLCBtYXRjaFJlc3VsdCwgd29yZGxpc3QsIGRhdGEpXHJcbiAgICAgIHN1bW1hcnkgPSBzdW1tYXJ5LnJlcGxhY2UoL1xcdCsvZ2ksICcgJykudHJpbSgpXHJcbiAgICAgIHRoaXMucmVzdWx0c01ldGFkYXRhW2lkXS50b3BpY1RleHQgPSB0aGlzLmNyZWF0ZVRleHQoaWQsIGRhdGEpXHJcbiAgICAgIGlmKCF0aGlzLmV4YWN0U2VhcmNoKSB7XHJcbiAgICAgICAgdGhpcy50b3BpY0NhbGxiYWNrKHRoaXMuZ2V0SWQoaWQpLCBzdW1tYXJ5LCB0aGlzLmNyZWF0ZVVybChpZCwgd29yZGxpc3QpKVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICB0aGlzLnNlYW1hcGhvcmUuc2lnbmFsKClcclxuICB9XHJcblxyXG4gIGNyZWF0ZVRleHQodG9waWNJZCwgdGV4dHMpIHtcclxuICAgIGxldCBuZXh0VGV4dHMgPSB0aGlzLm1ldGFkYXRhLmdldFRvcGljTmV4dElkKHRvcGljSWQpXHJcbiAgICBsZXQgbWVyZ2VyID0gbmV3IFRleHRNZXJnZXIobmV4dFRleHRzLCB0ZXh0cywgdGhpcy5maWx0ZXJJZC5iaW5kKHRoaXMpKVxyXG4gICAgcmV0dXJuIG1lcmdlci5nZXRUZXh0KClcclxuICB9XHJcblxyXG4gIGZpbHRlcklkKGlkKXtcclxuICAgIGxldCBmaWVsZHMgPSB0aGlzLm1ldGFkYXRhLmZpZWxkc1xyXG4gICAgbGV0IGZpZWxkSXRlbSA9IGZpZWxkc1tpZF1cclxuICAgIHJldHVybiB0aGlzLmZpbHRlckl0ZW0oZmllbGRJdGVtKSAgXHJcbiAgfVxyXG4gIFxyXG4gIGZpbHRlckl0ZW0oZmllbGRJdGVtKSB7XHJcbiAgICBsZXQgZmllbGRzID0gdGhpcy5tZXRhZGF0YS5maWVsZHNcclxuICAgIGxldCBmaWx0ZXIgPSBuZXcgQ2J0RmlsdGVyKGZpZWxkcywgdGhpcy5vcHRzLm9yaWdpbiwgdGhpcy5vcHRzLmNidClcclxuICAgIHJldHVybiBmaWVsZEl0ZW0gJiYgZmlsdGVyLmZpbHRlcihmaWVsZEl0ZW0pXHJcbiAgfVxyXG4gIFxyXG4gIGdldElkKGlkKSB7XHJcbiAgICByZXR1cm4gdGhpcy5sb2FkZXIuZ2V0SWQoaWQpXHJcbiAgfVxyXG5cclxuICBjcmVhdGVVcmwoaWQsIHdvcmRsaXN0KSB7XHJcbiAgICBsZXQgZGF0YSA9IHRoaXMubWV0YWRhdGEuZ2V0VG9waWNEYXRhKGlkKVxyXG4gICAgbGV0IHVybFBhcmFtID0ge1xyXG4gICAgICByaHNlYXJjaDogdGhpcy5xdWVyeS5vcmlnaW5hbFRleHRcclxuICAgIH1cclxuICAgIGlmKGdsb2JhbC5nYkhpZ2hMaWdodCl7XHJcbiAgICAgIGxldCBobFRlcm0gPSB0aGlzLmV4YWN0U2VhcmNoID8gYFwiJHt3b3JkbGlzdFswXX1cImAgOiAod29yZGxpc3R8fFtdKS5qb2luKCcgJylcclxuICAgICAgdXJsUGFyYW0ucmhobHRlcm0gPSBobFRlcm1cclxuICAgIH1cclxuICAgIGlmIChkYXRhKSB7XHJcbiAgICAgIGxldCByZXN1bHRzUGFyYW1zID0gJz8nICsgXy5tYXBUb0VuY29kZWRTdHJpbmcodXJsUGFyYW0pXHJcbiAgICAgIHJldHVybiBgJHt0aGlzLmxvYWRlci5nZXRVcmwoZGF0YS5yZWxVcmwpfSR7cmVzdWx0c1BhcmFtc31gXHJcbiAgICB9XHJcbiAgfVxyXG5cclxufVxyXG4iLCJjb25zdCByaCA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi8uLi9saWIvcmhcIilcclxuY29uc3QgXyA9IHJoLl9cclxuY29uc3QgQ2J0RmlsdGVyID0gcmVxdWlyZShcIi4vY2J0XCIpXHJcbmNvbnN0IGx1bnIgPSByZXF1aXJlKFwibHVuclwiKVxyXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIFNlYXJjaFF1ZXJ5IHtcclxuICBjb25zdHJ1Y3Rvcih0ZXh0LCBzZXR0aW5ncywgb3B0cykge1xyXG4gICAgdGhpcy5vcmlnaW5hbFRleHQgPSB0ZXh0LnRyaW0oKVxyXG4gICAgdGhpcy50ZXh0ID0gdGhpcy5vcmlnaW5hbFRleHQudG9Mb3dlckNhc2UoKVxyXG4gICAgdGhpcy5zZXR0aW5ncyA9IHNldHRpbmdzIHx8IHt9XHJcbiAgICB0aGlzLm9wdHMgPSBvcHRzIHx8IHt9XHJcbiAgICB0aGlzLm9wdHMuZ2JIaWdoTGlnaHQgPSBnbG9iYWwuZ2JIaWdoTGlnaHRcclxuICAgIHRoaXMuY2hlY2tFeGFjdE1hdGNoKClcclxuICB9XHJcbiAgZmlsdGVyKGl0ZW1MaXN0KSB7XHJcbiAgICBsZXQgZmlsdGVyID0gbmV3IENidEZpbHRlcih0aGlzLnNldHRpbmdzLmZpZWxkcywgdGhpcy5vcHRzLm9yaWdpbiwgdGhpcy5vcHRzLmNidClcclxuICAgIHJldHVybiBmaWx0ZXIuZmlsdGVyKGl0ZW1MaXN0KVxyXG4gIH1cclxuICBnZXRQYXJhbXMoaXNTdG9wV29yZEZuKSB7XHJcbiAgICB0aGlzLmlzU3RvcFdvcmQgPSBpc1N0b3BXb3JkRm5cclxuICAgIHJldHVybiB0aGlzLmZpZWxkc1BhcmFtXHJcbiAgfVxyXG5cclxuICBpc0VxdWFsKG90aGVyKSB7XHJcbiAgICBpZiAodGhpcy50ZXh0ICE9PSBvdGhlci50ZXh0IHx8IHRoaXMuX2JFeGFjdE1hdGNoICE9PSBvdGhlci5fYkV4YWN0TWF0Y2gpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlXHJcbiAgICB9XHJcbiAgICByZXR1cm4gXy5pc0VxdWFsKHRoaXMub3B0cywgb3RoZXIub3B0cylcclxuICB9XHJcbiAgZ2V0RnV6enlMZW5ndGgodG9rZW4pIHtcclxuICAgIHJldHVybiBfLm1heChbMCwgTWF0aC5mbG9vcihNYXRoLmxvZzIodG9rZW4ubGVuZ3RoKSAtIDEpXSlcclxuICB9XHJcbiAgLy8gZ2V0UXVlcnlUZXh0KGlkLCB0b2tlbiwgYm9vc3QpIHtcclxuICAvLyAgIGlmICh0aGlzLmlzU3RvcFdvcmQodG9rZW4pKSB7XHJcbiAgLy8gICAgIHJldHVybiAnJ1xyXG4gIC8vICAgfVxyXG4gIC8vICAgZWxzZSBpZiAodGhpcy5vcHRzLmZ1enp5KSB7XHJcbiAgLy8gICAgIHJldHVybiBgJHtpZH06JHt0b2tlbn1+JHt0aGlzLmdldEZ1enp5TGVuZ3RoKHRva2VuKX1eJHtib29zdH1gXHJcbiAgLy8gICB9XHJcbiAgLy8gICBlbHNlIGlmICh0aGlzLm9wdHMuc2VhcmNoU3Vic3RyaW5ncyAmJiAhdGhpcy5fYkV4YWN0TWF0Y2gpXHJcbiAgLy8gICB7XHJcbiAgLy8gICAgIHJldHVybiBgJHtpZH06JHt0b2tlbn1eJHtib29zdH0gJHtpZH06KiR7dG9rZW59Kl4ke01hdGgucm91bmQoTWF0aC5zcXJ0KGJvb3N0KSl9YFxyXG4gIC8vICAgfVxyXG4gIC8vICAgZWxzZSB7XHJcbiAgLy8gICAgIHJldHVybiBgJHtpZH06JHt0b2tlbn1eJHtib29zdH1gXHJcbiAgLy8gICB9XHJcbiAgLy8gfVxyXG4gIGdldFF1ZXJ5QXJyKGlkLCB0b2tlbiwgYm9vc3QpIHtcclxuICAgIGlmICh0aGlzLmlzU3RvcFdvcmQodG9rZW4pKSB7XHJcbiAgICAgIHJldHVybiBbXVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodGhpcy5vcHRzLmZ1enp5KSB7XHJcbiAgICAgIHJldHVybiBbeyBuYW1lOiB0b2tlbiwgZmllbGRzOiBbaWRdLCBlZGl0RGlzdGFuY2U6IHRoaXMuZ2V0RnV6enlMZW5ndGgodG9rZW4pLCBib29zdCB9XVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodGhpcy5vcHRzLnNlYXJjaFN1YnN0cmluZ3MgJiYgIXRoaXMuX2JFeGFjdE1hdGNoKSB7XHJcbiAgICAgIHJldHVybiBbeyBuYW1lOiB0b2tlbiwgZmllbGRzOiBbaWRdLCBib29zdCB9LFxyXG4gICAgICB7IG5hbWU6IHRva2VuLCBmaWVsZHM6IFtpZF0sIGJvb3N0OiBNYXRoLnJvdW5kKE1hdGguc3FydChib29zdCkpLCB3aWxkY2FyZDogbHVuci5RdWVyeS53aWxkY2FyZC5MRUFESU5HIHwgbHVuci5RdWVyeS53aWxkY2FyZC5UUkFJTElORyB9XVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgIHJldHVybiBbeyBuYW1lOiB0b2tlbiwgZmllbGRzOiBbaWRdLCBib29zdCB9XVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgY2hlY2tFeGFjdE1hdGNoKCkge1xyXG4gICAgaWYgKHRoaXMuX2lzRXhhY3RNYXRjaCkge1xyXG4gICAgICB0aGlzLl9iRXhhY3RNYXRjaCA9IHRydWVcclxuICAgICAgdGhpcy50ZXh0ID0gdGhpcy50ZXh0LnN1YnN0cmluZygxLCB0aGlzLnRleHQubGVuZ3RoIC0gMSlcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGdldCBfaXNFeGFjdE1hdGNoKCkge1xyXG4gICAgcmV0dXJuICh0aGlzLnRleHQubGVuZ3RoID4gMilcclxuICAgICAgJiYgdGhpcy5xdW90ZXNDaGFyLmluZGV4T2YodGhpcy50ZXh0WzBdKSAhPT0gLTFcclxuICAgICAgJiYgdGhpcy5xdW90ZXNDaGFyLmluZGV4T2YodGhpcy50ZXh0W3RoaXMudGV4dC5sZW5ndGggLSAxXSkgIT09IC0xXHJcbiAgfVxyXG5cclxuICBnZXQgZXhhY3RNYXRjaCgpIHtcclxuICAgIHJldHVybiB0aGlzLl9iRXhhY3RNYXRjaFxyXG4gIH1cclxuXHJcbiAgZ2V0IGV4YXhjdFRlcm1zKCkge1xyXG4gICAgcmV0dXJuIFt0aGlzLnRleHRdXHJcbiAgfVxyXG5cclxuICBnZXQgcXVvdGVzQ2hhcigpIHtcclxuICAgIHJldHVybiBbXCJcXFwiXCIsIFwiXFwnXCJdXHJcbiAgfVxyXG4gIGdldEZpZWxkQm9vc3QoZmllbGQpIHtcclxuICAgIHJldHVybiBfLnJlZHVjZShmaWVsZCwgKG1heCwgcnVsZSkgPT4ge1xyXG4gICAgICByZXR1cm4gKHJ1bGUgJiYgcnVsZS5ib29zdCAmJiBydWxlLmJvb3N0ID4gbWF4KSA/IHJ1bGUuYm9vc3QgOiBtYXhcclxuICAgIH0sIDEpXHJcbiAgfVxyXG5cclxuICBnZXQgZmllbGRzUGFyYW0oKSB7XHJcbiAgICBsZXQgZmllbGRxdWVyaWVzID0gW11cclxuICAgIGxldCB0b2tlbnMgPSBfLmZpbHRlcihfLm1hcChsdW5yLnRva2VuaXplcih0aGlzLnRleHQpLCB0b2tlbiA9PiB0b2tlbi5zdHIpLCBzdHIgPT4gIV8uaXNFbXB0eVN0cmluZyhzdHIudHJpbSgpKSlcclxuICAgIF8uZWFjaCh0b2tlbnMsIHRva2VuID0+IHtcclxuICAgICAgbGV0IHFBcnIgPSBbXVxyXG4gICAgICBfLmVhY2godGhpcy5zZXR0aW5ncy5maWVsZHMsIChpdGVtLCBpZCkgPT4ge1xyXG4gICAgICAgIGlmICghdGhpcy5maWx0ZXIoaXRlbSkpIHtcclxuICAgICAgICAgIGxldCBib29zdCA9IHRoaXMuZ2V0RmllbGRCb29zdChpdGVtKVxyXG4gICAgICAgICAgLy8gcVRleHQgPSBgJHtxVGV4dH0gJHt0aGlzLmdldFF1ZXJ5VGV4dChpZCwgdG9rZW4sIGJvb3N0KX1gXHJcbiAgICAgICAgICBxQXJyID0gcUFyci5jb25jYXQodGhpcy5nZXRRdWVyeUFycihpZCwgdG9rZW4sIGJvb3N0KSlcclxuICAgICAgICB9XHJcbiAgICAgIH0pXHJcbiAgICAgIGZpZWxkcXVlcmllcy5wdXNoKHFBcnIpXHJcbiAgICB9KVxyXG4gICAgcmV0dXJuIGZpZWxkcXVlcmllc1xyXG4gIH1cclxufVxyXG4iLCJjb25zdCByaCA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi8uLi9saWIvcmhcIilcclxuY29uc3QgVGV4dE1lcmdlciA9IHJlcXVpcmUoJy4uL3RleHRfbWVyZ2VyJylcclxuY29uc3QgXyA9IHJoLl9cclxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBTZWFyY2hTdW1tYXJ5IHtcclxuICBjb25zdHJ1Y3Rvcih0b3BpY0RhdGEsIGNvbnRleHQsY29udGV4dExpbWl0KSB7XHJcbiAgICB0aGlzLnRvcGljRGF0YSA9IHRvcGljRGF0YVxyXG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dFxyXG4gICAgdGhpcy5jb250ZXh0TGltaXQgPSBOdW1iZXIucGFyc2VJbnQoY29udGV4dExpbWl0KVxyXG4gICAgdGhpcy5yaWdodExpbWl0ID0gTWF0aC5jZWlsKCg3MCAqIHRoaXMuY29udGV4dExpbWl0KSAvIDEwMClcclxuICAgIHRoaXMubGVmdExpbWl0ID0gTWF0aC5jZWlsKCgzMCAqIHRoaXMuY29udGV4dExpbWl0KSAvIDEwMClcclxuICB9XHJcbiAgbWluRGlzdGFuY2UoKSB7XHJcbiAgICAvL18uZWFjaCgpXHJcbiAgfVxyXG5cclxuICBnZXRTdW1tYXJ5KGlkLCBtYXRjaFJlc3VsdCwgd29yZGxpc3QsIGRhdGEpIHtcclxuICAgIGxldCBzdW1tYXJpZXMgPSBbXVxyXG4gICAgbGV0IHN1bW1hcnkgPSAnJ1xyXG4gICAgaWYgKHRoaXMuY29udGV4dCkge1xyXG4gICAgICBzdW1tYXJ5ID0gdGhpcy50b3BpY0RhdGFbaWRdICYmICh0aGlzLnRvcGljRGF0YVtpZF0uc3VtbWFyeSB8fCBcIlwiKS5zdWJzdHJpbmcoMCwgdGhpcy5jb250ZXh0TGltaXQpXHJcbiAgICB9XHJcbiAgICB0cnl7XHJcbiAgICAgIHN1bW1hcmllcyA9IF8ubWFwKG1hdGNoUmVzdWx0LCAobWV0YWRhdGEpID0+IHtcclxuICAgICAgXHJcbiAgICAgICAgcmV0dXJuIF8udW5pb24obWV0YWRhdGEsIChwb3NEYXRhLCBmaWVsZElkKSA9PiB7XHJcbiAgICAgICAgICBpZighcG9zRGF0YSB8fCAhcG9zRGF0YS5wb3NpdGlvbiB8fCAhcG9zRGF0YS5wb3NpdGlvblswXSl7XHJcbiAgICAgICAgICAgIGxldCB0ZXh0cyA9IGRhdGFbZmllbGRJZF1cclxuICAgICAgICAgICAgcmV0dXJuIF8ubWFwKHRleHRzLCB0ZXh0ID0+IHRoaXMudHJpbVJpZ2h0KHRleHQpKSAgXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBlbHNle1xyXG4gICAgICAgICAgICByZXR1cm4gXy51bmlvbihwb3NEYXRhLnBvc2l0aW9uLCAoZmlzdHJQb3MpID0+IHtcclxuICAgICAgICAgICAgICBpZihmaXN0clBvc1swXSAhPT0gdW5kZWZpbmVkICYmIGZpc3RyUG9zWzFdICE9PSB1bmRlZmluZWQpe1xyXG4gICAgICAgICAgICAgICAgbGV0IHRleHRzID0gZGF0YVtmaWVsZElkXVxyXG4gICAgICAgICAgICAgICAgbGV0IG1lcmdlciA9IG5ldyBUZXh0TWVyZ2VyKClcclxuICAgICAgICAgICAgICAgIGxldCB0ZXh0ID0gbWVyZ2VyLmdldEluZGV4VGV4dCh0ZXh0cylcclxuICAgICAgICAgICAgICAgIGxldCB3b3JkID0gdGV4dC5zdWJzdHJpbmcoZmlzdHJQb3NbMF0sIGZpc3RyUG9zWzBdICsgZmlzdHJQb3NbMV0pXHJcbiAgICAgICAgICAgICAgICB3b3JkID0gd29yZC50b0xvd2VyQ2FzZSgpXHJcbiAgICAgICAgICAgICAgICBpZiAod29yZGxpc3QuaW5kZXhPZih3b3JkKSA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgd29yZGxpc3QucHVzaCh3b3JkKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U3VtbWFyeVRleHQodGV4dCwgZmlzdHJQb3NbMF0sIGZpc3RyUG9zWzFdLCB3b3JkKVxyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KVxyXG4gICAgICB9KVxyXG4gICAgICBpZighdGhpcy5jb250ZXh0IHx8ICFzdW1tYXJ5IHx8IHN1bW1hcnkgPT09ICcnKXtcclxuICAgICAgICBfLmVhY2goc3VtbWFyaWVzWzBdIHx8IFtdLCBzID0+IHtcclxuICAgICAgICAgIGlmIChzLmxlbmd0aCA+IHN1bW1hcnkubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHN1bW1hcnkgPSBzXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgY2F0Y2goZSl7XHJcbiAgICAgIHN1bW1hcnkgPSAnJ1xyXG4gICAgfVxyXG4gICAgaWYoc3VtbWFyeSA9PT0gJycpe1xyXG4gICAgICBzdW1tYXJ5ID0gdGhpcy5nZXREZWZhdWx0U3VtbWFyeShkYXRhKVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHN1bW1hcnlcclxuICB9XHJcblxyXG4gIGdldERlZmF1bHRTdW1tYXJ5KGRhdGEpe1xyXG4gICAgbGV0IHN1bW1hcnkgPSAnJ1xyXG4gICAgdHJ5e1xyXG4gICAgICBsZXQgdGV4dCA9ICcnXHJcbiAgICAgIF8uZWFjaChkYXRhLCAodmFsdWUsIGtleSkgPT57XHJcbiAgICAgICAgaWYoa2V5ICE9PSAnaWQnKXtcclxuICAgICAgICAgIHRleHQgPSB0ZXh0ICsgXCIgXCJcclxuICAgICAgICB9XHJcbiAgICAgIH0pIFxyXG4gICAgICBzdW1tYXJ5ID0gdGhpcy5nZXRTdW1tYXJ5VGV4dCh0ZXh0LCAwLCB0aGlzLmNvbnRleHRMaW1pdCB8fCAxMDAsICcnKVxyXG4gICAgfVxyXG4gICAgY2F0Y2goZSl7XHJcbiAgICAgIHN1bW1hcnkgPSAnJ1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHN1bW1hcnlcclxuICB9XHJcblxyXG4gIGdldFN1bW1hcnlUZXh0KHRleHQsIGlkeCwgbGVuZ3RoLCB3b3JkKXtcclxuICAgIGxldCBsZWZ0VGV4dCA9IHRleHQuc3Vic3RyaW5nKDAsIGlkeClcclxuICAgIGxldCByaWdodFRleHQgPSB0ZXh0LnN1YnN0cmluZyhpZHggKyBsZW5ndGgpXHJcblxyXG4gICAgcmV0dXJuIGAke3RoaXMudHJpbUxlZnQobGVmdFRleHQpfTxiPiR7d29yZH08L2I+XHJcbiAgICAgICAgICAgICAgJHt0aGlzLnRyaW1SaWdodChyaWdodFRleHQpfWBcclxuICB9XHJcbiAgdHJpbUxlZnQobGVmdFRleHQpIHtcclxuICAgIGxldCBsZWZ0SWR4ID0gbGVmdFRleHQuaW5kZXhPZihcIiBcIiwgbGVmdFRleHQubGVuZ3RoIC0gdGhpcy5sZWZ0TGltaXQpXHJcbiAgICBsZWZ0VGV4dCA9IGxlZnRUZXh0LnN1YnN0cmluZyhsZWZ0SWR4LCBsZWZ0VGV4dC5sZW5ndGgpXHJcbiAgICByZXR1cm4gbGVmdFRleHQudHJpbVN0YXJ0KClcclxuICB9XHJcbiAgdHJpbVJpZ2h0KHJpZ2h0VGV4dCkge1xyXG4gICAgbGV0IHJpZ2h0SWR4ID0gcmlnaHRUZXh0LmluZGV4T2YoXCIgXCIsIHRoaXMucmlnaHRMaW1pdClcclxuICAgIHJpZ2h0SWR4ID0gKHJpZ2h0SWR4ID09PSAtMSkgPyByaWdodFRleHQubGVuZ3RoIDogcmlnaHRJZHggXHJcbiAgICByaWdodFRleHQgPSByaWdodFRleHQuc3Vic3RyaW5nKDAsIHJpZ2h0SWR4KVxyXG4gICAgcmV0dXJuIHJpZ2h0VGV4dC50cmltRW5kKClcclxuICB9XHJcbn0iLCJpbXBvcnQgc2VhcmNoX3V0aWxzIGZyb20gJy4uL3N1Z2dlc3Rpb24vdXRpbHMnXHJcbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgU2VhcmNoUmVzdWx0e1xyXG4gIGNvbnN0cnVjdG9yKHJlc3VsdCkge1xyXG4gICAgdGhpcy5mUmFua2luZyA9IHJlc3VsdC5zY29yZVxyXG4gICAgdGhpcy5uSW5kZXggPSAxXHJcbiAgICB0aGlzLnN0clN1bW1hcnkgPSBgLnAuc2VhcmNoc3VtbWFyeSR7cmVzdWx0LnJlZn1gXHJcbiAgICB0aGlzLnN0clRpdGxlID0gcmVzdWx0LnRpdGxlXHJcbiAgICB0aGlzLnN0clVybCA9IGAucC5zZWFyY2h1cmwke3Jlc3VsdC5yZWZ9YFxyXG4gICAgdGhpcy5zdHJCcmVhZGNydW1icyA9IHJlc3VsdC5yZWxVcmxcclxuICB9XHJcbiAgbWVyZ2UobmV3X2l0ZW0pIHtcclxuICAgIHRoaXMuZlJhbmtpbmcgKz0gbmV3X2l0ZW0uZlJhbmtpbmc7XHJcbiAgfVxyXG4gIGNvbXBhcmUob3RoZXIpIHtcclxuICAgIHJldHVybiBvdGhlci5mUmFua2luZyAtIHRoaXMuZlJhbmtpbmdcclxuICB9XHJcbiAgbWF0Y2gob3RoZXIpIHtcclxuICAgIHJldHVybiBzZWFyY2hfdXRpbHMuY29tcGFyZU5vQ2FzZShvdGhlci5zdHJVcmwsIHRoaXMuc3RyVXJsKSA9PT0gMDtcclxuICB9XHJcbn0iLCJjb25zdCByaCA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi9saWIvcmhcIilcclxuY29uc3QgXyA9IHJoLl9cclxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBTZWFyY2hUZXh0TWVyZ2VyIHtcclxuICBjb25zdHJ1Y3RvcihuZXh0VGV4dHMsIHRleHRzLCBmaWx0ZXIpIHtcclxuICAgIHRoaXMubmV4dFRleHRzID0gbmV4dFRleHRzXHJcbiAgICB0aGlzLnRleHRzID0gdGV4dHNcclxuICAgIHRoaXMuZmlsdGVyID0gZmlsdGVyIHx8IHRoaXMuZGVmYXVsdEZpbHRlclxyXG4gIH1cclxuICBqb2luKGlkLCBzdGFydCwgZW5kKSB7XHJcbiAgICBsZXQgdGV4dHMgPSBbXVxyXG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDw9IGVuZDsgaSsrKXtcclxuICAgICAgaWYgKHRoaXMudGV4dHNbaWRdW2ldKSB7XHJcbiAgICAgICAgdGV4dHMucHVzaCh0aGlzLnRleHRzW2lkXVtpXSlcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRleHRzLmpvaW4oXCJcIikucmVwbGFjZSgvW1xcbiBdKy9nLCAnICcpLnJlcGxhY2UoL1xcdTAwQTAvZ2ksIFwiIFwiKVxyXG4gIH1cclxuICBkZWZhdWx0RmlsdGVyKCkge1xyXG4gICAgcmV0dXJuIGZhbHNlXHJcbiAgfVxyXG4gIGdldEluZGV4VGV4dCh0ZXh0cykge1xyXG4gICAgcmV0dXJuIHRleHRzLmpvaW4oXCIgXCIpLnJlcGxhY2UoL1xcbi9naSwgXCIgXCIpLnRyaW0oKVxyXG4gIH1cclxuICBnZXRUZXh0KCkge1xyXG4gICAgbGV0IHRleHRzID0gW11cclxuICAgIF8uZWFjaCh0aGlzLm5leHRUZXh0cywgaXRlbSA9PiB7XHJcbiAgICAgIGlmICghdGhpcy5maWx0ZXIoaXRlbVswXSkpIHtcclxuICAgICAgICB0ZXh0cy5wdXNoKHRoaXMuam9pbihpdGVtWzBdLCBpdGVtWzFdLCBpdGVtWzJdKSlcclxuICAgICAgfVxyXG4gICAgfSlcclxuICAgIHJldHVybiB0ZXh0cy5qb2luKFwiXCIpXHJcbiAgfVxyXG59IiwibGV0IHJoID0gcmVxdWlyZShcIi4uLy4uL2xpYi9yaFwiKVxyXG5sZXQgXyA9IHJoLl9cclxubGV0IGNvbnN0cyA9IHJoLmNvbnN0c1xyXG5jbGFzcyBTZWFyY2hSZXN1bHRDb250cm9sbGVyIHtcclxuXHJcbiAgY29uc3RydWN0b3Iod2lkZ2V0KSB7XHJcbiAgICB0aGlzLndpZGdldCA9IHdpZGdldFxyXG4gIH1cclxuXHJcbiAgZ2V0TGluayh1cmwpIHtcclxuICAgIGxldCBzZWFyY2hVcmwgPSB1cmwgXHJcbiAgICBsZXQgaGlnaGxpZ2h0UGFyYW0gPSB0aGlzLndpZGdldC5nZXQoY29uc3RzKCdLRVlfU0VBUkNIX1JFU1VMVF9QQVJBTVMnKSlcclxuICAgIGxldCBzZWFyY2hUZXJtID0gdGhpcy53aWRnZXQuZ2V0KGNvbnN0cygnS0VZX1NFQVJDSF9URVJNJykpIFxyXG4gICAgbGV0IHNlYXJjaFRlcm1QYXJhbSA9ICcnXHJcbiAgICBpZihzZWFyY2hUZXJtICYmICBzZWFyY2hUZXJtICE9PSAnJykge1xyXG4gICAgICBsZXQga2V5ID0gY29uc3RzKCdIQVNIX0tFWV9SSF9TRUFSQ0gnKVxyXG4gICAgICBsZXQgc2VhcmNoVGVybU1hcCA9IHt9O1xyXG4gICAgICBzZWFyY2hUZXJtTWFwW2tleV0gPSBzZWFyY2hUZXJtXHJcbiAgICAgIHNlYXJjaFRlcm1QYXJhbSA9IF8ubWFwVG9FbmNvZGVkU3RyaW5nKHNlYXJjaFRlcm1NYXApXHJcbiAgICB9XHJcbiAgICBpZihoaWdobGlnaHRQYXJhbSAhPT0gdW5kZWZpbmVkICYmIGhpZ2hsaWdodFBhcmFtICE9PSAnJyl7XHJcbiAgICAgIHNlYXJjaFVybCA9IHNlYXJjaFVybCArIGhpZ2hsaWdodFBhcmFtICsgJyYnICsgc2VhcmNoVGVybVBhcmFtIFxyXG4gICAgfVxyXG4gICAgZWxzZSBpZihzZWFyY2hUZXJtUGFyYW0gIT09ICcnKXtcclxuICAgICAgc2VhcmNoVXJsID0gc2VhcmNoVXJsICsgJz8nICsgc2VhcmNoVGVybVBhcmFtXHJcbiAgICB9IFxyXG4gICAgcmV0dXJuIHNlYXJjaFVybFxyXG4gIH1cclxufVxyXG5cclxucmguY29udHJvbGxlcignU2VhcmNoUmVzdWx0Q29udHJvbGxlcicsIFNlYXJjaFJlc3VsdENvbnRyb2xsZXIpIiwibGV0IHJoID0gcmVxdWlyZShcIi4uLy4uL2xpYi9yaFwiKVxyXG5sZXQgXyA9IHJoLl9cclxubGV0IGNvbnN0cyA9IHJoLmNvbnN0c1xyXG4vL2NvbnN0IEtFWV9BQ1RJVkVfQk9PS0lEID0gJ2FjdGl2ZV9ib29raWQnO1xyXG5cclxuY2xhc3MgVG9jQnJlYWRjcnVtYnNDb250cm9sbGVyIHtcclxuXHJcbiAgY29uc3RydWN0b3Iod2lkZ2V0KSB7XHJcbiAgICB0aGlzLndpZGdldCA9IHdpZGdldDtcclxuICAgIC8vdGhpcy53aWRnZXQubW9kZWwuc3Vic2NyaWJlKEtFWV9BQ1RJVkVfQk9PS0lELCB0aGlzLnVwZGF0ZUJyZWFkY3J1bWJzKVxyXG4gIH1cclxuICBzZWxlY3QoaWQsIHVybCl7XHJcbiAgICB0aGlzLndpZGdldC5wdWJsaXNoKGNvbnN0cygnS0VZX1RPQ19TRUxFQ1RfSVRFTScpLFxyXG4gICAgICB7J2lkJzogaWQgLCAndXJsJzogdXJsfSk7XHJcbiAgfVxyXG4gIGdldExpbmsoaWQpe1xyXG4gICAgaWYoaWQpe1xyXG4gICAgICBsZXQgYnJlYWRjcnVtYnMgPSB0aGlzLndpZGdldC5nZXQoY29uc3RzKCdLRVlfVE9DX0JSRUFEQ1JVTUJTJykpXHJcbiAgICAgIGxldCBpdGVtID0gYnJlYWRjcnVtYnNbaWRdXHJcbiAgICAgIGlmKGl0ZW0gJiYgaXRlbS5oYXNVcmwpe1xyXG4gICAgICAgIHJldHVybiBpdGVtLnVybFxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG4gIGdvVG9Ib21lKGluZGV4KXtcclxuICAgIGlmKGluZGV4KXtcclxuICAgICAgbGV0IGJyZWFkY3J1bWJzID0gdGhpcy53aWRnZXQuZ2V0KGNvbnN0cygnS0VZX1RPQ19CUkVBRENSVU1CUycpKVxyXG4gICAgICBsZXQgaXRlbSA9IGJyZWFkY3J1bWJzW2luZGV4XVxyXG4gICAgICBpZihpdGVtICYmICFpdGVtLmhhc1VybCl7XHJcbiAgICAgICAgXy5nb1RvSG9tZSh7cmh0b2NpZDogaXRlbS5pZH0pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5yaC5jb250cm9sbGVyKCdUb2NCcmVhZGNydW1ic0NvbnRyb2xsZXInLCBUb2NCcmVhZGNydW1ic0NvbnRyb2xsZXIpIiwibGV0IHJoID0gcmVxdWlyZShcIi4uLy4uLy4uL2xpYi9yaFwiKVxyXG5sZXQgJCA9IHJoLiQ7XHJcbmxldCBDQVJPVVNFTF9DSEFOR0UgPSAnY2hhbmdlJztcclxubGV0IENBUk9VU0VMX0lURU0gPSAnLmNhcm91c2VsLWl0ZW06bm90KC5oaWRlKTpub3QoLnJoLWhpZGUpJztcclxuXHJcbmNsYXNzIENhcm91c2VsIHtcclxuICBjb25zdHJ1Y3Rvcih3aWRnZXQsIG9wdHMpIHtcclxuICAgIHRoaXMud2lkZ2V0ID0gd2lkZ2V0O1xyXG4gICAgdGhpcy5ub2RlID0gdGhpcy53aWRnZXQubm9kZTtcclxuICAgIHRoaXMudGFiID0gMDtcclxuICAgIHJoLm1vZGVsLnN1YnNjcmliZU9uY2UocmguY29uc3RzKG9wdHMua2V5KSwgKCkgPT4ge1xyXG4gICAgICB0aGlzLndpZGdldC5wdWJsaXNoKENBUk9VU0VMX0NIQU5HRSwgdHJ1ZSk7XHJcbiAgICB9KTtcclxuICAgIHJoLm1vZGVsLnN1YnNjcmliZShyaC5jb25zdHMoJ0tFWV9TQ1JFRU4nKSwgKCkgPT4ge1xyXG4gICAgICB0aGlzLmdvdG8odGhpcy50YWIsIDApO1xyXG4gICAgfSk7XHJcbiAgICByaC5tb2RlbC5zdWJzY3JpYmUob3B0cy5rZXkrJ2dvdG90YWInLCAoYm9va0RhdGEpID0+IHtcclxuICAgICAgdGhpcy5nb3RvKHRoaXMucGFnZWNvdW50KCksIGJvb2tEYXRhLnRhYik7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIGdvdG8oZnJvbSwgdG8pIHtcclxuICAgIHRoaXMudGFiID0gdG87XHJcbiAgICB0aGlzLmNhcm91c2Vsbm9kZSA9ICQuZmluZCh0aGlzLm5vZGUsICcuY2Fyb3VzZWwnKVswXTtcclxuICAgIHRoaXMuYW5pbWF0ZUxlZnQoZnJvbSk7XHJcbiAgICByaC5fLmRlbGF5KCgpID0+IHtcclxuICAgICAgdGhpcy53aWRnZXQucHVibGlzaChDQVJPVVNFTF9DSEFOR0UsIHRydWUpO1xyXG4gICAgfSwgMTAwMCk7XHJcbiAgfVxyXG5cclxuICBoYXNOZXh0KCkge1xyXG4gICAgdGhpcy5jYXJvdXNlbG5vZGUgPSAkLmZpbmQodGhpcy5ub2RlLCAnLmNhcm91c2VsJylbMF07XHJcbiAgICBsZXQgbGFzdEl0ZW0gPSAkLmZpbmQoJC5maW5kKHRoaXMubm9kZSwgJy5jYXJvdXNlbCcpWzBdLCBDQVJPVVNFTF9JVEVNKTtcclxuICAgIGxhc3RJdGVtID0gKGxhc3RJdGVtICYmIGxhc3RJdGVtLmxlbmd0aCA+IDApPyBsYXN0SXRlbVtsYXN0SXRlbS5sZW5ndGggLSAxXSA6IG51bGw7XHJcbiAgICByZXR1cm4gbGFzdEl0ZW0ub2Zmc2V0TGVmdCArIHRoaXMuY2Fyb3VzZWxub2RlLm9mZnNldExlZnQgPiB0aGlzLmNhcm91c2Vsbm9kZS5vZmZzZXRXaWR0aDtcclxuICB9XHJcblxyXG4gIGFuaW1hdGVMZWZ0KCkge1xyXG4gICAgbGV0IGxlZnRWYWwgPSAnY2FsYygtJyArIHRoaXMudGFiKjE0ICsgJ3B4IC0gJyArIHRoaXMudGFiKjEwMCArICclKSdcclxuICAgICQuY3NzKHRoaXMuY2Fyb3VzZWxub2RlLCAnbGVmdCcsIGxlZnRWYWwpXHJcbiAgfVxyXG5cclxuICBuZXh0KCkge1xyXG4gICAgdGhpcy5nb3RvKHRoaXMudGFiLCB0aGlzLnRhYisxKTtcclxuICB9XHJcblxyXG4gIHBhZ2Vjb3VudCgpIHtcclxuICAgIHJldHVybiB0aGlzLnRhYjtcclxuICB9XHJcblxyXG4gIHByZXZpb3VzKCkge1xyXG4gICAgdGhpcy5nb3RvKHRoaXMudGFiLCB0aGlzLnRhYi0xKTtcclxuICB9XHJcblxyXG4gIGVuc3VyZVZpc2libGUoKSB7XHJcblxyXG4gIH1cclxufVxyXG5cclxucmguY29udHJvbGxlcignQ2Fyb3VzZWwnLCBDYXJvdXNlbCk7XHJcbiIsImxldCByaCA9IHJlcXVpcmUoXCIuLi8uLi9saWIvcmhcIilcclxubGV0ICQgPSByaC4kXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG5cclxuICBub2RlVHlwZToge1xyXG4gICAgRUxFTUVOVF9OT0RFOiAxLFxyXG4gICAgQVRUUklCVVRFX05PREU6IDIsXHJcbiAgICBURVhUX05PREU6IDMsXHJcbiAgICBDREFUQV9TRUNUSU9OX05PREU6IDQsXHJcbiAgICBFTlRJVFlfUkVGRVJFTkNFX05PREU6IDUsXHJcbiAgICBFTlRJVFlfTk9ERTogNixcclxuICAgIFBST0NFU1NJTkdfSU5TVFJVQ1RJT05fTk9ERTogNyxcclxuICAgIENPTU1FTlRfTk9ERTogOCxcclxuICAgIERPQ1VNRU5UX05PREU6IDksXHJcbiAgICBET0NVTUVOVF9UWVBFX05PREU6IDEwLFxyXG4gICAgRE9DVU1FTlRfRlJBR01FTlRfTk9ERTogMTEsXHJcbiAgICBOT1RBVElPTl9OT0RFOiAxMlxyXG4gIH0sXHJcblxyXG4gIHJlbW92ZUNoaWxkKG5vZGUsIHBhcmVudCA9IHRoaXMucGFyZW50Tm9kZShub2RlKSkge1xyXG4gICAgcmV0dXJuIHBhcmVudCAmJiBwYXJlbnQucmVtb3ZlQ2hpbGQgJiYgcGFyZW50LnJlbW92ZUNoaWxkKG5vZGUpXHJcbiAgfSxcclxuICBhcHBlbmRDaGlsZChwYXJlbnQsIG5ld05vZGUpIHtcclxuICAgIHJldHVybiBwYXJlbnQgJiYgcGFyZW50LmFwcGVuZENoaWxkICYmIHBhcmVudC5hcHBlbmRDaGlsZChuZXdOb2RlKVxyXG4gIH0sXHJcbiAgcGFyZW50Tm9kZShub2RlKSB7XHJcbiAgICByZXR1cm4gbm9kZSAmJiBub2RlLnBhcmVudE5vZGVcclxuICB9LFxyXG4gIGNoaWxkTm9kZXMobm9kZSkge1xyXG4gICAgcmV0dXJuIG5vZGUgJiYgbm9kZS5jaGlsZE5vZGVzIHx8IFtdXHJcbiAgfSxcclxuICB0b0h0bWxOb2RlKGh0bWwpIHtcclxuICAgIHJldHVybiB0aGlzLmNoaWxkTm9kZXMoJC5jcmVhdGVFbGVtZW50KCdkaXYnLCBodG1sKSlcclxuICB9LFxyXG4gIG91dGVySFRNTChub2RlKSB7XHJcbiAgICByZXR1cm4gbm9kZSAmJiBub2RlLm91dGVySFRNTCB8fCAnJ1xyXG4gIH0sXHJcbiAgaW5zZXJ0QWZ0ZXIobm9kZSwgbmV3Tm9kZSl7XHJcbiAgICByZXR1cm4gbm9kZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZShuZXdOb2RlLCBub2RlLm5leHRTaWJsaW5nKVxyXG4gIH0sXHJcbiAgdmFsdWUobm9kZSkge1xyXG4gICAgcmV0dXJuIG5vZGUgJiYgbm9kZS5ub2RlVmFsdWVcclxuICB9LFxyXG4gIG5hbWUobm9kZSkge1xyXG4gICAgcmV0dXJuIG5vZGUgJiYgbm9kZS5ub2RlTmFtZVxyXG4gIH0sXHJcbiAgdHlwZShub2RlKSB7XHJcbiAgICByZXR1cm4gbm9kZSAmJiBub2RlLm5vZGVUeXBlXHJcbiAgfSxcclxuICBpc0VsZW1lbnROb2RlKG5vZGUpIHtcclxuICAgIHJldHVybiB0aGlzLnR5cGUobm9kZSkgPT09IHRoaXMubm9kZVR5cGUuRUxFTUVOVF9OT0RFXHJcbiAgfSxcclxuICBpc1RleHROb2RlKG5vZGUpIHtcclxuICAgIHJldHVybiB0aGlzLnR5cGUobm9kZSkgPT09IHRoaXMubm9kZVR5cGUuVEVYVF9OT0RFXHJcbiAgfVxyXG59Il19
