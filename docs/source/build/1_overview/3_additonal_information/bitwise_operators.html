<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="keywords" content="online documentation, web online help, web help, chm2web" />
<meta http-equiv="Content-Style-Type" content="text/css" />
<meta http-equiv="content-type" content="text/html; charset=UTF-8">

<meta name="generator" content="chm2web Pro 2.85 (unicode)" />
<title>位运算和二进制</title>
<meta http-equiv="X-UA-Compatible" content="IE=9">

<link rel="stylesheet" href="../../../../files/helpindex.css" type=
"text/css">
<link rel="stylesheet" href="../../../../default.css" type=
"text/css">

<script type="text/JavaScript" src="../../../../files/supply.js"></script>
<script type="text/JavaScript">
chmtop.c2wtopf.pageid = "_build/1_overview/3_additonal_information/bitwise_operators.html";
</script>

</head>
<body><script type="text/JavaScript"> 
if (window.name != "content") 
  document.write(" <table width=\"100%\" bgcolor=\"#e1e1e1\"cellspacing=\"2\" cellpadding=\"0\" style=\"border-collapse: collapse; font-family: sans-serif; font-size: 14px; color: #000000; text-decoration: none;  \"> <tr> <td align=\"center\" style=\"border-bottom: 2px solid gray\" > <br>&nbsp;Click <a href=\"../../../../index.html?page=source%2F_build%2F1_overview%2F3_additonal_information%2Fbitwise_operators.html\">here</a> to show toolbars of the Web Online Help System: <a href=\"../../../../index.html?page=source%2F_build%2F1_overview%2F3_additonal_information%2Fbitwise_operators.html\">show toolbars</a><br>&nbsp;</td></tr></table><br> "); 
</script><!-- !chm2web! -->


<h2>位运算和二进制</h2>

<div class="body-scroll">
<p><br>
</p>

<p>计算机的早期时代，二进制和十六进制是一种生活方式，可能是因由高级语言（如BASIC）简直太慢了（计算机速度也慢）。然而今 天，甚至是使用最普通的PC，你也不再需要了解这些东西，或者走一个很长的路，机器的速度和结构复杂的CPU将弥补这种方法的任何缺点。</p>

<p>一个非常简单的例子，过去乘以32可能需要几个CPU周期来执行，而简单的二进制运算同样的事情只需要一次。因为机器已经变足够复杂了，这也减少了很多复杂指令的运行时间，一个32x32位乘法可能也只需要一个周期 - 同二进制运算一样的效率。这当然是好消息，因为这意味着你不再需要优化你写的每一行代码，如果真是这样 - 你还会真正关心二进制吗？</p>

<p>答案明显是“是的，你应该”。虽然这是事实，你仍然可以得到一些速度上的提升 - 而有时这些提升可以更加显著 - 使用二进制和十六进制可以让CPU运行得更快，也能写出更好的代码，以及更好的打包数据，让一些任务变得简单得多，这些你应该都是知道的。此页要解释一下，什么是二进制，以及如何在制作游戏时使用它们。</p>

<blockquote><label class="collapse" for="one">数论</label>
<input id="one" type="checkbox">
<div class="index_list">所以，我们先看一下最基础的二进制理论 - 数字是怎样创建的。请看下面的表格：<br>
<br>

<p class="code">000 = 0<br>
001 = 1<br>
010 = 2<br>
100 = 4<br></p>
<br>
每个 1 或 0 代表一个单个 <i>位</i> 数据，“10”等于2！首位等于1，每一位 <i>是之前值的2倍</i>。所以2号位 = 2，3号位 = 4，4号位 = 8等等（如下所示，在这个 <i>字节</i>表中 - 一个字节是8位的集合）：<br>
<br>

<p class="code">00000001 = 1<br>
00000010 = 2<br>
00000100 = 4<br>
00001000 = 8<br>
00010000 = 16<br>
00100000 = 32<br>
01000000 = 64<br>
10000000 = 128<br></p>
<br>
数字是2的幂的情况都还行，但怎样创建更复杂的数字？单个二进制数只能存储 0 或 1，只能这样，所以复杂的数字需要添加位数。例子的话，比如我们需要是6，我们需要将4和2添加到一起，像这样：<br>
<br>

<p class="code">00000010 = 2<br>
00000100 = 4<br>
00000110 = 6<br></p>
<br>
这适用于 <i>所有的</i> 二进制数，包括计算机内部构成的任何数字。我们再看一个稍微更复杂的数字作为进一步的例子： 23。数字23实际上由 1+2+4+16 或者 00010111组成。那么更复杂的例子196呢？好的， 由128+64+4 或者说 11000100构成。所以其实没有那么复杂，真的。如果我们开始造一个字节（存储0至255之间的数字）以外的值，难度会开始变大。比如217,361，二进制上是 110101000100010001。或者， 1+16+256+等... 不管表示的值是什么，规则都是一样的 - 每个数字由多个位加在一起构成。</div>
<br>
<label class="collapse" for="two">二进制运算符（位运算符）</label>
<input id="two" type="checkbox">
<div class="index_list">那么，二进制里这意味着什么？嗯，你想将 <tt>真</tt> 或者 <tt>假</tt>作为一个值储存。通常编译器会使用一个INT（INIT通常定义一个有符号的32位数字），然后简单的赋值为0或1。然而，它只有二个状态，一个<tt>真</tt> / <tt>假</tt>值理想的情况是储存在一个位上，如果我们这样做，每个INT我们可以储存32个<tt>真</tt> / <tt>假</tt>位，而不是只是一个。<br><br>我们该怎么做？结论是很容易做到：<br>
<br>

<p class="code">flags = flags | 1;flags<br></p>
<br>
"|" 运算符是 <b>位运算的“或”</b>，意思是上述说明的“或”1并赋值回flags。如果你还记得之前的情况，使用一个1将设置第一个位。如果我们想要设置第二个位，我们要这样做：<br>
<br>

<p class="code">flags = flags | 2;<br></p>
<br>
我们“或”2，因为这个位模式00000010等于2。所以二进制“或”运算符究竟是做什么的呢？事实上，它将所有的位融合在一起，成为一个单独的值，像这样：<br>
<br>

<p class="code">010110100<br>
110011001<br>
110111101<br></p>

<p><br>
下面是所谓的“或运算符的<i>真值表</i>：<br>
<br></p>

<p class="code">00 | 00 = 00<br>
00 | 01 = 01<br>
01 | 01 = 01<br>
01 | 00 = 01<br></p>
<br>
所以两个零的值仍然保持零。使用位作为真/假状态的一个优点是，有些时候你不能简单的设置一个一般的布尔值，此时，你可以在一个操作里设置多个标志。例如，我们假设1号位标记”活跃“，3号位标记”可见“。我们可以像这样<i>同时</i>设置它们：<br>
<br>

<p class="code">flags = flags | 5;<br></p>
<br>
因为5在二进制中表示为00000101，而根据上述的规则，变量"flags"就会将这两个位合并进来。所以，当1号位已经被设置的时候，该操作对3号位依然有效并且也会同样被设置.<br><br>那么，清除标记呢？这里就该让位与（位且，Binary AND）运算符登场了。当你“与”一些东西，掩码中设置的位将保留，掩码中清除的位将删除 - 如下：<br>
<br>

<p class="code">01110010101<br>
00110000100<br>
00110000100<br></p>
<br>
如你所见，相同位的值一样时，值将保留（都为1，则为1），而值是混合的，一个是0，一个是1，则为0（一个不为1，则为0）。这里是“与”运算的真值表：<br>
<br>

<p class="code">00 &amp; 00 = 00<br>
01 &amp; 00 = 00<br>
00 &amp; 01 = 00<br>
01 &amp; 01 = 01<br></p>

<p><br>
所以，每个位置都有1的地方将保留。这意味着什么呢，那就是你能够一次性<i>设置</i>多个标志（flag），也可以一次性<i>清除clear</i>多个标志。比如，还是上面的例子，这次是清除他们。我们要清除位1和位3（值等于5），但是记一下上面的真值表，我们要的是保留其它的位，清除位1和位3。这里需要一个二进制掩码“11111111111111111111111111111010（32位）”。这个掩码保留当前所有设置的位，但是清除我们想要清除的那两个位。再比如我们有一个值“1000111011”，我们想要清理位1和位3，使用上面的掩码，我将用这个结束这个操作：<br>
<br></p>

<p class="code">00000000000000000000001000111011<br>
11111111111111111111111111111010<br>
00000000000000000000001000111010<br></p>
<br>
这是很不错的思路，但每次我们需要清除标志时，如果不得不解决这个问题，这样会变得非常烦琐。我们需要的是一种比较容易翻转“位”的方法（最好没有CPU开销）。幸运的是的确还有简单的方法，那就是使用“非（NOT）”运算符。<br><br>“非”运算就像它说的一样 - “非”那些位。下面是“非”运算的真值表。<br>
<br>

<p class="code">~00 = 11<br>
~01 = 10<br>
~10 = 01<br>
~11 = 00<br></p>
<br>
这个运算符让删除标志非常简单，而且更好，这通常是一个编译时间上的优化。如果你使用一个常数值（即不是变量），然后编译器将为你自动翻转“位”。我们想要再次清除位1和位3的地方使用这个语句：<br>
<br>

<p class="code">a = a &amp; ~5;<br></p>
<br>
这将实际编译为 "a  &amp; 11111111111111111111111111111010"。就清除标志来说，这变得相当简单。<br><br>最后我们要看的运算符是“异或（EOR，有时叫 XOR）” ，这个运算翻转位设置，当<i>两个位</i>相同时为0，不同时为1。这里是“异或”的真值表：<br>
<br>

<p class="code">0 ^ 0 = 0<br>
0 ^ 1 = 1<br>
1 ^ 0 = 1<br>
1 ^ 1 = 0<br></p>
<br>
异或很奇特，但非常有用。例如，我们要一个计数器，简单的从0数到1然后回到0（0和1之间切换），我们可以递增1，使用“IF”检查是否获得2，然后重新设置为1。或者……我们加1然后“与”1（ 因为01+01 = 10，以及10 &amp; 01 = 0）或者我们这样做：<br>
<br>

<p class="code">a = a ^ 1;<br></p>
<br>
这样做，第一次的时候（a=0）是 0 ^ 1 = 1，然后第二次（a=1）是1 ^ 1 = 0，从而触发从0到1再到0的来回。<br><br>所以 - 或 (|)、 与(&amp;)、 非(~) 以及异或(^) 让我们可以相对容易的操作位运算，允许我们在一个最简单的层面上一次性同时控制多个位。很明显地，在开发游戏时我们可以使用这些运算做些其它的事情，像是掩蔽精灵、整数MOD运算（使用与）或者一个不错的循环计数器。</div>
<br>
<label class="collapse" for="three">简单二进制算术运算</label> <input id="three" type="checkbox">
<div class="index_list">计算机是怎样做加法的？那么让我们来看看一个非常简单的示例 1+1。<br>
<br>

<p class="code">00000001<br>
00000001<br>
00000010<br></p>
<br>
就像正常的加法，数字加起来然后溢出到下一列中，但是不同于普通的十进制加法，只会进到1，没有9。所以 1+1 means we overflow into 10. So let's look at a more complex example.<br>
<br>

<p class="code">01011011 = 91<br>
00101101 = 45<br>
10001000 = 136<br></p>
<br>

It's obviously harder to see here, but the overflows ripple along
until there are no ones in a column - or 2 at which point an
overflow bit makes 3 and it stays there. Fortunately, you don't
ever have to worry about this unless you want to add very large
numbers together (like 2x128bit numbers). It’s also worth noting,
that computers can only add (or subtract, multiply or divide) 2
numbers at once, even SIMD is based on 2 calculations at once, but
doing multiple calculations in parallel. Take 19 + 19 + 19. Being
human, we can add all the 9's together, carry the 2 and then on we
go! But computers can't do that - what they <i>can</i> do is this:
(19 + 19) + 19. So they'll do each calculation in blocks of 2.<br>
<br>
The binary calculations that are of interest to us, and of great
use, are multiplication and division. Computers only multiply in
2s, and to do more it'll break a number apart, and then add all the
results together. Let's take some very simple examples first. 4 * 2
= 8. Now to multiply by 2 in binary, we shift all the bits to the
LEFT by one. Like this:<br>
<br>

<p class="code">00000100 * 2 = 00001000 = 8</p>
<br>

All the bits in this case have moved to the left by one, making it
move from the 3rd bit, to the 4th, and changing the value from 4 to
8. How about a larger number?<br>
<br>

<p class="code">101 = 01100101 * 2 = 11001010 = 202</p>
<br>
Again, all the bits move on one, and that multiples by 2. So, how about a multiple by 4?Easy, we shift everything left by 2, rather than one. So how about 16, or 128?This would require a left shift of 4 bits, or 7 bits respectively. This is incredibly useful; it means we can do simple multiplications by simply moving bits around. 为了完成这件事，我们需要使用移位（Shift）运算符 &lt;&lt; 。下面有几个例子<br>
<br>

<p class="code">00000001 &lt;&lt; 1 = 000000010 = 2<br>
00000001 &lt;&lt; 2 = 000000100 = 4<br>
00000001 &lt;&lt; 3 = 000001000 = 8<br>
00000001 &lt;&lt; 4 = 000010000 = 16<br>
00000001 &lt;&lt; 5 = 000100000 = 32<br>
00000001 &lt;&lt; 6 = 001000000 = 64<br>
00000001 &lt;&lt; 7 = 010000000 = 128<br>
00000001 &lt;&lt; 8 = 100000000 = 256<br></p>
<br>
Now, aside from being very useful for fast/simple multiplications, it's also very useful for setting specific BITs, without having to figure out the bit value. 假设我们希望设置27号位，那么数字将会是多少呢？（顺便一提，是67108864！），而我们可以通过上述用法很容易地将标记设置成这样：<br>
<br>

<p class="code">A = A | (1&lt;&lt;27)<br></p>
<br>
好吧……因此实际上以我目前所描述的方法（我是假装位是从1开始的）会设置26号位，但实际上是从0号位开始的并向上递增的，而非1号位。所以，当一个整型数中有32位的时候，它的位域是从0到31号位，而非1到32号位。实际上这相当有用，现在我们就可以建立比特常数（Bit Numbers）。<br><br>那么假设27号位是一个活动标记，0号位是一个爆炸标记。So let's say Bit 27 is an active flag, and bit 0 is an exploding flag. 我们该如何设置两者How can we set both?<br>
<br>

<p class="code">ACTIVE= 27;<br>
BOOM = 0;<br>
A = A | (1&lt;&lt;ACTIVE) | (1&lt;&lt;BOOM);<br></p>
<br>
这样代码可能看起来有点多，但是如果这些数是常数，那么编译器可以预编译这些指令成为单个值，使得我们最终实际代码是这样的：<br>
<br>

<p class="code">A = A | 13421772;<br></p>
<br>
而清空这些位（如上文所见）只是使用位非修饰符的问题，像这样：<br>
<br>

<p class="code">A = A &amp; ~((1&lt;&lt;ACTIVE) |
(1&lt;&lt;BOOM));<br></p>
<br>
所以，这让我们很方便地设置并清空我们需要的任意位，并且它也可以让我们很大幅度地压缩数据结构。压缩数据结构是一件非常好的事情，因为如果你使用的内存越少，缓存丢失的也就越少，而你的代码就可以运行地更快。这么说吧，拷贝一个32兆字节的数据和4兆字节的数据，那个更快？显然是4啦。所以如果你能把你所有的标记都打包成单一的内存通道，那是极好的！</div>
<br>
<label class="collapse" for="four">二进制除法</label>
<input id="four" type="checkbox">
<div class="index_list">我们快速的看一下你是如何做触发的，以及为什么这很有用。我们取一组简单的数——64，然后除以32<br>
<br>

<p class="code">64 / 32 = 01000000 &gt;&gt; 5 = 00000010<br></p>
<br>
所以，这里你是向<i>低阶</i>移动单个位5个位数（这也是要得到32时需要移动的位数——见上文），就会给我们一个2. 但是，如果还有别的位在里面该怎么办呢？我们来看一下：<br>
<br>

<p class="code">68 / 32 = 01000100 &gt;&gt; 5 = 00000010<br></p>
<br>
这样做下去……它们完全相等。我们右移的位丢失了。实际上，这很有用，因为当我们向下除的时候如果我们需要余数，我们就可以更容易地获取它，我们一会会去获取它。但是首先，我们先看一下这个使用的例子我有一个X和Y坐标位置，然后我想获取它落入的单元格，其中单元格大小为32×32。允许使用的方法有存储物体、碰撞、标记——等各种东西，并快速地访问它们。那么我们这样做：<br>
<br>

<p class="code">var X_index = x&gt;&gt;5;<br>
var Y_index = y&gt;&gt;5;<br>
cell_data = mygrid[# X_index,Y_index];<br></p>
<br>
这非常快，快得不得了。这很好地避免了使用浮点数除法然后在用floor()向下取整计算一起进行的必要。<br><br>那么，如果我们想要获取余数该怎么办呢？或许，这个余数可以被用于某些指令或者什么别的东西当中，不考虑原因，获取余数简单到用一个位与运算就能完成：<br>
<br>

<p class="code">var r = x &amp; 31<br>
var X_Index = x&gt;&gt;5;<br></p>
<br>
现在，一些思维敏锐的人就会察觉到，我们在此处两种方法都使用了（这也是常有的情况），但是，它仍然只是一组指令。但为什么会有31？因为5号位是32，其下所有的位就是31，这也是可能的最大余数，因此这就是我们使用位与运算的对象（我们也可以这样用((1&lt;&lt;5)-1），会使得32-1 = 31现在，如果我不理解二进制方法的话，代码会变成这样：<br>
<br>

<p class="code">var r = x mod 32;<br>
var X_Index = floor(x/32);<br></p>
<br>
为什么这样更糟呢？为了除以32，我们必须执行一次浮点数触发——显然，这很花费时间，但是为了和对32取余数，你实际上还需要再做一次！假如我们是在汇编语言（Assembler）上完成这件事，我们实际上会在一次除法当中同时得到这两个值，但是在高级语言中你不会得到这种结果（应该说，不是很常见），并且因此你必须做两次所有的工作。当这些累加起来，特别是你在对一个像这样很紧张的，带有很多运算的循环当中的时候。使用上述的整数触发确实会有效地优化你的游戏。</div></blockquote>

<p><br>
</p>

<h2>举例</h2>

<p><br>
</p>

<p>Since this can be quite a complex concept to grasp and then
apply to real-world programming situations, you can find below a
series of short examples that could be applied to any game made
with <i>GameMaker Studio 2</i>.</p>

<blockquote><label class="collapse" for="five">图块对齐</label> <input id="five" type="checkbox">
<div class="index_list"><i>GameMaker Studio 2</i> devs often use
the function <tt>place_free()</tt>, and then when a collision is
found, try to slowly move the object out by either looping around
an x or y position (or something) while continuing to execute that
function, or by using the <tt>move_outside_all()</tt> function.<br>
<br>
So, what's the faster way to do this? Well, if we use proper
power-of-2 tiles, then we have a very simple method that's also
lightning fast. If we are moving right, and we've moved into a
collision block, then as we know everything is aligned to 32, so we
need to also align the sprite to a 32 pixel boundary - preferably
the one to the left - so the sprite is moved OUT of the collision.
This is really easy, knowing the rules we've used above to get the
remainder, and knowing how to get the inverse of bits, we can
simply do this:<br>
<br>

<p class="code">X = x&amp;~31;<br></p>
<br>

That's right, that's ALL that it takes to align to a 32 pixel
boundary. By changing the 31 we can align to anything we like – as
long as it's a power of 2. (This is the equivalent of dividing by
32, then multiplying by 32, thereby removing the lower bits.)<br>
<br>
If we wanted to align to the right, then we'd do the above, but
then add 32 to move it into the next tile. Simple. All this makes
the whole collision code monumentally faster, and lets you spend
the CPU time where you really need it.</div>
<br>
<label class="collapse" for="six">钥匙与门</label> <input id=
"six" type="checkbox">
<div class="index_list">Say you have a level with a few doors, and a key for each. How can you easily mark a key for a key?Well, normally you'd just assign an ID to the key and the door. So what if you wanted a key to open 2 or 3 doors?很简单。你可以使用掩码。The door would have a single "bit" assigned like so door_id=1 (0001), another with door_id=2 (0010), door_id=4 (0100),door_id=8 (1000) and so on. If we wanted the key to open door 1 and 3, then the key would have the MASK of 5 (which is 101 in binary). If we perform an AND of this, and it comes out "not zero", then we know if the key can open the door. You could also have keys that opened nothing by having a MASK of 0. See the code below for the actual check:<br>
<br>

<p class="code">if( (key_id &amp; door_id) !=0 ) { opendoor();
}<br></p></div>
<br>
<label class="collapse" for="seven">Looping Counters</label>
<input id="seven" type="checkbox">
<div class="index_list">Let's say we want a simple animation
counter, counting from 0 to to 15 (as we have 16 frames of
animation), now we can either do an increment, and then do an IF,
or we can use our knowledge of binary and remove the IF completely.
IF's are slow, and if we don't need them, we should remove
them.<br>
<br>

<p class="code">counter = (counter+1)&amp;31;<br></p>
<br>

Since 16 frames is a power of 2 number, and since 0 is included in
the counter, we can reduce the POW2 number by 1 and use it as a
MASK, and using that we can use it to wrap our counter. If the
counter moves from 15 to 16, we end up with bit pattern 10000, and
if we then AND with 15 (bit pattern 01111) we end up with 0. This
means the above code is incredibly useful for wrapping counters -
as long as you use POW2 frame numbers.</div>
<br>
<label class="collapse" for="eight">Power Of 2 Check</label>
<input id="eight" type="checkbox">
<div class="index_list">What if you wanted to check to see if
something was a power of 2? Well, here's a neat little trick.. This
will return TRUE if argument0 is a power of 2.<br>
<br>

<p class="code">return (argument0&amp;(argument0-1))==0;<br></p>
<br>

So if we had the number 51 (110011) what does this do? Well, we get
this... 110011 &amp; 110010, which obviously leaves us with FALSE,
as there are lots of "bits" left after the AND. If we had 64
1000000, then it becomes this... 1000000 &amp; 0111111 which DOES
leave us 0, so it's TRUE.</div>
<br>
<label class="collapse" for="nine">Index Alignment</label>
<input id="nine" type="checkbox">
<div class="index_list">Here's a quick bit of code to align to
power of 2 numbers. (1,2,4,8,16 and so on). This can be very useful
for memory allocation, or making sure you write data to proper
boundaries.In this example, argument0 needs to be aligned to
argument1 bytes, where argument1 is a power of 2 number. This
little script rounds UP to the next boundary of the desired
number.<br>
<br>

<p class="code">return (argument0 + (argument1-1)) &amp;
~(argument1-1);<br></p>
<br></div></blockquote>

<p><br>
</p>
</div>

<div class="footer">
<div class="buttons">
<div class="clear">
<div style="float:left">上一页：<a href="index.html">附加信息索引</a></div>

<div style="float:right">下一页：<a href="errors.html">编译错误</a></div>
</div>
</div>

<h5>© Copyright YoYo Games Ltd. 2016 All Rights Reserved</h5>
<script type="text/javascript">
   (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){   (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),   m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)   })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');   ga('create', 'UA-2711665-14', 'auto');   ga('send', 'pageview'); 
</script>
</div>

<script type="text/JavaScript">
var fe = FindFrame("toc", top);
if ((fe != null) && (chmtop.c2wtopf.jstree != null)) {
  if (chmtop.c2wtopf.FITEMS[chmtop.c2wtopf.pagenum] != chmtop.c2wtopf.pageid)
    chmtop.c2wtopf.jstree.OpenTreeNode("source/" + chmtop.c2wtopf.pageid);
}
</script>
</body>
</html>
