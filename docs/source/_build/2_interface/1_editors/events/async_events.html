<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="keywords" content="在线文档、网络联机帮助、web 帮助、chm2w" />
<meta http-equiv="Content-Style-Type" content="text/css" />
<meta http-equiv="content-type" content="text/html; charset=UTF-8">

<meta name="generator" content="chm2web Pro 2.85 (unicode)" />
<title>异步事件</title>
<meta http-equiv="X-UA-Compatible" content="IE=9">

<link rel="stylesheet" href="../../../../../files/helpindex.css"
type="text/css">
<link rel="stylesheet" href="../../../../../default.css" type=
"text/css">

<script type="text/JavaScript" src="../../../../../files/supply.js"></script>
<script type="text/JavaScript">
chmtop.c2wtopf.pageid = "_build/2_interface/1_editors/events/async_events.html";
</script>

</head>
<body><script type="text/JavaScript"> 
if (window.name != "content") 
  document.write(" <table width=\"100%\" bgcolor=\"#e1e1e1\"cellspacing=\"2\" cellpadding=\"0\" style=\"border-collapse: collapse; font-family: sans-serif; font-size: 14px; color: #000000; text-decoration: none;  \"> <tr> <td align=\"center\" style=\"border-bottom: 2px solid gray\" > <br>&nbsp;Click <a href=\"../../../../../index.html?page=source%2F_build%2F2_interface%2F1_editors%2Fevents%2Fasync_events.html\">here</a> to show toolbars of the Web Online Help System: <a href=\"../../../../../index.html?page=source%2F_build%2F2_interface%2F1_editors%2Fevents%2Fasync_events.html\">show toolbars</a><br>&nbsp;</td></tr></table><br> "); 
</script><!-- !chm2web! -->


<script type="text/JavaScript">
 if( typeof(chmtop.helpStyle) != 'undefined' ) { var linkNodes = document.getElementsByTagName("link");  for( var i=0; i < linkNodes.length; ++i ) { var link = linkNodes[i];    if( link.href.endsWith("default.css")) {    var style = link.href.replace("default.css", chmtop.helpStyle); document.write('<link id="newstyleLink" rel="stylesheet" href=' + style + ' type="text/css">');    break; } } } 
</script>
<h2>异步事件</h2>

<div class="body-scroll">
<p><img class="center" src="images/editor_objects_async.png" alt=
"物体编辑器异步事件"> <b>异步事件</b> 是当 <i>GameMaker Studio 2</i> 从某些外部源（可以来自 Web 或运行游戏的设备）收到 “回调” 时触发的事件。你告诉 <i>GameMaker Studio 2</i> 做一些事情，比如加载一个图像，然后它就会在加载图像时同时干其它事情。 然后，当请求（即加载图像）完成后，将向 <i>GameMaker Studio 2</i> 发送回调，并且将触发为该类型的回调定义的 <b>异步事件</b>。请注意，异步事件将针对具有它们的 <i>所有</i> 实例触发，就像按键事件一样，因此你可以在一个实例中执行 <tt>http_get</tt> 调用，但在另一个实例中使用异步 HTTP 事件来处理回调。<br></p>

<div class="note"><b>注意</b>： 你应该知道，由于浏览器中的 XSS 保护，对来自跨域的请求和尝试加载资源的操作都被阻止，并且在使用以下任何事件时可能会返回空白结果</div>

<p><br>
有与异步事件类别相关的各种类型的事件，它们都在以下部分中解释：</p>

<div class="note"><b>注意：</b> 以下各节中提到的变量 <tt>async_load</tt> 仅在这些事件中有效，因为指向的 <tt>ds_map</tt> 是在 <b>事件开始时创建的</b>，然后在结尾处再次删除，此变量在其他时间被重置为 -1。</div>

<p><br>
</p>

<blockquote><a name="async_audio_play" id="async_audio_play"></a>
<label class="collapse" for="thirteen">录音回放</label>
<input id="thirteen" type="checkbox">
<div class="index_list">此事件只能由 <a href=
"../../../3_scripting/4_gml_reference/audio/audio%20buffers.html">音频队列播放函数</a> 触发，并将返回存储在变量 <tt>async_load</tt> 中的 <a href=
"../../../3_scripting/4_gml_reference/data_structures/ds%20maps/index.html"><tt>ds_map</tt></a>，其中包含与触发事件的音频队列相关的不同键 / 值对。 选择要回放的音频队列并完成该音频队列中的缓冲区播放后，将触发该事件。<br><br>ds_map 中将提供以下键：<br>
<br>

<ul>
<li>"<b>queue_id</b>" - 已完成播放的队列的索引，由函数 <a href=
"../../../3_scripting/4_gml_reference/audio/audio_create_play_queue.html"><tt>audio_create_play_queue</tt></a> 返回。</li>

<li>"<b>buffer_id</b>" - 不再播放的缓冲区的缓冲区 ID</li>

<li>"<b>queue_shutdown</b>" - 在正常播放期间设置为 0，在接收到事件时设置为 1，因为已调用 <a href=
"../../../3_scripting/4_gml_reference/audio/audio_free_play_queue.html"><tt>audio_free_play_queue</tt></a>。如果将其设置为 1，你不希望排队等待任何进一步的数据。</li>
</ul>
由于可以从多个缓冲区创建音频队列，因此当到达缓冲音频的每个部分的末尾时，可以针对一个队列多次触发该事件，因此使用了 “buffer_id” 键。<br>
<br>

<div class="note"><b>注意：</b> 变量 <tt>async_load</tt> 仅在异步事件中有效，因为指向的 <tt>ds_map</tt> 是在事件开始时创建的，然后在结尾处再次删除，此变量将重置为值 -1。但是，<b>必须使用适当的函数清除</b> 从事件创建的所有其他数据结构。</div>
<br>
在下面给出的使用示例中，我们将创建一个音频队列，其中添加了 10 个缓冲的音频声音，然后播放队列：<br>
<br>

<p class="code">audio_queue = audio_create_play_queue(buffer_s16, 11052, audio_mono);<br>for (var i = 0; i &lt; 10; i++;)<br>&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;audio_queue_sound(audio_queue, audio_buffer[i], 0, buffer_get_size(audio_buffer[i]));<br>&nbsp;&nbsp;&nbsp;}<br>audio_play_sound(audio_queue, 0, true);<br></p>
<br>
现在每个游戏步都会检测到录音将触发异步音频录制事件，你可以在此处处理录制的输入，如下所示：<br>
<br>

<p class="code">var queue = async_load[?"queue_id"];<br>var num = 0;<br>if queue = audio_queue<br>&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;for (var i = 0; i &lt; 10; i++;)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if async_load[?"buffer_id"] == audio_buffer[i]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buffer_seek(audio_buffer[i], buffer_seek_start, 0);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;num = i;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;if num == 9<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;audio_stop_sound(audio_queue);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;audio_free_play_queue(audio_queue);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;}<br></p>
<br>
在这里我们检查队列 ID，如果它是我们想要的那个，我们就检查缓冲区 ID 以查看哪个缓冲已经完成播放。 然后，我们还将局部变量设置为该索引值以便稍后检查，并将缓冲区设置回该声音的开始。 一旦我们的局部变量达到 9，表明队列已经完成，我们停止播放声音并释放队列。</div>
<br>
<a name="async_audio_rec" id="async_audio_rec"></a> <label class=
"collapse" for="twelve">录音</label> <input id="twelve"
type="checkbox">
<div class="index_list">此事件只能由 <a href=
"../../../3_scripting/4_gml_reference/audio/audio_start_recording.html"><tt>audio_start_recording()</tt></a> 函数触发，并将返回存储在变量 <tt>async_load</tt> 中的 <a href=
"../../../3_scripting/4_gml_reference/data_structures/ds%20maps/index.html"><tt>ds_map</tt></a>，其中包含不同的键 / 值对，具体取决于触发事件的函数的回调。<br><br>ds_map 中将提供以下键：<br>
<br>

<ul>
<li>"<b>buffer_id</b>" - 可用于检索音频数据的临时缓冲区的 ID</li>

<li>"<b>channel_index</b>" - 由此数据来自的调用函数返回的记录通道索引</li>

<li>"<b>data_len</b>" - 你收到的数据长度（以字节为单位）</li>
</ul>

<div class="note"><b>注意：</b> 如本页开头所述，变量 <tt>async_load</tt> 仅在异步事件中有效，因为指向的 <tt>ds_map</tt> 是在事件开始时创建的，然后在结束时再次删除。但是，请注意，所有音频与地图一起存储的临时缓冲区也将在事件结束时删除，因此如果要保留以供以后使用，则应将其复制到自定义缓冲区。</div>
<br>
在下面的用法示例中，我们将创建一个自定义缓冲区来存储我们录制的音频，并将我们的游戏设置为从输入源 0 录制：<br>
<br>

<p class="code">channel_index = audio_start_recording(0);<br>
audio_buffer = buffer_create(len, buffer_fast, 1);<br></p>
<br>
现在每个游戏步都会检测到录音将触发异步音频录制事件，你可以在此处处理录制的输入，如下所示：<br>
<br>

<p class="code">var channel = async_load[?"channel_index"];<br>if channel == channel_index<br>&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;len = async_load[?"data_len"];<br>&nbsp;&nbsp;&nbsp;buffer_copy(async_load[?"buffer_id"], 0, len, audio_buffer, 0);<br>&nbsp;&nbsp;&nbsp;}<br></p>
<br>
在这里，我们只需检查 “channel_index” 键以确保它与我们开始记录时返回的值匹配，如果是，我们将为此事件创建的临时缓冲区的内容复制到我们的自定义缓冲区中。 之后，你可以使用自定义缓冲区执行所需操作 - 你可以使用专用缓冲区音频函数播放它，你可以处理它并通过网络发送它，你可以将其保存到磁盘... 一旦你在缓冲区中有录制的音频，你可以做任何你想要的事情。
</div>
<br>
<a name="async_cloud" id="async_cloud"></a> <label class="collapse"
for="five">云</label> <input id="five" type="checkbox">
<div class="index_list">云事件是由其中一个 <a href=
"../../../3_scripting/4_gml_reference/asynchronous%20functions/index.html"><tt>cloud_</tt> 函数</a>（如 <a href=
"../../../3_scripting/4_gml_reference/asynchronous%20functions/cloud_synchronise.html"><tt>cloud_synchronise</tt></a>）的回调触发的事件。它实际上生成了一个独特的 <tt>ds_map</tt>，并存储在特殊变量 <b>async_load</b> 中（请参阅各个函数以获取更详细地解释此事件使用的代码示例）。 此 ds_map 具有以下结构：<br>
<br>

<ul>
<li><b>"status":</b> 这是状态码，其中负值表示错误，错误详情包含在 “errorstring” 中。
0 （或者大于 0 的值）代表成功（见下文）的返回, “resultString” 中包含返回的消息数据。</li>

<li style="list-style: none"><br>
</li>

<li><b>"id":</b> 返回被调用的函数的 id，如果你发送了一系列的 <tt>cloud_</tt> 请求，你需要知道被回应的是哪一个，所以你要用这个值来和发送时存储的值进行比较来找到你需要的请求。</li>

<li style="list-style: none"><br>
</li>

<li><b>"description":</b> 上传的最后一个文件的描述。</li>

<li style="list-style: none"><br>
</li>

<li><b>"resultString":</b> 从云端返回的二进制数据。</li>

<li style="list-style: none"><br>
</li>

<li><b>"errorString":</b> 返回的错误消息。</li>
</ul>
返回值 "status" 的详细映射关系如下如下：

<div class="compat">
<table>
<tr>
<th>状态值</th>
<th>errorString / resultString</th>
<th>描述</th>
</tr>

<tr>
<td>-1</td>
<td>errorString = "Not logged in to &lt;SERVICE&gt;"</td>
<td>未能成功登陆到给定的云服务。</td>
</tr>

<tr class="alt">
<td>0</td>
<td>resultString = recovered data</td>
<td>从云端下载新的游戏数据（在 cloud_synchronise 后调用）。</td>
</tr>

<tr>
<td>1</td>
<td>resultString = "AlreadySynchronized"</td>
<td>自从上次调用以来 cloud_synchronise 没有新的数据。</td>
</tr>

<tr class="alt">
<td>2</td>
<td>resultString = "ConflictDeferral"</td>
<td>遇到冲突,但玩家选择忽略它。</td>
</tr>

<tr>
<td>3</td>
<td>resultString = "GameUploadSuccess"</td>
<td>来自 <a href=
"../../../3_scripting/4_gml_reference/asynchronous%20functions/cloud_string_save.html"><tt>cloud_string_save</tt></a> 或 <a href=
"../../../3_scripting/4_gml_reference/asynchronous%20functions/cloud_file_save.html"><tt>cloud_file_save</tt></a> 的数据已成功上传到云端</td>
</tr>

<tr class="alt">
<td>-n</td>
<td>errorString = Description of error</td>
<td>负数意味着同步失败。</td>
</tr>
</table>
</div></div>
<br>
<a name="async_dialogue" id="async_dialogue"></a> <label class=
"collapse" for="three">对话框</label> <input id="three" type=
"checkbox">
<div class="index_list">与上述事件一样， <b>对话框</b> 事件仅在从其中一个特殊异步用户函数（如 <a href=
"../../../3_scripting/4_gml_reference/asynchronous%20functions/get_login_async.html"><tt>get_login_async()</tt></a>）返回时触发（请参阅此函数以获取有关如何使用此事件的扩展代码示例）。 这些事件是要求某种类型的用户输入的事件，可以是名称、登录详细信息、数字或颜色等...... 由于大多数设备不喜欢在循环中等待回复，它们必须是异步的，<i>GameMaker Studio 2</i> 将继续在后台运行，而这些函数打开对话框，直到它们获得触发此事件的所需用户输入。<br><br>同样，会返回 <a href=
"../../../3_scripting/4_gml_reference/data_structures/ds%20maps/index.html"><tt>ds_map</tt></a>，其 id 保存在特殊变量 <b>async_load</b> 中。此映射中保存的值取决于所使用的功能，有关详细信息，请参阅本手册中每个功能的各个条目。</div>
<br>
<a name="async_http" id="async_http"></a> <label class="collapse"
for="two">HTTP</label> <input id="two" type="checkbox">
<div class="index_list">HTTP 事件是由一个 <a href=
"../../../3_scripting/4_gml_reference/asynchronous%20functions/index.html"><tt>http_</tt> 函数</a>（如 <a href=
"../../../3_scripting/4_gml_reference/asynchronous%20functions/http_post_string.html"><tt>http_post_string</tt></a>）的回调触发的事件。它实际上生成了一个 <tt>ds_map</tt>（有时称为“字典”），它独有于此事件并存储在特殊变量 <tt>async_load</tt> 中（请参阅各个函数以获取更详细地解释此事件使用的代码示例）。 此 <tt>ds_map</tt> 具有以下结构：<br>
<br>

<ul>
<li><b>"id":</b> 从命令返回的id。如果你发出一系列 <tt>http_</tt> 请求，那么你需要知道你得到了哪一个回复，因此你可以使用这个值来比较你最初发送请求时存储的值，以找到正确的请求。</li>

<li style="list-style: none"><br>
</li>

<li><b>"status":</b> 为错误返回小于 0 的值，为成功返回 0，如果正在下载内容则返回 1。</li>

<li style="list-style: none"><br>
</li>

<li><b>"result":</b> 收到的数据（仅限字符串），或者如果使用了 <a href=
"../../../3_scripting/4_gml_reference/asynchronous%20functions/http_get_file.html"><tt>http_get_file()</tt></a>，则是下载的文件的路径。</li>

<li style="list-style: none"><br>
</li>

<li><b>"url":</b> 你请求的完整网址。</li>

<li style="list-style: none"><br>
</li>

<li><b>"http_status":</b> 原始 http 状态代码（如果可用）。这将返回大多数浏览器的标准 Web 状态代码，例如：304 表示 “未修改” 或 204 表示 “无内容” 等...</li>
</ul>
这适用于使用 <tt>http_post_string()</tt> 函数时，但每个 <tt>http_</tt> 函数可能会返回略有不同的映射，因此请参阅每个函数的手册条目，以找出为其返回的精确数据。
<br>
<br>

<div class="note"><b>注意：</b> 当 <tt>async_load</tt> 创建 <a href=
"../../../3_scripting/4_gml_reference/data_structures/ds%20maps/index.html"><tt>ds_map</tt></a> 时，这些函数在与 <a href=
"../../../3_scripting/4_gml_reference/file%20handling/json_encode.html"><tt>json_encode</tt></a> 和 <a href=
"../../../3_scripting/4_gml_reference/file%20handling/json_decode.html"><tt>json_decode</tt></a> 函数结合使用时特别有用。
</div>
<br>
<br>
如果你已请求下载文件，则此映射还可能提供其他数据。 在这种情况下，“status” 的值为 1，ds_map 将保存这些额外的键：<br>
<br>

<ul>
<li><b>"contentLength":</b> 这是 Web 服务器所说的你应该接收的文件大小（如果服务器不返回此数据，则可能为 -1）。</li>

<li style="list-style: none"><br>
</li>

<li><b>"sizeDownloaded":</b> 已下载的数据大小。</li>
</ul>
请注意，<i>不会</i> 为接收到的每个数据包触发事件，而是在主游戏循环中的下载过程中随时更新事件。 另请注意，目前此功能仅适用于常规 <i>Windows</i> 目标平台。</div>
<br>
<a name="async_iap" id="async_iap"></a> <label class="collapse"
for="four">应用内购</label> <input id="four" type="checkbox">
<div class="index_list">只有在为游戏激活 <a href=
"../../../3_scripting/4_gml_reference/in%20app%20purchases/index.html">应用内购</a> 时才能触发此事件。 如果添加了此功能，则在以下情况下将触发该事件：<br>
<br>

<ul>
<li>商店状态发生变化。</li>

<li>一种产品（或多种产品）已被激活。</li>

<li>产品和购买已经恢复。</li>

<li>已购买产品。</li>

<li>产品已被消费。</li>
</ul>
该事件将始终创建一个特殊的 <a href=
"../../../3_scripting/4_gml_reference/data_structures/ds%20maps/index.html"><tt>ds_map</tt></a>，其索引 ID 存储在内置变量 <tt><b>iap_data</b></tt> 中。 此映射将 <i>始终</i> 包含键 “<b>type</b>”，它将包含以下常量值之一：

<div class="compat">
<table>
<tr>
<th>常量</th>
<th>描述</th>
</tr>

<tr>
<td>iap_ev_storeload</td>
<td>在目标平台存储中检测到更改时会触发此操作。</td>
</tr>

<tr class="alt">
<td>iap_ev_product</td>
<td>激活产品时会触发此事件，并包含有关产品的其他信息。</td>
</tr>

<tr>
<td>iap_ev_restore</td>
<td>只有在使用 <a href=
"../../../3_scripting/4_gml_reference/in%20app%20purchases/iap_restore_all.html"><tt>iap_restore_all</tt></a> 函数时才会触发此事件。</td>
</tr>

<tr class="alt">
<td>iap_ev_purchase</td>
<td>购买完成后，将触发此事件。</td>
</tr>

<tr>
<td>iap_ev_consume</td>
<td>当你使用函数 <a href=
"../../../3_scripting/4_gml_reference/in%20app%20purchases/iap_consume.html"><tt>iap_consume</tt></a> 时，它会触发此事件。</td>
</tr>
</table>
</div>

<p><br>
<br>
这些可能的事件 “类型” 中的每一个都将为 <tt>iap_data</tt> ds_map 添加额外的密钥，然后可以对其进行解析以获取必要的购买或产品信息。 下面列出了每个事件 “类型” 的 <tt>iap_data</tt> 映射的确切内容。</p>

<blockquote><a name="iap_ev_storeload" id="iap_ev_storeload"></a>
<label class="collapse" for="fifteen">iap_ev_storeload</label>
<input id="fifteen" type="checkbox">
<div class="index_list">当你激活购买时，你的游戏将尝试联系目标商店，在此过程中触发此事件。 然后，<tt>iap_data</tt> 映射将具有一个附加键 “<b>status</b>”，它将具有以下常量之一作为其值：<br>
<br>

<div class="compat">
<table>
<tr>
<th>常量</th>
<th>描述</th>
</tr>

<tr>
<td>iap_storeload_ok</td>
<td>已连接商店，连接良好。</td>
</tr>

<tr class="alt">
<td>iap_storeload_failed</td>
<td>存在连接错误或由于某种原因存储不可用。</td>
</tr>
</table>
</div></div>
<br>
<a name="iap_ev_product" id="iap_ev_product"></a> <label class=
"collapse" for="sixteen">iap_ev_product</label> <input id="sixteen"
type="checkbox">
<div class="index_list">所有激活的购买都会触发此事件 “类型”，但每次购买只会触发一次，因此如果你已激活十个产品，则应该会触发此事件十次。 如果你收到此事件，则 <tt>iap_data</tt> ds_map 将保留附加键 “<b>index</b>”，其中包含正在激活的产品的唯一 <b>产品 ID </b> 字符串。 然后，你可以使用函数 <a href=
"../../../3_scripting/4_gml_reference/in%20app%20purchases/iap_product_details.html"><tt>iap_product_details</tt></a> 以及此产品 ID 来获取更多信息。<br>
<br>

<div class="note"><b>注意：</b> Google Play（Android）一次只能请求产品的 20 条详细信息，这会导致具有大量产品的应用程序的加载时间相当长。</div></div>
<br>
<a name="iap_ev_restore" id="iap_ev_restore"></a> <label class=
"collapse" for="seventeen">iap_ev_restore</label> <input id=
"seventeen" type="checkbox">
<div class="index_list">当你调用函数 <a href=
"../../../3_scripting/4_gml_reference/in%20app%20purchases/iap_restore_all.html"><tt>iap_restore_all</tt></a> 时，它将触发此事件，向 <tt>iap_data ds_map</tt> 添加 “<b>result</b>” 键。 此键将包含 <tt>true</tt> 或 <tt>false</tt>，以指示是否已从目标商店成功还原购买数据。</div>
<br>
<a name="iap_ev_purchase" id="iap_ev_purchase"></a> <label class=
"collapse" for="eighteen">iap_ev_purchase</label> <input id=
"eighteen" type="checkbox">
<div class="index_list">在使用函数 <a href=
"../../../3_scripting/4_gml_reference/in%20app%20purchases/iap_acquire.html"><tt>iap_acquire</tt></a> 请求购买时，将触发此事件类型。<tt>iap_data</tt> ds_map 将具有附加键 “<b>index</b>”，其中包含所购买产品的唯一 <b>购买 ID</b> 值。 然后，你可以使用函数 <a href=
"../../../3_scripting/4_gml_reference/in%20app%20purchases/iap_purchase_details.html"><tt>iap_purchase_details</tt></a> 以及此购买 ID 来获取更多信息。<br>
<br>

<div class="note"><b>注意：</b> 如果购买的产品是消耗品，则 <b>必须先使用</b> <tt>iap_consume</tt> 进行购买，然后才能进一步购买。</div></div>
<br>
<a name="iap_ev_consume" id="iap_ev_consume"></a> <label class=
"collapse" for="nineteen">iap_ev_consume</label> <input id=
"nineteen" type="checkbox">
<div class="index_list">使用函数 <a href=
"../../../3_scripting/4_gml_reference/in%20app%20purchases/iap_consume.html"><tt>iap_consume</tt></a> 时，将触发此事件类型。 <tt>iap_data</tt> ds_map 将具有附加密钥 “<b>product</b>”，其中包含正在使用的产品的唯一 <b>产品 ID</b> 字符串。</div></blockquote></div>
<br>
<a name="async_image_loaded" id="async_image_loaded"></a>
<label class="collapse" for="one">加载图片</label> <input id=
"one" type="checkbox">
<div class="index_list">只要你使用了具有适用加载文件功能的有效 URL 或路径，就会在将图像加载到 <i>GameMaker Studio 2</i> 时触发此事件。例如，假设你要加载精灵图像，并且仅在加载时将实例的当前精灵更改为新精灵。 那么你会在创建事件或计时器事件中有这样的事情（例如）：

<p class="code">spr =
sprite_add("http://www.angusgames.com/game/background1.png", 0,
false, false, 0, 0);</p>

<p>现在，这将开始将图像加载到设备或浏览器中，但在等待加载文件时 <i>不会</i> 阻止 <i>GameMaker Studio 2</i>。 相反，<i>GameMaker Studio 2</i> 将继续正常运行，直到加载图像并且回调触发 <b>加载图片</b> 事件，其中创建 <a href=
"../../../3_scripting/4_gml_reference/data_structures/ds%20maps/index.html"><tt>ds_map</tt></a> 并将其存储在特殊变量 <b>async_load</b> 中。 该映射包含以下信息：</p>

<ul>
<li><b>"filename":</b> 你请求的文件的完整路径。</li>

<li style="list-style: none"><br>
</li>

<li><b>"id":</b> 已加载资源的 ID。这与你为其分配资源的变量相同。</li>

<li style="list-style: none"><br>
</li>

<li><b>"status":</b> 为错误返回小于 0 的值。</li>
</ul>

<p>然后，你将在此事件中将新加载的图像分配给背景。 对于精灵和声音也是如此，如上所示为每个资源生成 ds_map，以下代码示例演示了如何在此事件中使用返回的信息：</p>

<p class="code">if ds_map_find_value(async_load, "id") == spr<br>&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;if ds_map_find_value(async_load, "status") &gt;= 0<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sprite_index = spr<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;}<br></p>

<p>上面的代码将首先检查已创建的 ds_map 的 id，然后检查回调的状态。如果该值大于或等于 0（信号成功），则回调的结果将用于将背景索引设置为新加载的图像。</p></div>
<br>
<a name="async_networking" id="async_networking"></a> <label class=
"collapse" for="six">联网</label> <input id="six" type=
"checkbox">
<div class="index_list">网络事件是由任何传入网络流量触发的事件，并链接到 <a href=
"../../../3_scripting/4_gml_reference/networking/index.html">网络函数</a>。此事件生成一个特殊的 <a href=
"../../../3_scripting/4_gml_reference/data_structures/ds%20maps/index.html">ds_map</a>，该事件专用于此事件，并存储在特殊变量 <b>async_load</b> 中。 此 <tt>ds_map</tt> 将包含不同的信息，具体取决于生成它的网络事件的类型。

<blockquote><a name="async_network_common" id=
"async_network_common"></a> <label class="collapse" for=
"twenty">常见网络事件</label> <input id="twenty" type=
"checkbox">
<div class="index_list">以下键对所有接收的网络功能都是通用的，并且始终存在于 <tt>async_load</tt> 映射中：<br>
<br>

<ul>
<li><b>"type":</b> 这将使下面列出的常量之一作为其返回值，并指定网络事件类型。</li>

<li style="list-style: none"><br>
</li>

<li><b>"id":</b> 正在接收事件的套接字 id（由 <a href=
"../../../3_scripting/4_gml_reference/networking/network_create_server.html">network_create_server</a> 或 <a href=
"../../../3_scripting/4_gml_reference/networking/network_create_socket.html">network_create_socket</a> 函数返回的实数）。 在大多数情况下，返回的套接字 ID 是触发事件的 TCP 或 UDP 套接字的 ID，但是如果在 <i>服务器</i> 中触发事件并且它是数据事件（见下文），那么套接字 ID 是发送数据的 <i>客户端</i> 套接字 ID。 </li>

<li style="list-style: none"><br>
</li>

<li><b>"ip":</b> 套接字的 IP 地址（作为字符串）。</li>

<li style="list-style: none"><br>
</li>

<li><b>"port":</b> 与 IP 地址关联的端口（在使用 UDP 时很有用）。</li>
</ul>
“type” 键的可能返回值可以是下面列出的四个常量中的任何一个：

<div class="compat">
<table>
<tr>
<th>常量</th>
<th>描述</th>
</tr>

<tr>
<td>network_type_connect</td>
<td>事件由连接触发。</td>
</tr>

<tr class="alt">
<td>network_type_disconnect</td>
<td>事件由断开连接触发。</td>
</tr>

<tr>
<td>network_type_data</td>
<td>事件由传入数据触发。</td>
</tr>

<tr class="alt">
<td>network_type_non_blocking_connect</td>
<td>事件由配置为非阻塞的连接触发（你可以使用函数 <a href=
"../../../3_scripting/4_gml_reference/networking/network_set_config.html"><tt>network_set_config()</tt></a>）。</td>
</tr>
</table>
</div></div>
<br>
<a name="async_network_connect" id="async_network_connect"></a>
<label class="collapse" for="twentyone">连接 / 断开连接</label> <input id="twentyone" type="checkbox">
<div class="index_list">如果你有类型为 <tt>network_type_connect</tt>、<tt>network_type_non_blocking_connect</tt> 或 <tt>network_type_disconnect</tt> 的事件，则 <tt>async_load</tt> 映射将具有以下附加键：<br>
<br>

<ul>
<li><b>"socket":</b> 此键将保持连接 / 断开套接字 ID。</li>

<li style="list-style: none"><br>
</li>

<li><b>"succeeded":</b> 此键将为 0 或 1，其中 0 表示连接超时，1 表示成功，套接字可以使用。</li>
</ul>
值得注意的是，当 <i>服务器</i> 断开连接时，网络事件不会在 <i>客户端</i> 中触发，并且当连接的服务器断开连接时，即使连接基于 TCP，也不会在客户端中触发 <tt>network_type_*</tt> 事件。</div>
<br>
<a name="async_network_receive" id="async_network_receive"></a>
<label class="collapse" for="twentytwo">接收数据</label>
<input id="twentytwo" type="checkbox">
<div class="index_list">当你有 <tt>network_type_data</tt> 类型事件（表示你的网络已收到数据）时，创建的映射将具有以下键：
<br>
<br>

<ul>
<li><b>"buffer":</b> 这是由事件生成的唯一 “缓冲区 ID”。 创建一个 “增长” 类型缓冲区，字节对齐为 1，以保存 id 应存储在变量中，并用于 <i><b>此事件中</b></i> 对缓冲区的所有进一步函数调用。 就像 <tt>async_load</tt> 映射一样，创建的缓冲区会在此事件结束时自动从内存中删除。 有关缓冲区的更多信息，请参阅 <a href=
"../../../3_scripting/4_gml_reference/buffers/index.html">参考 - 缓冲区</a></li>

<li style="list-style: none"><br>
</li>

<li><b>"size":</b> 这是正在接收的缓冲区数据的大小（以字节为单位）。</li>
</ul>

<div class="note"><b>注意：</b> 创建的缓冲区 <b>仅在这些事件中有效</b>，并在事件结束时释放。</div></div></blockquote></div>
<br>
<a name="async_push" id="async_push"></a> <label class="collapse"
for="ten">推送通知</label> <input id="ten" type=
"checkbox">
<div class="index_list">推送通知事件是由设备操作系统上的 <b>推送通知</b> 回调触发的事件，可以是使用函数 <a href=
"../../../3_scripting/4_gml_reference/asynchronous%20functions/push_local_notification.html"><tt>push_local_notification</tt></a> 的本地源，也可以是远程源（即：你的服务器）。它生成一个独特于此事件的 <tt>ds_map</tt>，并存储在特殊变量 <b>async_load</b> 中（请参阅触发异步事件的各个函数，以获取更详细地解释此事件使用的代码示例）。此 <tt>ds_map</tt> 具有以下键：
<br>
<br>

<ul>
<li><b>"type":</b> 值可以是设备本地通知的 “local”，远程通知的 “reomte” 或远程通知注册的 “register”。</li>

<li><b>"status":</b> 成功的值为 “1”，错误的值为 “0”。</li>
</ul>
根据返回的 “类型” 和 “状态” 值，可能存在其他键条目。对于 “status”，如果返回错误（“0”），那么你还将拥有以下键：<br>
<br>

<ul>
<li><b>"error":</b> 包含收到的错误的详细信息。</li>
</ul>
如果 “status” 值为 1（即：无错误），则 <tt>ds_map</tt> 将包含以下附加值，具体取决于 “type” 键的值：<br>
<br>

<ul>
<li><b>"reg_id":</b> 如果收到的 “type” 是 “register”，则该键将保存设备注册 ID 以进行远程通知。</li>

<li><b>"data":</b> 如果收到的 “type” 是 “local” 或 “remote”，则此键将保存你在调用通知函数时定义的字符串有效内容。</li>
</ul>
为了更好地理解这一点，我们在下面创建了一个小示例代码段供你查看。在这个示例中,我们将使用下面的代码来发送一个本地推送通知：<br>
<br>

<p class="code">var fireTime =
date_inc_day(date_current_datetime(), 1);<br>
var data = "daily_reward";<br>
push_local_notification(fireTime, "Ahoy!", "Catch The Haggis Has A
Present", data);<br></p>
<br>
设置一个计时器在一天后向设备 “推送” 一个通知。一天以后，无论你的程序是在后台还是未启动状态，玩家都将收到之前设置的通知（在 iOS 平台标题被游戏的名字替代），然后一个异步的推送通知事件（Push Notification Event）会被触发。需要注意的是，如果推送时程序运行在前台，通知将 <i>不会</i> 被展示，但是异步推送事件 <b>仍会触发</b>。在事件本身你会这样处理回调：<br>
<br>

<p class="code">var type = ds_map_find_value(async_load, "type");<br>var status = ds_map_find_value(async_load, "status");<br>if status == 0<br>&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;//error of some kind<br>&nbsp;&nbsp;&nbsp;var error = ds_map_find_value(async_load, "error");<br>&nbsp;&nbsp;&nbsp;show_debug_message("error=" + string(error));<br>&nbsp;&nbsp;&nbsp;}<br>else<br>&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;if type == "register"<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;global.reg_id = ds_map_find_value(async_load, "reg_id");<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;else<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var data = ds_map_find_value(async_load, "data");<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if data == "daily_reward"<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;global.Gold += 1000;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;}<br></p></div>
<br>
<a name="async_saveload" id="async_saveload"></a> <label class=
"collapse" for="eleven">保存 / 载入</label> <input id="eleven"
type="checkbox">
<div class="index_list">此事件将由与加载和保存文件缓冲区以及从内存加载或卸载音频时相关的某些函数触发。 事件本身将包含内置的 <tt>async_load</tt> DS 映射，该映射将由特定函数所需的密钥填充。 这些列在下面的部分中。

<blockquote><a name="async_saveload_buffers" id=
"async_saveload_buffers"></a> <label class="collapse" for=
"twentynine">缓冲区</label> <input id="twentynine" type=
"checkbox">
<div class="index_list">使用函数 <a href=
"../../../3_scripting/4_gml_reference/buffers/buffer_save_async.html"><tt>buffer_save_async()</tt></a> 或 <a href=
"../../../3_scripting/4_gml_reference/buffers/buffer_load_async.html"><tt>buffer_load_async()</tt></a> 时，将在数据传输完成时触发异步事件。 此事件将使用以下键 / 值对填充 <tt>async_load</tt> 映射<br>
<br>

<ul>
<li><b>"id":</b> 由所使用的函数返回的异步函数的 ID。</li>

<li><b>"status":</b> 如果正确保存/加载数据，则返回 <tt>true</tt>，否则返回 <tt>false</tt>。</li>
</ul>
这允许你轮询保存 / 加载进度并显示消息或更改房间等...当过程完成时。</div>
<br>
<a name="async_saveload_audio" id="async_saveload_audio"></a>
<label class="collapse" for="thirty">音频组</label>
<input id="thirty" type="checkbox">
<div class="index_list">使用 <a href=
"../../../3_scripting/4_gml_reference/audio/audio%20groups.html">音频组</a> 时，你可以使用 <a href=
"../../../3_scripting/4_gml_reference/audio/audio_group_load.html"><tt>audio_group_load()</tt></a> 和 <a href=
"../../../3_scripting/4_gml_reference/audio/audio_group_unload.html"><tt>audio_group_unload()</tt></a> 函数加载它们并从内存中卸载它们。使用加载功能时，当为该组设置的完整音频文件集已加载到内存中时，它将触发此事件，并使用以下键 / 值对填充映射：<br>
<br>

<ul>
<li><b>"type":</b> 这告诉我们被调用的事件的类型，并且将是 “<tt>audiogroup_load</tt>” 来加载音频。</li>

<li><b>"group_id":</b> 将返回已加载的音频组的 ID（如 <a href=
"c:/source/yoyostudio/documentation/english/2_interface/3_settings/audio.html">音频组编辑器</a> 中所定义）。</li>
</ul>
当为一个组加载所有音频时，此事件将触发，然后可用于更改房间，或播放音乐曲目等...</div></blockquote></div>
<br>
<a name="async_social" id="async_social"></a> <label class=
"collapse" for="eight">社交</label> <input id="eight" type=
"checkbox">
<div class="index_list">此事件只能由各种特定的 <a href=
"../../../3_scripting/4_gml_reference/asynchronous%20functions/index.html">社交函数</a> 触发，并将返回存储在变量 <a href=
"../../../3_scripting/4_gml_reference/data_structures/ds%20maps/index.html"><tt>async_load</tt></a> 中的 <tt>ds_map</tt>，其中包含不同的键 / 值对，具体取决于触发事件的函数的回调。<br><br>ds_map 将包含许多键，其中最重要的是 “<i>id</i>” 键。 这将返回一个 <b>常量</b>，然后可以在代码中检查该常量以确定事件已收到的许多回调中的哪一个。 解析此密钥并将返回的值与可用常量进行比较后，你可以继续从映射中提取其余信息。

<blockquote><a name="async_social_leaderboards" id=
"async_social_leaderboards"></a> <label class="collapse" for=
"twentyseven">成就和排行榜</label> <input id=
"twentyseven" type="checkbox">
<div class="index_list">函数页面 <a href=
"../../../3_scripting/4_gml_reference/asynchronous%20functions/achievements%20and%20leaderboards/index.html">社交游戏 - 成就和排行榜</a> 参考部分中详细介绍了函数和回调以及用于触发此事件的常量，但是在某些情况下，如果没有来自游戏的函数调用，它将在运行时被触发：<br>
<br>

<ul>
<li>从操作系统常用工具栏启动游戏时</li>

<li>当你完成挑战时</li>

<li>当另一位玩家完成挑战时</li>

<li>从操作系统常用工具栏启动游戏时选择挑战</li>
</ul>

<p>任何上述回调都将触发 <b>社交事件（Social Event）</b>，并且将生成带有以下详细信息的 <tt>async_load</tt> 映射（请注意，有一个不同的 “id” 键值来定义调用该事件的每个不同原因，但所有其他内容映射是一样的）：<br>
<br></p>

<ul>
<li>"<b>id</b>" - 此键的值取决于触发事件的回调类型。 它可以是以下常量之一：<br>
<br>

<ul>
<li><b><tt>achievement_challenge_received</tt></b> - 已收到挑战<br></li>

<li><b><tt>achievement_challenge_completed</tt></b> - 挑战已经完成。<br></li>

<li><b><tt>achievement_challenge_completed_by_remote</tt></b> - 其他玩家已完成挑战。<br></li>

<li><b><tt>achievement_challenge_launched</tt></b> - 游戏是从具有给定挑战的操作常用工具栏启动的。<br></li>
</ul></li>

<li>"<b>playerid</b>" - 挑战的玩家 id。<br>
<br></li>

<li>"<b>issuerid</b>" - 发出挑战的人的 id。<br>
<br></li>

<li>"<b>state</b>" - 挑战的状态，对于 <i>无效</i>、<i>待定</i>、<i>已完成</i> 或 <i>已拒绝</i>，其值为 0 - 3（作为字符串）。<br>
<br></li>

<li>"<b>message</b>" - 挑战的消息。<br>
<br></li>

<li>"<b>issueddate</b>" - 挑战的发布日期<br>
<br></li>

<li>"<b>completeddate</b>" - 挑战的完成日期。<br>
<br></li>

<li>"<b>type</b>" - 给出的挑战类型。 可以是两个常量之一：<br>
<br>

<ul>
<li><b><tt>achievement_type_score_challenge</tt></b> - 基于分数值的挑战。<br></li>

<li><b><tt>achievement_type_achievement_challenge</tt></b> - 基于成就的挑战。<br></li>
</ul></li>

<li>"<b>identifier</b>" - 挑战的识别字符串。<br>
<br></li>

<li>"<b>score</b>" - 分数与挑战是一致的。</li>
</ul>
你可以在下面找到一小段代码作为使用示例：<br>
<br>

<p class="code">var ident = ds_map_find_value(async_load, "id" );<br>if ident == achievement_challenge_completed;<br>&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;player_id = ds_map_find_value(async_load, "playerid");<br>&nbsp;&nbsp;&nbsp;issuer_id = ds_map_find_value(async_load, "issuerid");<br>&nbsp;&nbsp;&nbsp;state = ds_map_find_value(async_load, "state");<br>&nbsp;&nbsp;&nbsp;date_completed = ds_map_find_value(async_load, "completeddate");<br>&nbsp;&nbsp;&nbsp;date_issued = ds_map_find_value(async_load, "issueddate");<br>&nbsp;&nbsp;&nbsp;ach_type = ds_map_find_value(async_load, "type");<br>&nbsp;&nbsp;&nbsp;ach_ident = ds_map_find_value(async_load, "identifier");<br>&nbsp;&nbsp;&nbsp;ach_score = ds_map_find_value(async_load, "score");<br>&nbsp;&nbsp;&nbsp;}</p></div>
<br>
<a name="async_social_facebook" id="async_social_facebook"></a>
<label class="collapse" for="twentyeight">Facebook</label>
<input id="twentyeight" type="checkbox">
<div class="index_list">一些 <a href=
"../../../3_scripting/4_gml_reference/asynchronous%20functions/facebook/index.html">Facebook 函数</a> 将触发社交异步事件并创建带有一些特定信息的 <tt>ds_map</tt>。 返回的信息将取决于已调用事件的 “类型”。 你可以通过读取 ds_map 中的 “type” 键来检查这一点，这将是以下 Facebook 事件的字符串：<br>
<br>

<ul>
<li>"<b>facebook_permission_request</b>"</li>
</ul>

<p>当事件被触发并且属于这种类型时，还会有其他可以检查的键：</p>

<ul>
<li>"<b>requestId</b>" - 触发事件的 <tt>facebook_request_xxx_permission()</tt> 函数返回的请求 ID 值<br>
<br></li>

<li>"<b>result</b>" - 这将是以下字符串之一：<br>
<br>

<ul>
<li>"<b>granted</b>" – 用户接受了许可</li>

<li>"<b>denied</b>" – 用户不接受一个或多个权限</li>

<li>"<b>error</b>" – 发生错误</li>
</ul></li>

<li><b>"error</b>" - 这将包含错误的描述，但 <i>仅</i> 在 “<b>result</b>” = “<b>error</b>”时出现。</li>
</ul></div></blockquote></div>
<br>
<a name="async_steam" id="async_steam"></a> <label class="collapse"
for="seven">Steam</label> <input id="seven" type="checkbox">
<div class="index_list">此事件只能由 <a href=
"../../../3_scripting/4_gml_reference/steam%20api/index.html">Steam API</a> 函数触发，并将返回存储在变量 <tt>async_load</tt> 中的 <a href=
"../../../3_scripting/4_gml_reference/data_structures/ds%20maps/index.html"><tt>ds_map</tt></a>，其中包含不同的键 / 值对，具体取决于触发事件的函数的回调。映射将始终包含键 “<b>event_type</b>”，然后可以对其进行解析以查找触发事件的函数类型并更改所需的代码。<br><br>当调用任何触发此事件的函数时，它将生成一个唯一的异步 ID 值，该值应存储在变量中并进行检查，因为 <tt>async_load</tt> 映射将始终包含一个 ID 密钥，然后你可以解析该密钥并确保你正在响应正确的事件。实际上，无论用于生成异步响应的 Steam 函数如何，映射都将 <i>始终</i> 包含以下键：<br>

<br>

<ul>
<li>"<b>id</b>" - 触发事件的函数返回的异步 ID</li>

<li style="list-style: none"><br>
</li>

<li>"<b>result</b>" - 操作的结果（实际值）。这将是 GML 常量 <tt>ugc_result_success</tt> 或其他一些实数。因此，你应检查此常量以确保调用成功，否则某些内容无法正常工作。返回的其余可能值显示为 Steam “EResult” 值的结果，你应该在 SDK 头文件 <tt>steamclientpublic.h</tt> 中看到所有 89 个可能值。</li>

<li style="list-style: none"><br>
</li>

<li>"<b>event_type</b>" - 表示事件类型的字符串（详见下文）</li>
</ul>

<blockquote><a name="async_steam_uploading" id=
"async_steam_uploading"></a> <label class="collapse" for=
"twentythree">上传数据</label> <input id="twentythree" type=
"checkbox">
<div class="index_list">使用 Steam 函数上传排行榜（<a href=
"../../../3_scripting/4_gml_reference/steam%20api/steam_upload_score.html"><tt>steam_upload_score()</tt></a> 或 <a href=
"../../../3_scripting/4_gml_reference/steam%20api/steam_upload_score_buffer.html"><tt>steam_upload_score_buffer()</tt></a>）时，返回的 <tt>ds_map</tt> 将具有以下键 / 值对：<br>
<br>

<ul>
<li>"<b>event_type</b>" - 此键将保存 “<b>leaderboard_upload</b>” 值</li>

<li style="list-style: none"><br>
</li>

<li>"<b>post_id</b>" - 此键应与上传调用函数返回的 ID 值匹配</li>

<li style="list-style: none"><br>
</li>

<li>"<b>lb_name</b>" - 此键包含已发布到的排行榜的名称</li>

<li style="list-style: none"><br>
</li>

<li>"<b>success</b>" - 如果传输成功，则为 1，0 为失败</li>

<li style="list-style: none"><br>
</li>

<li>"<b>updated</b>" - 如果排行榜得分实际更新（即：新得分更高），则为 1，否则为 0</li>

<li style="list-style: none"><br>
</li>

<li>"<b>score</b>" - 此键保留已发布的分数</li>
</ul>
你可以在分数上传功能的页面上查看此示例。</div>
<br>
<a name="async_steam_downloading" id="async_steam_downloading"></a>
<label class="collapse" for="twentyfour">下载排行榜</label> <input id="twentyfour" type="checkbox">
<div class="index_list">使用 Steam 函数下载排行榜（<a href=
"../../../3_scripting/4_gml_reference/steam%20api/steam_download_scores.html"><tt>steam_download_scores()</tt></a>、<a href=
"../../../3_scripting/4_gml_reference/steam%20api/steam_download_scores_around_user.html"><tt>steam_download_scores_around_user()</tt></a> 或 <a href=
"../../../3_scripting/4_gml_reference/steam%20api/steam_download_friends_scores.html"><tt>steam_download_friends_scores()</tt></a>）时，返回的 <tt>ds_map</tt> 将具有以下键 / 值对：
<br>
<br>

<ul>
<li>"<b>event_type</b>" - 此键将保存 “<b>leaderboard_download</b>” 值</li>

<li style="list-style: none"><br>
</li>

<li>"<b>id</b>" - 此键应与下载调用函数返回的 ID 值匹配</li>

<li style="list-style: none"><br>
</li>

<li>"<b>status</b>" - 回调的状态，其中 -1 等于失败或没有返回结果，0 等于成功。</li>

<li>"<b>lb_name</b>" - 此键包含已发布到的排行榜的名称</li>

<li style="list-style: none"><br>
</li>

<li>"<b>numEntries</b>" - 要返回的排行榜数据的 “行” 数。</li>

<li style="list-style: none"><br>
</li>

<li>"<b>entries</b>" - 包含另一个 ds_map 的 JSON 对象字符串，它将包含键 “default”（表示其中未包含任何结果）或键 “entries”（你可以获取其值）。 “entries” 的返回值将是包含排行榜中每个排名的 <a href=
"../../../3_scripting/4_gml_reference/data_structures/ds%20lists/index.html"><tt>ds_list</tt></a>，其中列表中的每个条目本身将引用另一个 <tt>ds_map</tt>，其中包含键 “name”、“score” 和 “rank”，以及它也可能包含 “数据” 键，具体取决于用于上载的功能。</li>
</ul>
我们将通过请求给定排行榜的前十名排名并在 <b>Steam 异步事件</b> 中解析其结果来显示下载得分数据如何工作的示例（有关上传示例，请参阅相应的功能页面）。首先，我们需要使用以下代码请求分数：<br>
<br>

<p class="code">score_get = steam_download_scores("Game Scores", 1,
10);<br></p>
<br>
这将向 Steam 服务器发送请求，以获取排行榜 “Game Scores” 中的分数，并将请求的 <b>异步 ID</b> 存储在变量 “score_get” 中。 然后，将通过以下方式在 <b>Steam 异步事件</b> 中处理：<br>
<br>

<p class="code">var async_id = ds_map_find_value(async_load, "id");<br>if async_id == score_get<br>&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;var entries = ds_map_find_value(async_load, "entries");<br>&nbsp;&nbsp;&nbsp;var map = json_decode(entries);<br>&nbsp;&nbsp;&nbsp;if ds_map_exists(map, "default")<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ds_map_destroy(map);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exit;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;else<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var list = ds_map_find_value(map, "entries");<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var len = ds_list_size(list);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var entry;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(var i = 0; i &lt; len; i++;)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;entry = ds_list_find_value(list, i );<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;steam_name[i] = ds_map_find_value(entry, "name");<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;steam_score[i] = ds_map_find_value(entry, "score");<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;steam_rank[i] = ds_map_find_value(entry, "rank");<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (ds_map_exists(entry, "data"))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var data = ds_map_find_value(entry, "data");<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var buffId = buffer_base64_decode(data);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var message = buffer_read(buffId, buffer_string);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;show_debug_message( " -- attached message: " + string(message));<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buffer_delete(buffId);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ds_map_destroy(entry);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ds_list_destroy(list)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;ds_map_destroy(map)<br>&nbsp;&nbsp;&nbsp;}<br></p>
<br>
我们在这里做的是首先检查特殊 <tt>async_load</tt> 映射的 “id” 键。如果此值与原始回调函数的值（存储在 “score_get” 变量中）相同，则我们将继续处理数据。我们要做的第一件事就是为关键 “entries” 解析 <tt>async_load</tt> ds_map，它将包含一个包含排行榜数据的 JSON 对象。然后将此 JSON 对象解码（请参阅 <a href=
"../../../3_scripting/4_gml_reference/file%20handling/json_decode.html"><tt>json_decode</tt></a>）作为另一个 ds_map，并将此新映射 ID 存储在变量 “map” 中。<br><br>检查该映射是否有为 “default” 的键，如果有的话，则销毁该映射并退出该事件。如果未找到 “default” 键，则代码将解析映射以提取有关排行榜的必要信息，方法是首先从 ds_map 的 “entries” 键中提取 ds_list，然后循环遍历列表的每个条目以获取 <i>另一个</i> ds_map，其中包含每个条目的名称，分数和排名。然后将这些值存储在数组中，然后检查是否有其他 “数据” 键。如果有（即：分数是使用附加数据包上传的），那么我们也会解析它并将其发送到编译器控制台进行调试，然后再销毁缓冲区然后继续销毁映射。请注意，如果包含 “data” 键，则需要先使用 <a href=
"../../../3_scripting/4_gml_reference/buffers/buffer_base64_decode.html"><tt>buffer_base64_decode()</tt></a> 对其进行解码，然后才能正确读取。<br><br>一旦循环完成，条目列表就会像从其获取的映射一样被销毁。无需销毁 <tt>async_load</tt> ds_map，因为这是由 <i>GameMaker Studio 2</i> 为你处理的。</div>
<br>
<a name="async_steam_downloadingugc" id=
"async_steam_downloadingugc"></a> <label class="collapse" for=
"twentyfive">下载 UGC（用户生成的内容）</label>
<input id="twentyfive" type="checkbox">
<div class="index_list">使用 Steam 功能下载 <a href=
"../../../3_scripting/4_gml_reference/steam%20api/user%20generated%20content/index.html">用户生成内容（UGC）</a> 时，其中一些将触发此事件。但是，每个函数都会生成一个具有不同键 / 值对的 <tt>async_load</tt> ds_map（尽管它们通常将始终包含 “<b>id</b>”、“<b>result</b>” 和 “<b>event_type</b>” 键），因此，请参阅特定于所使用的函数的页面，以获得详细信息和示例。</div>
<br>
<a name="async_steam_ugc_events" id="async_steam_ugc_events"></a>
<label class="collapse" for="twentysix">独特的 UGC 事件</label>
<input id="twentysix" type="checkbox">
<div class="index_list">当用户订阅游戏外的项目时，也可以触发 Steam 异步事件 - 例如，他们选择跳转到浏览器并订阅新项目然后选项回到游戏。在这些情况下，<tt>async_load</tt> 映射将 <b>仅</b> 包含以下详细信息（并且没有列出本页顶部的默认值）：<br>
<br>

<ul>
<li>"<b>event_type</b>" - 此键将保存 “<b>ugc_item_installed</b>” 值</li>

<li style="list-style: none"><br>
</li>

<li>"<b>published_file_id</b>" - 新安装的 UGC 项的 ID（你可以使用函数 <a href=
"../../../3_scripting/4_gml_reference/steam%20api/user%20generated%20content/steam_ugc_get_item_install_info.html"><tt>steam_ugc_get_item_install_info()</tt></a> 来获取已安装项的路径）</li>

<li style="list-style: none"><br>
</li>
</ul>
订阅创意工坊项目时也可以触发 Steam 异步事件 - 从应用程序内部或从创意工坊浏览器外部 - 并且在这些情况下，<tt>async_load</tt> 映射将包含以下键 / 值对：
<br>
<br>

<ul>
<li>"<b>event_type</b>" - 此键将保存 “<b>ugc_item_subscribed</b>” 值</li>

<li style="list-style: none"><br>
</li>

<li>"<b>published_file_id</b>" : 此密钥具有新订阅项的已发布文件ID</li>

<li style="list-style: none"><br>
</li>
</ul>
如果任何项目也未被订阅，则会触发该事件，数据结构映射包含以下内容：<br>
<br>

<ul>
<li>"<b>event_type</b>" - 此键将保存 “<b>ugc_item_unsubscribed</b>” 值</li>

<li style="list-style: none"><br>
</li>

<li>"<b>published_file_id</b>" : 此密钥具有未订阅项的已发布文件 ID</li>

<li style="list-style: none"><br>
</li>
</ul></div></blockquote></div>
<br>
<a name="async_system" id="async_system"></a> <label class=
"collapse" for="fourteen">系统</label> <input id="fourteen" type=
"checkbox">
<div class="index_list">
<p>此事件只能由系统级事件触发（例如检测到游戏手柄或自动登录到 XBox Live），它将返回存储在变量 <tt>async_load</tt> 中的 <a href=
"../../../3_scripting/4_gml_reference/data_structures/ds%20maps/index.html"><tt>ds_map</tt></a>，其中包含不同的键 / 值对，具体取决于系统触发回调的事件级别。</p>

<blockquote><a name="async_system_gamepads" id=
"async_system_gamepads"></a> <label class="collapse" for=
"thirtyone">游戏手柄</label> <input id="thirtyone" type=
"checkbox">
<div class="index_list">
<p>当连接或断开游戏手柄触发此事件时，它将返回 <tt>async_load</tt> 映射中的以下键 / 值对之一：<br>
<br></p>

<ul>
<li>"<b>event_type</b>" - 收到的系统事件的类型，它将是以下字符串之一：<br>
<br>

<ul>
<li>"<b>gamepad discovered</b>" - 当系统报告已连接新游戏手柄时发生</li>

<li>"<b>gamepad lost</b>" - 当系统失去与游戏手柄的连接时发生</li>
</ul></li>

<li>"<b>pad_index</b>" - 已添加或删除的游戏手柄的索引</li>
</ul>

<p>此事件现在允许你将所有游戏手柄检查逻辑从步骤事件或警报事件移动到系统事件中，并仅在实际需要时运行它。
</p>
</div>
<br>
<a name="async_system_xboxlive" id="async_system_xboxlive"></a>
<label class="collapse" for="thirtytwo">XBox Live</label>
<input id="thirtytwo" type="checkbox">
<div class="index_list">
<p>在以 <b>XBox One</b> 为目标平台并使用 <b>UWP</b> 导出时，如果勾选 <a href=
"../../../2_interface/3_settings/game_options/options_windowsuwp.html">UWP 游戏选项</a> 中的 <b>启用 XBox Live</b> 选项，可以触发异步系统事件。当你启动启用了 Xbox Live 的 <i>GameMaker Studio 2</i> UWP 项目时，项目将自动尝试以静默方式登录 Xbox Live。 此登录尝试的结果将作为 <tt>async_load</tt> 映射中的以下键 / 值对之一返回：</p>

<ul>
<li>"<b>event_type</b>" - 收到的系统事件的类型，它将是以下字符串之一：<br>
<br>

<ul>
<li>"<b>user signed in</b>" - 静默用户登录已成功完成</li>

<li>"<b>user sign in failed</b>" - 静默用户登录失败（当发生这种情况时，你可以使用函数 <a href=
"../../../3_scripting/4_gml_reference/xbox_live/xboxlive_show_account_picker.html"><tt>xboxlive_show_account_picker()</tt></a> 让用户选择要登录的帐户）</li>

<li>"<b>user signed out</b>" - 用户已退出</li>
</ul></li>
</ul>

<p>有关 XBox Live 可用特定函数的更多信息，请参阅 <a href=
"../../../3_scripting/4_gml_reference/xbox_live/index.html">此处</a>。</p>
</div></blockquote>
</div></blockquote>

<p><br>
</p>
</div>

<div class="footer">
<div class="buttons">
<div class="clear">
<div style="float:left">上一页：<a href="../objects.html">物体编辑器</a></div>

<div style="float:right">下一页：<a href="draw_events.html">绘制事件</a></div>
</div>
</div>

<h5>© Copyright YoYo Games Ltd. 2017 All Rights Reserved</h5>
<script type="text/javascript">
   (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){   (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),   m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)   })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');   ga('create', 'UA-2711665-14', 'auto');   ga('send', 'pageview'); 
</script>
</div>

<script type="text/JavaScript">
var fe = FindFrame("toc", top);
if ((fe != null) && (chmtop.c2wtopf.jstree != null)) {
  if (chmtop.c2wtopf.FITEMS[chmtop.c2wtopf.pagenum] != chmtop.c2wtopf.pageid)
    chmtop.c2wtopf.jstree.OpenTreeNode("source/" + chmtop.c2wtopf.pageid);
}
</script>
</body>
</html>
